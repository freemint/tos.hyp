<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 02.08.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: XBIOS Strukturen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_functions.html"><img src="udo_lf.gif" alt="XBIOS-Funktionsliste" title="XBIOS-Funktionsliste" border="0" width="24" height="24">XBIOS-Funktionsliste</a>
<a name="UDO_nav_rg_HEAD" href="gemdos_main.html"><img src="udo_rg.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>

<hr>

<h1><a name="XBIOS_20Strukturen">4.24 XBIOS Strukturen</a></h1>
<ul class="content">
	<li> 4.24.1 <a href="#BCONMAP">BCONMAP</a>
	<li> 4.24.2 <a href="#CD_DISC_INFO">CD_DISC_INFO</a>
	<li> 4.24.3 <a href="#CD_TOC_ENTRY">CD_TOC_ENTRY</a>
	<li> 4.24.4 <a href="#DSPBLOCK">DSPBLOCK</a>
	<li> 4.24.5 <a href="#IOREC">IOREC</a>
	<li> 4.24.6 <a href="#KEYBDPARMS">KEYBDPARMS</a>
	<li> 4.24.7 <a href="#KBDVBASE">KBDVBASE</a>
	<li> 4.24.8 <a href="#KEYTAB">KEYTAB</a>
	<li> 4.24.9 <a href="#MAPTAB">MAPTAB</a>
	<li> 4.24.10 <a href="#META_DRVINFO">META_DRVINFO</a>
	<li> 4.24.11 <a href="#META_INFO_1">META_INFO_1</a>
	<li> 4.24.12 <a href="#META_INFO_2">META_INFO_2</a>
	<li> 4.24.13 <a href="#MOD_DESC">MOD_DESC</a>
	<li> 4.24.14 <a href="#MOUSE">MOUSE</a>
	<li> 4.24.15 <a href="#OVERPATCH">OVERPATCH</a>
	<li> 4.24.16 <a href="#PBDEF">PBDEF</a>
	<li> 4.24.17 <a href="#PCI_RSC_DESC">PCI_RSC_DESC</a>
	<li> 4.24.18 <a href="#PMODE">PMODE</a>
	<li> 4.24.19 <a href="#SCRCLIPMEMBLK">SCRCLIPMEMBLK</a>
	<li> 4.24.20 <a href="#SCRCOPYMEMBLK">SCRCOPYMEMBLK</a>
	<li> 4.24.21 <a href="#SCREEN">SCREEN</a>
	<li> 4.24.22 <a href="#SCREENINFO">SCREENINFO</a>
	<li> 4.24.23 <a href="#SCREEN_2C_20OverScan">SCREEN, OverScan</a>
	<li> 4.24.24 <a href="#SCRFILLMEMBLK">SCRFILLMEMBLK</a>
	<li> 4.24.25 <a href="#SCRLINEMEMBLK">SCRLINEMEMBLK</a>
	<li> 4.24.26 <a href="#SCRMEMBLK">SCRMEMBLK</a>
	<li> 4.24.27 <a href="#SCRTEXTUREMEMBLK">SCRTEXTUREMEMBLK</a>
	<li> 4.24.28 <a href="#VDO_MODE">VDO_MODE</a>
	<li> 4.24.29 <a href="#VDO_PARAM">VDO_PARAM</a>
	<li> 4.24.30 <a href="#vidix_capability_t">vidix_capability_t</a>
	<li> 4.24.31 <a href="#vidix_deinterlace_t">vidix_deinterlace_t</a>
	<li> 4.24.32 <a href="#vidix_dma_t">vidix_dma_t</a>
	<li> 4.24.33 <a href="#vidix_fourcc_t">vidix_fourcc_t</a>
	<li> 4.24.34 <a href="#vidix_grkey_t">vidix_grkey_t</a>
	<li> 4.24.35 <a href="#vidix_playback_t">vidix_playback_t</a>
	<li> 4.24.36 <a href="#vidix_video_eq_t">vidix_video_eq_t</a>
	<li> 4.24.37 <a href="#VPOS">VPOS</a>
	</li>
</ul>
<br>
<h3><a name="BCONMAP">4.24.1 BCONMAP</a></h3>
<pre>typedef struct
{
   <a href="#MAPTAB">MAPTAB</a>  *maptab;     /* Liste der seriellen Schnittstellen         */
   int16_t  maptabsize; /* Anzahl der Schnittstellentreiber           */

   /* Undokumentiertes, bei <a href="tos_main.html">TOS</a> und <a href="magic.html">MagiC</a> so: */
   int16_t  auxnr;      /* aktuell auf AUX eingestellte Kanalnummer   */
   int32_t  rscon;      /* Zeiger auf aktuell eingestellte <a href="xbios_interface.html#Rsconf">Rsconf</a>-
                           Funktion */
   int32_t  iorec;      /* Zeiger auf <a href="#IOREC">IOREC</a> des aktuellen Kanals      */
} BCONMAP;

Querverweis: <a href="xbios_interface.html#Bconmap">Bconmap</a>
</pre>
<h3><a name="CD_DISC_INFO">4.24.2 CD_DISC_INFO</a></h3>
<p>Diese Struktur ist wie folgt definiert:
</p>
<pre>typedef struct
{
   uint8_t  disctype;         /* 0: audio, 1: data */
   uint8_t  firsttrack, lasttrack, curtrack;
   uint8_t  relposz, relposm, relposs, relposf;
   uint8_t  absposz, absposm, absposs, absposf;
   uint8_t  endposz, endposm, endposs, endposf;
   uint8_t  index, res[3];
   uint32_t reserved[123];
} CD_DISC_INFO;
</pre>
<p>Querverweis: <a href="xbios_drive.html#Metadiscinfo">Metadiscinfo</a>
</p>
<h3><a name="CD_TOC_ENTRY">4.24.3 CD_TOC_ENTRY</a></h3>
<p>Die Struktur CD_TOC_ENTRY ist wie folgt definiert:
</p>
<pre>typedef struct
{
   uint8_t trackno;
   uint8_t minute;
   uint8_t second;
   uint8_t frame;
} CD_TOC_ENTRY;
</pre>
<p>Querverweis: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM-Kommandos_20f_C3_BCr">CD-ROM Opcodes für Fcntl</a>
</p>
<h3><a name="DSPBLOCK">4.24.4 DSPBLOCK</a></h3>
<p>Diese Struktur ist wie folgt definiert:
</p>
<pre>typedef struct
{
   int16_t  blocktype;  /* Typ der Daten im Puffer: */
                        /*   0 : LongInt            */
                        /*   1 : Integer            */
                        /*   2 : Byte               */
   int32_t  blocksize;  /* Puffergröße              */
   void    *blockaddr;  /* Zeiger auf den Puffer    */
} DSPBLOCK;

</pre>
<p>Querverweis: <a href="xbios_dsp56001.html#Dsp_MultBlocks">Dsp_MultBlocks</a> &nbsp; <a href="xbios_dsp56001.html">DSP-Programmierung</a>
</p>
<h3><a name="IOREC">4.24.5 IOREC</a></h3>
<p>Diese Struktur ist wie folgt definiert:
</p>
<pre>typedef struct
{
   void    *ibuf;        /* Zeiger auf den Buffer   */
   int16_t ibufsiz;      /* Größe des Buffers       */
   int16_t ibufhd;       /* nächste Schreibposition */
   int16_t ibuftl;       /* nächste Leseposition    */
   int16_t ibuflow;      /* Marke für Xon           */
   int16_t ibufhi;       /* Marke für Xoff          */
} IOREC;
</pre>
<p><b>Hinweis:</b> Für die serielle Schnittstelle schließt sich
direkt ein entsprechender Puffer für die Ausgabe an. Die beiden
letzten Zeiger werden nur für die serielle Schnittstelle im XON/XOFF
bzw. RTS/CTS-Betrieb genutzt.
</p>
<p>Fällt nämlich der Pegel unter die untere 'Wassermarke', so
wird der Sender aufgefordert weitere Zeichen zu senden; übersteigt er
hingegen die obere 'Wassermarke' so wird ihm signalisiert, keine
Zeichen mehr zu schicken.
</p>
<p>Querverweis: <a href="xbios_interface.html#Iorec">Iorec</a>
</p>
<h3><a name="KEYBDPARMS">4.24.6 KEYBDPARMS</a></h3>
<pre>typedef struct
{
  <a href="#KEYTAB">KEYTAB</a> *keytblx;           /* Adresse der 6 Tabellen       */
  int8_t  *kbshift;          /* Adresse des Shiftstatus      */
  int8_t  *altgr_status;     /* Adresse des AltGr- Status    */
  void    (*handle_key)();   /* Adresse der Tastaturroutine  */
  int8_t  *keyrepeat;        /* Adresse der Wdh.daten        */
} KEYBDPARMS;
</pre>
<p>- <i>keytblx</i> ist auch über <a href="xbios_keyboard.html#Keytbl">Keytbl</a> zu ermitteln
</p>
<p>- <i>kbshift</i> ist auch über den <a href="tos_main.html">TOS</a>- Header ermittelbar.
</p>
<p>- Das Flag <i>altgr_status</i> darf nur $00 oder $ff sein!
<br>Die <a href="guidelines_styles.html#Tastaturbelegung">Tastaturbelegung</a> unter AltGr ist so gewählt, daß die
akzentuierten Zeichen stets in der Nähe der zugehörigen Grundzeichen
liegen. Einige der Tasten (Cursortasten, Leertaste usw.) haben unter
AltGr ihre normale Funktion, alle anderen liefern im Lobyte das ASCII-
Zeichen und im High- byte immer $5f, was ein ungültiger Scancode ist.
Die Belegung ist an eine Standard- MF2 Tastatur angepaßt.
<br>Gedacht ist diese Erweiterung für einen Treiber für eine MF2
Tastatur, der selbst das AltGr- Flag kontrolliert und dem <a href="tos_main.html">TOS</a>- Treiber
lediglich Scancodes liefert.
<br>Um nicht nur die AltGr-Tabellen, sondern auch die Standardtabellen
an die MF2- Tastatur anpassen zu können, enthält das <a href="bios_main.html">BIOS</a> die ersten
drei Tastaturtabellen zusätzlich auch in MF2- Ausführung. Um das <a href="tos_main.html">TOS</a>
auf MF2 umzuschalten, schaltet man das KAOS- Konfigurationsbit 9 ein.
Der nächste <a href="xbios_main.html">XBIOS</a>-Aufruf <a href="xbios_keyboard.html#Bioskeys">Bioskeys</a> setzt dann je nach diesem Bit die
Atari- oder die MF2- Tabellen. Die AltGr- Tabellen ohne SHIFT und mit
CapsLock werden dabei immer als identisch gesetzt.
<br>Um die zusätzlichen Tastaturebenen auch auf der Originaltastatur
verfügbar zu machen, kann man mit ALT-CapsLock das AltGr-Flag
toggeln.
</p>
<p>In <a href="magic.html">MagiC</a> ist dieses Umschalten nicht mehr vorhanden!
</p>
<p>Querverweis: <a href="xbios_keyboard.html#Bioskeys">Bioskeys</a> &nbsp; <a href="xbios_keyboard.html#Keytbl">Keytbl</a> &nbsp; <a href="gemdos_system.html#Sconfig">Sconfig</a>
</p>
<h3><a name="KBDVBASE">4.24.7 KBDVBASE</a></h3>
<p>Diese Struktur ist wie folgt definiert:
</p>
<pre>typedef struct
{
   void   (*kb_midivec)();   /* MIDI Interrupt-Vektor    */
   void   (*kb_vkbderr)();   /* Tastatur Fehler-Vektor   */
   void   (*kb_vmiderr)();   /* MIDI Fehler-Vektor       */
   void   (*kb_statvec)();   /* Tastatur-Status          */
   void   (*kb_mousevec)();  /* Tastatur-Maus-Status     */
   void   (*kb_clockvec)();  /* Tastatur-Zeitgeber       */
   void   (*kb_joyvec)();    /* Tastatur-Joystick-Status */
   void   (*kb_midisys)();   /* System-Midi-Vektor       */
   void   (*kb_kbdsys)();    /* Tastatur-Vektor          */
   int8_t drvstat;           /* Tastatur-Treiberstatus   */
} KBDVBASE;
</pre>
<p><b>Hinweis:</b> Bei den Komponenten <i>kb_clockvec</i> und
<i>kb_joyvec</i> ist zu beachten, daß die Adresse des Paketes im
Register A0 und auf dem Stack übergeben wird; die Routinen sollten
außerdem mit einem RTS abgeschlossen sein, und nach Möglichkeit
nicht länger als 1ms laufen.
</p>
<p>Die Komponente <i>drvstat</i> enthält einen Wert ungleich
Null, wenn der IKBD gerade eine Paket verschickt.
</p>
<p>Querverweis: <a href="xbios_interface.html#Kbdvbase">Kbdvbase</a>
</p>
<h3><a name="KEYTAB">4.24.8 KEYTAB</a></h3>
<pre>typedef struct
{
   int8_t *unshift;       /* Tabelle 'normale' Tastendrücke */
   int8_t *shift;         /* Tabelle Shift-Tastendrücke     */
   int8_t *capslock;      /* Tabelle Capslock-Tastendrücke  */
   int8_t *altunshift;    /* ab <a href="tos_main.html">TOS</a> 4.00, undokumentiert!   */
   int8_t *altshift;      /* ab <a href="tos_main.html">TOS</a> 4.00, undokumentiert!   */
   int8_t *altcapslock;   /* ab <a href="tos_main.html">TOS</a> 4.00, undokumentiert!   */
   int8_t *altgr;         /* ab <a href="tos_main.html">TOS</a> 4.06, undokumentiert!   */
} KEYTAB;
</pre>
<p>Ab KAOS 1.4.2 und <a href="magic.html">MagiC</a> sind <i>altunshift</i>,
<i>altshift</i> und <i>altcapslock</i> vorhanden.
</p>
<p>Querverweis: <a href="xbios_keyboard.html#Keytbl">Keytbl</a>
</p>
<h3><a name="MAPTAB">4.24.9 MAPTAB</a></h3>
<pre>typedef struct
{
   int16_t  (*<a href="About_the_BIOS.html#Bconstat">Bconstat</a>)(void);
   int32_t  (*<a href="About_the_BIOS.html#Bconin">Bconin</a>)(void);
   int32_t  (*<a href="About_the_BIOS.html#Bcostat">Bcostat</a>)(void);
   void     (*<a href="About_the_BIOS.html#Bconout">Bconout</a>)(int16_t dev, int16_t c);
   uint32_t (*<a href="xbios_interface.html#Rsconf">Rsconf</a>)(int16_t baud, int16_t ctr, int16_t ucr, int16_t rsr, int16_t tsr, int16_t scr);
   <a href="#IOREC">IOREC</a>    *iorec;
} MAPTAB;
</pre>
<p>Querverweis: <a href="xbios_interface.html#Bconmap">Bconmap</a> &nbsp; <a href="#BCONMAP">BCONMAP</a>
</p>
<h3><a name="META_DRVINFO">4.24.10 META_DRVINFO</a></h3>
<pre>typedef struct
{
   int8_t  *mdr_name;
   int32_t  reserved[3];
} META_DRVINFO;
</pre>
<p>Querverweis: <a href="xbios_drive.html">Laufwerksfunktionen</a> &nbsp; <a href="xbios_drive.html#Metaopen">Metaopen</a>
</p>
<h3><a name="META_INFO_1">4.24.11 META_INFO_1</a></h3>
<pre>typedef struct
{
   uint32_t    drivemap;  /* Bits für <a href="xbios_metados.html">MetaDOS</a> Laufwerke.   */
                          /*   (Bit-0 = Laufwerk-A, usw.)  */
   int8_t      *version;  /* Name und Version von <a href="xbios_metados.html">MetaDOS</a>  */
   int32_t     reserved;  /* reserviert                    */
   <a href="#META_INFO_2">META_INFO_2</a> *info;     /* Zeiger auf zweite Struktur    */
} META_INFO_1;
</pre>
<p><b>Hinweis:</b> Die Komponente <i>info</i> ist erst ab MetaDOS
V2.30 vorhanden!
</p>
<p>Querverweis: <a href="xbios_drive.html#Metainit">Metainit</a>
</p>
<h3><a name="META_INFO_2">4.24.12 META_INFO_2</a></h3>
<pre>typedef struct
{
   /* Versionsnummer (0x230 = '02.30') */
   uint16_t     mi_version;
   /* Magic Konstante '_MET' */
   int32_t      mi_magic;
   /* Zuordnung <a href="gemdos_main.html">GEMDOS</a>-&gt;<a href="xbios_metados.html">MetaDOS</a> */
   const int8_t *mi_log2phys;
} META_INFO_2;
</pre>
<p><b>Hinweis:</b> Diese Struktur existiert erst ab MetaDOS Version
2.30. Der Parameter <i>mi_log2phys</i> ist ein Zeiger auf ein Feld,
das zu jedem GEMDOS-Gerät den dazugehörigen MetaDOS
Laufwerksbuchstaben oder Null enthält. Mit Hilfe dieser Information
kann man also feststellen, welcher MetaDOS Laufwerksbuchstabe zu
welchem GEMDOS-Laufwerk gehört.
</p>
<p>Querverweis: <a href="xbios_drive.html#Metainit">Metainit</a> &nbsp; <a href="#META_INFO_1">META_INFO_1</a>
</p>
<h3><a name="MOD_DESC">4.24.13 MOD_DESC</a></h3>
<pre>typedef struct
{
   int8_t  Name[34];   /* beschreibender Text     */
   int32_t colors;
   int16_t xres,yres;
   int32_t fileptr;    /* Zeiger in die Modedatei */
} MOD_DESC;
</pre>
<p>Querverweis: <a href="crazydots.html">Crazy-Dots-XBIOS-Erweiterung</a>
</p>
<h3><a name="MOUSE">4.24.14 MOUSE</a></h3>
<pre>typedef struct
{
   int8_t  topmode;  /* 0: Y=0 am unteren Rand,    */
                     /* 1: Y=1 am oberen Rand      */
   int8_t  buttons;  /* analog IKBD                */
   int8_t  x_scale;  /* zusätzliche Parameter, vom */
   int8_t  y_scale;  /* gewählten Modus abhängig.  */
   int16_t x_max;    /* maximale X-Position        */
   int16_t y_max;    /* maximale Y-Position        */
   int16_t x_start;  /* Anfangsposition X          */
   int16_t y_start;  /* Anfangsposition Y          */
} MOUSE;
</pre>
<p><b>Hinweis:</b> Die Komponenten <i>x_max</i> und folgende sind
nur im absoluten Modus verfügbar.
</p>
<p>Querverweis: <a href="gem_about.html">GEM</a> &nbsp; <a href="Screen_functions.html#Initmouse">Initmouse</a> &nbsp; <a href="vdi_main.html">VDI</a>
</p>
<h3><a name="OVERPATCH">4.24.15 OVERPATCH</a></h3>
<pre>typedef struct
{
   int16_t low_w  ,mid_w  ,high_w;   /* Breite in Pixeln                */
   int16_t low_h  ,mid_h  ,high_h;   /* Höhe   in Pixeln                */
   int32_t low_off,mid_off,high_off; /* Offset Bildspeicher&lt;&gt;<a href="Screen_functions.html#Logbase">Logbase</a>    */
   int32_t mono_add,color_add;       /* Zusätzlicher Speicherbedarf     */
   int8_t  clear_scan;               /* Scancode  der Clear-Funktion    */
   int8_t  clear_shift;              /* Shiftcode der Clear-Funktion    */
   int8_t  setup_shift;              /* Shiftcode für Setup (Maske)     */
   int8_t  invert_shift;             /* Shiftcode zum Invert. des Modus */
   int8_t  abort_shift;              /* Shiftcode zum Abbrechen         */
} OVERPATCH;
</pre>
<p>Querverweis: <a href="xbios_overscan.html#Oscanpatch">Oscanpatch</a> &nbsp; <a href="xbios_overscan.html">OverScan-XBIOS-Erweiterungen</a>
</p>
<h3><a name="PBDEF">4.24.16 PBDEF</a></h3>
<pre>typedef struct
{
   void    *pb_scrptr;  /* Zeiger auf Bildschirmanfang     */
   int16_t  pb_offset;  /* dazu zu addierender Offset      */
   int16_t  pb_width;   /* Bildschirmbreite in Punkten     */
   int16_t  pb_height;  /* Bildschirmhöhe in Punkten       */
   int16_t  pb_left;    /* Linker Rand in Punkten          */
   int16_t  pb_right;   /* Rechter Rand in Punkten         */
   int16_t  pb_screz;   /* Auflösung                       */
   int16_t  pb_prrez;   /* Druckertyp (Atari/Epson)        */
   void    *pb_colptr;  /* Zeiger auf Farbpalette          */
   int16_t  pb_prtype;  /* 0: Atari Matrix monochrom
                           1: Atari Matrix farbig
                           2: Atari Typenrad monochrom
                           3: Epson Matrix monochrom       */
   int16_t  pb_prport;  /* Schnittstelle Centronics/RS-232 */
   void    *pb_mask;    /* Zeiger auf Halbtonmaske         */
} PBDEF;
</pre>
<p><b>Hinweis:</b> Es muß darauf geachtet werden, daß die Summe
der Komponenten <i>pb_width</i>, <i>pb_left</i> und <i>pb_right</i>
genau die tatsächliche Bildschirmbreite ergibt.
</p>
<p>Querverweis: <a href="xbios_printer.html#Prtblk">Prtblk</a> &nbsp; <a href="xbios_main.html">XBIOS</a>
</p>
<h3><a name="PCI_RSC_DESC">4.24.17 PCI_RSC_DESC</a></h3>
<pre>typedef struct
{
  uint16_t next;      /* Länge dieser Struktur in Bytes, dient zur      */
                      /* Ermittlung des nächsten Deskiptors             */
  uint16_t flags;     /* Resourcen-Typ und verschiedene andere Flags    */
  uint32_t start;     /* Startadresse der Resource im PCI Adreßbereich, */
                      /* ist die Resource nicht direkt ansprechbar,     */
                      /* so ist die Adresse 0                           */
  uint32_t length;    /* Länge der Resource                             */
  uint32_t offset;    /* Offset von der physikalischen CPU-Adresse      */
                      /* zur PCI-Adresse                                */
  uint32_t dmaoffset; /* Offset für DMA-Transfers vom/zum Hauptspeicher */
} PCI_RSC_DESC;
</pre>
<p>Um den Deskriptor der nächsten Resource des PCI-Gerätes zu
ermitteln, muß man zur Startadresse des aktuellen Deskriptors das
Feld next addieren. Das Feld start gibt den Beginn der entsprechenden
Resource im PCI-Adreßbereich an. Falls diese Resource nicht direkt
ansprechbar sein sollte, so steht in diesem Feld die Adresse 0. Über
length kann man schließlich die Länge dieser Resource bestimmen. Der
PCI-Adreßbereich ist im allgemeinen nicht mit der von der CPU aus
gesehenen Adresse gleichzusetzen. Der Adreß-Offset, der zur
PCI-Adresse zu addieren ist, um die physikalische Adresse für die CPU
zu ermitteln, ist im Feld offset abgelegt.Der Eintrag dmaoffset gibt
schließlich den Offset an, der zur PCI-Adresse addiert werden muß,
wenn es sich um DMA-Transfers handelt.
</p>
<p>Die Flags im Resource-Deskriptor
</p>
<a name="RSC_ROM"></a>
<a name="RSC_IO"></a>
<a name="RSC_LAST"></a>
<a name="FLG_8BIT"></a>
<a name="FLG_16BIT"></a>
<a name="FLG_32BIT"></a>
<a name="FLG_ENDMASK"></a>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">RSC_ROM</td>
  <td align="left" valign="top">0x2000</td>
  <td align="left" valign="top">This is an expansion ROM (must be Memory, not IO)</td>
</tr>
<tr>
  <td align="left" valign="top">RSC_IO</td>
  <td align="left" valign="top">0x4000</td>
  <td align="left" valign="top">kennzeichnet einen I/O-Bereich, bei</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">gelöschten Bit handelt es sich um</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">einen memory-Bereich</td>
</tr>
<tr>
  <td align="left" valign="top">RSC_LAST</td>
  <td align="left" valign="top">0x8000</td>
  <td align="left" valign="top">letzte Resource für dieses PCI-Gerät</td>
</tr>
<tr>
  <td align="left" valign="top">FLG_8BIT</td>
  <td align="left" valign="top">0x0100</td>
  <td align="left" valign="top">8 Bit Zugriffe werden unterstützt</td>
</tr>
<tr>
  <td align="left" valign="top">FLG_16BIT</td>
  <td align="left" valign="top">0x0200</td>
  <td align="left" valign="top">16 Bit Zugriffe werden unterstützt</td>
</tr>
<tr>
  <td align="left" valign="top">FLG_32BIT</td>
  <td align="left" valign="top">0x0400</td>
  <td align="left" valign="top">32 Bit Zugriffe werden unterstützt</td>
</tr>
<tr>
  <td align="left" valign="top">FLG_ENDMASK</td>
  <td align="left" valign="top">0x000F</td>
  <td align="left" valign="top">kennzeichnet das Byte Ordering:</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0: Motorola (big endian)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">1: Intel (little endian), address swapped</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">2: Intel (little endian), lane swapped</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">3..14: reserviert</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">15: unbekannt, Zugriff nur über <a href="bios_main.html">BIOS</a> möglich</td>
</tr>
</table>
</div>

<p>The <i>start</i> field contains the start address on the PCI
bus of the resource. If the resource is not directly accessible, the
start address is 0.
</p>
<p>The <i>length</i> field contains its length.
</p>
<p>The <i>offset</i> field contains the offset from physical CPU
to PCI address for the resource - ie. the value that must be added to
the PCI address to get the physical address in CPU address space.
</p>
<p>The <i>dmaoffset</i> gives the offset that a PCI bus master
must add to a CPU memory address to access that address in main memory
over the PCI BUS.
</p>
<p><u>What are all these byte orders?</u>
</p>
<p>The PCI-bus is defined as a little endian byte ordering bus. The
most significant byte of a multi-byte number is located at the lowest
address occupied by this number.
</p>
<p>The 68xxx-series CPUs are big endian. PCI-bus and CPU are
connected together by a host bridge which does some kind of format
conversion. The <a href="PCI_BIOS.html">PCI-BIOS</a> knows about the format conversion performed
by the host bridge. The <a href="PCI_BIOS.html">PCI-BIOS</a> does not know about any format
conversion done (internally) by PCI devices. The driver has to know
its device's properties and capabilities.
</p>
<p>The table shows what 68xxx data byte (top row) is connected to
what PCI-bus data byte (lower right) by what 68xxx-access and format
conversion (left column):
</p>
<pre>                  68xxx-CPU data bus bits
                  D31..24  D23..16  D15..8   D7..0
----------------------------------------------------
big endian
32-bit-access +0  D31..24  D23..16  D15..8   D7..0
16-bit-access +0  D15..8   D7..0
16-bit-access +2                    D31..24  D23..16
 8-bit-access +0  D7..0
 8-bit-access +1           D15..8
 8-bit-access +2                    D23..16
 8-bit-access +3                             D31..24
----------------------------------------------------
little endian, lane swapped
32-bit-access +0  D0..7    D15..8   D23..16  D31..24
16-bit-access +0  D0..7    D15..8
16-bit-access +2                    D23..16  D31..24
 8-bit-access +0  D0..7
 8-bit-access +1           D15..8
 8-bit-access +2                    D23..16
 8-bit-access +3                             D31..24
----------------------------------------------------
little endian, address swapped
32-bit-access +0  D31..24  D23..16  D15..8   D7..0
16-bit-access +0  D31..24  D23..16
16-bit-access +2                    D15..8   D7..0
 8-bit-access +0  D31..24
 8-bit-access +1           D23..16
 8-bit-access +2                    D15..8
 8-bit-access +3                             D7..0
</pre>
<ul>
<li><p> &quot;Big endian&quot; makes the PCI-bus appear as a big endian
resource from the viewpoint of the 68xxx processor. It requires
dynamic route changes in the host bridge and seems not to be
implemented by any host bridge.
<br>&nbsp;
</p></li>
<li><p> &quot;Little endian, lane swapped&quot; is the easy way to make
8 bit per pixel modes work in the frame buffer of a PCI-device (VGA
controller) which does not have its own format conversion. This mode
is used in PCI-Macintoshs and for memory and IO accesses in the Milan.
In this mode, the address needs no modifications. 8-bit accesses work
normal, on 16 and 32 bit accesses endian conversion must be performed
on the the read or written data (ror.w #8,d0 for 16 bit, ror.w
#8,d0:swap d0:ror.w #8,d0 for 32 bit).
<br>&nbsp;
</p></li>
<li><p> &quot;Little endian, address swapped&quot; is the way to go if
accesses to 32 bit registers or 32 bit per pixel frame buffers have
top priority. In this mode, 32 bit accesses work without
modifications. On 16 bit accesses, the address needs to be XOR'd with
a value of 2, on 8-bit accesses the address is XOR'd with a value of
3. The data read or written is in correct format.
<br>&nbsp;
</p></li>
</ul>

<p>Querverweis: <a href="PCI_BIOS.html#get_resource">get_resource</a>
</p>
<h3><a name="PMODE">4.24.18 PMODE</a></h3>
<pre>typedef struct  {
   int8_t  name[34];
   int16_t mode_id;       /* lfd. Nr.                             */
   int16_t xres,yres;     /* Breite/Höhe in Pixeln                */
   int16_t fx,fy;         /* Breite/Höhe gesamt                   */
   int32_t colors;        /* Anzahl gleichzeitiger Farben         */
   int16_t org;           /* Organisation des Speichers           */
   int16_t fh10,fv10;     /* Zeilenfreq.*10, Bildfreq*10          */
   int16_t aspect100;     /* 100*PixelBreite/PixelHöhe            */
   int16_t disp_scan100;
   int32_t clk;           /* Dotclock in Hz                       */
   /*
   * Register des Grafikcontrollers
   */
   int16_t Clock;         /* Frequenznummer, muß vorm Schreiben in */
                          /* das Clock-Register über die IcsLut
                             umgesetzt werden (s. u.)              */
   int8_t  misc_out;
   int8_t  ts[10];        /* Timing Sequencer Regs.                */
   int8_t  crtc[35];      /* CRT-Controller Regs.                  */
   int8_t  gdc[10];       /* Graphics Display Controller           */
   int8_t  atc[24];       /* Attribute Controller                  */
   int8_t  reserved[18];
} PMODE;

static int8_t IcsLut[32] = { 0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,
               30,1,17,9,25,5,21,13,29,3,19,11,27,7,23,15,31 };
</pre>
<p>Querverweis: <a href="crazydots.html">Crazy-Dots-XBIOS-Erweiterung</a> &nbsp; <a href="crazydots.html#ReadMode">ReadMode</a> &nbsp;
<a href="crazydots.html#GetActiveModeDesc">GetActiveModeDesc</a>
</p>
<h3><a name="SCRCLIPMEMBLK">4.24.19 SCRCLIPMEMBLK</a></h3>
<pre>typedef struct _scrclipblk
{
  int32_t size;        /* size of structure            */
  int32_t blk_status;  /* status bits of blk           */
  int32_t blk_clip_on; /* clipping flag 1:on, 0:off    */
  int32_t blk_x;       /* x pos in total screen        */
  int32_t blk_y;       /* y pos in in total screen     */
  int32_t blk_w;       /* width                        */
  int32_t blk_h;       /* height                       */
} SCRCLIPMEMBLK;
</pre>
<p>Querverweise: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCRCOPYMEMBLK">4.24.20 SCRCOPYMEMBLK</a></h3>
<pre>typedef struct _scrcopyblk
{
  int32_t size;                 /* size of structure            */
  int32_t blk_status;           /* status bits of blk           */
  int32_t blk_src_x;            /* x pos source in total screen */
  int32_t blk_src_y;            /* y pos source in total screen */
  int32_t blk_dst_x;            /* x pos dest in total screen   */
  int32_t blk_dst_y;            /* y pos dest in total screen   */
  int32_t blk_w;                /* width                        */
  int32_t blk_h;                /* height                       */
  int32_t blk_op;               /* mode operation               */
} SCRCOPYMEMBLK;
</pre>
<p>Querverweise: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCREEN">4.24.21 SCREEN</a></h3>
<pre>typedef struct
{
   int8_t   xbra_id[4];       /* XBRA-Id: 'CDOT'                      */
   int8_t   version[4];       /* z.B.: '1.10'                         */
   int8_t  *sm194_addr;       /* Zeiger auf Großbildschirmspeicher    */
   int8_t  *sm124_addr;       /* Zeiger auf SM124 Bildspeicher.       */
   <a href="linea_vars.html">LINEA</a>   *line_A;           /* Zeiger auf <a href="gemdos_structures.html#LINE">LINE</a>_A Block.             */
   int16_t  scrn_width;       /* Bildschirmweite                      */
   int16_t  scrn_height;      /* Bildschirmhöhe                       */
   int16_t  scrn_byte_width;  /* Bildschirmweite in Bytes             */
   int16_t  scrn_planes;      /* Bildschirmfarbebenen                 */
   int16_t  PhysMode;         /* Modusmummer                          */
   int16_t  VirtMode;         /* x/16 u. y/16 in je einem Byte cod.   */
   <a href="#PMODE">PMODE</a>   *ModStruct;        /* Zeiger auf akt. Grafikmodus (s.u.)   */
   int16_t  grau;/* Flag für den <a href="VDI_fundamentals.html#VDI-Treiber">VDI-Treiber</a> (Darstellung: Grau/Farbe)*/
   int16_t  BiosText;         /* Flag für den <a href="VDI_fundamentals.html#VDI-Treiber">VDI-Treiber</a>             */
   int16_t  CurText;          /* Flag für den <a href="VDI_fundamentals.html#VDI-Treiber">VDI-Treiber</a>             */
   int16_t  BlitMode;         /*           &quot;                          */
} SCREEN;
</pre>
<p>Querverweis: <a href="crazydots.html">Crazy-Dots-XBIOS-Erweiterung</a>
</p>
<h3><a name="SCREENINFO">4.24.22 SCREENINFO</a></h3>
<a name="SCRINFO_OK"></a>
<a name="NO_CLUT"></a>
<a name="HARD_CLUT"></a>
<a name="SOFT_CLUT"></a>
<a name="INTERLEAVE_PLANES"></a>
<a name="STANDARD_PLANES"></a>
<a name="PACKEDPIX_PLANES"></a>
<a name="STANDARD_BITS"></a>
<a name="FALCON_BITS"></a>
<a name="INTEL_BITS"></a>
<pre>/* scrFlags */
 #define SCRINFO_OK 1

/* scrClut */
 #define NO_CLUT    0
 #define HARD_CLUT  1
 #define SOFT_CLUT  2

/* scrFormat */
 #define INTERLEAVE_PLANES  0
 #define STANDARD_PLANES    1
 #define PACKEDPIX_PLANES   2

/* bitFlags */
 #define STANDARD_BITS  1
 #define FALCON_BITS    2
 #define INTEL_BITS     8

typedef struct screeninfo
{
  int32_t size;        /* Size of structur           */
  int32_t devID;       /* Device ID number           */
  int8_t  name[64];    /* Friendly name of Screen    */
  int32_t scrFlags;    /* Some flags                 */
  int32_t frameadr;    /* Adress of framebuffer      */
  int32_t scrHeight;   /* Visible X res              */
  int32_t scrWidth;    /* Visible Y res              */
  int32_t virtHeight;  /* Virtual X res              */
  int32_t virtWidth;   /* Virtual Y res              */
  int32_t scrPlanes;   /* color Planes               */
  int32_t scrColors;   /* # of colors                */
  int32_t lineWrap;    /* # of bytes to next line    */
  int32_t planeWarp;   /* # of bytes to next plane   */
  int32_t scrFormat;   /* Screen format              */
  int32_t scrClut;     /* Type of clut               */
  int32_t redBits;     /* Mask of Red Bits           */
  int32_t greenBits;   /* Mask of Green Bits         */
  int32_t blueBits;    /* Mask of Blue Bits          */
  int32_t alphaBits;   /* Mask of Alpha Bits         */
  int32_t genlockBits; /* Mask of Genlock Bits       */
  int32_t unusedBits;  /* Mask of unused Bits        */
  int32_t bitFlags;    /* Bits organisation flags    */
  int32_t maxmem;      /* Max. memory in this mode   */
  int32_t pagemem;     /* Needed memory for one page */
  int32_t max_x;       /* Max. possible width        */
  int32_t max_y;       /* Max. possible heigth       */
}SCREENINFO;
</pre>
<p>Querverweise: <a href="Screen_functions.html#Setscreen_2C_20Milan">Setscreen, Milan</a> &nbsp; <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCREEN_2C_20OverScan">4.24.23 SCREEN, OverScan</a></h3>
<pre>typedef struct
{
   int16_t width;             /* Breite in Pixel                     */
   int16_t height;            /* Höhe   in Pixel                     */
   int16_t bytes_per_line;    /* Bytes pro Bildschirmzeile           */
   int32_t length_of_screen;  /* Länge des Bildspeichers in Bytes    */
   int32_t physbase_offset;   /* Offset Start-Bildspeicher&lt;&gt;<a href="Screen_functions.html#Physbase">Physbase</a> */
   int32_t logbase_offset;    /* Offset Start-Bildspeicher&lt;&gt;<a href="Screen_functions.html#Logbase">Logbase</a>  */
} <a href="#SCREEN">SCREEN</a>;
</pre>
<p>Querverweis: <a href="xbios_overscan.html">OverScan-XBIOS-Funktionen</a> &nbsp; <a href="xbios_overscan.html#Oscantab">Oscantab</a>
</p>
<h3><a name="SCRFILLMEMBLK">4.24.24 SCRFILLMEMBLK</a></h3>
<pre>/* operations */
 #define BLK_CLEAR        0
 #define BLK_AND          1
 #define BLK_ANDREVERSE   2
 #define BLK_COPY         3
 #define BLK_ANDINVERTED  4
 #define BLK_NOOP         5
 #define BLK_XOR          6
 #define BLK_OR           7
 #define BLK_XNOR         8
 #define BLK_EQUIV        9
 #define BLK_INVERT       10
 #define BLK_ORREVERSE    11
 #define BLK_COPYINVERTED 12
 #define BLK_ORINVERTED   13
 #define BLK_NAND         14
 #define BLK_SET          15

typedef struct _scrsetblk
{
  int32_t size;                  /* size of structure           */
  int32_t blk_status;            /* status bits of blk          */
  int32_t blk_op;                /* mode operation              */
  int32_t blk_color;             /* background fill color       */
  int32_t blk_x;                 /* x pos in total screen       */
  int32_t blk_y;                 /* y pos in total screen       */
  int32_t blk_w;                 /* width                       */
  int32_t blk_h;                 /* height                      */
  int32_t blk_unused;
} SCRFILLMEMBLK;
</pre>
<p>Querverweise: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCRLINEMEMBLK">4.24.25 SCRLINEMEMBLK</a></h3>
<pre>typedef struct _scrlineblk
{
  int32_t size;        /* size of structure            */
  int32_t blk_status;  /* status bits of blk           */
  int32_t blk_fgcolor; /* foreground fill color        */
  int32_t blk_bgcolor; /* background fill color        */
  int32_t blk_x1;      /* x1 pos dest in total screen  */
  int32_t blk_y1;      /* y1 pos dest in total screen  */
  int32_t blk_x2;      /* x2 pos dest in total screen  */
  int32_t blk_y2;      /* y2 pos dest in total screen  */
  int32_t blk_op;      /* mode operation               */
  int32_t blk_pattern; /* pattern (-1: solid line)     */
} SCRLINEMEMBLK;
</pre>
<p>Querverweise: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCRMEMBLK">4.24.26 SCRMEMBLK</a></h3>
<a name="BLK_ERR"></a>
<a name="BLK_OK"></a>
<a name="BLK_CLEARED"></a>
<pre>
 #define BLK_ERR      0
 #define BLK_OK       1
 #define BLK_CLEARED  2

typedef struct _scrblk
{
  int32_t size;              /* Size of strukture                  */
  int32_t blk_status;        /* Status bits of blk                 */
  int32_t blk_start;         /* Start adress                       */
  int32_t blk_len;           /* Length of memblk                   */
  int32_t blk_x;             /* X pos in total screen              */
  int32_t blk_y;             /* Y pos in total screen              */
  int32_t blk_w;             /* Width                              */
  int32_t blk_h;             /* Height                             */
  int32_t blk_wrap;          /* Width in bytes, from: 2000-01-13   */
} SCRMEMBLK;
</pre>
<p>Querverweise: <a href="Screen_functions.html#Setscreen_2C_20Milan">Setscreen, Milan</a> &nbsp; <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCRTEXTUREMEMBLK">4.24.27 SCRTEXTUREMEMBLK</a></h3>
<pre>typedef struct _scrtextureblk
{
  long size;                /* size of structure             */
  long blk_status;          /* status bits of blk            */
  long blk_src_x;           /* x pos source                  */
  long blk_src_y;           /* y pos source                  */
  long blk_dst_x;           /* x pos dest in total screen    */
  long blk_dst_y;           /* y pos dest in total screen    */
  long blk_w;               /* width                         */
  long blk_h;               /* height                        */
  long blk_op;              /* mode operation                */
  long blk_src_tex;         /* source texture address        */
  long blk_w_tex;           /* width texture                 */
  long blk_h_tex;           /* height texture                */
}SCRTEXTUREMEMBLK;
</pre>
<p>Querverweise: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="VDO_MODE">4.24.28 VDO_MODE</a></h3>
<pre>/* mode code xxxx xxxF SOPV 8NNN */
typedef struct
{
   uint16_t Plan:3;           /* Bit 0-2: NNN (Anzahl Planes)       */
   uint16_t _80Col:1;         /* Bit 3: Flag 80 Spalten (8)         */
   uint16_t VGA:1;            /* Bit 4: Flag VGA (V)                */
   uint16_t Pal:1;            /* Bit 5: Flag Pal (P)                */
   uint16_t Overscan:1;       /* Bit 6: Flag overscan (O)           */
   uint16_t STComp:1;         /* Bit 7: Flag ST compatible (S)      */
   uint16_t Vertical:1;       /* Bit 8: Flag Vertical (F)           */
   uint16_t NRJStart:1;       /* Bit 9: Energy Star                 */
   uint16_t Eco:1;            /* Bit 10: Eenrgiesparmodus           */
   uint16_t Virtual:1;        /* Bit 11: <a href="bios_cookiejar.html#virtueller_20Bildschirm">virtueller Bildschirm</a>      */
   uint16_t ExtClock:1;       /* Bit 12: externe Uhr 32/36MHz (CT2) */
   uint16_t ExtClockEnable:1; /* Bit 13: externen Uhr testen        */
   uint16_t StandardResol:1;  /* Bit 14: Standardauflösung          */
   uint16_t DefaultMode:1;    /* Bit 15: default Videomode          */
} VDO_MODE;
</pre>
<p>Querverweise: <a href="#VDO_PARAM">VDO_PARAM</a>
</p>
<h3><a name="VDO_PARAM">4.24.29 VDO_PARAM</a></h3>
<pre>typedef struct
{
   int16_t V_Hdl;        /* Handle                                  */
   <a href="#VDO_MODE">VDO_MODE</a> V_mode;      /* Videomodus wie beim Falcon              */
   int16_t  V_physw;     /* Breite des physikalischen Bildschirms   */
   int16_t  V_physh;     /* Höhe des physikalischen Bildschirms     */
   int16_t  V_plan;      /* Anzahl Planes                           */
   int16_t  V_logw;      /* Breite des virtuellen Bildschirms       */
   int16_t  V_logh;      /* Höhe des virtuellen Bildschirms         */
   int16_t  V_eco;       /* Delay in Sekunden vor <a href="gemdos_system.html#Shutdown">Shutdown</a>          */
   int16_t  V_eco2;      /* Delay in Sekunden zwischen <a href="gemdos_system.html#Shutdown">Shutdown</a>     */
                         /* und Energie Star Modus                  */
   int8_t   V_name[33];  /* Name des Videomodus (max. 32 Bytes)     */
                         /* mit 0 abgeschlossen.                    */
   int8_t   Reserved;    /* reserviert für zukünftige Erweiterungen */
   int32_t  V_length;    /* Puffergröße                             */
} VDO_PARAM;
</pre>
<p>Querverweise: <a href="CENTScreen_XBIOS_extension.html#Vread">Vread</a>
</p>
<h3><a name="vidix_capability_t">4.24.30 vidix_capability_t</a></h3>
<pre>typedef struct vidix_capability_s
{
   char    name[64];    /* Driver name */
   char    author[64];  /* Author name */
#define TYPE_OUTPUT      0x00000000    /* Is a video playback device */
#define TYPE_CAPTURE     0x00000001    /* Is a capture device */
#define TYPE_CODEC       0x00000002    /* Device supports hw (de)coding */
#define TYPE_FX          0x00000004    /* Is a video effects device */
   int    type;         /* Device type, see below */
   unsigned reserved0[4];
   int    maxwidth;
   int    maxheight;
   int    minwidth;
   int    minheight;
   int    maxframerate; /* -1 if unlimited */
#define FLAG_NONE        0x00000000 /* No flags defined */
#define FLAG_DMA         0x00000001 /* Card can use DMA */
#define FLAG_EQ_DMA      0x00000002 /* Card can use DMA only if src pitch == dest pitch */
#define FLAG_UPSCALER    0x00000010 /* Card supports hw upscaling */
#define FLAG_DOWNSCALER  0x00000020 /* Card supports hw downscaling */
#define FLAG_SUBPIC      0x00001000 /* Card supports DVD subpictures */
#define FLAG_EQUALIZER   0x00002000 /* Card supports equalizer */
   unsigned flags;      /* Feature flags, see above */
   unsigned short vendor_id;
   unsigned short device_id;
   unsigned reserved1[4];
}vidix_capability_t;
</pre>
<p>Querverweis: <a href="vidix_xbios_extension.html">VIDIX-XBIOS-Erweiterung</a>
</p>
<h3><a name="vidix_deinterlace_t">4.24.31 vidix_deinterlace_t</a></h3>
<pre>typedef struct vidix_deinterlace_s
{
#define CFG_NON_INTERLACED        0x00000000 /* stream is not interlaced */
#define CFG_INTERLACED            0x00000001 /* stream is interlaced */
#define CFG_EVEN_ODD_INTERLACING  0x00000002 /* first frame contains even fields but second - odd */
#define CFG_ODD_EVEN_INTERLACING  0x00000004 /* first frame contains odd fields but second - even */
#define CFG_UNIQUE_INTERLACING    0x00000008 /* field deinterlace_pattern is valid */
#define CFG_UNKNOWN_INTERLACING   0x0000000f /* unknown deinterlacing - use adaptive if it's possible */
   unsigned    flags;               /* driver -&gt; app */
   unsigned    deinterlace_pattern; /* driver -&gt; app: deinterlace pattern if flag CFG_UNIQUE_INTERLACING is set */
}vidix_deinterlace_t;
</pre>
<p>Querverweis: <a href="vidix_xbios_extension.html">VIDIX-XBIOS-Erweiterung</a>
</p>
<h3><a name="vidix_dma_t">4.24.32 vidix_dma_t</a></h3>
<pre>typedef struct vidix_dma_s
{
   void *src;               /* app -&gt; driver: Virtual address of source */
   unsigned dest_offset;    /* app -&gt; driver: Destination offset within of video memory */
   unsigned size;           /* app -&gt; driver: Size of transaction */
#define BM_DMA_NOSYNC      0
#define BM_DMA_SYNC        1 /* wait previous dma transfer completion */
#define BM_DMA_FIXED_BUFFS 2 /* app uses buffers witch are fixed in memory */
#define BM_DMA_BLOCK       4 /* block until the transfer is complete */
   unsigned flags;          /* app -&gt; driver */
   unsigned idx;            /* app -&gt; driver: index of the src buffer */
   unsigned src_incr;       /* app -&gt; driver: if src_incr &amp; dest_incr are */
   unsigned dest_incr;      /*                different, else 0 */
   void *internal[VID_PLAY_MAXFRAMES];    /* for internal use by driver */
}vidix_dma_t;
</pre>
<p>Querverweis: <a href="vidix_xbios_extension.html">VIDIX-XBIOS-Erweiterung</a>
</p>
<h3><a name="vidix_fourcc_t">4.24.33 vidix_fourcc_t</a></h3>
<pre>typedef struct vidix_fourcc_s
{
   unsigned fourcc; /* input: requested fourcc */
   unsigned srcw;   /* input: hint: width of source */
   unsigned srch;   /* input: hint: height of source */
#define VID_DEPTH_NONE             0x0000
#define VID_DEPTH_1BPP             0x0001
#define VID_DEPTH_2BPP             0x0002
#define VID_DEPTH_4BPP             0x0004
#define VID_DEPTH_8BPP             0x0008
#define VID_DEPTH_12BPP            0x0010
#define VID_DEPTH_15BPP            0x0020
#define VID_DEPTH_16BPP            0x0040
#define VID_DEPTH_24BPP            0x0080
#define VID_DEPTH_32BPP            0x0100
   unsigned depth; /* output: screen depth for given fourcc */
#define VID_CAP_NONE               0x0000
#define VID_CAP_EXPAND             0x0001 /* if overlay can be bigger than source */
#define VID_CAP_SHRINK             0x0002 /* if overlay can be smaller than source */
#define VID_CAP_BLEND              0x0004 /* if overlay can be blended with framebuffer */
#define VID_CAP_COLORKEY           0x0008 /* if overlay can be restricted to a colorkey */
#define VID_CAP_ALPHAKEY           0x0010 /* if overlay can be restricted to an alpha channel */
#define VID_CAP_COLORKEY_ISRANGE   0x0020 /* if the colorkey can be a range */
#define VID_CAP_ALPHAKEY_ISRANGE   0x0040 /* if the alphakey can be a range */
#define VID_CAP_COLORKEY_ISMAIN    0x0080 /* colorkey is checked against framebuffer */
#define VID_CAP_COLORKEY_ISOVERLAY 0x0100 /* colorkey is checked against overlay */
#define VID_CAP_ALPHAKEY_ISMAIN    0x0200 /* alphakey is checked against framebuffer */
#define VID_CAP_ALPHAKEY_ISOVERLAY 0x0400 /* alphakey is checked against overlay */
   unsigned flags; /* output: capability */
}vidix_fourcc_t;
</pre>
<p>Querverweis: <a href="vidix_xbios_extension.html">VIDIX-XBIOS-Erweiterung</a>
</p>
<h3><a name="vidix_grkey_t">4.24.34 vidix_grkey_t</a></h3>
<pre>typedef struct vidix_grkey_s
{
   vidix_ckey_t    ckey;      /* driver -&gt; app: color key */
   vidix_vkey_t    vkey;      /* driver -&gt; app: video key */
#define KEYS_PUT    0
#define KEYS_AND    1
#define KEYS_OR     2
#define KEYS_XOR    3
   unsigned    key_op;        /* driver -&gt; app: keys operations */
}vidix_grkey_t;
</pre>
<p>Querverweis: <a href="vidix_xbios_extension.html">VIDIX-XBIOS-Erweiterung</a>
</p>
<h3><a name="vidix_playback_t">4.24.35 vidix_playback_t</a></h3>
<pre>typedef struct vidix_playback_s
{
   unsigned fourcc;           /* app -&gt; driver: movies's fourcc */
   unsigned capability;       /* app -&gt; driver: what capability to use */
   unsigned blend_factor;     /* app -&gt; driver: blending factor */
   vidix_rect_t src;          /* app -&gt; driver: original movie size */
   vidix_rect_t dest;         /* app -&gt; driver: destinition movie size. driver-&gt;app dest_pitch */
#define VID_PLAY_INTERLEAVED_UV 0x00000001    /* driver -&gt; app: interleaved UV planes */
#define INTERLEAVING_UV         0x00001000    /* UVUVUVUVUV used by Matrox G200 */
#define INTERLEAVING_VU         0x00001001    /* VUVUVUVUVU */
   int        flags;
   /* memory model */
   unsigned frame_size;       /* driver -&gt; app: destinition frame size */
   unsigned num_frames;       /* app -&gt; driver: after call: driver -&gt; app */
#define VID_PLAY_MAXFRAMES 64 /* reasonable limitation for decoding ahead */
   unsigned offsets[VID_PLAY_MAXFRAMES];    /* driver -&gt; app */
   vidix_yuv_t    offset;     /* driver -&gt; app: relative offsets within frame for yuv planes */
   void    *dga_addr;         /* driver -&gt; app: linear address */
}vidix_playback_t;
</pre>
<p>Querverweis: <a href="vidix_xbios_extension.html">VIDIX-XBIOS-Erweiterung</a>
</p>
<h3><a name="vidix_video_eq_t">4.24.36 vidix_video_eq_t</a></h3>
<pre>typedef struct vidix_video_eq_s
{
#define VEQ_CAP_NONE            0x00000000UL
#define VEQ_CAP_BRIGHTNESS      0x00000001UL
#define VEQ_CAP_CONTRAST        0x00000002UL
#define VEQ_CAP_SATURATION      0x00000004UL
#define VEQ_CAP_HUE             0x00000008UL
#define VEQ_CAP_RGB_INTENSITY   0x00000010UL
   int        cap;             /* should contain capability of equalizer */
   /* end-user app can have presets like: cold-normal-hot picture and so on */
   int        brightness;      /* -1000 : +1000 */
   int        contrast;        /* -1000 : +1000 */
   int        saturation;      /* -1000 : +1000 */
   int        hue;             /* -1000 : +1000 */
   int        red_intensity;   /* -1000 : +1000 */
   int        green_intensity; /* -1000 : +1000 */
   int        blue_intensity;  /* -1000 : +1000 */
#define VEQ_FLG_ITU_R_BT_601    0x00000000 /* ITU-R BT.601 colour space (default) */
#define VEQ_FLG_ITU_R_BT_709    0x00000001 /* ITU-R BT.709 colour space */
#define VEQ_FLG_ITU_MASK        0x0000000f
   int        flags;           /* currently specifies ITU YCrCb color space to use */
}vidix_video_eq_t;
</pre>
<p>Querverweis: <a href="vidix_xbios_extension.html">VIDIX-XBIOS-Erweiterung</a>
</p>
<h3><a name="VPOS">4.24.37 VPOS</a></h3>
<pre>typedef struct
{
   int16_t x;
   int16_t y;
} VPOS;
</pre>
<p>Querverweise: <a href="CENTScreen_XBIOS_extension.html#Vseek">Vseek</a>
</p>
<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_functions.html"><img src="udo_lf.gif" alt="XBIOS-Funktionsliste" title="XBIOS-Funktionsliste" border="0" width="24" height="24">XBIOS-Funktionsliste</a>
<a name="UDO_nav_rg_FOOT" href="gemdos_main.html"><img src="udo_rg.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
</body>
</html>
