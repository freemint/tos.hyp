<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 02.08.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: BSIM-BIOS-Erweiterungen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="bios_main.html"><img src="udo_up.gif" alt="BIOS" title="BIOS" border="0" width="24" height="24">BIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbra_main.html"><img src="udo_lf.gif" alt="XBRA-Verfahren" title="XBRA-Verfahren" border="0" width="24" height="24">XBRA-Verfahren</a>
<a name="UDO_nav_rg_HEAD" href="bios_functions.html"><img src="udo_rg.gif" alt="BIOS-Funktionsliste" title="BIOS-Funktionsliste" border="0" width="24" height="24">BIOS-Funktionsliste</a>

<hr>

<h1><a name="BSIM-BIOS-Erweiterungen">3.10 BSIM-BIOS-Erweiterungen</a></h1>
<a name="BSIM"></a>
<p>Die Grundidee des Drive-B-Simulator war, eine Diskette in den
Speicher einzulesen und als RAM-Disk zu betreiben. Die Funktion
'Diskette schreiben' schreibt die RAM-Disk auf eine Diskette zurück.
Mit der Einführung des 'Swap-Modus' arbeitet das Programm auch mit
Anwendungen, die stur auf Laufwerk A zugreifen.
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#bsim_id">bsim_id</a></td>
<td valign="top"> Ermittelt, ob BSIM verfügbar ist
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#drv_change">drv_change</a></td>
<td valign="top"> Tauscht Laufwerke
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#drvprotec">drvprotec</a></td>
<td valign="top"> Schützt Laufwerke
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#dstate">dstate</a></td>
<td valign="top"> Get details about the drive
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#kill_disk">kill_disk</a></td>
<td valign="top"> Löscht Diskette
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#load_disk">load_disk</a></td>
<td valign="top"> Lädt eine Diskette in den Speicher
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#save_disk">save_disk</a></td>
<td valign="top"> Schreibt Diskette.

</td></tr>
</table>

<p><b>Note:</b> Drive-B-Simulator uses the same XBRA ID as BlitSim
('BSIM').
</p>
<p><b>Configuration file:</b>
</p>
<p>The config file BSTAT.INF is an array of 18 bytes. The following
apply:
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Offset</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">0..15</td>
<td valign="top"> Write lock status (0 or 1) for each drive, from byte 0=A to
byte 15=P
</td></tr>

<tr><td nowrap="nowrap" valign="top">16</td>
<td valign="top"> Load disk at startup (0 or 1)
</td></tr>

<tr><td nowrap="nowrap" valign="top">17</td>
<td valign="top"> Swap drives at startup (0 or 1)

</td></tr>
</table>

<p><b>Warning</b> Calls to this <a href="bios_main.html">BIOS</a> extension must be avoided
because Drive-B-Simulator uses undocumented <a href="tos_main.html">TOS</a> features and
hard-coded addresses which prevent it from working under EmuTOS.
</p>
<p>Vorgestellt in der deutsche Zeitschrift <a href="tos_main.html">TOS</a> 3/1992.
</p>
<h3><a name="bsim_id">3.10.1 bsim_id</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »BSIM id« - ermittelt, ob <a href="BSIM-BIOS-Extension.html#BSIM">BSIM</a> verfügbar ist.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Biosnummer:</td>
<td valign="top"> 300 (0x012c)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20bsim_id">Bindings für bsim_id</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ermittelt die <a href="BSIM-BIOS-Extension.html#BSIM">BSIM</a> id.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Wenn <a href="BSIM-BIOS-Extension.html#BSIM">BSIM</a> installiert ist, gibt die Funktion 0x4253494D
('BSIM') zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Drive-B-Simulator.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20bsim_id">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20bsim_id">3.10.1.1 Bindings für bsim_id</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #$12C,-(sp)   ; Offset 0
trap      #13           ; <a href="bios_main.html">BIOS</a> aufrufen
addq.l    #2,sp         ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic:</td>
<td valign="top"> Fehler%=Bios(300)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="drv_change">3.10.2 drv_change</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Drive change« - tauscht Drives.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Biosnummer:</td>
<td valign="top"> 304 (0x0130)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20drv_change">Bindings für drv_change</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion tauscht Drives. Für <i>data</i> gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0:</td>
<td valign="top"> Normal
</td></tr>

<tr><td nowrap="nowrap" valign="top">1:</td>
<td valign="top"> Tauschen
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1:</td>
<td valign="top"> Status holen

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern in D0:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0:</td>
<td valign="top"> Normal
</td></tr>

<tr><td nowrap="nowrap" valign="top">1:</td>
<td valign="top"> Tauschen

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Drive-B-Simulator.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20drv_change">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20drv_change">3.10.2.1 Bindings für drv_change</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #data,-(sp)   ; Offset 2
move.w    #$130,-(sp)   ; Offset 0
trap      #13           ; <a href="bios_main.html">BIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic:</td>
<td valign="top"> Fehler%=Bios(304,W:data%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="drvprotec">3.10.3 drvprotec</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Drive protection« - schützt Laufwerke.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Biosnummer:</td>
<td valign="top"> 305 (0x0131)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20drvprotec">Bindings für drvprotec</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion schützt Laufwerke. <i>ptrdrv</i> ist ein
Bitvektor für geschützte Laufwerke (Bit 0=A, Bit 1=B...), oder -1
(Status holen).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Bitvektor für die
geschützte Laufwerke.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Drive-B-Simulator.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20drvprotec">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20drvprotec">3.10.3.1 Bindings für drvprotec</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    #ptrdrv,-(sp) ; Offset 2
move.w    #$131,-(sp)   ; Offset 0
trap      #13           ; <a href="bios_main.html">BIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic:</td>
<td valign="top"> Fehler%=Bios(305,L:prtdrv%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="dstate">3.10.4 dstate</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Drive status« - Get RAM-disk details.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Biosnummer:</td>
<td valign="top"> 306 (0x0132)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20dstate">Bindings für dstate</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ermittelt den Deskriptorfeld für die RAM-Disk.
Der <i>pointer</i> zeigt auf Deskriptorfeld.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Offset</td>
<td valign="top"> Beschreibung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0 (long)</td>
<td valign="top"> Startadresse der Disk im Speicher
</td></tr>

<tr><td nowrap="nowrap" valign="top">4 (long)</td>
<td valign="top"> Länge der Disk
</td></tr>

<tr><td nowrap="nowrap" valign="top">8 (short)</td>
<td valign="top"> Seiten (der eingelesenen Disk)
</td></tr>

<tr><td nowrap="nowrap" valign="top">10 (short)</td>
<td valign="top"> Tracks
</td></tr>

<tr><td nowrap="nowrap" valign="top">12 (short)</td>
<td valign="top"> Sektoren

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern in D0:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>:</td>
<td valign="top"> OK
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1:</td>
<td valign="top"> Keine Disk im Speicher

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Drive-B-Simulator.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20dstate">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20dstate">3.10.4.1 Bindings für dstate</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 2
move.w    #$132,-(sp)   ; Offset 0
trap      #13           ; <a href="bios_main.html">BIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic:</td>
<td valign="top"> Fehler%=Bios(306,L:pointer%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="kill_disk">3.10.5 kill_disk</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Kill disk« - löscht Diskette.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Biosnummer:</td>
<td valign="top"> 302 (0x012e)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20kill_disk">Bindings für kill_disk</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion löscht die Diskette aus dem Speicher.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern in D0:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>:</td>
<td valign="top"> Disk ist gelöscht
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1:</td>
<td valign="top"> Falsches Magic

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Drive-B-Simulator.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20kill_disk">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20kill_disk">3.10.5.1 Bindings für kill_disk</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    #magic,-(sp)  ; Offset 2, magic:$87654321
move.w    #$12E,-(sp)   ; Offset 0
trap      #13           ; <a href="bios_main.html">BIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic:</td>
<td valign="top"> Fehler%=Bios(302,L:magic%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="load_disk">3.10.6 load_disk</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Load disk« - lädt eine Diskette in den Speicher.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Biosnummer:</td>
<td valign="top"> 301 (0x012d)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20load_disk">Bindings für load_disk</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion lädt eine Diskette in den Speicher.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern in D0:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>:</td>
<td valign="top"> OK
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1:</td>
<td valign="top"> Zuwenig Speicher
</td></tr>

<tr><td nowrap="nowrap" valign="top">-2:</td>
<td valign="top"> Bereits eine Disk im Speicher
</td></tr>

<tr><td nowrap="nowrap" valign="top">-3:</td>
<td valign="top"> Disk Error
</td></tr>

<tr><td nowrap="nowrap" valign="top">-4:</td>
<td valign="top"> Falsches Magic

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Drive-B-Simulator.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20load_disk">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20load_disk">3.10.6.1 Bindings für load_disk</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    #magic,-(sp)  ; Offset 2, magic:$12345678
move.w    #$12D,-(sp)   ; Offset 0
trap      #13           ; <a href="bios_main.html">BIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic:</td>
<td valign="top"> Fehler%=Bios(301,L:magic%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="save_disk">3.10.7 save_disk</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Save disk« - schreibt Diskette.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Biosnummer:</td>
<td valign="top"> 303 (0x012f)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20save_disk">Bindings für save_disk</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion schreibt den Speicher auf die Diskette.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern in D0:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>:</td>
<td valign="top"> Alles OK
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1:</td>
<td valign="top"> Falsches Magic
</td></tr>

<tr><td nowrap="nowrap" valign="top">-2:</td>
<td valign="top"> Keine Disk im Speicher
</td></tr>

<tr><td nowrap="nowrap" valign="top">-4:</td>
<td valign="top"> Schreibfehler

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Drive-B-Simulator.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20save_disk">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20save_disk">3.10.7.1 Bindings für save_disk</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    #magic,-(sp)  ; Offset 2, magic:$ABCD0123
move.w    #$12F,-(sp)   ; Offset 0
trap      #13           ; <a href="bios_main.html">BIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic:</td>
<td valign="top"> Fehler%=Bios(303,L:magic%)
<br>&nbsp;

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="bios_main.html"><img src="udo_up.gif" alt="BIOS" title="BIOS" border="0" width="24" height="24">BIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbra_main.html"><img src="udo_lf.gif" alt="XBRA-Verfahren" title="XBRA-Verfahren" border="0" width="24" height="24">XBRA-Verfahren</a>
<a name="UDO_nav_rg_FOOT" href="bios_functions.html"><img src="udo_rg.gif" alt="BIOS-Funktionsliste" title="BIOS-Funktionsliste" border="0" width="24" height="24">BIOS-Funktionsliste</a>
</body>
</html>
