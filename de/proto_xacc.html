<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 02.08.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: XAcc
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="protocols.html"><img src="udo_up.gif" alt="Protokolle" title="Protokolle" border="0" width="24" height="24">Protokolle</a>
<a name="UDO_nav_lf_HEAD" href="proto_vscreen.html"><img src="udo_lf.gif" alt="Virtual-Screen-Protokoll" title="Virtual-Screen-Protokoll" border="0" width="24" height="24">Virtual-Screen-Protokoll</a>
<a name="UDO_nav_rg_HEAD" href="proto_xfsl.html"><img src="udo_rg.gif" alt="xFSL-Schnittstelle" title="xFSL-Schnittstelle" border="0" width="24" height="24">xFSL-Schnittstelle</a>

<hr>

<h1><a name="XAcc">15.13 XAcc</a></h1>
<p>The XAcc protocol was originally designed for non-multitasking
versions of <a href="gem_about.html">GEM</a> to allow data exchange between the main application
and any number of accessories. Since the <a href="aes_main.html">AES</a> did not provide a
function to find the application IDs (apIDs) of other applications
without knowing their names, XAcc had to rely on the undocumented
feature that the main application always has the apID 0. Therefore
XAcc in its present <a class="UDO_footnote" title="refers to the XAcc definition before &quot;Classic XAcc&quot;">(1)</a> form does not work in a multitasking
environment. However, AES 4.0 provides the new function
<a href="appl.html#appl_search">appl_search</a>, which allows any application to find the apIDs of all
other applications running concurrently. This makes it possible to
design a modified XAcc that does not use any 'dirty tricks'. This
document contains a proposal for such a modified XAcc; the changes
with respect to the previous definition are small and modifying an
existing XAcc-based application should be a matter of minutes. Since
single-tasking <a href="tos_main.html">TOS</a> will still be with us for a while, applications are
encouraged to implement both 'traditional' and 'modern' XAcc,
depending on the version number of the AES.
</p>
<ul class="content">
	<li>15.13.1 <a href="#Purpose_20of_20XAcc">Purpose of XAcc</a>
	<li>15.13.2 <a href="#Classic_20XAcc">Classic XAcc</a>
			<ul class="content">
		<li>15.13.2.1 <a href="#XAcc_20message_20groups">XAcc message groups</a>
		<li>15.13.2.2 <a href="#XAcc_20messages">XAcc messages</a>
				<ul class="content">
			<li>15.13.2.2.1 <a href="#Basic_20XAcc_20messages">Basic XAcc messages</a>
					<ul class="content">
				<li>15.13.2.2.1.1 <a href="#Single-tasking_20GEM_20versions">Single-tasking GEM versions</a>
				<li>15.13.2.2.1.2 <a href="#Multitasking_20GEM_20versions">Multitasking GEM versions</a>
						</li>
					</ul>
					</li>
			<li>15.13.2.2.2 <a href="#Extended_20names">Extended names</a>
			<li>15.13.2.2.3 <a href="#Message_20group_201">Message group 1</a>
			<li>15.13.2.2.4 <a href="#Message_20group_202">Message group 2</a>
					</li>
				</ul>
				</li>
		<li>15.13.2.3 <a href="#Compatibility_20considerations">Compatibility considerations</a>
				</li>
			</ul>
			</li>
	<li>15.13.3 <a href="#Extended_20XAcc">Extended XAcc</a>
			<ul class="content">
		<li>15.13.3.1 <a href="#MailMerge-Protokoll">MailMerge-Protokoll</a>
		<li>15.13.3.2 <a href="#Remote-Mailmerge-Protokoll">Remote-Mailmerge-Protokoll</a>
		<li>15.13.3.3 <a href="#Inquiry-Protokoll">Inquiry-Protokoll</a>
		<li>15.13.3.4 <a href="#Request_2FReply-Protokoll">Request/Reply-Protokoll</a>
				</li>
			</ul>
			</li>
	<li>15.13.4 <a href="#Example:_20no_7CLink_27s_20XAcc_20protocol">Example: no|Link's XAcc protocol</a>
	<li>15.13.5 <a href="#XACC.H">XACC.H</a>
	</li>
</ul>
<br>
<h3><a name="Purpose_20of_20XAcc">15.13.1 Purpose of XAcc</a></h3>
<p>The <a href="gem_about.html">GEM</a> AES functions <a href="appl.html#appl_write">appl_write</a> and <a href="appl.html#appl_read">appl_read</a> can be used to
exchange data between <a href="gem_about.html">GEM</a> applications running concurrently. In
practice however, some problems need to be solved to make good use of
these two functions:
</p>
<ul>
<li><p> There are no standard messages for exchanging data. Their
definition is the main goal of <a href="#XAcc">XAcc</a>.
<br>&nbsp;
</p></li>
<li><p> <a href="appl.html#appl_write">appl_write</a> needs the receiver's application identifier (apID).
The only way to get this (before AES 4.0) is to call <a href="appl.html#appl_find">appl_find</a>,
which needs the receiver's name. Thus communication is only possible
if the sender knows the receiver's name.
<br>This problem is solved in AES 4.0 by the introduction of the
function <a href="appl.html#appl_search">appl_search</a>.
<br>&nbsp;
</p></li>
<li><p> The main application does not know when an accessory is
activated or deactivated. This would often be useful, for example if
the main application changes system variables that could affect the
accessory's behaviour. If the main application were informed before
the accessory gains control, it could reset those to their old values
and change them back after the accessory is finished.
<br>Another advantage would be that after an accessory has been
called, the main application could check if something has been written
to the clipboard <a class="UDO_footnote" title="a special non-XAcc message - SC_CHANGED - has been introduced for this purpose">(1)</a> or if other changes to the environment have
been made.
<br>&nbsp;
<br>With multitasking <a href="gem_about.html">GEM</a>, the situation has changed in several
important ways. The possibility of using several 'main' applications
in parallel makes it even more undesirable to let them directly
manipulate system variables and the like; nevertheless there will
probably always remain some purposes that require such methods. On the
other hand, at least for applications using windows (the preferred
method to get the most out of a multitasking system) it is now
possible to detect changes of the active application by interpreting
the new <a href="aes_main.html">AES</a> messages <a href="evnt.html#WM_ONTOP">WM_ONTOP</a> and <a href="evnt.html#WM_UNTOPPED">WM_UNTOPPED</a>. Therefore it is not
considered necessary for XAcc to provide additional means to achieve
this.
<br>&nbsp;
</p></li>
</ul>

<p>The communications protocol described in this document solves
all these problems. It was designed for two distinct purposes:
</p>
<ul>
<li><p> Exchanging data of standard types between programs that have no
information about each other.
<br>&nbsp;
</p></li>
<li><p> Exchanging data between specific applications known to each
other. The standard protocol ensures that program combinations from
different vendors do not interfere with each other.
<br>&nbsp;
</p></li>
</ul>

<p>A potential problem caused by this protocol should be mentioned
at this point: for single-tasking <a href="gem_about.html">GEM</a> versions, it relies on the
currently undocumented fact that the main application's apID is always
zero. Without this assumption there is no way to exchange data without
using <a href="appl.html#appl_find">appl_find</a>. Although this fact is not documented, it holds for
all single-tasking versions of GEM in existence until now, both for
MS-DOS and the Atari ST (this information was confirmed by Digital
Research Germany). Of course the main application's apID may be
different in future versions, although there is no reason to change
the current behaviour for single-tasking systems. For <a href="aes_main.html">AES</a> 4.0 (and
later) the above assumption is not needed anyway, so no compatibility
problems are to be expected in the future.
</p>
<p>A further requirement is that all programs not using this
protocol must ignore its messages. This should not be a serious
problem, as all GEM applications should ignore messages they do not
understand. At the time of writing no programs are known to violate
this rule.
</p>
<h3><a name="Classic_20XAcc">15.13.2 Classic XAcc</a></h3>
<p>The &quot;classic&quot; <a href="#XAcc">XAcc</a> protocoll was finally defined on
November 28, 1992. All known <a href="#XAcc">XAcc</a> applications implement the protocol
this way.
</p>
<ul class="content">
	<li>15.13.2.1 <a href="#XAcc_20message_20groups">XAcc message groups</a>
	<li>15.13.2.2 <a href="#XAcc_20messages">XAcc messages</a>
	<li>15.13.2.3 <a href="#Compatibility_20considerations">Compatibility considerations</a>
		</li>
</ul>
<br>
<h4><a name="XAcc_20message_20groups">15.13.2.1 XAcc message groups</a></h4>
<p>[Note: The &quot;levels&quot; used in previous <a href="#XAcc">XAcc</a> versions
have been replaced by this new concept. Compatibility issues are
discussed in a special section at the end of this document.]
</p>
<p>Both main applications and accessories can have widely different
needs for communication with other programs. Therefore XAcc defines
several groups of related messages <a class="UDO_footnote" title="Note: The &quot;levels&quot; used in previous XAcc versions have been replaced by this new concept. Compatibility issues are discussed in a special section at the end of this document.">(1)</a> that deal with a certain
range of data types. The message groups always indicate the messages
understood by a program, not the messages it might send to other ones.
If a program supports a certain message group, it must correctly
respond to all corresponding messages, whether it can actually use the
supplied data or not.
</p>
<p>In addition to XAcc message groups, there are the so-called
&quot;basic messages&quot;, which must be supported by any
XAcc-aware program, and program-specific so-called &quot;special
messages&quot;.
</p>
<p>The basic messages deal solely with identification, but no real
data exchange. They are already sufficient for programs that either do
not exchange data with others at all or use only special messages to
communicate with a number of other specific programs.
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="#Message_20group_201">Message group 1</a></td>
<td valign="top"> specifies the exchange of ASCII-format character data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="#Message_20group_202">Message group 2</a></td>
<td valign="top"> deals with the exchange of drawings and pictures using the <a href="gem_about.html">GEM</a>
metafile format and the <a href="gem_about.html">GEM</a> bit-image file format.
<br>&nbsp;

</td></tr>
</table>

<p>Future extensions might include sound or spreadsheet data. In
addition, a message group could be defined to handle command
interchange between applications, e.g. for a &quot;Drag&amp;Drop&quot;
protocol <a class="UDO_footnote" title="meanwhile Atari has introduced the MultiTOS drag&amp;drop protocol">(2)</a>.
</p>
<h4><a name="XAcc_20messages">15.13.2.2 XAcc messages</a></h4>
<p>There are two kinds of XAcc messages: standard messages, which
must be understood by every participating program, and special
messages intended for communications between specific program
combinations. The standard messages have numbers ranging from 0x400 to
0x7ff, special messages start from 0x800. The latter ones may only be
sent after the receiver has been identified and is known to understand
them. The following description is only concerned with standard
messages. In addition to <a href="#XAcc">XAcc</a> standard messages, the <a href="aes_main.html">AES</a> messages
normally sent by the <a href="aes_fundamentals.html#The_20screen-manager">screen manager</a> may be used. The most useful ones are
<a href="evnt.html#AC_OPEN">AC_OPEN</a> and <a href="evnt.html#MN_SELECTED">MN_SELECTED</a>; the latter one requires a knowledge of the
receiver and therefore belongs to the special messages.
</p>
<ul class="content">
	<li>15.13.2.2.1 <a href="#Basic_20XAcc_20messages">Basic XAcc messages</a>
	<li>15.13.2.2.2 <a href="#Extended_20names">Extended names</a>
	<li>15.13.2.2.3 <a href="#Message_20group_201">Message group 1</a>
	<li>15.13.2.2.4 <a href="#Message_20group_202">Message group 2</a>
			</li>
</ul>
<br>
<h5><a name="Basic_20XAcc_20messages">15.13.2.2.1 Basic XAcc messages</a></h5>
<a name="ACC_ID"></a>
<a name="ACC_OPEN"></a>
<a name="ACC_CLOSE"></a>
<a name="ACC_ACC"></a>
<a name="ACC_EXIT"></a>
<pre>ACC_ID    = 0x400
ACC_OPEN  = 0x401
ACC_CLOSE = 0x402
ACC_ACC   = 0x403
ACC_EXIT  = 0x404
</pre>
<p>These messages provide <a href="#XAcc">XAcc</a> initialization and organization.
This is the only part of XAcc which has to be implemented in a
different way for single- and multi-tasking <a href="gem_about.html">GEM</a> versions. Note that
the procedure described for 'multitasking' actually only depends on
the existence of <a href="appl.html#appl_search">appl_search</a> and hence on an <a href="aes_main.html">AES</a> version number &gt;=
4.0. If some future single-tasking AES supports <a href="appl.html#appl_search">appl_search</a>, the
'multitasking' initialization should be used. Multitasking AES
versions with a version number &lt; 4.0 should never exist; to be on
the safe side, applications should not attempt to use XAcc if such a
situation is detected <a class="UDO_footnote" title="NB: ASH's MagiC (even the latest version) uses AES version 3.99 despite of supporting appl_search()">(1)</a>.
</p>
<ul class="content">
	<li>15.13.2.2.1.1 <a href="#Single-tasking_20GEM_20versions">Single-tasking GEM versions</a>
	<li>15.13.2.2.1.2 <a href="#Multitasking_20GEM_20versions">Multitasking GEM versions</a>
				</li>
</ul>
<br>
<h6><a name="Single-tasking_20GEM_20versions">15.13.2.2.1.1 Single-tasking GEM versions</a></h6>
<p>The communication between the main application and the
accessories is initiated in the following way:
</p>

<ol class="UDO_env_enumerate">
<li><p> When a main application is started (or terminated), all desk
accessories receive an <a href="evnt.html#AC_CLOSE">AC_CLOSE</a> message from the AES <a href="aes_fundamentals.html#The_20screen-manager">screen manager</a>. In
response they must send an identification to the main application
according to the following format:
<br>&nbsp;
<pre>     msg[0]:  <a href="proto_xacc.html#ACC_ID">ACC_ID</a> (0x400)
     msg[1]:  sender's apID
     msg[2]:  length of the message - 16, giving 0
     msg[3]:  program version number and message groups
     msg[4] and msg[5]:   pointer to sender's name
     msg[6]:  menu number (menu_id) as returned by <a href="menu.html#menu_register">menu_register</a>
     msg[7]:  reserved (see <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a>)
</pre>
<br>The low byte of msg[3] contains a bitmap indicating which
message groups are understood by the sender. Bit zero is set for
message group 1, bit one for message group 2, and so on. This is
independent of the message types which the sender might itself send to
others. The sender of a message must ensure that it is understood by
the receiver. The high byte is used to indicate a program version
number using an arbitrary encoding scheme.
<br>&nbsp;
<br>The pointer to the sender's name is stored in a
machine-dependent format. The name itself is a character string
following C conventions, i.e. a string of characters terminated by a
zero byte. To avoid name conflicts, long names are preferred to short
abbreviations. The name must be available at the given address at any
time, it may not be removed after initialization. As the version
number is stored in msg[3], it should not occur again in the name.
<a class="UDO_footnote" title="see the section &quot;Extended names&quot; for more details on names.">(1)</a>
<br>&nbsp;
<br><a href="aes_fundamentals.html#Accessories">Accessories</a> using more than one menu entry must issue one <a href="proto_xacc.html#ACC_ID">ACC_ID</a>
message for each entry used. Accessories without a menu entry must use a
number of -1.
<br>&nbsp;
<br>Since msg[1] and msg[2] have the same meaning for all message
types, they are no longer mentioned from now on.
<br>&nbsp;
</p></li>
<li><p> In response to an <a href="proto_xacc.html#ACC_ID">ACC_ID</a> message the main application sends an
identification back to the accessory. The format is identical, except
that there is no menu number and thus msg[6] can be used for any other
purpose if neccessary. The same applies to msg[7].
<br>&nbsp;
</p></li>
<li><p> In addition to the <a href="proto_xacc.html#ACC_ID">ACC_ID</a> message, the main application informs
all previously registered accessories about the new one by sending
them the message
<br>&nbsp;
<pre>     msg[0]:  <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a> (0x403)
     msg[3]:  program version number and message groups
     msg[4] and msg[5]:   pointer to accessory's name
     msg[6]:  accessory's menu number (menu_id)
     msg[7]:  accessory's apID
</pre>
</p></li>
<li><p> A desk accessory receiving the <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a> message from the main
application sends an <a href="proto_xacc.html#ACC_ID">ACC_ID</a> message to the thereby registered
accessory, identical to the one previously sent to the main
application.
<br>&nbsp;
</p></li>
<li><p> When an accessory is activated by receiving an <a href="evnt.html#AC_OPEN">AC_OPEN</a> message,
it sends the following message to the main application:
<br>msg[0]: <a href="proto_xacc.html#ACC_OPEN">ACC_OPEN</a>
<br>Just before the accessory returns control to another program, it
sends the message
<br>msg[0]: <a href="proto_xacc.html#ACC_CLOSE">ACC_CLOSE</a>
<br>When receiving <a href="proto_xacc.html#ACC_OPEN">ACC_OPEN</a>, the main application restores all system
variables it has changed to their original values (if possible and
neccessary). After receiving <a href="proto_xacc.html#ACC_CLOSE">ACC_CLOSE</a>, it may set them again to any
desired value.
<br>&nbsp;
<br><a href="aes_fundamentals.html#Accessories">Accessories</a> should change system variables only after sending
ACC_OPEN and restore them before ACC_CLOSE.
<br>&nbsp;
<br>There have been some problems with the implementation of
<a href="proto_xacc.html#ACC_OPEN">ACC_OPEN</a> and <a href="proto_xacc.html#ACC_CLOSE">ACC_CLOSE</a> that should be mentioned. The system was
designed with window-less accessories in mind, i.e. accessories that
only display a dialog box. For these accessories, the above procedure
is well-defined. <a href="aes_fundamentals.html#Accessories">Accessories</a> that use windows however have no way to
find out if they have been activated or deactivated, because they do
not receive a message to indicate this (starting from <a href="aes_main.html">AES</a> 4.0, this
problem is solved). Therefore such accessories must be careful with
<a href="proto_xacc.html#ACC_OPEN">ACC_OPEN</a> and <a href="proto_xacc.html#ACC_CLOSE">ACC_CLOSE</a>. The most important thing is to guarantee that
ACC_OPEN and ACC_CLOSE always occur in pairs, and that in between no other
program gains control. How exactly this is implemented depends on the
specific application. Sometimes the best implementation is not to use
ACC_OPEN and ACC_CLOSE at all.
<br>&nbsp;
</p></li>
</ol>

<p>After initialization is completed, all participating programs
know the identity of all other ones, either by receiving an <a href="proto_xacc.html#ACC_ID">ACC_ID</a>
message or by receiving an <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a> message. The main application is
always informed about accessory activities. If in addition it proves
neccessary to inform one accessory about the activation of another
one, this can be accomplished by sending special messages (starting
from 0x800).
</p>
<h6><a name="Multitasking_20GEM_20versions">15.13.2.2.1.2 Multitasking GEM versions</a></h6>
<p>The initialization procedure is much simpler in this case. Any
application, i.e. both 'standard' applications and accessories, uses
<a href="appl.html#appl_search">appl_search</a> to detect all currently running <a href="aes_main.html">AES</a> processes when it is
started. To each application or accessory (i.e. everything but system
processes) it sends an <a href="proto_xacc.html#ACC_ID">ACC_ID</a> message:
</p>
<pre>  msg[0]:  <a href="proto_xacc.html#ACC_ID">ACC_ID</a> (0x400)
  msg[1]:  sender's apID
  msg[2]:  length of the message - 16, giving 0
  msg[3]:  program version number and message groups
  msg[4] and msg[5]:  pointer to sender's name
  msg[6]:  menu number (menu_id) as returned by <a href="menu.html#menu_register">menu_register</a>
  msg[7]:  reserved
</pre>
<p>The low byte of msg[3] contains a bitmap indicating which
message groups are understood by the sender. Bit zero is set for
message group 1, bit one for message group 2, and so on. This is
independent of the message types which the sender might itself send to
others. The sender of a message must ensure that it is understood by
the receiver. The high byte is used to indicate a program version
number using an arbitrary encoding scheme.
</p>
<p>The pointer to the sender's name is stored in a
processor-dependent format. The name itself is a string of characters
terminated by two zero bytes. To avoid name conflicts, long names are
preferred to short abbreviations. The name must be available at the
given address at any time, it may not be removed after initialization.
It must also reside in globally accessible memory. As the version
number is stored in msg[3], it should not occur again in the name.
<a class="UDO_footnote" title="see the section &quot;Extended names&quot; for more details on names.">(1)</a>
</p>
<p>Applications using more than one menu entry must issue one
<a href="proto_xacc.html#ACC_ID">ACC_ID</a> message for each entry used. <a href="aes_fundamentals.html#Accessories">Accessories</a> without a menu entry
must use a number of -1.
</p>
<p>When receiving an <a href="proto_xacc.html#ACC_ID">ACC_ID</a> message, an application replies by
sending a message of the same format to the original sender, the only
difference being that <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a> is used instead of <a href="proto_xacc.html#ACC_ID">ACC_ID</a>. Applications
with several menu entries must again send one message for each entry.
</p>
<p>The messages <a href="proto_xacc.html#ACC_OPEN">ACC_OPEN</a> and <a href="proto_xacc.html#ACC_CLOSE">ACC_CLOSE</a> are not used in multitasking
systems.
</p>
<p><b>Note:</b> The only difference between <a href="proto_xacc.html#ACC_ID">ACC_ID</a> and <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a> for
multitasking systems is that an application receiving ACC_ID sends
ACC_ACC as a reply, whereas no reply is sent on receiving ACC_ACC. This
prevents applications from sending <a href="proto_xacc.html#ACC_ID">ACC_ID</a> to each other indefinitely.
Obviously the name <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a> has lost its original meaning and probably
should be changed. But since the symbolic names do not influence the
actual behaviour of any program, this is not really important at all.
</p>
<p>Since in a multitasking environment every participating
application can terminate, some means must be provided to tell other
applications about this. Therefore the message <a href="proto_xacc.html#ACC_EXIT">ACC_EXIT</a> has been added
to the list of level 0 messages. Before terminating, any application
sends
</p>
<pre>  msg[0]:  <a href="proto_xacc.html#ACC_EXIT">ACC_EXIT</a> (0x404)
  msg[1]:  sender's apID
  msg[2]:  length of the message - 16, giving 0
</pre>
<p>to all applications that have ever registered themselves by
sending <a href="proto_xacc.html#ACC_ID">ACC_ID</a> or <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a>.
</p>
<h5><a name="Extended_20names">15.13.2.2.2 Extended names</a></h5>
<p>Experience with <a href="#XAcc">XAcc</a> has shown that it would often be useful to
have more information about an application than specified with <a href="proto_xacc.html#ACC_ID">ACC_ID</a>
messages. For example it is sometimes useful to check for a special
feature that is not unique to a single program, but to several similar
ones. This was the motivation for the introduction of &quot;extended
names&quot;.
</p>
<p>An &quot;extended name&quot; is a character string of the
format:
</p>
<p>'name'\0XDSC\0'string'\0'string'\0...'string'\0\0
</p>
<p>i.e. a &quot;standard&quot; name followed by the string
&quot;XDSC&quot; (for &quot;e<b>X</b>tended
<b>D</b>e<b>SC</b>ription&quot;), followed by a list of strings
containing additional information. The end of the list is marked by an
additional zero byte.
</p>
<p>Each information string indicates by its first byte what kind of
information it contains. Currently the following types are defined:
</p>
<table class="UDO_env_blist">
<tr><td nowrap="nowrap" valign="top"><b>'1'</b></td>
<td valign="top"> - application type (human-readable)
<br>&nbsp;
<br>The text following this byte (an ASCII-1, 0x31) should roughly
specify the type of application, e.g. &quot;word processor&quot; or
&quot;spreadsheet&quot;. The purpose is for applications to present
this information to the user to let him/her decide where data should
go. This is not the place for advertising hype; a word processor
should call itself &quot;word processor&quot; and not &quot;document
editing and design system&quot;.
<br>&nbsp;
<br>It should be clear that the text should be understandable for
end users, especially it should be in the language used for the user
interface.
<br>&nbsp;
<a name="CD"></a>
<a name="DB"></a>
<a name="DC"></a>
<a name="DP"></a>
<a name="DT"></a>
<a name="ED"></a>
<a name="GG"></a>
<a name="MU"></a>
<a name="MV"></a>
<a name="PE"></a>
<a name="RG"></a>
<a name="SS"></a>
<a name="VG"></a>
<a name="WP"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>'2'</b></td>
<td valign="top"> - application type (machine-readable)
<br>&nbsp;
<br>Currently defined are:
<br>&quot;WP&quot; - Word processor
<br>&quot;DP&quot; - DTP
<br>&quot;ED&quot; - Text editor
<br>&quot;DB&quot; - Database
<br>&quot;SS&quot; - Spreadsheet
<br>&quot;RG&quot; - Raster graphics application
<br>&quot;VG&quot; - Vector graphics application
<br>&quot;GG&quot; - General graphics application
<br>&quot;MU&quot; - Music application
<br>&quot;CD&quot; - CAD
<br>&quot;DC&quot; - Data communication
<br>&quot;DT&quot; - Desktop
<br>&quot;PE&quot; - Programming environment
<br>&nbsp;
<a name="Extended_20feature"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>'X'</b></td>
<td valign="top"> - extended features This string is used to indicate special
communication capabilities of an application. It can be used to give
more specific information than just the message groups understood.
Since this information is meant to be used by other applications
rather than end users, short abbreviations are sufficient.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>'N'</b></td>
<td valign="top"> - generic name Often several related, but not completely
identical, applications have different names. Marketing requirements
may even dictate changes of the &quot;official&quot; brand names,
making them unsuitable for a &quot;technical&quot; identification. In
such cases a &quot;generic&quot; name for all these programs can be
specified, which is mainly used by other programs wishing to use
special messages.
<br>&nbsp;

</td></tr>
</table>

<p>The &quot;normal&quot; name should be the &quot;official&quot;
name of the program, just as it is used on the package, in the manual,
and in similar places. It should be presentable to the user to let
him/her decide where to send data.
</p>
<p><b>Example:</b> The address database &quot;That's Address&quot;
identifies itself with the extended name (in C syntax)
</p>
<p>&quot;That's Address\0XDSC\01database\02DB\0XMM\0XSU\0&quot;,
</p>
<p>indicating that it is a database with features &quot;MM&quot;
and &quot;SU&quot;. The first one indicates a special mail merge mode,
the second one the possibility of retrieving data by sending the key
via <a href="proto_xacc.html#ACC_TEXT">ACC_TEXT</a>. (Further information on this program can be obtained
from its manual.)
</p>
<h5><a name="Message_20group_201">15.13.2.2.3 Message group 1</a></h5>
<a name="ACC_ACK"></a>
<a name="ACC_TEXT"></a>
<a name="ACC_KEY"></a>
<pre>ACC_ACK  = 0x500
ACC_TEXT = 0x501
ACC_KEY  = 0x502
</pre>

<ol class="UDO_env_enumerate">
<li><p> Transmitting text data:
<br>&nbsp;
<pre>     msg[0]:  ACC_TEXT (0x501)
     msg[4] and msg[5]:   pointer to text
</pre>
<br>The text may contain all printable ASCII characters (code &gt;=
32) and the following control codes:
<br>&nbsp;
<br>0x09 TAB (may be interpreted as a space by the receiver)
<br>0x0A LF (usually ignored by receiver)
<br>0x0D CR (used to mark an end-of-line (or end-of paragraph)
<br>&nbsp;
<br>Other control codes may only be used if the receiver is known to
understand them. The text is terminated by a zero byte. After the text
has been interpreted completely, the receiver acknowledges by sending
<br>&nbsp;
<pre>     msg[0]:  ACC_ACK (0x500)
     msg[3]:  0 if the text was simply ignored
              1 if it was used in some sensible way
</pre>
<br>The sender of a text message may not change the text nor send
any other text messages to the same receiver until is has received the
acknowledgement.
<br>&nbsp;
<br>The sender must make sure that the memory used to store the text
is globally accessible.
<br>&nbsp;
<br>The receiver should normally interpret the text as if it were
typed from the keyboard. A word processor would for example insert it
into the currently edited document (this implies using CR as an
end-of- paragraph mark), a command line interpreter would interpret
the text as a command (which implies using CR as an end-of-line mark).
<br>&nbsp;
</p></li>
<li><p> Simulation of a key press:
<br>&nbsp;
<pre>     msg[0]:  ACC_KEY (0x502)
     msg[3]:  scancode of the simulated key and corresponding
              ASCII-code (as returned by <a href="evnt.html#evnt_keybd">evnt_keybd</a>)
     msg[4]:  state of the SHIFT keys (as returned by <a href="About_the_BIOS.html#Kbshift">Kbshift</a>)
</pre>
<br>This message should be regarded identical to a keyboard
event<a class="UDO_footnote" title="AV_SENDKEY from Gemini's AV protocol is used more often">(1)</a>. It can be used to send control commands to a receiver
which might have been issued from the keyboard. Of course this
requires a knowledge of the receiver, as no standard keyboard command
sets exist. It should be noted that the receiver is free to use only
the ASCII-code or only the scan code, or both of them.
<br>&nbsp;
<br>This message is acknowledged after its interpretation with:
<br>&nbsp;
<pre>     msg[0]:  ACC_ACK (0x500)
     msg[3]:  0 if ACC_KEY was ignored or a given command was not
              understood, 1 if some action was taken.
</pre>
</p></li>
</ol>

<p>To prevent a deadlock if a program does not properly acknowledge
a message, the sender should have some way to recover. An accessory
could for example stop waiting for an acknowledgement after the next
<a href="evnt.html#AC_OPEN">AC_OPEN</a>, a main application might time out after a sufficiently long
period.
</p>
<h5><a name="Message_20group_202">15.13.2.2.4 Message group 2</a></h5>
<a name="ACC_META"></a>
<a name="ACC_IMG"></a>
<pre>ACC_META = 0x503
ACC_IMG  = 0x504
</pre>
<p>These message are used to exchange drawings and pictures. Only
the file formats defined in the GEM documentation are used; they
are sufficient to meet most requirements, and any GEM application
should be able to handle them anyway.
</p>

<ol class="UDO_env_enumerate">
<li><p> Sending a metafile:
<br>&nbsp;
<pre>     msg[0]:  ACC_META (0x503)
     msg[3]:  1 for the final part, 0 otherwise
     msg[4] and msg[5]:   pointer to data
     msg[6] and msg[7]:   length of data (32 bit longword)
</pre>
<br>The metafile data is sent in the same format as it would be
stored on disk. As metafiles can become quite large, and often
accessories in particular do not have sufficient memory free to store
them, a file can be sent in several pieces. The receiver has to take
care of assembling all parts to restore the original data, if
neccessary by writing the parts to a file. The last part of a file is
marked by msg[3]=1. The sender may send no other data between the
parts of a file. msg[6] and msg[7] contain the length of the part
being sent, not the total length.
<br>&nbsp;
<br>The receiver acknowledges each part as described for <a href="#Message_20group_201">group 1</a>. As
for text messages, the sender must make sure that the data to be
transferred is stored in globally accessible memory.
<br>&nbsp;
</p></li>
<li><p> Sending a bit image file:
<br>&nbsp;
<br>msg[0]: ACC_IMG (0x504)
<br>&nbsp;
<br>otherwise identical to 1.
<br>&nbsp;
</p></li>
</ol>

<h4><a name="Compatibility_20considerations">15.13.2.3 Compatibility considerations</a></h4>
<p>There are two major changes with respect to the original<a class="UDO_footnote" title="refers to the XAcc definition before &quot;Classic XAcc&quot;">(1)</a>
<a href="#XAcc">XAcc</a> definition:
</p>

<ol class="UDO_env_enumerate">
<li><p> &quot;Levels&quot; have been replaced by &quot;message
groups&quot;
<br>&nbsp;
<br>The motivation for this change was that the classification
according to exchangeable data types was not really a hierarchical
one; there is no reason why a programm accepting graphics should also
be able to understand text. The new scheme makes no such arbitrary
assumptions.
<br>&nbsp;
<br>There is only one situation in which a possible incompatibility
could occur: an application following the &quot;old&quot; convention
encounters a &quot;new&quot; application and one of them indicates 2
in the level/message group byte. This would be interprets as
&quot;graphics only&quot; by one and as &quot;graphics and text&quot;
by the other. Since the number of level-2 applications was always
extremely small (in fact, the author<a class="UDO_footnote" title="Konrad Hinsen anno 1992. But obviously the extremely small number has not increased yet.">(2)</a> knows only of a single
one), this should be no problem in practice.
<br>&nbsp;
</p></li>
<li><p> <a href="#Extended_20names">Extended names</a> have been introduced
<br>&nbsp;
<br>This could lead to a problem in the extremely unlikely case of
an &quot;old&quot; application using a name string which is
accidentally followed by &quot;XDSC&quot;.
<br>&nbsp;
</p></li>
</ol>

<p>In any case it is expected that most applications will be
converted to the new rules soon, if only to support MultiTOS.
</p>
<h3><a name="Extended_20XAcc">15.13.3 Extended XAcc</a></h3>
<p>This chapter describes developments of the XAcc protocol after
&quot;<a href="#Classic_20XAcc">Classic XAcc</a>&quot; (11/28/92). Last changes have been made on
June 15, 1995.
</p>
<p>Seit der letzten offiziellen Dokumentationen zum
XAcc-Protokoll haben sich einige Erweiterungen ergeben, die nun
zusammengefaßt worden sind. Einige der Erweiterungen sind aus
speziellen Formen des Datenaustauschs zwischen der Textverarbeitung
That's Write und der Adreßverwaltung That's Address bzw. dessen
Nachfolger no|Address hervorgegangen. Trotzdem sind diese
Erweiterungen auch beliebigen anderen Applikationen zugänglich und
die Verwendung dieser Applikationsnamen in der folgenden Dokumentation
hat nur beispielhaften Charakter (That's Address = TA und That's Write
= TW). Bei den Erweiterungen handelt es sich um:
</p>
<ul>
<li><p> <a href="#MailMerge-Protokoll">MailMerge-Protokoll</a>
<br>&nbsp;
<br>Der eigentliche Seriendruck (MailMerge) des TW wird über dieses
Protokoll abgehandelt.
<br>&nbsp;
</p></li>
<li><p> <a href="#Remote-Mailmerge-Protokoll">Remote-Mailmerge-Protokoll</a>
<br>&nbsp;
<br>Ermöglicht es einer Applikation, von sich aus einen Seriendruck
im TW zu initiieren.
<br>&nbsp;
</p></li>
<li><p> <a href="#Inquiry-Protokoll">Inquiry-Protokoll</a>
<br>&nbsp;
<br>Dient der Ermittlung von Informationen über den Aufbau einer
Datenbank.
<br>&nbsp;
</p></li>
<li><p> <a href="#Request_2FReply-Protokoll">Request/Reply-Protokoll</a>
<br>&nbsp;
<br>Dient dem allgemeinen Datenaustausch zwischen Applikationen.
<br>&nbsp;
</p></li>
</ul>

<ul class="content">
	<li>15.13.3.1 <a href="#MailMerge-Protokoll">MailMerge-Protokoll</a>
	<li>15.13.3.2 <a href="#Remote-Mailmerge-Protokoll">Remote-Mailmerge-Protokoll</a>
	<li>15.13.3.3 <a href="#Inquiry-Protokoll">Inquiry-Protokoll</a>
	<li>15.13.3.4 <a href="#Request_2FReply-Protokoll">Request/Reply-Protokoll</a>
		</li>
</ul>
<br>
<h4><a name="MailMerge-Protokoll">15.13.3.1 MailMerge-Protokoll</a></h4>
<p>Dieses Protokoll arbeitet aus historischen Gründen mit
<a href="proto_xacc.html#ACC_TEXT">ACC_TEXT</a>- Messages. Das TW schickt dem TA zuerst eine ACC_TEXT -Messages mit
einem String, der mit &quot;#I&quot; beginnt und nach dem 'I' den SDF-
Formatstring beinhaltet, der dem TA sagt, welche Teile eines
Adreßdatensatzes übertragen werden sollen.
</p>
<p>Beispiel: &quot;#IA1,A2,A3,A4,T1&quot; (die ersten 4
Adreßfelder und die 1. Telefonnr.).
</p>
<p>Bei erfolgreichem Empfang dieser Nachricht wird dem TW eine
ACC_TEXT- <a href="proto_ssp.html#Message">Message</a> mit dem String &quot;0&quot; zurückgesendet,
ansonsten ein Leerstring &quot;.
</p>
<p>Nun kann TW beginnen, die einzelnen Adreßdaten mittels der
ACC_TEXT- <a href="proto_ssp.html#Message">Message</a> &quot;#N&quot; anzufordern. Bei Empfang einer solchen
Nachricht schickt TA für jedes Adreßfeld einer Adresse eine
<a href="proto_xacc.html#ACC_TEXT">ACC_TEXT</a>-<a href="proto_ssp.html#Message">Message</a> und zum Abschluß eines Datensatzes einen Leerstring
&quot;.
</p>
<h4><a name="Remote-Mailmerge-Protokoll">15.13.3.2 Remote-Mailmerge-Protokoll</a></h4>
<p>Für dieses Protokoll gibt es zwei neue XAcc-message Typen,
nämlich:
</p>
<a name="ACC_FORCESDF"></a>
<a name="ACC_GETSDF"></a>
<pre>#define ACC_FORCESDF        0x520
#define ACC_GETSDF          0x521
</pre>
<p>TA sendet dem TW ein ACC_FORCESDF, wenn eine Adresse oder eine
Adreßliste an das TW geschickt werden soll. Im Falle, daß es sich
nur um eine Adresse handelt, steht in msg[4]+[5] ein Pointer auf das
Suchwort der Adresse, bei einer Adreßliste steht in msg[4]+[5] ein
Pointer auf &quot;#L&quot;. Die ACC_FORCESDF-message muß mit einem
<a href="proto_xacc.html#ACC_ACK">ACC_ACK</a> bestätigt werden (msg[3]==1 -&gt; OK und msg[3]==0 -&gt;
<a href="bios_errors.html#ERROR">ERROR</a>).
</p>
<p>Wenn TW ein &quot;#L&quot; bekommst, dann fährt TW ein ganz
normales MailMerge- Protokoll (eingangs erklärt). Wenn TW ein
Suchwort bekommt (max. 20 Zeichen lang), dann fordert TW beim TA diese
Adresse mittels ACC_GETSDF an. Die ACC_GETSDF-message muß in
msg[4]+[5] einen Pointer auf einen Buffer haben, in dem zuerst das
Suchwort mit abschließendem '\0' steht und dann der XDF-Formatstring
steht (Bsp.: &quot;JÖRG\0A1,A2,A3\0&quot;).
</p>
<p>Wenn TA die ACC_GETSDF-message verstehen kann, dann schickt es
ein <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a> mit msg[3]==1, ansonsten ein <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a> mit msg[3]==0.
Anschließend bekommt TW die Daten dieser einen Adresse wie beim
normalen MailMerge- Protokoll.
</p>
<p>TW muß in seinem XDSC-String ein &quot;XRM&quot; zu stehen
haben, damit TA von sich aus ein Remote-Mailmerge-Protokoll startet.
</p>
<p>TA hat jetzt folgende XDSC-Features (Bsp. ACC):
</p>
<pre>const char ta2Ident[] = &quot;That's Address ACC\0XDSC\0&quot;
                        &quot;1Adressverwaltung\0&quot;
                        &quot;2DB\0&quot;
                        &quot;XMM\0XSU\0XDI\0XRM\0NnoAddress ACC\0&quot;;
</pre>
<table class="UDO_env_blist">
<tr><td nowrap="nowrap" valign="top"><b>XMM</b></td>
<td valign="top"> MailMerge
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>XSU</b></td>
<td valign="top"> Suchwortübergabe (optional mit anschließendem '?')
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>XDI</b></td>
<td valign="top"> <a href="#Inquiry-Protokoll">Inquiry-Protokoll</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>XRM</b></td>
<td valign="top"> Remote-MailMerge
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Inquiry-Protokoll">15.13.3.3 Inquiry-Protokoll</a></h4>
<a name="ACC_GETDSI"></a>
<a name="ACC_DSINFO"></a>
<a name="ACC_FILEINFO"></a>
<p>Im Prinzip läuft das ganze Inquiry-Protokoll in 2 Stufen ab.
Zuerst werden die Daten der verfügbaren Datenbanken ermittelt, und
anschließend (zeitlich voneinander völlig unabhängig) werden die
einzelnen Felder einer ausgewählten Datenbank erfragt.
</p>
<p>Also Part 1 (am Beispiel von TA und TW):
</p>
<pre>            TA                  |                   TW
--------------------------------+------------------------------------
                            ACC_GETDSI
            &lt;----------------------------------------

                            ACC_DSINFO
            ----------------------------------------&gt;

                            <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>
            &lt;----------------------------------------

    {
                            ACC_FILEINFO
            ----------------------------------------&gt;

                            <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>
            &lt;----------------------------------------

    }   /* &lt;n&gt; mal, wobei &lt;n&gt; bei ACC_DSINFO übertragen wurde */
</pre>
<p>Erklärung der einzelnen Protokollelemente:
</p>
<table class="UDO_env_blist">
<tr><td nowrap="nowrap" valign="top"><b>ACC_GETDSI</b></td>
<td valign="top">
<br>&nbsp;
<br>Hiermit wird das Inquiry-Protokoll initiiert. Diese <a href="proto_ssp.html#Message">Message</a>
enthält einen Pointer auf eine Variable des Typs <a href="proto_xacc.html#Xacc_Dsi_Request">Xacc_Dsi_Request</a>, in
dem codiert wird, welche Felder welchen Typs gewünscht sind.
<br>&nbsp;
<pre>        msg[0]            = ACC_GETDSI (0x510)
        msg[1]            = application id
        msg[4] und msg[5] = Pointer auf die gewünschten Feld-Typen
                            (siehe <a href="#XACC.H">XACC.H</a>)
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ACC_DSINFO</b></td>
<td valign="top">
<br>&nbsp;
<br>Auf ein ACC_GETDSI antwortet die angefragte Applikation mit
dieser <a href="proto_ssp.html#Message">Message</a>. Hierbei wird ein Pointer auf eine Variable des Typs
<a href="proto_xacc.html#Xacc_Dsinfo">Xacc_Dsinfo</a>, wenn die Anfrage beantwortet werden kann, oder ein
NULL-Pointer, wenn die Anfrage nicht beantwortet werden kann, der
anfragenden Applikation übergeben.
<br>&nbsp;
<pre>        msg[0]            = ACC_DSINFO (0x511)
        msg[4] und msg[5] = Pointer auf <a href="proto_xacc.html#Xacc_Dsinfo">Xacc_Dsinfo</a> Struktur
                            (siehe <a href="#XACC.H">XACC.H</a>) oder NULL
</pre>
<br>Die anfragende Applikation beantwortet alle Replys seinerseits
mit einer ACC_ACK= <a href="proto_ssp.html#Message">Message</a>: <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>:
<br>&nbsp;
<pre>        msg[0]            = <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>
        msg[3]            = 1     wenn alles OK ist
                          = 0     wenn ein Fehler aufgetreten ist
                                  (Abbruch des Protokolls)
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ACC_FILEINFO</b></td>
<td valign="top">
<br>&nbsp;
<br>Wenn die ACC_DSINFO <a href="proto_ssp.html#Message">Message</a> von der anfragenden Applikation
bestätigt wurde, so wird für jede verfügbare Datei eine
ACC_FILEINFO-<a href="proto_ssp.html#Message">Message</a> mit einem Pointer auf eine Variable des Typs
<a href="proto_xacc.html#Xacc_File_Info">Xacc_File_Info</a>, oder ein NULL-Pointer bei einem Fehler, an die
anfragende Applikation gesendet.
<br>&nbsp;
<br>Jede dieser Messages muß, wie oben erwähnt, mit einer <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>
von der anfragenden Applikation bestätigt werden.
<br>&nbsp;
<pre>        msg[0]            = ACC_FILEINFO (0x512)
        msg[4] und msg[5] = Pointer auf <a href="proto_xacc.html#Xacc_File_Info">Xacc_File_Info</a> Struktur
                            (siehe <a href="#XACC.H">XACC.H</a>) oder NULL
</pre>

</td></tr>
</table>

<a name="ACC_GETFIELDS"></a>
<a name="ACC_FIELDINFO"></a>
<p>Wenn dieser erste Teil des Inquiry-Protokolls erfolgreich
beendet wurde, dann kann die anfragende Applikation dem Anwender die
Liste der verfügbaren Datenbanken und deren Information 'auf die Nase
knallen' und ihn eine Auswahl treffen lassen.
</p>
<p>Tut der Anwender dies, so läuft der 2. Part des
Inquiry-Protokolls los (wieder am Beispiel von TA und TW):
</p>
<pre>            TA                  |                   TW
--------------------------------+------------------------------------
                            ACC_GETFIELDS
            &lt;----------------------------------------

    {
                            ACC_FIELDINFO
            ----------------------------------------&gt;

                            <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>
            &lt;----------------------------------------

    }   /* &lt;n&gt; mal, wobei &lt;n&gt; bei ACC_FILEINFO übertragen wurde */
</pre>
<p>Erklärung der einzelnen Protokollelemente:
</p>
<table class="UDO_env_blist">
<tr><td nowrap="nowrap" valign="top"><b>ACC_GETFIELDS</b></td>
<td valign="top">
<br>&nbsp;
<br>Hiermit wird von der anfragenden Applikation eine Datenbank
ausgewählt (die entsprechende Datenbank-ID hat sie ja bei der
ACC_FILEINFO <a href="proto_ssp.html#Message">Message</a> in der Struktur <a href="proto_xacc.html#Xacc_File_Info">Xacc_File_Info</a> empfangen) und
gibt der angefragten Applikation bekannt, daß nun die einzelnen
Feldinformationen übertragen werden sollen.
<br>&nbsp;
<pre>        msg[0]            = ACC_GETFIELDS (0x513)
        msg[1]            = application id
        msg[3]            = ID der gewünschte Datenbank
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ACC_FIELDINFO</b></td>
<td valign="top">
<br>&nbsp;
<br>Wenn die ACC_GETFIELDS <a href="proto_ssp.html#Message">Message</a> von der anfragenden Applikation
bestätigt wurde, so wird für jedes Feld eine ACC_FIELDINFO <a href="proto_ssp.html#Message">Message</a>
mit einem Pointer auf eine Variable des Typs <a href="proto_xacc.html#Xacc_Field_Info">Xacc_Field_Info</a>, oder ein
NULL-Pointer bei einem Fehler, an die anfragende Applikation gesendet.
<br>&nbsp;
<br>Jede dieser Messages muß, wie oben erwähnt, mit einer <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>
von der anfragenden Applikation bestätigt werden.
<br>&nbsp;
<pre>        msg[0]            = ACC_FIELDINFO (0x514)
        msg[4] und msg[5] = Pointer auf <a href="proto_xacc.html#Xacc_Field_Info">Xacc_Field_Info</a> Struktur
                            (siehe <a href="#XACC.H">XACC.H</a>) oder NULL
</pre>

</td></tr>
</table>

<p>In That's / no| Address wurden im Moment die Feldtypen FT_CHAR,
FT_DATE und FT_TIME implementiert.
</p>
<h4><a name="Request_2FReply-Protokoll">15.13.3.4 Request/Reply-Protokoll</a></h4>
<p>Es werden zwei weitere <a href="proto_ssp.html#Message">Message</a>-Typen eingeführt, um einen
allgemeinen Datenaustausch zu ermöglichen:
</p>
<a name="ACC_REQUEST"></a>
<a name="ACC_REPLY"></a>
<pre>#define ACC_REQUEST     0x480
#define ACC_REPLY       0x481
</pre>
<table class="UDO_env_blist">
<tr><td nowrap="nowrap" valign="top"><b>ACC_REQUEST</b></td>
<td valign="top">
<br>&nbsp;
<br>Mittels dieser Nachricht fordert man bei einer anderen
Applikation einen Dienst an. Der Aufbau dieser Nachricht ist
folgendermaßen:
<br>&nbsp;
<pre>      msg[0]:     ACC_REQUEST (0x480)
      msg[1]:     Application-ID des Senders
      msg[2]:     0
      msg[3]:     Das high-Byte ist frei für Applikationsspezifische
                  Informationen und im low-Byte ist der Typ der
                  Daten codiert, die mit dieser Nachricht verschickt
                  werden:
                  0x01  String, d.h. msg[4]+msg[5] ist
                        ein Pointer auf den String
                  0x02  Env-String, d.h
                        msg[4]+msg[5] ist ein Pointer
                        auf den Env-String (mehrere durch
                        '\0' getrennte Strings mit
                        abschließenden doppelten '\0'-Bytes)
                  0x03  binär-Daten, d.h.
                        msg[4]+msg[5] ist ein Pointer auf
                        die binär-Daten. In diesem Fall muß der
                        Empfänger natürlich über die Struktur
                        Bescheid wissen! (lokale Typunterscheidung
                        ist z.B. mittels des high-Bytes möglich)
                  0x04  code, d.h. msg[4] bis msg[7]
                        enthalten direkt die Daten (sinnvoll bei
                        Übertragung von Datenmengen bis 8 Byte)
      msg[4,5]:   Pointer auf die Daten (außer Typ 0x04)
      msg[6,7]:   Länge des Datenbereichs incl. eventueller
                  '\0'-Bytes (außer Typ 0x04)
</pre>
<br>Es existieren zwei verschiedene Möglichkeiten, diese Nachricht
zu beantworten:
<br>&nbsp;
<ul>
<li><p> <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a> mit msg[3]=0, wenn die empfangende Applikation diese
Nachricht nicht bearbeiten kann
<br>&nbsp;
</p></li>
<li><p> ACC_REPLY, wenn die Nachricht bearbeitet werden konnte und eine
Antwort zurückgeschickt wird
<br>&nbsp;
</p></li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ACC_REPLY</b></td>
<td valign="top">
<br>&nbsp;
<br>Mittels dieser Nachricht wird eine ACC_REQUEST Anforderung
erfolgreich beantwortet. Der Aufbau dieser Nachricht ist
folgendermaßen:
<br>&nbsp;
<pre>            msg[0]:     ACC_REPLY (0x481)
            msg[1]:
                .
                .       siehe ACC_REQUEST!
                .
            msg[7]:
</pre>

</td></tr>
</table>

<p>Applikationen, die oben beschriebene Protokollelemente
unterstützen, müssen in ihrer XDSC-Beschreibung das Extended-Feature
&quot;RQ&quot; enthalten haben.
</p>
<h3><a name="Example:_20no_7CLink_27s_20XAcc_20protocol">15.13.4 Example: no|Link's XAcc protocol</a></h3>
<p>Das no|Link-Accessory wurde für die Ansteuerung von
Infrarotgeräten konzipiert und beinhaltet eine
XAcc-Kommunikationsschicht für die Ansteuerung durch spezielle
Applikationen. Zum momentanen Zeitpunkt wird das Media-Link-Interface
von Catch Computer unterstützt. Eine weitere Anpassung an das
no|Remote-Interface von no|Software ist in Arbeit.
</p>
<p>Das no|Link-Accessory verwaltet alle Informationen, die zur
Ansteuerung der verwendeten Infrarot- oder sonstiger Hardware
benötigt werden. Jedem hardwareabhängigen Code (z.B einem
Infrarotsignal) wird ein Befehl zugeordnet, und für jedes Gerät
(z.B. Videorekorder) existiert eine Liste solcher Befehle.
</p>
<p>Will nun z.B. eine Applikation für die Fernbedienung eines
Videorekorders ein Infrarotsignal für die Play-Taste senden, so
schickt es no|Link eine XAcc-Nachricht, in der das Kommando
&lt;senden&gt;, das Gerät &lt;VIDEOREKORDER&gt; und der Befehl
&lt;PLAY&gt; codiert sind.
</p>
<p>Damit eine Applikation mit no|Link vollständig kommunizieren
kann, muß diese das <a href="#Request_2FReply-Protokoll">Request/Reply-Protokoll</a> unterstützen, was als
Extended- Feature in der XDSC-Beschreibung durch ein &quot;RQ&quot;
bekannt gemacht wird. Nur so ist es möglich, die Liste der
eingetragenen Geräte von no|Link erhalten zu können.
</p>
<p>Wenn die Applikation auch Codes vom Accessory empfangen können
will (nur mit entsprechender Hardware möglich), so muß als
Extended-Feature in der XDSC-Beschreibung zusätzlich ein
&quot;RR&quot; (Remote Receive) enthalten sein. Alle Applikationen,
die mit noLink arbeiten wollen, müssen den XAcc-Level 1
unterstützen.
</p>
<p>Als Application-Type enthält das no|Link-Accessory im XDSC
&quot;\2RC&quot; (Remote Control).
</p>
<p>Die vollständige XAcc-Identifikation von no|Link lautet zur
Zeit folgendermaßen (in C-Syntax):
</p>
<pre>    char xaccNoLinkIdent[] =    &quot;Infrarot Manager\0&quot;
                                &quot;XDSC\0&quot;
                                &quot;1Fernsteuerschnittstelle\0&quot;
                                &quot;2RC\0&quot;
                                &quot;XRQ\0&quot;
                                &quot;NnoRci\0&quot;;
</pre>
<p>Eine denkbare XAcc-Identifikation für eine
no|Link-Applikation könnte so aussehen:
</p>
<pre>    char xaccIdentstring[] =    &quot;VideoControl\0&quot;
                                &quot;XDSC\0&quot;
                                &quot;1Video Fernbedienung\0&quot;
                                &quot;XRQ\0&quot;
                                &quot;Nno|Video ACC\0&quot;;
</pre>
<p>Die Kommunikation zwischen Applikation und dem no|Link-Accessory
findet hauptsächlich über ACC_TEXT Messages statt.
</p>
<p>Das Accessory versteht zur Zeit folgende Befehle, die als String
mittels einer <a href="proto_xacc.html#ACC_TEXT">ACC_TEXT</a> <a href="proto_ssp.html#Message">Message</a> versendet werden müssen (&lt;X&gt; :=
&lt;Gerät&gt;:&lt;Befehl&gt;):
</p>
<table class="UDO_env_blist">
<tr><td nowrap="nowrap" valign="top"><b>&quot;S &lt;X&gt;&quot;</b></td>
<td valign="top"> Senden eines Befehls, z.B: &quot;S VIDEO:PLAY&quot;.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>&quot;P &lt;X&gt;&quot;</b></td>
<td valign="top"> Präparieren eines Befehls, z.B: &quot;P VIDEO:PLAY&quot;.
Hierbei wird der Infrarot-Hardware der Code für diesen Befehl
mitgeteilt, aber noch nicht abgeschickt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>&quot;S&quot;</b></td>
<td valign="top"> Senden des zuletzt präparierten Befehls.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>&quot;T &lt;X&gt;&quot;</b></td>
<td valign="top"> Test der Existenz eines Befehls.
<br>&nbsp;
<br>Insbesondere bei der Neuinstallation einer Fernsteuerungs-
Applikation sollten alle Geräte und Befehle, die diese Applikation
verwendet, dem Accessory mitgeteilt werden!
<br>&nbsp;
<br>Wenn no|Link den mitgelieferten Befehl nicht kennt, so wird der
Benutzer aufgefordert, die nötige &quot;Lernprozedur&quot; zu
tätigen bzw. dem neuen Befehl einen schon vorhandenen zuzuweisen.
<br>&nbsp;
<br>Es sollte in jeder Fernsteuerungsapplikation eine Funktion
geben, die es dem Benutzer ermöglicht, alle unterstützten Befehle zu
&quot;testen&quot; - am besten über einen
&quot;Anmelden&quot;-Button.
<br>&nbsp;

</td></tr>
</table>

<p>Die Testfunktion ist die einzige, die u.U. eine Interaktion mit
dem Benutzer führt. Alle anderen vollführen keine Ausgabe.
</p>
<p>Als Antwort erhält die Applikation eine <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>-<a href="proto_ssp.html#Message">Message</a>, bei
der in msg[3] der Erfolg der Behandlung des Befehls vermerkt ist:
</p>
<table class="UDO_env_blist">
<tr><td nowrap="nowrap" valign="top"><b>1</b></td>
<td valign="top"> Operation war erfolgreich
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>0</b></td>
<td valign="top"> Gerät/Befehl ist nicht vorhanden bzw. Fehler bei der
Bearbeitung
<br>&nbsp;

</td></tr>
</table>

<p>Geräte- und Befehlsnamen dürfen maximal 32 Zeichen lang sein
und dürfen KEINEN ':' enthalten. Es wird nicht zwischen Groß- und
Kleinschreibung unterschieden.
</p>
<p>Eine Applikation kann vom Accessory eine Liste der eingetragenen
Geräte anfordern. Hierfür muß die Applikation das neue <a href="#XAcc">XAcc</a>-
<a href="#Request_2FReply-Protokoll">Request/Reply-Protokoll</a> verstehen (siehe oben bzw. <a href="#XACC.H">XACC.H</a>).
</p>
<p>Um die Liste anzufordern, wird von der Applikation ein ACC_REQUEST an
das Accessory geschickt, wobei diese Nachricht folgendermaßen
aufgebaut sein muß:
</p>
<pre>    msg[0] = <a href="proto_xacc.html#ACC_REQUEST">ACC_REQUEST</a> (0x480)
    msg[1] = apid
    msg[2] = 0
    msg[3] = 0x04       /* Datentyp: Code */
    msg[4] = 'D'        /* 'D' steht für &quot;devices&quot; */
    msg[5] = 0
    msg[6] = 0
    msg[7] = 0
</pre>
<p>Als Antwort erhält die Applikation, wenn ein Fehler auftrat
eine <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>- <a href="proto_ssp.html#Message">Message</a> mit msg[3] == 0, oder bei Erfolg eine ACC_REPLY-
<a href="proto_ssp.html#Message">Message</a>:
</p>
<pre>    msg[0] = <a href="proto_xacc.html#ACC_REPLY">ACC_REPLY</a> (0x481)
    msg[1] = apid von no|Link
    msg[2] = 0
    msg[3] = 0x02       /* Datentyp: Environment-String */
    msg[4]+msg[5] = Pointer auf einen global zugreifbaren
                    Speicher, in dem die Liste der Geräte
                    in folgendem Format steht:
                    &quot;DEVICEINFOS:\0Gerät1\0Gerät2\0&quot;
    msg[6]+msg[7] = long-value, der die Größe des Buffers
                    angibt (inkl. der abschließenden zwei
                    NULL-Bytes)

</pre>
<p>Der Empfang einer <a href="proto_xacc.html#ACC_REPLY">ACC_REPLY</a>-<a href="proto_ssp.html#Message">Message</a> muß abschließend mit einer
<a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>- <a href="proto_ssp.html#Message">Message</a> bestätigt werden, damit das no|Link-Accessory seine
Resourcen wieder freigeben kann!
</p>
<h3><a name="XACC.H">15.13.5 XACC.H</a></h3>
<a name="Xacc_Dsi_Request"></a>
<a name="Xacc_Dsinfo"></a>
<a name="Xacc_File_Info"></a>
<a name="Xacc_Field_Info"></a>
<pre>/*==================================================================*/
/*                                                                  */
/*                <a href="#XAcc">XAcc</a> definitions (PureC syntax)                   */
/*                                                                  */
/*==================================================================*/

#ifndef __XACC__
# define __XACC__

/*--------------------------------------------------------------------
    <a href="#XAcc">XAcc</a> message types
--------------------------------------------------------------------*/
/* Level 0 */
# define <a href="proto_xacc.html#ACC_ID">ACC_ID</a>             0x400
# define <a href="proto_xacc.html#ACC_OPEN">ACC_OPEN</a>           0x401
# define <a href="proto_xacc.html#ACC_CLOSE">ACC_CLOSE</a>          0x402
# define <a href="proto_xacc.html#ACC_ACC">ACC_ACC</a>            0x403
# define <a href="proto_xacc.html#ACC_EXIT">ACC_EXIT</a>           0x404

/* Level 1 */
# define <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a>            0x500
# define <a href="proto_xacc.html#ACC_TEXT">ACC_TEXT</a>           0x501
# define <a href="proto_xacc.html#ACC_KEY">ACC_KEY</a>            0x502

/* Level 2 */
# define <a href="proto_xacc.html#ACC_META">ACC_META</a>           0x503
# define <a href="proto_xacc.html#ACC_IMG">ACC_IMG</a>            0x504

/*
 * extended XACC <a href="proto_ssp.html#Message">Message</a>-Types:
 * Diese Messages sind relativ &quot;unabhängig&quot; vom XACC-Level der
 * Applikationen, d.h. sie sollten nur verwendet werden,
 * wenn der Kommunikationspartner in seiner XDSC-Beschreibung
 * über das ensprechende Extended-Feature verfügt!
 */

/* Reuest/Reply Protokoll: (Extended-Feature &quot;RQ&quot;)      */
/*        <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a> Messages sind Teil des Protokolls und */
/*        müssen deshalb verstanden werden!             */
# define <a href="proto_xacc.html#ACC_REQUEST">ACC_REQUEST</a>        0x480
# define <a href="proto_xacc.html#ACC_REPLY">ACC_REPLY</a>          0x481

/* Inquiry Protokoll: (Extended-Feature &quot;DI&quot;)           */
/*        <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a> Messages sind Teil des Protokolls und */
/*        müssen deshalb verstanden werden!             */
#define <a href="proto_xacc.html#ACC_GETDSI">ACC_GETDSI</a>          0x510
#define <a href="proto_xacc.html#ACC_DSINFO">ACC_DSINFO</a>          0x511
#define <a href="proto_xacc.html#ACC_FILEINFO">ACC_FILEINFO</a>        0x512
#define <a href="proto_xacc.html#ACC_GETFIELDS">ACC_GETFIELDS</a>       0x513
#define <a href="proto_xacc.html#ACC_FIELDINFO">ACC_FIELDINFO</a>       0x514

/* Remote MailMerge Protokoll: (Extended-Feature &quot;RM&quot;)  */
/*        <a href="proto_xacc.html#ACC_ACK">ACC_ACK</a> Messages sind Teil des Protokolls und */
/*        müssen deshalb verstanden werden!             */
#define <a href="proto_xacc.html#ACC_FORCESDF">ACC_FORCESDF</a>        0x520
#define <a href="proto_xacc.html#ACC_GETSDF">ACC_GETSDF</a>          0x521


/*--------------------------------------------------------------------
    definitions for the Request/Reply protocol
--------------------------------------------------------------------*/
/* <a href="proto_xfsl.html#Datentypen">Datentypen</a> des Request/Reply: */
#define RQREP_TYPE_STRING   1
#define RQREP_TYPE_ENVSTR   2
#define RQREP_TYPE_BIN      3
#define RQREP_TYPE_CODE     4


/*--------------------------------------------------------------------
    definitions for the Inquiry protocol
--------------------------------------------------------------------*/
#define DSI_VERSION         0x0100


/* field data-types:
 *    values lower than 128 are 'human readable types' and
 *    values greater/equal 128 are 'machine readable types'
 */
#define FT_CHAR        0x00  /* string                                */
#define FT_DATE        0x02  /* string in _IDT format.                */
                             /* dflt: DD.MM.YY if no _IDT available   */
                             /* For more about _IDT see MINT          */
#define FT_TIME        0x03  /* string: HH:MM:SS                      */

#define FT_BYTE        0x80  /* 2  byte HEX-string                    */
#define FT_UBYTE       0x81  /* 2  byte HEX-string                    */
#define FT_SHORT       0x82  /* 4  byte HEX-string                    */
#define FT_USHORT      0x83  /* 4  byte HEX-string                    */
#define FT_LONG        0x84  /* 8  byte HEX-string                    */
#define FT_ULONG       0x85  /* 8  byte HEX-string                    */
#define FT_FLOAT       0x86  /* 8  byte HEX-string                    */
#define FT_DOUBLE      0x87  /* 20 byte HEX-string                    */
#define FT_ENUM        0x88  /* 4  byte HEX-string                    */
#define FT_BOOL        0x89  /* string: &quot;T&quot; or &quot;F&quot;                    */
#define FT_BITFLD      0x8A  /* at 8 Bit aligned HEX-string           */
#define FT_TIME_T      0x90  /* 8  byte HEX-string (time_t, see UNIX) */


typedef struct {
    int     version;
    char    field_types[32]; /* max. count of 256 fieldtypes are      */
                             /* available (see definements above)     */
                             /* Each bit in this field represents a   */
                             /* valid field-type, where type 0 is     */
                             /* the lowest bit of the first character */
                             /* and type 255 the highest bit of the   */
                             /* last character                        */
} Xacc_Dsi_Request;

typedef struct {
    int     db_anz;          /* count of available data bases         */
} Xacc_Dsinfo;

typedef struct {
    long    db_id;           /* ID of the data base                   */
    char    fname[32];       /* Filename of the data base. if you     */
                             /* are using a <a href="gemdos_main.html">GEMDOS</a> or DOS filesystem  */
                             /* it must have a &lt;8.3&gt; format.          */
    char    title[32];       /* A max. 32 byte long description of    */
                             /* the data base.                        */
    time_t  crea_time;       /* The creation date/time of the data    */
                             /* base file.                            */
    time_t  mod_time;        /* The last modification date/time of    */
                             /* the data base structure.              */
    int     n_fields;        /* The number of fields that are         */
                             /* available corresponding to the        */
                             /* requested field typs given by the     */
                             /* <a href="proto_xacc.html#ACC_GETDSI">ACC_GETDSI</a> message                    */
} Xacc_File_Info;

typedef struct {
    int     fld_size;        /* the count of bits into the field      */
    int     n_fields;        /* The count of field elements           */
    int     elem_size;       /* The length of one field element       */
    char    field_buff[0];   /* from here the list of the &lt;n_fields&gt;  */
                             /* elements follows in this format:      */
                             /* 2 byte &lt;bitno&gt; and &lt;elem_size&gt; byte   */
                             /* description.                          */
                             /* e.g. (&lt;elem_size&gt;=10):                */
                             /*    &quot;\0\1private\0\0\0&quot;                */
                             /*    &quot;\0\2sex\0\0\0\0\0\0\0&quot;            */
                             /*    &quot;\0\4dealer\0\0\0\0&quot;               */
                             /* The value &quot;06&quot; identifies the 2nd     */
                             /* and the 3rd element.                  */
                             /* NOTE that you can't use sizeof()      */
                             /* because of this declaration.          */
} Bitfld_Info;

typedef struct {
    int     n_enums;         /* The count of enum-elements            */
    int     elem_size;       /* The length of one enum element        */
    char    enum_buff[0];    /* from here the list of the &lt;n_enums&gt;   */
                             /* elements follows in this format:      */
                             /* 2 byte &lt;id&gt; and &lt;elem_size&gt; byte      */
                             /* description.                          */
                             /* e.g. (&lt;elem_size&gt;=10):                */
                             /*    &quot;\0Aprivate\0\0\0&quot;                 */
                             /*    &quot;\0Bsex\0\0\0\0\0\0\0&quot;             */
                             /*    &quot;\0Edealer\0\0\0\0&quot;                */
                             /* The value &quot;0042&quot; identifies the 2nd   */
                             /* element.                              */
                             /* NOTE that you can't use sizeof()      */
                             /* because of this declaration.          */
} Enum_Info;

typedef <a href="proto_xfsl.html#union">union</a> {
    ulong        n_elems;      /* for types like char,uchar this is     */
                               /* the length of the field               */
    Enum_Info    *enum_info;   /* enum is a special type, which needs   */
                               /* more description than the length!     */
    Bitfld_Info  *bitfld_info; /* a bitfield like used in TA2 for the   */
                               /* info-flags                            */
} Type_Desc;

typedef struct {
    char         id[8];      /* The export-identifier of the corres-  */
                             /* ponding field, i.e. &quot;A1&quot; for the      */
                             /* first address field of Clever or TA2  */
    char         name[16];   /* A short description                   */
    char         desc[32];   /* A long description                    */
    int          type;       /* The data type. Must be one of the     */
                             /* constants defined at the top of this  */
                             /* file                                  */
    Type_Desc    t_desc;     /* This <a href="proto_xfsl.html#union">union</a> contains either the length */
                             /* of the field or a pointer to a info-  */
                             /* struct if the type is a special one   */
                             /* like enum or other user-defined types */
} Xacc_Field_Info;


#endif    /* #ifndef __XACC__ */
</pre>
<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="protocols.html"><img src="udo_up.gif" alt="Protokolle" title="Protokolle" border="0" width="24" height="24">Protokolle</a>
<a name="UDO_nav_lf_FOOT" href="proto_vscreen.html"><img src="udo_lf.gif" alt="Virtual-Screen-Protokoll" title="Virtual-Screen-Protokoll" border="0" width="24" height="24">Virtual-Screen-Protokoll</a>
<a name="UDO_nav_rg_FOOT" href="proto_xfsl.html"><img src="udo_rg.gif" alt="xFSL-Schnittstelle" title="xFSL-Schnittstelle" border="0" width="24" height="24">xFSL-Schnittstelle</a>
</body>
</html>
