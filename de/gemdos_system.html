<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 02.08.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Systemfunktionen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="gemdos_main.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
<a name="UDO_nav_lf_HEAD" href="gemdos_network.html"><img src="udo_lf.gif" alt="Netzwerkfunktionen" title="Netzwerkfunktionen" border="0" width="24" height="24">Netzwerkfunktionen</a>
<a name="UDO_nav_rg_HEAD" href="gemdos_directory.html"><img src="udo_rg.gif" alt="Verzeichnisfunktionen" title="Verzeichnisfunktionen" border="0" width="24" height="24">Verzeichnisfunktionen</a>

<hr>

<h1><a name="Systemfunktionen">5.14 Systemfunktionen</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Salert">Salert</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Warnung bzw. Fehlermeldung ausgeben.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Sconfig">Sconfig</a>&nbsp;&nbsp;</td>
<td valign="top"> Betriebssystem-Konfiguration ermitteln/setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Scookie">Scookie</a>&nbsp;&nbsp;</td>
<td valign="top"> Controlling Cookie Jar.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Shutdown">Shutdown</a>&nbsp;</td>
<td valign="top"> Kills all processes, syncs filesystems then halts or reboots
the system.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Slbclose">Slbclose</a>&nbsp;</td>
<td valign="top"> Schließt eine <a href="magic_sharelib.html">Shared Library</a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Slbopen">Slbopen</a>&nbsp;&nbsp;</td>
<td valign="top"> Öffnet eine Shared Library
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Srealloc">Srealloc</a>&nbsp;</td>
<td valign="top"> Bildschirmspeicher reservieren.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Ssystem">Ssystem</a>&nbsp;&nbsp;</td>
<td valign="top"> Controlling Cookie Jar, memory access and various system
settings.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#STEFcntrl">STEFcntrl</a></td>
<td valign="top"> <a href="emulators_stem.html">STEmulator</a> Kontrollfunktionen
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Super">Super</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Supervisor-Modus ermitteln oder ändern.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Suptime">Suptime</a>&nbsp;&nbsp;</td>
<td valign="top"> Returns the current uptime and load averages from the system.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Sversion">Sversion</a>&nbsp;</td>
<td valign="top"> Versionsnummer von GEMDOS ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Syield">Syield</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> CPU für andere Prozesse freigeben.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Sync">Sync</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Synchronisation der gemounteten Dateisysteme.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Sysconf">Sysconf</a>&nbsp;&nbsp;</td>
<td valign="top"> Betriebssystem-Konfiguration überprüfen.

</td></tr>
</table>

<p>Querverweis: <a href="gemdos_file.html">Dateifunktionen</a> &nbsp; <a href="gemdos_process.html">Prozessfunktionen</a>
</p>
<h3><a name="Salert">5.14.1 Salert</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Salert« - Warnung bzw. Fehlermeldung ausgeben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 316
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Salert ( int8_t *msg );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion gibt eine Fehler- bzw. Warnmeldung aus, die in die
Alert-Pipeline U:\PIPE\ALERT geschrieben wird.
<br>&nbsp;
<br>Die Meldung <i>msg</i> sollte keine Steuerzeichen, Linefeeds
etc. enthalten. Sie sollte eine einfache einzeilige Warn- oder
Fehlermeldung sein.
<br>&nbsp;
<br>Die Funktion formatiert die Meldung selbständig und sendet sie
dem Benutzer. Die genaue Form des Outputs hängt jedoch von der
verwendeten Systemkonfiguration ab.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion hat kein direktes Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.98 existiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Salert">Binding</a> &nbsp; <a href="gemdos_chrinout.html#Cconws">Cconws</a> &nbsp; <a href="magic_driveu.html#Pipes">Test auf Pipes</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Salert">5.14.1.1 Bindings für Salert</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Salert">Salert</a> ( int8_t *msg );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       msg          ; Offset 2
move.w    #316,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Sconfig">5.14.2 Sconfig</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Sconfig« - erlaubt die Konfigurierung von Teilen des
Betriebssystems.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 51
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Sconfig ( int16_t mode, int32_t flags );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion erlaubt die Konfigurierung von Teilen des
Betriebssystems. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> <b>Aktion</b>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0 =</td>
<td valign="top"> Konfiguration ermitteln
</td></tr>

<tr><td nowrap="nowrap" valign="top">1 =</td>
<td valign="top"> Konfiguration setzen
</td></tr>

<tr><td nowrap="nowrap" valign="top">2 =</td>
<td valign="top"> Zeiger auf <a href="gemdos_structures.html#DOSVARS">DOSVARS</a>-Struktur ermitteln; seit KAOS 1.4.2 und
<a href="magic.html">MagiC</a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">3 =</td>
<td valign="top"> reserviert; <a href="magic.html">MagiC</a> 3.00
</td></tr>

<tr><td nowrap="nowrap" valign="top">4 =</td>
<td valign="top"> für <a href="magic_programs.html#WBDAEMON">WBDAEMON</a>; <a href="magic.html">MagiC</a> 4.01
</td></tr>

<tr><td nowrap="nowrap" valign="top">5 =</td>
<td valign="top"> reserviert; <a href="magic.html">MagiC</a> 4.01
</td></tr>

<tr><td nowrap="nowrap" valign="top">6 =</td>
<td valign="top"> reserviert; <a href="magic.html">MagiC</a> 4.01

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">flags</td>
<td valign="top"> <b>Konfiguration als Bitvektor</b>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bit-0 =</td>
<td valign="top"> Pfadüberprüfung ein
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-1 =</td>
<td valign="top"> Einfügemodus für <a href="gemdos_main.html">GEMDOS</a> und Dialogboxen
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-2 =</td>
<td valign="top"> reserviert
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-3 =</td>
<td valign="top"> reserviert
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-4 =</td>
<td valign="top"> <a href="magic_programs.html#Fastload">Fastload</a> für Diskette aus
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-5 =</td>
<td valign="top"> <a href="magic_programs.html#TOS-Kompatibilit_C3_A4t">TOS-Kompatibilität</a> ein
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-6 =</td>
<td valign="top"> <a href="magic_smartredraw.html#Smart-Redraw">Smart-Redraw</a> aus
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-7 =</td>
<td valign="top"> Grow-/Shrinkboxen aus
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-8 =</td>
<td valign="top"> kein Halt nach <a href="tos_main.html">TOS</a>-Programmen
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-9 =</td>
<td valign="top"> reserviert
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-10 =</td>
<td valign="top"> Pulldown-Menüs
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-11 =</td>
<td valign="top"> Floppy-Hintergrundbetrieb

</td></tr>
</table>


</td></tr>
</table>

<br><b>Hinweis:</b> Gesetzte Bits schalten die jeweilige Funktion
ein, nicht gesetzte Bits schalten sie wieder aus.
<br>Bit-11 steht erst ab MagiC 3.0 zur Verfügung. Das Setzen der
Konfiguration ist nur bei <i>abgeschalteter</i> <a href="magic_programs.html#TOS-Kompatibilit_C3_A4t">TOS-Kompatibilität</a>
möglich.
<br>&nbsp;
<br>Die Funktion ist auch in KAOS vorhanden, allerings mit einer
etwas anderen Belegung des Bitvektors. Als <i>mode</i> kennt KAOS 1.2
nur die ersten beiden Unterfunktionen.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bit-0 =</td>
<td valign="top"> Pfadüberprüfung ein
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-1 =</td>
<td valign="top"> Diskwechsel-Simulation im Desktop ein
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-2 =</td>
<td valign="top"> Break ein; CTRL-C Abfrage bei jedem DOS-Aufruf
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-3 =</td>
<td valign="top"> CTRL-C Abfrage aus; für zeichenorientierte Funktionen
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-4 =</td>
<td valign="top"> <a href="magic_programs.html#Fastload">Fastload</a> für Diskette aus
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-5 =</td>
<td valign="top"> <a href="magic_programs.html#TOS-Kompatibilit_C3_A4t">TOS-Kompatibilität</a> ein (seit KAOS 1.4.2)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-6 =</td>
<td valign="top"> <a href="magic_smartredraw.html#Smart-Redraw">Smart-Redraw</a> aus (seit KAOS 1.4.2)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-7 =</td>
<td valign="top"> Grow-/Shrinkboxen aus (seit KAOS 1.4.2)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-8 =</td>
<td valign="top"> kein Halt nach <a href="tos_main.html">TOS</a>-Programmen (seit KAOS 1.4.2)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-9 =</td>
<td valign="top"> MF2-Layout ein (seit KAOS 1.4.2)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-10 =</td>
<td valign="top"> Pulldown-Menüs (seit KAOS 1.4.2)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-11..30 =</td>
<td valign="top"> reserviert (seit KAOS 1.4.2)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-31 =</td>
<td valign="top"> muß unbedingt 0 sein, sonst Fehler! (seit KAOS 1.4.2)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert, in Abhängigkeit des Parameters
<i>mode</i>, die aktuell gültige Konfiguration oder einen Zeiger auf
eine <a href="gemdos_structures.html#DOSVARS">DOSVARS</a>-Struktur zurück.
<br>Im Fehlerfall wird <a href="gemdos_errors.html#EINVFN">EINVFN</a> oder <a href="gemdos_errors.html#EACCDN">EACCDN</a> zurückgeben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> seit KAOS Version 1.2 und <a href="magic.html">MagiC</a> ab Version 1.0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Sconfig">Binding</a> &nbsp; <a href="#Sysconf">Sysconf</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Sconfig">5.14.2.1 Bindings für Sconfig</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Sconfig">Sconfig</a> ( int16_t mode, int32_t flags );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    flags,-(sp)  ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #51,-(sp)    ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Scookie">5.14.3 Scookie</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Scookie« - Cookie jar management.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 330 (0x014a)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Scookie ( int16_t action, COOKIE *cookie );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> The function Scookie permits the management of the cookie jar.
The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">action</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">C_BAKE (0x01)</td>
<td valign="top"> <i>cookie</i> is a pointer to a cookie you want to install
into the cookie jar. Only root can bake a cookie (or you get <a href="gemdos_errors.html#EACCDN">EACCDN</a>),
and you cannot overwrite an existing cookie (<a href="gemdos_errors.html#ELOCKED">ELOCKED</a>).
<br>Returns 0 for success, or a negative error code
</td></tr>

<tr><td nowrap="nowrap" valign="top">C_GRAB (0x02)</td>
<td valign="top"> <i>cookie</i> is a pointer to a cookie you want to grab from
the cookie jar. You must supply a cookie with a tag name to look for.
If you use a -1 (LONG) value for the cookie tag, then the first cookie
will be returned to you. If the cookie is found, it will be copied
into the cookie pointed to by <i>cookie</i>.
<br>Returns 0 for success or <a href="gemdos_errors.html#EFILNF">EFILNF</a>. If you need direct access to the
jar, pass -1L as your <i>cookie</i> pointer. This will return a
pointer to the jar
</td></tr>

<tr><td nowrap="nowrap" valign="top">C_MORE (0x04)</td>
<td valign="top"> Like <i>C_GRAB</i> but find the NEXT cookie after the one with
a tag like <i>cookie</i>'s. This is so that you can find the entire
jar with <i>C_GRAB</i> and <i>C_MORE</i>. The found cookie is copied
into <i>cookie</i>. The NULL cookie is copied into <i>cookie</i> if
<i>cookie</i> was the last cookie, or returns <a href="gemdos_errors.html#EFILNF">EFILNF</a> if not found.
<br>Returns 0 for success (or last cookie)
</td></tr>

<tr><td nowrap="nowrap" valign="top">C_READ (0x08)</td>
<td valign="top"> <i>cookie</i> should be a LONG tag value to find, NOT a
pointer! The returned value is the value of the cookie indicated, or
<a href="gemdos_errors.html#EFILNF">EFILNF</a> if not found. Use this when you know the cookie exists, such as
&quot;_MCH&quot; since this is faster and easier.
</td></tr>

<tr><td nowrap="nowrap" valign="top">C_SIZE (0x10)</td>
<td valign="top"> Returns the number of cookies that are actually in the jar. Use
<i>C_READ,0</i> to find out how many cookies can be put in the jar
without resizing
</td></tr>

<tr><td nowrap="nowrap" valign="top">C_EAT (0x20)</td>
<td valign="top"> <i>cookie</i> is the cookie to delete (only need tag value).
Only root can eat cookies (or you get <a href="gemdos_errors.html#EACCDN">EACCDN</a>).
<br>Returns <a href="gemdos_errors.html#EFILNF">EFILNF</a> if cookie is not found or zero for success.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> The return value depends on the parameter <i>action</i>
<br>In case of invalid action value the function will return <a href="gemdos_errors.html#EINVFN">EINVFN</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> This function is not available, use <a href="#Ssystem">Ssystem</a>() instead to manage
cookies.
<br>&nbsp;
<br><span style="color: red;"> This function has been disabled as of FreeMiNT 1.12.4.
Opcode 330 is now assigned to Dchroot(). </span>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Scookie">Binding</a> &nbsp; <a href="#Ssystem">Ssystem</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Scookie">5.14.3.1 Bindings für Scookie</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Scookie">Scookie</a> ( int16_t action, COOKIE *cookie );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       cookie       ; Offset 4
move.w    action,-(sp) ; Offset 2
move.w    #330,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Shutdown">5.14.4 Shutdown</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Shutdown« - kills all processes, syncs filesystems then
halts or reboots the system.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 337 (0x0151)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Shutdown ( int32_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function kills all processes, syncs filesystems then halts
or reboots the system.
<br>&nbsp;
<a name="SHUT_POWER"></a>
<br>On <i>mode</i> equal to SHUT_POWER (0L), the system will turn
the power off. The only hardware that supports it at present is CT60
and the FireBee. If the hardware does not support it, SHUT_HALT will
be performed. SHUT_POWER mode is recognized as of FreeMiNT version
1.16a; older versions of the kernel will treat the SHUT_POWER mode as
SHUT_COLD.
<br>&nbsp;
<a name="SHUT_BOOT"></a>
<br>On <i>mode</i> equal to SHUT_BOOT (1L), the system will reboot
the machine after shutting everything down.
<br>&nbsp;
<a name="SHUT_COLD"></a>
<br>On <i>mode</i> equal to SHUT_COLD (2L), the system will act the
same as with the SHUT_BOOT mode, except that a cold start rather than
the warm start will be performed.
<br>SHUT_COLD mode is recognized as of FreeMiNT version 1.15.5, older
versions of the kernel will treat the SHUT_COLD as SHUT_BOOT.
<br>&nbsp;
<a name="SHUT_HALT"></a>
<br>On <i>mode</i> equal to SHUT_HALT (3L), the system will shut
down, then enter a halted condition.
<br>&nbsp;
<br>All other values of mode are reserved for future definition.
<br>&nbsp;
<br>Older versions of MiNT contained a bug that might cause the
system to crash, if you called Shutdown() while both <a href="gem_about.html">GEM</a> <a href="aes_main.html">AES</a> and
virtual console daemon were present.
<br>&nbsp;
<br>You need root privileges to shut the system down.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns a negative <a href="gemdos_main.html">GEMDOS</a> error code, if failed. On success
this call obviously never returns.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Shutdown">Binding</a> &nbsp; <a href="#Sync">Sync</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Shutdown">5.14.4.1 Bindings für Shutdown</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Shutdown">Shutdown</a> ( int32_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    mode,-(sp)   ; Offset 2
move.w    #337,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Slbclose">5.14.5 Slbclose</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Slbclose« - schließt eine &quot;shared lib&quot;.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 23 (0x017)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Slbclose( SHARED_LIB *sl );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion schließt eine Shared Lib
<br>&nbsp;
<br>Der Parameter <i>sl</i> ist der Deskriptor welcher bei <a href="#Slbopen">Slbopen</a>
ermittelt wird.
<br>&nbsp;
<br>Seit <a href="magic.html">MagiC</a> 6: Ist <i>sl</i>=-1, dann werden <b>alle</b> Shared
Lib geschlossen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="gemdos_errors.html#E_OK">E_OK</a> = Alles OK oder negative <a href="gemdos_main.html">GEMDOS</a>-Fehlernummer.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Sie steht ab MagiC 5.20 und FreeMiNT 1.15.4 zu Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Slbclose">Binding</a> &nbsp; <a href="#Slbopen">Slbopen</a> &nbsp; <a href="magic_sharelib.html">Shared Libraries</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Slbclose">5.14.5.1 Bindings für Slbclose</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Slbclose">Slbclose</a>( SHARED_LIB *sl );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       sl           ; Offset 2
move.w    #23,-(sp)    ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Slbopen">5.14.6 Slbopen</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Slbopen« - Öffnet eine &quot;shared lib&quot;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 22 (0x016)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Slbopen( int8_t *name, int8_t *path, int32_t min_ver,
SHARED_LIB *sl, SLB_EXEC *fn );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion öffnet eine Shared Lib
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">name</td>
<td valign="top"> Der Name der Bibliothek, in Großschrift, inkl. Extension
(&quot;.SLB&quot;). Der Bibliotheksname ist gleichzeitig Dateiname.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">path</td>
<td valign="top"> Pfad bei dem zuerst nach der Bibliothek gesucht (der Pfad muß
in MagiC 5.20 mit '\' abgeschlossen sein; dies ist in MagiC 6 nicht
mehr nötig).
<br>Wenn der Parameter NULL ist oder die Bibliothek im angegebenen
Pfad nicht gefunden wurde, wird im XTENSION-Ordner gesucht.
<br>Ab MagiC 6 wird die Environment-Variable SLBPATH ausgewertet. Sie
enthält wie PATH eine Liste der Suchpfade, jeweils durch ';'
getrennt. Ist die Variable definiert, wird nicht mehr extra im
XTENSION-Ordner gesucht.
<br>&nbsp;
<br>Bei FreeMiNT wird versucht die Bibliothek aus dem aktuellen
Verzeichnis zu laden, falls <i>path</i> NULL ist.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">min_ver</td>
<td valign="top"> Minimal notwendige Versionsnummer der Bibliothek.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">sl</td>
<td valign="top"> Zeiger auf den Deskriptor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">fn</td>
<td valign="top"> Zeiger auf den Funktionszeiger.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;= 0</td>
<td valign="top"> Alles OK, Versionsnummer der Bibliothek.
<br>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a></td>
<td valign="top"> Versionsnummer zu niedrig
<br>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a></td>
<td valign="top"> Bibliothek schon von diesem Prozeß geöffnet
<br>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a></td>
<td valign="top"> Bibliothek nicht gefunden
<br>
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENSMEM">ENSMEM</a></td>
<td valign="top"> zuwenig Speicher

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Sie steht ab MagiC 5.20 und FreeMiNT 1.15.4 zu Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Slbopen">Binding</a> &nbsp; <a href="#Slbclose">Slbclose</a> &nbsp; <a href="magic_sharelib.html">Shared Libraries</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Slbopen">5.14.6.1 Bindings für Slbopen</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Slbopen">Slbopen</a>( int8_t *name, int8_t *path, int32_t min_ver,
SHARED_LIB *sl, SLB_EXEC *fn );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       fn           ; Offset 18
pea       sl           ; Offset 14
move.l    minver,-(sp) ; Offset 10
pea       path         ; Offset 6
pea       name         ; Offset 2
move.w    #22,-(sp)    ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       22(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Srealloc">5.14.7 Srealloc</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Srealloc« - Bildschirmspeicher allozieren.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 21
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Srealloc ( int32_t len );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="gemdos_main.html">GEMDOS</a>-Routine Srealloc alloziert für den
Bildschirmspeicher einen Bereich der Länge <i>len</i> Bytes.
<br>&nbsp;
<br>Der Bildschirmspeicher ist ein Block des ST-RAM, dessen Eigner
der Bootprozeß ist. Die Adresse des Bildschirmspeichers (logbase oder
physbase) wird von dieser Funktion nicht beeinflußt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert (falls <i>len</i> den Wert -1 besitzt)
die maximal mögliche Größe des Bildschirmspeichers zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> ab <a href="gemdos_main.html">GEMDOS</a> 0.30 (<a href="tos_main.html">TOS</a> 4).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Srealloc">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Srealloc">5.14.7.1 Bindings für Srealloc</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Srealloc">Srealloc</a> ( int32_t len );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    len,-(sp)    ; Offset 2
move.w    #21,-(sp)    ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Ssystem">5.14.8 Ssystem</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Ssystem« - controlling Cookie Jar, memory access and various
system settings.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 340 (0x0154)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Ssystem ( int16_t mode, int32_t arg1, int32_t arg2 );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> The Ssystem call has been designed to make your life easier.
Using this you can get some closer control on the system and the kernel
itself. Via this call the kernel now supports e.g. an easy Cookie Jar
management and provides a safe access to supervisor memory. It's
strictly encouraged to access <a href="gemdos_main.html">GEMDOS</a> variables and system vectors via
the Ssystem(), because this way is considered safe for multiuser
setups.
<br>&nbsp;
<br><i>arg1</i> and <i>arg2</i> are long parameters specific for a
particular mode. If a mode doesn't use a parameter, it is usually
ignored, but should be set to a zero for future compatibility. mode
specifies a particular action as follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> meaning
<br>&nbsp;
<a name="S_INQUIRE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_INQUIRE(0xffff)</td>
<td valign="top"> Returns a zero if the kernel supports Ssystem. You can expect
the function to be present if MiNT version at least 1.15 is detected.
<br>&nbsp;
<a name="S_OSNAME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSNAME(0x0000)</td>
<td valign="top"> Identifies the operating system type. Returned longword
contains a 32-bit positive number, which interpreted as an ASCII
string gives a 4-character id. For MiNT the returned value is
0x4d694e54 ('MiNT').
<br>&nbsp;
<a name="S_OSXNAME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSXNAME(0x0001)</td>
<td valign="top"> Identifies the subtype of the operating system. If this call
returns a zero or a negative value, that means, that no subtype is
available. Otherwise the returned value, when interpreted as an ASCII
string gives a 4-character subtype id. For FreeMiNT, being a
derivative of the MiNT, the returned value is 0x46726565 ('<a href="c_task_royal.html#Free">Free</a>').
<br>&nbsp;
<br>If a subtype id is less than 4 characters long, it should be
padded with zeros.
<br>&nbsp;
<a name="S_OSVERSION"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSVERSION(0x0002)</td>
<td valign="top"> Identifies the exact operating system version. Returned
longword contains a 32 bit positive version number encoded as follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">bits</td>
<td valign="top"> meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0-7</td>
<td valign="top"> some printable character to characterize the current version,
e.g.
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0x61</td>
<td valign="top"> (`a') if alpha release,
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x62</td>
<td valign="top"> (`b') if beta release.

</td></tr>
</table>

<br>For official releases you will always find a value of 0 here.
</td></tr>

<tr><td nowrap="nowrap" valign="top">8-15</td>
<td valign="top"> patchlevel (0x55 for pl 88)
</td></tr>

<tr><td nowrap="nowrap" valign="top">16-23</td>
<td valign="top"> minor version number (0x0e for x.14)
</td></tr>

<tr><td nowrap="nowrap" valign="top">24-31</td>
<td valign="top"> major version number (0x01 for 1.xx)

</td></tr>
</table>

<br>Definition of an official release: every release for which in
bits 0-7 a value of 0 is returned...
<br>&nbsp;
<a name="S_OSHEADER"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSHEADER(0x0003)</td>
<td valign="top"> Allows to access the <a href="tos_main.html">TOS</a> header in order to get some
information from. Current implementation allows to access the first
256 longwords of the header. The address of the required longword,
relative to the begin address of the <a href="tos_main.html">TOS</a> header, has to be specified
as arg1. Only even values are allowed (bit 0 of the arg1 is masked out
by the kernel). Always a whole longword is returned.
<br>&nbsp;
<a name="S_OSBUILDDATE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSBUILDDATE(0x0004)</td>
<td valign="top"> Returns a 32 bit positive value with the build date encoded as
follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">bits</td>
<td valign="top"> meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0-15</td>
<td valign="top"> binary year (0x07dd for 1998)
</td></tr>

<tr><td nowrap="nowrap" valign="top">16-23</td>
<td valign="top"> binary month (0x0c for the December)
</td></tr>

<tr><td nowrap="nowrap" valign="top">24-31</td>
<td valign="top"> binary day of the month

</td></tr>
</table>

<a name="S_OSBUILDTIME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSBUILDTIME(0x0005)</td>
<td valign="top"> Returns a 32 bit positive value with the build time encoded as
follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">bits</td>
<td valign="top"> meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0-7</td>
<td valign="top"> binary seconds
</td></tr>

<tr><td nowrap="nowrap" valign="top">8-15</td>
<td valign="top"> binary minutes
</td></tr>

<tr><td nowrap="nowrap" valign="top">16-23</td>
<td valign="top"> binary hours
</td></tr>

<tr><td nowrap="nowrap" valign="top">24-31</td>
<td valign="top"> day of week

</td></tr>
</table>

<br>day of week has 1 for Monday, 2 for Tuesday... 7 for Sunday.
<br>&nbsp;
<br>The call should never return a zero in these bits, but if it
does, it should be interpreted as Sunday.
<br>&nbsp;
<a name="S_OSCOMPILE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSCOMPILE(0x0006)</td>
<td valign="top"> Returns a 32-bit positive value specifying the primary CPU type
the kernel has been compiled for. Encoding:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">bits</td>
<td valign="top"> meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0-7</td>
<td valign="top"> binary minor CPU ID
</td></tr>

<tr><td nowrap="nowrap" valign="top">8-15</td>
<td valign="top"> binary major CPU ID
</td></tr>

<tr><td nowrap="nowrap" valign="top">16-31</td>
<td valign="top"> reserved for future definition.

</td></tr>
</table>

<br>The major ID identifies a particular series of processors. A
value of $00 is assigned to the Motorola 68k series and since kernel
version 1.19 a value of $01 is assigned to the ColdFire processors.
Other values of this field are reserved for future definition.
<br>&nbsp;
<br>The minor CPU ID interpretation depends on the major ID. For 68k
series, values are as follows:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0x00</td>
  <td align="left" valign="top">68000</td>
</tr>
<tr>
  <td align="left" valign="top">0x0a</td>
  <td align="left" valign="top">68010</td>
</tr>
<tr>
  <td align="left" valign="top">0x14</td>
  <td align="left" valign="top">68020</td>
</tr>
<tr>
  <td align="left" valign="top">0x1e</td>
  <td align="left" valign="top">68030</td>
</tr>
<tr>
  <td align="left" valign="top">0x28</td>
  <td align="left" valign="top">68040</td>
</tr>
<tr>
  <td align="left" valign="top">0x3c</td>
  <td align="left" valign="top">68060</td>
</tr>
</table>
</div>

<br>For the ColdFire series:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0x00</td>
  <td align="left" valign="top">isa_a</td>
</tr>
<tr>
  <td align="left" valign="top">0X01</td>
  <td align="left" valign="top">isa_a+</td>
</tr>
<tr>
  <td align="left" valign="top">0X02</td>
  <td align="left" valign="top">isa_b</td>
</tr>
<tr>
  <td align="left" valign="top">0X03</td>
  <td align="left" valign="top">isa_c</td>
</tr>
</table>
</div>

<br>This is not the same as the <a href="bios_cookiejar.html#Cookie_2C_20_CPU">_CPU</a> cookie value. The _CPU
cookie specifies the CPU physically present in the machine, while the
S_OSCOMPILE indicates the processor type selected at the time when the
system was compiled. In other words, running a 68000-compiled kernel
will return a 0x00 here, even if the machine is running 68040 or
something.
<br>&nbsp;
<a name="S_OSFEATURES"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_OSFEATURES(0x0007)</td>
<td valign="top"> Returns a 32-bit positive value specifying the state of kernel
features. Encoding:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">bits</td>
<td valign="top"> meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> memory protection (1 = turned on)
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> virtual memory (1 = turned on)
</td></tr>

<tr><td nowrap="nowrap" valign="top">2-31</td>
<td valign="top"> reserved for future usage

</td></tr>
</table>

<br>This call has an informative purpose only and you cannot toggle
anything with it.
<br>&nbsp;
<a name="S_GETCOOKIE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETCOOKIE(0x0008)</td>
<td valign="top"> Fetches required information from the Cookie Jar.
<br>&nbsp;

<ol class="UDO_env_enumerate">
<li><p> If arg1 is a value bigger than 65535 (0xffff), it is
interpreted as a tag id. The Cookie Jar is searched for such a tag,
then if the tag is found, the corresponding slot value is returned or
-1 otherwise.
<br>&nbsp;
</p></li>
<li><p> If arg1 is a value between 1 and 65535, it is interpreted as a
slot number, not a tag id.Then the corresponding tag id is fetched and
returned or a value of -1 if the specified slot is free or does not
exist at all (a slot number past the end of the Cookie Jar was
specified). The first slot in the Cookie Jar is considered number 1.
<br>&nbsp;
</p></li>
<li><p> If arg1 is equal to a zero, then the Cookie Jar is searched for
the NULL cookie, then the corresponding slot value is returned.
<br>&nbsp;
</p></li>
</ol>

<br>The place where the value fetched from the Cookie Jar will be
returned is defined by the arg2. If this is a zero, the call returns
its values in the <a href="gemdos_main.html">GEMDOS</a> return value (d0). If the arg2 is not a zero,
it is interpreted as a pointer to a memory location, where the slot
tag or its value should be written to. The return value is 0 (<a href="gemdos_errors.html#E_OK">E_OK</a>)
then, if everything went OK, or -1 otherwise.
<br>&nbsp;
<br>This behaviour (where arg2 != NULL) is not implemented in MiNT
versions below 1.14.8.
<br>&nbsp;
<a name="S_SETCOOKIE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETCOOKIE(0x0009)</td>
<td valign="top"> Places a tag id specified by the arg1 with the value of the
arg2 in the Cookie Jar. If a slot with the specified tag id already
exists, it will be replaced with the new value. NULL cookie is
reallocated automatically and its value is adjusted. If there are no
more free slots, no action is performed and <a href="gemdos_errors.html#ENOMEM">ENOMEM</a> is returned
instead.
<br>&nbsp;
<br>S_SETCOOKIE requires root euid, <a href="gemdos_errors.html#EACCES">EACCES</a> is returned otherwise and
no action is performed.
<br>&nbsp;
<br>The call refuses to place a cookie (a value of -1 is returned)
whose tag ID contains a zero-byte.
<br>&nbsp;
<a name="S_GETLVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETLVAL(0x000a)</td>
<td valign="top"> Fetches and returns a LONGword from the address of supervisor
area specified as a 16-bit, even, unsigned integer value passed as
<i>arg1</i>. Bit 0 and bits 16-31 are masked out (ignored). The call
returns a zero if the value at the specified address has to be
&quot;hidden&quot; from reading. Currently the hidden values are the
initial PC value and the initial stack pointer value stored at
0x00000000 and 0x00000004 respectively. Reading a hidden value may
require root euid.
<br>&nbsp;
<br>If the desired address is LONGword aligned, LONGwords can be
also retrieved from the supervisor area using <a href="About_the_BIOS.html#Setexc">Setexc</a>.
<br>&nbsp;
<a name="S_GETWVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETWVAL(0x000b)</td>
<td valign="top"> Fetches and returns a word from the address of supervisor area
specified as a 16-bit, even, unsigned integer value passed as
<i>arg1</i>. Bit 0 and bits 16-31 are masked out (ignored). The call
returns a zero if the value at the specified address has to be
&quot;hidden&quot; from reading. Currently the hidden values are the
initial PC value and the initial stack pointer value stored at
0x00000000 and 0x00000004 respectively. Reading a hidden value may
require root euid.
<br>&nbsp;
<a name="S_GETBVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETBVAL(0x000c)</td>
<td valign="top"> Fetches and returns a byte from the address of supervisor area
specified as a 16-bit unsigned integer value passed as <i>arg1</i>.
Bits 16-31 are masked out (ignored). The call returns a zero if the
value at the specified address has to be &quot;hidden&quot; from
reading. Currently the hidden values are the initial PC value and the
initial stack pointer value stored at 0x00000000 and 0x00000004
respectively. Reading a hidden value may require root euid.
<br>&nbsp;
<a name="S_SETLVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETLVAL(0x000d)</td>
<td valign="top"> Places a LONGword value specified by <i>arg2</i> at address
specified as 16-bit integer by <i>arg1</i>. Bit 0 and bits 16-31 of
the <i>arg1</i> are masked out (ignored). Since this call is designed
to manipulate operating system variables located within the supervisor
area (first 32k), it is restricted to root euid and returns <a href="gemdos_errors.html#EACCES">EACCES</a> if
called by an unprivileged process.
<br>&nbsp;
<a name="S_SETWVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETWVAL(0x000e)</td>
<td valign="top"> Places a word value specified by <i>arg2</i> at address
specified as 16-bit integer by <i>arg1</i>. Bit 0 and bits 16-31 of
the <i>arg1</i> are masked out (ignored). Since this call is designed
to manipulate operating system variables located within the supervisor
area (first 32k), it is restricted for root euid and returns <a href="gemdos_errors.html#EACCES">EACCES</a> if
called by an unprivileged process.
<br>&nbsp;
<a name="S_SETBVAL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETBVAL(0x000f)</td>
<td valign="top"> Places a byte value specified by <i>arg2</i> at address
specified as 16-bit integer by <i>arg1</i>. Bits 16-31 of the
<i>arg1</i> are masked out (ignored). Since this call is designed to
manipulate operating system variables located within the supervisor
area (first 32k), it is restricted for root euid and returns <a href="gemdos_errors.html#EACCES">EACCES</a> if
called by an unprivileged process.
<br>&nbsp;
<a name="S_SECLEVEL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SECLEVEL(0x0010)</td>
<td valign="top"> Resets the current security level to a value specified by
<i>arg1</i>. Valid levels are as follows:
<br>&nbsp;
<br>0: none of hardware specific system calls are restricted. This
is a 'MultiTOS compatibility' mode.
<br>&nbsp;
<br>1: BIOS and XBIOS calls require root privileges; any call
except <a href="xbios_special.html#Supexec">Supexec</a> and <a href="#Super">Super</a> returns <a href="gemdos_errors.html#EACCES">EACCES</a> if called by an unprivileged
process. This does not apply to <a href="About_the_BIOS.html#Setexc">Setexc</a>, which sends <a href="gemdos_signals.html#SIGSYS">SIGSYS</a> to the
caller if a change of an exception vector was attempted.
<br>&nbsp;
<br>2: as above, with except that Supexec and Super generates SIGSYS
in order to kill the calling process.
<br>&nbsp;
<br>On values bigger than 2, <a href="gemdos_errors.html#EACCES">EACCES</a> is returned. If <i>arg1</i> is
equal to -1, the current security level value is returned.
<br>&nbsp;
<br>The call absolutely needs root privileges - user processes
cannot even inquire the current security level value.
<br>&nbsp;
<a name="S_RUNLEVEL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_RUNLEVEL(0x0011)</td>
<td valign="top"> Reserved for future definition.
<br>&nbsp;
<a name="S_TSLICE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_TSLICE(0x0012)</td>
<td valign="top"> Allows setting/interrogating the global timeslice value. Values
are exactly the same as for SLICES keyword in mint.cnf. If
<i>arg1</i> is equal to -1, the call returns the current global
timeslice value.
<br>&nbsp;
<br>Setting the timeslice requires root privileges.
<br>&nbsp;
<a name="S_FASTLOAD"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_FASTLOAD(0x0013)</td>
<td valign="top"> Allows changing the interpretation of the FASTLOAD bit in the
program header.
<br>&nbsp;
<br>On Ssystem(S_FASTLOAD, 0L, 0L); the program header bit will be
used as before, this is actually equal to FASTLOAD=NO in mint.cnf.
<br>&nbsp;
<br>On Ssystem(S_FASTLOAD, 1L, 0L); , the program header bit will be
ignored and fastload will be forced for all programs.
<br>&nbsp;
<br><i>arg1</i> = -1 allows interrogation of the current state of
this variable.
<br>&nbsp;
<br>You need root privileges to toggle the FASTLOAD mode.
<br>&nbsp;
<a name="S_SYNCTIME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SYNCTIME(0x0014)</td>
<td valign="top"> Allows interrogation or changing the global file-system sync
time. The default value is 5 sec.
<br>&nbsp;
<br>If <i>arg1</i> is a positive value, it is interpreted as a new
sync time value.
<br>&nbsp;
<br>If <i>arg1</i> is equal to -1, the current sync time value will
be returned.
<br>&nbsp;
<br>To be able to change the file-system sync time you must have
root privileges.
<br>&nbsp;
<a name="S_BLOCKCACHE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_BLOCKCACHE(0x0015)</td>
<td valign="top"> A positive value of <i>arg1</i> ranging from 0 to 100
specifies the percentage of file-system cache to be filled with linear
reads, as in the PERCENTAGE keyword in the mint.cnf file. A negative
value of <i>arg1</i> returns the currently set percentage value.
<br>&nbsp;
<br>Root privileges are required to use this mode.
<br>&nbsp;
<a name="S_FLUSHCACHE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_FLUSHCACHE(0x0016)</td>
<td valign="top"> Invalidates CPU cache entries. <i>arg1</i> is a pointer to the
memory area whose cache entries should be invalidated, <i>arg2</i> is
the size of the area in bytes. Passing -1 as <i>arg2</i> invalidates
all cache entries. If the CPU features separate instruction and data
caches, both are flushed.
<br>&nbsp;
<br>This call automatically recognizes caches in 68020/030/040/060
and handles them as appropriate. The 68060 branch cache is
automatically invalidated too. On 68000/68010 calling this mode has no
effect. This mode is in fact just an interface to the MiNT function
cpush used internally by the system.
<br>&nbsp;
<br>Root privileges are NOT required to use this mode.
<br>&nbsp;
<a name="S_CTRLCACHE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CTRLCACHE(0x0017)</td>
<td valign="top"> Provides an universal (among 68k family members) way of
controlling the CPU on-chip caches. <i>arg1</i>, referenced as Cache
Control Word (CCW), is a bit-field where each bit enables (if 1) or
disables (if 0) a particular function of CPU caches. <i>arg2</i>,
referenced as Cache Control Mask (CCM), is a bit-mask where you define
(by setting appropriate bits to 1) which bits of the Cache Control
Word should be actually taken into account and written into the Cache
Control Register (CACR). This is the control mode of the S_CTRLCACHE.
<br>&nbsp;
<br>In inquire mode you can pass -1 as either argument. If the CCW
is -1, the call returns a LONGword reflecting the actual state of the
caches.
<br>&nbsp;
<br>If the CCM is -1, a default bit-mask is returned, where any bit
set indicates that a cache function defined by the same bit in the
Cache Control Word is valid for the processor the MiNT is currently
running on.
<br>&nbsp;
<br>If both arguments are negative, the call simply returns <a href="gemdos_errors.html#E_OK">E_OK</a> if
it is valid at all, or <a href="gemdos_errors.html#ENOSYS">ENOSYS</a> otherwise. This is the acknowledge mode
of the S_CTRLCACHE.
<br>&nbsp;
<br>Bits in either argument are defined as follows:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top"></td>
  <td align="left" valign="top"></td>
  <td align="center" valign="top">020</td>
  <td align="center" valign="top">030</td>
  <td align="center" valign="top">040</td>
  <td align="center" valign="top">060</td>
  <td align="center" valign="top">CFv4e</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Enable instruction cache</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Enable data cache</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Enable branch cache</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">Freeze instruction cache</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">Freeze data cache</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">Instruction burst enable</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">6</td>
  <td align="left" valign="top">Data burst enable</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">7</td>
  <td align="left" valign="top">Enable write allocate</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">8</td>
  <td align="left" valign="top">Instruction cache full mode enable</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">9</td>
  <td align="left" valign="top">Instruction cache read/write allocate</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">10</td>
  <td align="left" valign="top">Data cache full mode enable</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">11</td>
  <td align="left" valign="top">Data cache read/write allocate enable</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">12</td>
  <td align="left" valign="top">Invalidate branch cache</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">13</td>
  <td align="left" valign="top">Invalidate branch cache user entries</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">-</td>
</tr>
<tr>
  <td align="center" valign="top">14</td>
  <td align="left" valign="top">Enable CPUSH invalidate</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">15</td>
  <td align="left" valign="top">Enable store buffer</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">16</td>
  <td align="left" valign="top">Instruction cache invalidate all</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">17</td>
  <td align="left" valign="top">Instruction cache mode default</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">18</td>
  <td align="left" valign="top">Instruction cache half lock enable</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">19</td>
  <td align="left" valign="top">CPUSH invalidate enable (instruction)</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">20</td>
  <td align="left" valign="top">Default cache-inhibited fill buffer</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">21</td>
  <td align="left" valign="top">Data cache invalidate all</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">22</td>
  <td align="left" valign="top">Default data cache mode (bit 0)</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">23</td>
  <td align="left" valign="top">Default data cache mode (bit 1)</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">24</td>
  <td align="left" valign="top">Data cache half lock enable</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">-</td>
  <td align="center" valign="top">x</td>
</tr>
<tr>
  <td align="center" valign="top">25-31</td>
  <td align="left" valign="top">Reserved for future definition</td>
  <td align="center" valign="top"></td>
  <td align="center" valign="top"></td>
  <td align="center" valign="top"></td>
  <td align="center" valign="top"></td>
  <td align="center" valign="top"></td>
</tr>
</table>
</div>

<br>Note that no processor currently supports all of these functions
and some (68000 and 68010) have no on-chip caches at all. To figure
out what functions are valid for the actual CPU used, you should first
request the default bit-mask using the inquire mode described above.
Your program should save this mask, logically AND the <i>arg2</i>
with it, then pass the result as the Cache Control Mask for a control
mode call.
<br>&nbsp;
<br>Also note that the above bit definition does not exactly reflect
the function and even position of actual bits in the physical Cache
Control Register. The bits of either argument are arbitrarily assigned
to particular cache functions, but their position and state are
converted by the system before the Cache Control Register is written
and after it is read, so that the user program can see always the same
functions assigned to bits as above regardless of the physical
configuration of the Cache Control Register.
<br>&nbsp;
<br>Since changing cache configuration is global and may severely
affect system performance, root privileges are needed to use
S_CTRLCACHE control mode.
<br>&nbsp;
<a name="S_INITIALTPA"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_INITIALTPA(0x0018)</td>
<td valign="top"> A positive non-zero value of <i>arg1</i> defines the default
amount of memory (in bytes) allocated for TPA space, as in the
INITIALMEM keyword of the mint.cnf file. A negative value allows one
to interrogate the value currently set. A value of 0 is illegal and
will cause the call to fail and return <a href="gemdos_errors.html#EBADARG">EBADARG</a>. Note that even if you
define a very small value, like 1 or 2 bytes, the system will round
this up to the smallest size of a memory block possible to allocate.
<br>&nbsp;
<br>Root privileges are required to use this mode.
<br>&nbsp;
<a name="S_CTRLALTDEL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CTRLALTDEL(0x0019)</td>
<td valign="top"> Reserved for future definition.
<br>&nbsp;
<a name="S_DELCOOKIE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_DELCOOKIE(0x001a)</td>
<td valign="top"> Removes a tag ID specified by <i>arg1</i> from the cookie jar.
If there is no slot with the specified tag ID, no action is performed
and <a href="gemdos_errors.html#EINVAL">EINVAL</a> is returned instead.
<br>&nbsp;
<br>S_DELCOOKIE requires root euid, <a href="gemdos_errors.html#EPERM">EPERM</a> is returned otherwise and
no action is performed.
<br>&nbsp;
<a name="S_LOADKBD"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_LOADKBD(0x001b)</td>
<td valign="top"> Load the keyboard table into memory. <i>arg1</i> specify the
address of the complete path to the keyboard table or NULL. If path is
NULL the default path of &lt;sysdir&gt;/keyboard.tbl is used. Returns
a negative <a href="gemdos_main.html">GEMDOS</a> error-code if it fails. On success this call returns
0 and _AKP and _ISO cookies are updated.
<br>&nbsp;
<br>S_LOADKBD requires root euid, <a href="gemdos_errors.html#EPERM">EPERM</a> is returned otherwise and no
action is performed.
<br>&nbsp;
<a name="S_SETEXC"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_SETEXC(0x001c)</td>
<td valign="top"> Allow <a href="About_the_BIOS.html#Setexc">Setexc</a>(). Valid <i>argc1</i> values are as follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Value</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> <a href="VT_52_terminal.html#Return">Return</a> the current setting
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> Deny all (only kernel-processes may change sys-vectors)
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> Deny trap-changes (numbers 0-15)
</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top"> Allow all (default)

</td></tr>
</table>

<br>Returns <a href="gemdos_errors.html#EBADARG">EBADARG</a> if <i>arg1</i> is greater than 2, or 0 on
success.
<br>&nbsp;
<br>S_SETEXC requires root euid, <a href="gemdos_errors.html#EPERM">EPERM</a> is returned otherwise and no
action is performed.
<br>&nbsp;
<a name="S_GETBOOTLOG"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_GETBOOTLOG(0x001d)</td>
<td valign="top"> Inquires the file path of bootlog file. <i>arg1</i> and
<i>arg2</i> specify the address and length in bytes, respectively, of
a memory buffer where a NULL-terminated ASCII string will be written
identifying the full name of the bootlog file. If the memory buffer is
not long enough to hold the entire string, the string is truncated
down to the buffer size. Returns <a href="gemdos_errors.html#EBADARG">EBADARG</a> if <i>arg1</i> is null or if
<i>arg2</i> is 0. On success this call returns 0.
<br>&nbsp;
<br>S_GETBOOTLOG requires root euid, <a href="gemdos_errors.html#EPERM">EPERM</a> is returned otherwise and
no action is performed.
<br>&nbsp;
<a name="S_CLOCKUTC"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CLOCKUTC(0x0064)</td>
<td valign="top"> S_CLOCKUTC called with an <i>arg1</i> of -1 inquires the
kernel's notion of the hardware system clock. If the command returns a
zero, the hardware clock is considered to tick in UTC; if it returns a
positive non-zero value, it is considered to tick in local time. Any
other positive value of <i>arg1</i> sets the current clock mode. On a
0 it is reset to UTC, or to local time otherwise.
<br>&nbsp;
<br>Although this call will never really change the setting of the
hardware clock, due to the changed interpretation the clock seems to
warp; don't play around too much with it.
<br>&nbsp;
<a name="S_KNAME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_KNAME(0x0384)</td>
<td valign="top"> <i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written identifying the full name and version of the
system kernel. If the memory buffer is not long enough to hold the
entire string, the string is truncated down to the buffer size.
<br>&nbsp;
<a name="S_CNAME"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CNAME(0x038e)</td>
<td valign="top"> <i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written identifying the full name of the compiler used
to compile the system kernel. If the memory buffer is not long enough
to hold the entire string, the string is truncated down to the buffer
size.
<br>&nbsp;
<a name="S_CVERSION"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CVERSION(0x038f)</td>
<td valign="top"> <i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written identifying the version of the compiler used to
compile the system kernel. If the memory buffer is not long enough to
hold the entire string, the string is truncated down to the buffer
size.
<br>&nbsp;
<a name="S_CDEFINES"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_CDEFINES(0x0390)</td>
<td valign="top"> <i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written containing the compile time definitions
(switches) used while compiling the system kernel. If the memory
buffer is not long enough to hold the entire string, the string is
truncated down to the buffer size.
<br>&nbsp;
<a name="S_COPTIM"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_COPTIM(0x0391)</td>
<td valign="top"> <i>arg1</i> and <i>arg2</i> specify the address and length in
bytes, respectively, of a memory buffer where a NULL-terminated ASCII
string will be written containing the compile time optimization
options used while compiling the system kernel. If the memory buffer
is not long enough to hold the entire string, the string is truncated
down to the buffer size.
<br>&nbsp;
<a name="S_DEBUGLEVEL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_DEBUGLEVEL(0x03e8)</td>
<td valign="top"> S_DEBUGLEVEL called with an <i>arg1</i> of -1 inquires the
kernel's current debug level. Any other positive value will set the
current debug level. If it is a zero, the kernel will not output any
debugging information, except for fatal error-messages. The higher the
debug level, the more MiNT will spew about what it is doing.
<br>&nbsp;
<br>Note that special debug kernels will output more information
than an ordinary distribution kernel.
<br>&nbsp;
<br>Root privileges are needed to change the debug level.
<br>&nbsp;
<a name="S_DEBUGDEVICE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_DEBUGDEVICE(0x03e9)</td>
<td valign="top"> S_DEBUGDEVICE called with an <i>arg1</i> of -1 inquires the
current BIOS device to output the debug information to. The order of
defined BIOS devices is as follows:
<br>&nbsp;
<ul>
<li> 0, printer
</li>
<li> 1, AUX:
</li>
<li> 2, console (default)
</li>
<li> 3, MIDI
</li>
<li> 4, keyboard
</li>
<li> 5, raw screen
</li>
</ul>

<br>Any positive value of <i>arg1</i>, ranging from 0 to 9, will
redirect the debug information output to an appropriate BIOS device.
Notice however, that setting device 4 (keyboard) as a debug device
does not make much sense and may produce undesired results. The system
does not restrict this in any way though, just assuming that you know
what you're doing.
<br>&nbsp;
<br>Root privileges are needed to change the debug device.
<br>&nbsp;
<a name="S_DEBUGKMTRACE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_DEBUGKMTRACE(0x044c)</td>
<td valign="top"> Dump out kmalloc'ed blocks with size and caller (debug kernel).
<i>arg1</i> specify the address of the kmalloc'ed block to check and
<i>arg2</i> specify the memory buffer where the dump will be written.
Returns <a href="gemdos_errors.html#ENOENT">ENOENT</a> if it fails. On success this call returns 0.
<br>&nbsp;
<br>S_DEBUGKMTRACE requires root euid, <a href="gemdos_errors.html#EPERM">EPERM</a> is returned otherwise
and no action is performed.
<br>&nbsp;
<a name="S_TIOCMGET"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">S_TIOCMGET(0x54f8)</td>
<td valign="top"> This mode is reserved for the internal and exclusive usage of
the MiNT Library.
<br>&nbsp;

</td></tr>
</table>

<br>Ssystem was first introduced as of MiNT version 1.14.6, but it
is considered fully functional as of MiNT version 1.15.0 release.
<br>&nbsp;
<br>The S_OSHEADER opcode should be only used for fetching the
TOS version number when running MiNT versions below 1.15.0 release.
<br>&nbsp;
<br>The S_FLUSHCACHE, S_CTRLCACHE, S_DEBUGLEVEL and S_DEBUGDEV are
supported as of MiNT version 1.15.1 release.
<br>&nbsp;
<br>You should never use Ssystem(S_TIOCMGET, ...); in your own
programs.
<br>&nbsp;
<br>The Ssystem behaviour does not depend on the S_SECLEVEL
settings.
<br>&nbsp;
<br>Any values returned by the kernel on reserved fields should be
considered undocumented and no software should rely on them.
<br>&nbsp;
<br>It's strictly encouraged to access GEMDOS variables and system
vectors via the Ssystem, because this way is considered safe for
multi-user setups. For example, you can access the cookie jar pointer
using the call Ssystem(S_GETLVAL, 0x05a0, NULL), though if
TOS-compatibility is the issue you should rather use (2, -1).
<br>&nbsp;
<br>Prior to any further Ssystem usage, your application should
first check if the kernel supports this call. If it does, the
Ssystem(-1, 0L, 0L); should return a zero.
<br>&nbsp;
<br>Ssystem is used and supported by the MiNT Library as of
patchlevel 48.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 1.15
exists.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Ssystem">Binding</a> &nbsp; <a href="gemdos_datetime.html#Tgettimeofday">Tgettimeofday</a> &nbsp; <a href="gemdos_datetime.html#Tsettimeofday">Tsettimeofday</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Ssystem">5.14.8.1 Bindings für Ssystem</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Ssystem">Ssystem</a> ( int16_t mode, int32_t arg1, int32_t arg2 );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    arg2,-(sp)   ; Offset 8
move.l    arg1,-(sp)   ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #340,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $0c(sp),sp   ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="STEFcntrl">5.14.9 STEFcntrl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »STEFcntrl« - <a href="emulators_stem.html">STEmulator</a> Kontrollfunktionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 24000 (0x5DC0)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t STEFcntrl ( int16_t func, int32_t special1, int32_t
special2 );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top">
<br>&nbsp;
<br>SET_INFOTEXT (1)
<br>special1 = (int8_t *) Zeiger auf neue Infozeile
<br>special2 = (int8_t *) Zeiger auf alte Infozeile
<br>&nbsp;
<br>Der String auf den <i>special1</i> zeigt, wird als neue
Infozeile in die Status-Zeile des <a href="emulators_stem.html">STEmulator</a> übernommen. Ein Wert von
NULL schaltet wieder auf die Standard-Anzeige zurück.
<br>&nbsp;
<br>Wenn in <i>special2</i> ein gültiger Zeiger auf einen Buffer
übergeben wird, enthält dieser nach dem Funktionsaufruf den alten
Text der Infozeile. Bei NULL, passiert nichts.
<br>&nbsp;
<br>SET_WINDOWTITLE (2)
<br>special1 = (int8_t *) Zeiger auf neue Titelzeile
<br>special2 = (int8_t *) Zeiger auf alte Titelzeile
<br>&nbsp;
<br>Der String auf den <i>special1</i> zeigt, wird als neue Titel
des <a href="emulators_stem.html">STEmulator</a>-Fenster übernommen.
<br>&nbsp;
<br>Wenn in <i>special2</i> ein gültiger Zeiger auf einen Buffer
übergeben wird, enthält dieser nach dem Funktionsaufruf den alten
Fenstertitel. Bei NULL, passiert nichts.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="gemdos_errors.html#EINVFN">EINVFN</a> = Unbekannte Funktion
<br><a href="gemdos_errors.html#ERANGE">ERANGE</a> = ungültiger Parameter
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> <a href="emulators_stem.html">STEmulator</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20STEFcntrl">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20STEFcntrl">5.14.9.1 Bindings für STEFcntrl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#STEFcntrl">STEFcntrl</a> ( int16_t func, int32_t special1, int32_t
special2 );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    special2,-(sp)   ; Offset 8
move.l    special1,-(sp)   ; Offset 4
move.w    func,-(sp)       ; Offset 2
move.w    #24000,-(sp)     ; Offset 0
trap      #1               ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $0c(sp),sp       ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Super">5.14.10 Super</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »supervisor« - Supervisor-Modus umschalten.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 32 (0x0020)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Super ( void *stack );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="gemdos_main.html">GEMDOS</a>-Routine Super schaltet zwischen User- und
Supervisor-Modus um bzw. fragt den aktuellen Betriebsmodus ab.
<br>&nbsp;
<br>Die Adresse des Supervisor-Stacks kann beim Umschalten
verändert werden. übergibt man für den Parameter <i>stack</i> den
Wert 1, so wird der aktuelle Betriebsmodus erfragt. Der Wert 0
schaltet zwischen User und Supervisor-Modus um. Alle anderen Werten
werden als neue Adresse für den Supervisor-Stack betrachtet. Im
Supervisor-Modus kann auf alle geschützten Speicherstellen
zugegriffen werden.
<br>&nbsp;
<br><b>Hinweis:</b> Im Hinblick auf zukünftige
Betriebssystemversionen sollten Sie den Einsatz der Super-Funktion
vermeiden. Diese Funktion verursacht im Zusammenhang mit virtuellem
Speicher und unterbrechbaren (und reentranten) Dateisystemen in einem
Multitaskingsystem große Probleme. Stellen Sie ggf. Ihren Code so um,
daß Sie die <a href="bios_main.html">BIOS</a>-Funktion <a href="xbios_special.html#Supexec">Supexec</a> verwenden können.
<br>&nbsp;
<br>Für MiNT gilt:
<br>If you are in SECURELEVEL &gt; 1, you must have root privileges to
get into supervisor mode. If you don't have them and call Super, the
<a href="gemdos_signals.html#SIGSYS">SIGSYS</a> signal (12) will be raised.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Sollte der Zustand ermittelt werden, erhält man als Resultat 0
für den User- und -1 für den Supervisor-Modus. Ansonsten liefert die
Funktion als Ergebnis die Adresse des alten Supervisor-Stacks, sofern
in den Supervisor-Modus umgeschaltet wurde.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle GEMDOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Super">Binding</a> &nbsp; <a href="xbios_special.html#Supexec">Supexec</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Super">5.14.10.1 Bindings für Super</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Super">Super</a> ( void *stack );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       stack        ; Offset 2
move.w    #32,-(sp)    ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h4><a name="Hinweis_20zur_20Verwendung_20der_20GEMDOS-Funktion_20Super">5.14.10.2 Hinweis zur Verwendung der GEMDOS-Funktion Super</a></h4>
<p>Die Funktion Super setzt bei der Umschaltung in den
Supervisor-Modus den Super-Stackpointer auf den User-Stack des
Programms. Das kann fatal sein, da das Programm nicht wissen kann, wie
groß ein Super-Stackbereich sein muß. Ein zu kleiner Stack kann zu
Fehlverhalten, Abstürzen o.ä. führen. Der Super-Stack liegt nicht
mehr in einem möglicherweise durch Speicherschutzmechanismen
gesicherten Bereich, kann also durch das Programm zerstört werden.
</p>
<p>Ein Teil des User-Stacks könnte durch virtuelle
Speichermechanismen ausgelagert worden sein. Ein ausgelagerter
Super-Stack bedeutet Prozessorhalt, da der MC-680x0 Prozessor seine
bei Exceptions übliche Sicherung des CPU-Status auf den Super-Stack
nicht mehr durchführen kann und dann absichtlich stehenbleibt. Kein
Anwendungsprogrammierer sollte es sich anmaßen, dem System irgendeine
Beschränkung der Supervisor-Stackgröße aufzuerlegen.
</p>
<p>Querverweis: <a href="gemdos_main.html">GEMDOS</a> &nbsp; <a href="xbios_special.html#Supexec">Supexec</a>
</p>
<h3><a name="Suptime">5.14.11 Suptime</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Suptime« - returns the current uptime and load averages from
the system.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 319 (0x013f)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Suptime ( int32_t *uptime, int32_t *loadaverage );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function returns the current uptime and load averages from
the system.
<br>&nbsp;
<br><i>uptime</i> is a pointer to a LONG value that will be filled
with the current amount of seconds elapsed since last reboot.
<br>&nbsp;
<br><i>loadaverage</i> is a pointer to a three longword array, that
will be filled with the current load averages (for last 1, 5 and 15
minutes).
<br>&nbsp;
<br>The load average value is calculated using the following
formula:
<br>&nbsp;
<br>sum += (new_load - old_load) * LOAD_SCALE;
<br>load_avg = sum / MAX_SIZE;
<br>&nbsp;
<br>where LOAD_SCALE is 2048, MAX_SIZE is the number of 5 second
periods in the specified amount of time (12 for 1 min., 60 for 5 min.
and 180 for 15 min). new_load is the number of currently running
processes, old_load is the number of processes running previous time.
A 'running' process is considered the one which is put onto run or
ready queue.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns <a href="gemdos_errors.html#E_OK">E_OK</a> or a negative <a href="gemdos_main.html">GEMDOS</a> error code otherwise
(actually it may be only <a href="gemdos_errors.html#ENOSYS">ENOSYS</a> if the call is not supported...).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 1.11
exists.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Suptime">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Suptime">5.14.11.1 Bindings für Suptime</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Suptime">Suptime</a> ( int32_t *uptime, int32_t *loadaverage );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       loadaverage  ; Offset 6
pea       uptime       ; Offset 4
move.w    #48,-(sp)    ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $0a(sp),sp   ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Sversion">5.14.12 Sversion</a></h3>
<a name="GEMDOS_2C_20Versionsnummer"></a>
<a name="Versionsnummer_20des_20GEMDOS"></a>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »operating system version« - ermittelt die Nummer der
GEMDOS-Version.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 48
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> uint16_t Sversion ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="gemdos_main.html">GEMDOS</a>-Routine Sversion ermittelt die Versionsnummer des
GEMDOS. Zur Zeit sind folgende Versionen bekannt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Version</td>
<td valign="top"> Erklärung
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.13</td>
<td valign="top"> Findet sich in <a href="tos_main.html">TOS</a> 1.00 und 1.02. Diese Version zeichnet sich
durch etliche Fehler aus, sollte daher nicht mehr benutzt werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.14</td>
<td valign="top"> Nummer des Turbo-DOS, welches für eine kurze Zeit von Atari
mit Festplatten ausgeliefert wurde. Schnell, aber auch sehr unsicher.
Auch KAOS 1.2.x besitzt diese Versionsnummer
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.15</td>
<td valign="top"> Findet sich in <a href="tos_main.html">TOS</a> 1.04 und 1.06. Diese Version ist relativ
schnell und stabil.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.16</td>
<td valign="top"> KAOS 1.4.x
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.17</td>
<td valign="top"> Findet sich in <a href="tos_main.html">TOS</a> 1.62. Der Unterschied zur Version 0.15 liegt
lediglich darin, daß das Patchprogramm POOLFIX3.PRG nicht mehr
benötigt wird.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.19</td>
<td valign="top"> Findet sich in TOS 2.01, 2.05, 2.06, 3.01, 3.05, 3.06. Diese
Version wurde im wesentlichen um Funktionen zur Verwaltung des
Alternate-Memory erweitert, und wird auch von MagiC bis Version 6.10
angezeigt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.20</td>
<td valign="top"> <a href="tos_main.html">TOS</a> 2.06 bis <a href="tos_main.html">TOS</a> 2.95 und <a href="tos_main.html">TOS</a> 3.06 haben die GEMDOS-Version
0.20. Einzige bislang bekannte Änderung: Medien mit nur einer FAT
werden unterstützt.
<br>MagiC 6.20 gibt ebenfalls 0.20 zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.30</td>
<td valign="top"> <a href="tos_main.html">TOS</a> 4.00 bis 4.04, auch MultiTOS 1.00 und 1.08.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.31</td>
<td valign="top"> Milan-<a href="tos_main.html">TOS</a> 4.05. <a href="gemdos_memory.html#Mxalloc">Mxalloc</a>() ignoriert Bit 2 bis 15 von mode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.32</td>
<td valign="top"> Milan-<a href="tos_main.html">TOS</a> 4.08, Release 08.07.1999
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.33</td>
<td valign="top"> Milan-<a href="tos_main.html">TOS</a> 4.08, Release 15.06.2001
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0.40</td>
<td valign="top"> FreeMiNT
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die genannte Versionsnummer, und zwar wie
folgt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Low-Byte :</td>
<td valign="top"> Haupt-Versionsnummer
</td></tr>

<tr><td nowrap="nowrap" valign="top">High-Byte :</td>
<td valign="top"> Neben-Versionsnummer

</td></tr>
</table>

<br>Der Wert wird im BCD Format geliefert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle GEMDOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Sversion">Binding</a> &nbsp; <a href="#Sysconf">Sysconf</a> &nbsp; <a href="tos_vers.html">TOS Liste</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Sversion">5.14.12.1 Bindings für Sversion</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> uint16_t <a href="#Sversion">Sversion</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #48,-(sp)    ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Syield">5.14.13 Syield</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Syield« - CPU für andere Prozesse freigeben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 255
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Syield ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Durch den Aufruf dieser Funktion, gibt ein Prozeß die CPU ab,
so daß anderen Prozessen diese (möglicherweise früher als geplant)
zugeteilt werden kann.
<br>&nbsp;
<br><b>Hinweis:</b> Unter MagiC ruft diese Funktion direkt die
AES-Routine <a href="appl.html#appl_yield">appl_yield</a> auf, und wird im Auto-Ordner ignoriert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Sie steht in MagiC ab Version 3.0 und wenn der MiNT Cookie
vorhanden ist zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Syield">Binding</a> &nbsp; <a href="gemdos_process.html#Pause">Pause</a> &nbsp; <a href="gemdos_file.html#Fselect">Fselect</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Syield">5.14.13.1 Bindings für Syield</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Syield">Syield</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #255,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Sync">5.14.14 Sync</a></h3>
<a name="Ssync"></a>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Sync« - synchronisiert alle gemounteten Dateisysteme.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 336 (0x0150)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Sync ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion synchronisiert alle gemounteten Dateisysteme.
<br>&nbsp;
<br><b>Achtung:</b> In <a href="magic.html">MagiC</a> wird diese Funktion mit Ssync
bezeichnet.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> <a href="magic.html">MagiC</a> ab Version 4.01 und seit der ersten in MultiTOS
integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Sync">Binding</a> &nbsp; <a href="#Shutdown">Shutdown</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Sync">5.14.14.1 Bindings für Sync</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Sync">Sync</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #336,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Sysconf">5.14.15 Sysconf</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Sysconf« - Informationen über die Konfiguration des
Betriebssystems ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 290
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Sysconf ( int16_t n );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert Informationen über die Möglichkeiten
(bzw. die Konfiguration) des Betriebssystems. Über den Parameter
<i>n</i> lassen sich die verschiedenen Werte abfragen:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">n</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> max. legaler Wert für n selbst.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top"> max. Wert von Speicherbereichen pro Prozeß.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top"> max. Länge der Kommandozeile für <a href="gemdos_process.html#Pexec">Pexec</a>.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;2</td>
<td valign="top"> max. Anzahl offener Dateien pro Prozess.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;3</td>
<td valign="top"> max. Anzahl der Supplementary-Groups pro Prozess.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;4</td>
<td valign="top"> max. Anzahl der Prozesse je Benutzer.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;5</td>
<td valign="top"> HZ (CLK_TCK).
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;6</td>
<td valign="top"> Größe einer Speicherseite.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;7</td>
<td valign="top"> verfügbare physikalische Seiten.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;8</td>
<td valign="top"> Größe des Passwort-Puffers.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;9</td>
<td valign="top"> Größe des Gruppe-Puffers.

</td></tr>
</table>

<br>Ein Rückgabewert von 0x7fffffff (2^31 - 1) bedeutet, daß der
entsprechende Wert unbegrenzt ist.
<br>Achtung: <a href="magic.html">MagiC</a> gibt -1 für unbegrenzte Werte zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die durch den Parameter <i>n</i>
spezifizierte Information zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Systemfunktionen">Systemfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Sysconf">Binding</a> &nbsp; <a href="gemdos_directory.html#Dpathconf">Dpathconf</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Sysconf">5.14.15.1 Bindings für Sysconf</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Sysconf">Sysconf</a> ( int16_t n );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    n,-(sp)      ; Offset 2
move.w    #290,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="gemdos_main.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
<a name="UDO_nav_lf_FOOT" href="gemdos_network.html"><img src="udo_lf.gif" alt="Netzwerkfunktionen" title="Netzwerkfunktionen" border="0" width="24" height="24">Netzwerkfunktionen</a>
<a name="UDO_nav_rg_FOOT" href="gemdos_directory.html"><img src="udo_rg.gif" alt="Verzeichnisfunktionen" title="Verzeichnisfunktionen" border="0" width="24" height="24">Verzeichnisfunktionen</a>
</body>
</html>
