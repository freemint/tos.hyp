<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 02.08.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Prozessfunktionen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="gemdos_main.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
<a name="UDO_nav_lf_HEAD" href="gemdos_datetime.html"><img src="udo_lf.gif" alt="Datum und Uhrzeit" title="Datum und Uhrzeit" border="0" width="24" height="24">Datum und Uhrzeit</a>
<a name="UDO_nav_rg_HEAD" href="gemdos_memory.html"><img src="udo_rg.gif" alt="Speicherverwaltung" title="Speicherverwaltung" border="0" width="24" height="24">Speicherverwaltung</a>

<hr>

<h1><a name="Prozessfunktionen">5.11 Prozessfunktionen</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pause">Pause</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Prozess bis zum Eintreffen eines Signales suspendieren.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pdomain">Pdomain</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Prozess-Umgebung setzen bzw. erfragen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pexec">Pexec</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Weiteres Programm laden und ausführen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pfork">Pfork</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Kopie des aktuellen Prozesses erzeugen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetauid">Pgetauid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> User-ID eines Prozesses zu Beginn ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetegid">Pgetegid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Effektive Gruppen-ID eines Prozesses ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgeteuid">Pgeteuid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Effektive User-ID eines Prozesses ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetgid">Pgetgid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gruppen-ID eines Prozesses ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetgroups">Pgetgroups</a>&nbsp;&nbsp;</td>
<td valign="top"> gets the supplementary group ids for the calling process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetpgrp">Pgetpgrp</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Aktuelle Prozess-Gruppennummer erfragen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetpid">Pgetpid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Aktuelle Prozess-ID erfragen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetppid">Pgetppid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Prozess-ID für Vater-Prozess erfragen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetpriority">Pgetpriority</a></td>
<td valign="top"> gets the current priority value for a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetuid">Pgetuid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> User-ID eines Prozesses ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pkill">Pkill</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Signal zu einem Prozess schicken.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pmsg">Pmsg</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Nachrichten senden und empfangen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pnice">Pnice</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Priorität des aktuellen Prozesses verändern.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Prenice">Prenice</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Priorität eines Prozesses verändern.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Prusage">Prusage</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Informationen über Resourcenverbrauch ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psemaphore">Psemaphore</a>&nbsp;&nbsp;</td>
<td valign="top"> Erzeugen, anwenden, zerstören einer <a href="powerdos.html#Semaphore">Semaphore</a>.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetauid">Psetauid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> User-ID eines Prozesses zu Beginn setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetegid">Psetegid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Effektive Gruppen-ID eines Prozesses setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pseteuid">Pseteuid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Effektive User-ID eines Prozesses setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetgid">Psetgid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gruppen-ID eines Prozesses verändern.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetgroups">Psetgroups</a>&nbsp;&nbsp;</td>
<td valign="top"> sets the supplementary group ids for the calling process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetlimit">Psetlimit</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Limits der Systemresourcen setzen/erfragen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetpgrp">Psetpgrp</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Prozess-Gruppennummer eines Prozesses setzen/erfragen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetpriority">Psetpriority</a></td>
<td valign="top"> sets the current priority value for a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetregid">Psetregid</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> sets the real and/or effective group id for the calling
process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetreuid">Psetreuid</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> sets the real and/or effective user id for the calling process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetuid">Psetuid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> User-ID eines Prozesses verändern.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigaction">Psigaction</a>&nbsp;&nbsp;</td>
<td valign="top"> Art der Signalbehandlung verändern.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigblock">Psigblock</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Signalmaske verändern.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigintr">Psigintr</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Assigns a signal to a particular exception vector.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psignal">Psignal</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Art der Signalbehandlung verändern.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigpause">Psigpause</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Signalmaske setzen und Prozess bis zum Eintreffen eines Signals
suspendieren.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigpending">Psigpending</a>&nbsp;</td>
<td valign="top"> Kontrollieren von abgeschickten Signalen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigreturn">Psigreturn</a>&nbsp;&nbsp;</td>
<td valign="top"> Verlassen eines Signal-Handlers.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigsetmask">Psigsetmask</a>&nbsp;</td>
<td valign="top"> Signalmaske ersetzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psysctl">Psysctl</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets or sets system information.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pterm">Pterm</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Programm beenden und Wert an Aufrufer zurückgeben.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pterm0">Pterm0</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Programm beenden und 0 an Aufrufer zurückgeben.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Ptermres">Ptermres</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Programm beenden, aber im Speicher behalten.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Ptrace">Ptrace</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Process tracing and debugging.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pumask">Pumask</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Erstellungsmaske für Dateien/Verzeichnisse setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pusrval">Pusrval</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Spezifische Informationen eines Prozesses setzen/erfragen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pvfork">Pvfork</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Kopie des aktuellen Prozesses erstellen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pwait">Pwait</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Auf Childprozess warten, Exitcode ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pwait3">Pwait3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Exitcode eines Childprozess ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pwaitpid">Pwaitpid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Exitcode eines oder mehrerer Childs ermitteln.

</td></tr>
</table>

<p>Querverweis: <a href="gemdos_memory.html">Speicherverwaltung</a> &nbsp; <a href="gemdos_signals.html">Signale</a> &nbsp; <a href="magic_taskmanager.html">Task-Manager</a>
</p>
<h3><a name="Pause">5.11.1 Pause</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pause« - Prozess bis zum Eintreffen eines Signals
suspendieren.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 289
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Pause ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion suspendiert den aufrufenden Prozeß, bis ein
Signal für diesen eintrifft. Wenn für dieses Signal ein
Signal-Handler mittels <a href="#Psignal">Psignal</a> installiert worden ist, wird der
Handler aufgerufen, bevor die Funktion Pause zurückkehrt.
<br>&nbsp;
<br>Die Funktion wird nicht zurückkehren, wenn der Signal-Handler
einen nicht lokalen Sprung (per longjump) ausführt, oder das Programm
beendet wird.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion hat kein direktes Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
<a href="magic.html">MagiC</a> ab Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pause">Binding</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="#Psigpause">Psigpause</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp;
<a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pause">5.11.1.1 Bindings für Pause</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Pause">Pause</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #289,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pdomain">5.11.2 Pdomain</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pdomain« - Prozessumgebung setzen bzw. erfragen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 281
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pdomain ( int16_t dom );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion dient dem Setzen bzw. Abfragen der Umgebung, in
der der Prozeß ausgeführt wird. Diese Umgebung beeinflußt das
Verhalten des Prozesses zum Teil drastisch. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">dom</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> aktuell gültige Domain erfragen.
<a name="TOS-Domain"></a>
<a name="Domain_2C_20TOS-"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top"> <b>TOS-Domain</b> (Default-Wert). In dieser Umgebung verhalten
sich alle Systemaufrufe exakt genauso wie unter dem normalen <a href="tos_main.html">TOS</a>.
<a name="MiNT-Domain"></a>
<a name="Domain_2C_20MiNT-"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top"> <b>MiNT-Domain</b>. In dieser Umgebung wird das Verhalten von
<a href="gemdos_file.html#Fread">Fread</a> und <a href="gemdos_file.html#Fwrite">Fwrite</a> durch die von <a href="gemdos_file.html#Fcntl">Fcntl</a> eingestellten Parameter
beeinflußt, wenn diese auf ein Terminal angewendet werden. Außerdem
werden Dateinamen die per <a href="gemdos_file.html#Fsfirst">Fsfirst</a> bzw. <a href="gemdos_file.html#Fsnext">Fsnext</a> geliefert werden, anders
behandelt.

</td></tr>
</table>

<br><b>Hinweis:</b> MiNT-kompatible Prozesse sollten auch mit
Dateien umgehen können, die <i>nicht</i> der Standard DOS-Konvention
(8+3 Zeichen) entsprechen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die Umgebung des Prozesses zurück, die
beim Funktionsaufruf gültig war.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
<a href="magic.html">MagiC</a> ab Version 4.0 (05.11.1995).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pdomain">Binding</a> &nbsp; <a href="gemdos_directory.html#Dpathconf">Dpathconf</a> &nbsp; <a href="gemdos_directory.html#Dopendir">Dopendir</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pdomain">5.11.2.1 Bindings für Pdomain</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pdomain">Pdomain</a> ( int16_t dom );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    dom,-(sp)    ; Offset 2
move.w    #281,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pexec">5.11.3 Pexec</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »program execution« - Programm laden und ausführen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 75
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pexec ( uint16_t mode, ... );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion lädt und startet ein Programm. Über den
Parameter <i>mode</i> lassen sich verschiedene Varianten auswählen:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> Bedeutung
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> int32_t Pexec (0, int8_t *name, int8_t *cmdline, int8_t *env);
<br>&nbsp;
<br><b>Load and go:</b> Lädt und startet das in <i>name</i>
angegebene Programm, und übergibt die Kommandozeile <i>cmdline</i>.
Für den Parameter <i>env</i> gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> = kein Environment anlegen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">NULL</td>
<td valign="top"> = Environment des Parent vererben.

</td></tr>
</table>

<br>Jeder andere Wert ist ein Zeiger auf das zu vererbene
Environment.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top"> PD *Pexec (3, int8_t* name, int8_t *cmdline, int8_t *env);
<br>
<br>&nbsp;
<br><b>Load, don't go:</b> wird meist zum Starten von Overlays oder
zum Laden von Programmen in einem Debugger benutzt. Entspricht
<i>mode</i> 0, mit dem Unterschied, daß das Programm nicht sofort
gestartet wird, sondern ein Zeiger auf die Basepage als LONG
zurückgeliefert wird. Der Parent ist der Eigentümer des Speichers,
den die Basepage und das Environment des Childs belegen und muß ihn
freigeben, wenn das Child sich beendet hat.
<br><b>Achtung:</b> Der Aufrufer ist dafür verantwortlich, Daten-
und Instruktions-caches ungültig zu machen, auch für den Fall, daß
das Overlay anschliessend mit Pexec Mode 4 ausgeführt werden soll.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">4</td>
<td valign="top"> int32_t Pexec (4, 0L, <a href="gemdos_structures.html#PD">PD</a> *basepage, 0L);
<br>
<br>&nbsp;
<br><b>Just go:</b> startet ein bereits geladenes Programm. Die
Basepage sollte mit mode 3 oder 5 erzeugt worden sein.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">5</td>
<td valign="top"> PD *Pexec (5, 0L, int8_t *cmdline, int8_t *env);
<br>
<br>&nbsp;
<br><b>Create Basepage:</b> Zunächst legt <a href="gemdos_main.html">GEMDOS</a> ein neues
Environment an. Dann wird der größte zusammenhängende Speicherblock
alloziert und in den ersten 256 Byte eine Basepage angelegt. Für den
Parameter <i>env</i> gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> = kein Environment anlegen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">NULL</td>
<td valign="top"> = Environment des Parent vererben.

</td></tr>
</table>

<br>Jeder andere Wert ist ein Zeiger auf das zu vererbende
Environment.
<br>&nbsp;
<br>Unter MiNT kann dieser Mode zusammen mit <i>mode 3</i> dazu
benutzt werden, einen Aufruf von <a href="#Pvfork">Pvfork</a> ohne Blockieren des parent zu
emulieren.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">6</td>
<td valign="top"> int32_t Pexec (6, 0L, <a href="gemdos_structures.html#PD">PD</a> *basepage, 0L);
<br>
<br>&nbsp;
<br><b>Just go, then free:</b> Entspricht <i>mode</i> 4, mit dem
Unterschied, daß allozierter Speicher dem gestarteten Prozess und
nicht dem Starter gehört, so daß der Speicher, den die Basepage
belegt, automatisch freigegeben wird, wenn das Child mit <a href="#Pterm">Pterm</a>
terminiert. Zusammen mit Modus 3 kann damit der gleiche Effekt erzielt
werden, wie durch Modus 0. Dieser Modus steht erst ab GEMDOS-Version
0.15 zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">7</td>
<td valign="top"> <a href="gemdos_structures.html#PD">PD</a> *Pexec (7, uint32_t prgflags, int8_t *cmdline, int8_t *env);
<br>&nbsp;
<br><b>Create Basepage, respecting prgflags:</b> Analog
<i>mode</i> 5, nur kann in <i>prgflags</i> die gleiche Information
wie im Feld <a href="gemdos_programs.html#ph_prgflags">ph_prgflags</a> des Programm-Headers übergeben werden. Dieser
Modus wird vom <a href="bios_main.html">BIOS</a> des TT benutzt, um <a href="gem_about.html">GEM</a> zu starten, und steht erst
ab <a href="gemdos_main.html">GEMDOS</a> Version 0.19 zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">100</td>
<td valign="top"> int32_t Pexec (100, int8_t *name, int8_t *cmdline, int8_t
*env);
<br>&nbsp;
<br><b>Load, go, don't wait:</b> Analog <i>mode</i> 0, nur wartet
der Aufrufer nicht, bis das gestartete Programm beendet wird, d.h. die
Funktion kehrt sofort zum Parent Prozess zurück, während das Child
startet. Der Rückgabewert ist ein negativer Fehlercode oder die
positive PID des Childs.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">101</td>
<td valign="top"> da dieser Modus nur <a href="magic.html">MagiC</a>-intern zum Vererben von Pfad- und
Dateihandles benutzt wird, wird auf die Angabe der genauen Syntax an
dieser Stelle verzichtet.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">102</td>
<td valign="top"> wird MagiC-intern verwendet, um einen bestimmten Prozess zu
entfernen. Auf die genaue Syntax wird daher an dieser Stelle
verzichtet.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">104</td>
<td valign="top"> int32_t Pexec (104, int8_t *name, <a href="gemdos_structures.html#PD">PD</a> *basepage, 0L);
<br>
<br>&nbsp;
<br><b>Just go, don't wait:</b> Analog <i>mode</i> 4, nur wartet
der Aufrufer nicht, bis das gestartete Programm beendet wird. Es wird
ein Prozess gestartet, dessen Basepage vorher durch einen Modus von 3,
5 oder 7 gesetzt wurde. Zu beachten ist, daß das Environment und die
Basepage des Childs sich auch im Besitz des Parents befinden
(tatsächlich erbt der Child allen Speicher, der sich im Besitz des
Parents befindet). Der Parameter <i>name</i> ist ein Zeiger auf einen
String, der den Namen des neuen Prozesses beschreibt; bei einem
NULL-Wert wird der Name des Parent-Prozesses benutzt. Die Funktion
liefert einen negativen Fehlercode, oder die positive PID des Childs
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">106</td>
<td valign="top"> int32_t Pexec (106, int8_t *name, <a href="gemdos_structures.html#PD">PD</a> *basepage, 0L);
<br>
<br>&nbsp;
<br><b>Just go, don't wait, no sharing:</b> Analog <i>mode</i>
104, allerdings befinden sich Environment und Basepage des Childs
<i>nicht</i> im Besitz des Parents, und der Child hat keinen Zugriff
auf Speicher, welcher dem Parent-Prozess zugeteilt wurde. Beim Beenden
des Childs wird dessen Speicherplatz wieder freigegeben. In Verbindung
mit Modus 3 entspricht Pexec (106, ...) daher dem Modus 100 (während
Modus 3 gefolgt von Modus 6 einem Aufruf von Pexec (0, ...)
entspricht).
<br>Wird ab <a href="magic.html">MagiC</a> 2.0 nicht mehr unterstützt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">107</td>
<td valign="top"> entspricht im wesentlichen <i>mode</i> 7, und wird intern von
<a href="magic.html">MagiC</a> seit Version 2.10 verwendet. Auf die genaue Syntax wird daher an
dieser Stelle verzichtet.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">108</td>
<td valign="top"> wird von MagiC seit Version 2.10 intern zum Starten eines
<a href="aes_fundamentals.html#Accessories">Accessories</a> verwendet. Da die genaue Syntax offiziell nicht
dokumentiert ist, sollten eigene Programme besser auf <a href="shel.html#shel_write">shel_write</a>
zurückgreifen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">200</td>
<td valign="top"> int32_t Pexec (200, int8_t *name, int8_t *cmdline, int8_t
*env);
<br>&nbsp;
<br><b>Replace program and go:</b> Analog <i>mode</i> 100, jedoch
überschreibt der neue Prozess den alten vollständig. Der alte
Prozess behält zwar seine PID und die meisten seiner Attribute, aber
sein gesamter Speicherplatz wird freigegeben. Während Pexec (0, ...)
als Unterprogrammaufruf (call...return) angesehen werden kann, wirkt
dieser Modus eher wie ein 'goto'.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">300</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">301</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">401</td>
<td valign="top"> da diese Modus nur <a href="magic.html">MagiC</a>-intern, wird auf die Angabe der
genauen Syntax an dieser Stelle verzichtet.
<br>&nbsp;

</td></tr>
</table>

<br><b>Hinweis:</b> Nicht alle Modi sind unter allen
Betriebssystemvarianten verfügbar; deshalb sollte der Rückgabewert
der Funktion beachtet werden. Unbekannte Modi sorgen für ein
Funktionsergebnis von <a href="gemdos_errors.html#EINVFN">EINVFN</a>.
<br>&nbsp;
<br>Kommandozeilen werden als String im <i>Pascal-Format</i>
übergeben, d.h. im ersten Byte befindet sich die Länge der Zeile
(maximal 124 Zeichen).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis den Abschlußcode des
Child-Prozesses. Wenn ein Overlay geladen wurde, enthält das Ergebnis
die Basepage des Overlays. Bei einem negativen Resultat ist ein Fehler
aufgetreten.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle <a href="gemdos_main.html">GEMDOS</a> Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pexec">Binding</a> &nbsp; <a href="shel.html#shel_write">shel_write</a> &nbsp; <a href="gemdos_programs.html#Die_20Programmflags">Programmflags</a> &nbsp; <a href="gemdos_argv.html">ARGV-Verfahren</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pexec">5.11.3.1 Bindings für Pexec</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pexec">Pexec</a> ( uint16_t mode, ... );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       env          ; Offset 12
pea       cmdline      ; Offset  8
pea       name         ; Offset  4
move.w    mode,-(sp)   ; Offset  2
move.w    #75,-(sp)    ; Offset  0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $10(sp),sp   ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top"> Adresse%=Gemdos(&amp;H4B,W:mode%,L:name%,L:cmdline%,L:env)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Pfork">5.11.4 Pfork</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pfork« - Kopie des aktuellen Prozesses erzeugen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 283
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pfork ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion erzeugt eine Kopie des aktuellen Prozesses. Der
Child-Prozeß erbt dabei eine Kopie des Adreßraums des
Parent-Prozesses, d.h. Änderungen, die der Child an Variablen macht,
haben keinen Einfluß auf den Parent.
<br>&nbsp;
<br>Der neu erzeugte Prozeß beginnt seine Arbeit, wenn die Funktion
Pfork zurückkehrt.
<br>&nbsp;
<br>Wenn der Parent im Supervisor-Modus ist, wenn diese Funktion
aufgerufen wird, wird das Child dennoch im User-Modus gestartet.
<br>&nbsp;
<br>Ein neuer Prozess, der mit dieser Funktion gestartet wird, darf
nicht <a href="gemdos_memory.html#Mshrink">Mshrink</a> aufrufen, muß aber jede GEM Initialisierung wie
<a href="appl.html#appl_init">appl_init</a> und v_openvwk erneut ausführen (wenn er GEM benötigt).
Parent und Child müssen beide <a href="#Pterm">Pterm</a> oder <a href="#Pterm0">Pterm0</a> aufrufen, um sich zu
beenden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> im Child-Prozeß.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> neue Prozess-ID im Parent-Prozeß.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENSMEM">ENSMEM</a>:</td>
<td valign="top"> nicht genug Speicher vorhanden, um den neuen Prozeß zu
erzeugen.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pfork">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pvfork">Pvfork</a> &nbsp; <a href="magic_threads.html">Threads</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pfork">5.11.4.1 Bindings für Pfork</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pfork">Pfork</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #283,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetauid">5.11.5 Pgetauid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetauid« - User ID eines Prozesses zu Beginn ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 325 (0x0145)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pgetauid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ermittelt die Anfangs-User-ID des aktuellen
Prozesses. Zusammen mit <a href="#Psetauid">Psetauid</a> kann damit in einer Multiuserumgebung
festgestellt werden, wer der zuerst eingeloggte Benutzer war.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Der Rückgabewert ist die Anfangs-User-ID des Prozesses.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> ab MiNT 1.11
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetauid">Binding</a> &nbsp; <a href="#Psetauid">Psetauid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetauid">5.11.5.1 Bindings für Pgetauid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetauid">Pgetauid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #325,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetegid">5.11.6 Pgetegid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetegid« - effektive Gruppen-ID eines Prozesses ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 313
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pgetegid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert die effektive Gruppen-ID des aktuellen
Prozesses und ähnelt dem Systemaufruf <a href="#Pgetgid">Pgetgid</a>. Der Unterschied
besteht darin, daß hier die effektive Gruppen-ID zurückgegeben wird.
<br>&nbsp;
<br>Diese ist normalerweise mit der wirklichen Gruppen-ID identisch;
falls aber ein Programm läuft, welches das setgid Bit gesetzt hat,
ist seine effektive Gruppen-ID gleich der (wirklichen) ID des
Besitzers dieser Programmdatei.
<br>&nbsp;
<br>Dateizugriff basiert u.a. auf der effektiven Gruppen-ID, so daß
der setgid-Mechanismus es Benutzern (vor allem dem <a href="gemdos_system.html#Super">Super</a>-User)
erlaubt, anderen Usern Zugriff zu erlauben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Der Rückgabewert ist die effektive Gruppen-ID des Prozesses.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.95 existiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetegid">Binding</a> &nbsp; <a href="#Pgetuid">Pgetuid</a> &nbsp; <a href="#Pgetgid">Pgetgid</a> &nbsp; <a href="#Pgeteuid">Pgeteuid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetegid">5.11.6.1 Bindings für Pgetegid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pgetegid">Pgetegid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #313,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgeteuid">5.11.7 Pgeteuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgeteuid« - effektive User-ID eines Prozesses ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 312
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pgeteuid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert die effektive User-ID des aktuellen
Prozesses und ähnelt dem Systemaufruf <a href="#Pgetuid">Pgetuid</a>. Der Unterschied
besteht darin, daß hier die effektive User-ID zurückgegeben wird.
<br>&nbsp;
<br>Diese ist normalerweise mit der wirklichen User-ID identisch;
falls aber ein Programm läuft, welches das setuid Bit gesetzt hat,
ist seine effektive User-ID gleich der (wirklichen) ID des Besitzers
dieser Programmdatei.
<br>&nbsp;
<br>Dateizugriff basiert u.a. auf der effektiven User-ID, so daß
der setuid-Mechanismus es Benutzern (vor allem dem <a href="gemdos_system.html#Super">Super</a>-User)
erlaubt, anderen Usern Zugriff zu erlauben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Der Rückgabewert ist die effektive User-ID des Prozesses.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.95 existiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgeteuid">Binding</a> &nbsp; <a href="#Pgetuid">Pgetuid</a> &nbsp; <a href="#Pgetgid">Pgetgid</a> &nbsp; <a href="#Pgetegid">Pgetegid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgeteuid">5.11.7.1 Bindings für Pgeteuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pgeteuid">Pgeteuid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #312,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetgid">5.11.8 Pgetgid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetgid« - Gruppen ID eines Prozesses ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 276
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pgetgid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert die wirkliche Gruppen-ID des aktuellen
Prozesses zurück. Dies ist eine Zahl zwischen 0 und 255, die die
Rechte der Prozessgruppe festlegt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Der Rückgabewert ist die wirkliche Gruppen-ID des Prozesses.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetgid">Binding</a> &nbsp; <a href="#Pgetuid">Pgetuid</a> &nbsp; <a href="#Pgeteuid">Pgeteuid</a> &nbsp; <a href="#Pgetegid">Pgetegid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetgid">5.11.8.1 Bindings für Pgetgid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetgid">Pgetgid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #276,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetgroups">5.11.9 Pgetgroups</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetgroups« - gets the supplementary group ids for the
calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 327 (0x0147)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pgetgroups( int16_t len, int16_t *gidset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function gets the supplementary group ids for the calling
process.
<br>&nbsp;
<br><i>len</i> specifies the length (in words) of the array to be
filled with the supplementary group ids available. This value must be
a positive number not greater than NGROUPS_MAX. If <i>len</i> is a
zero, the call will return the number of supplementary group ids
currently available for the calling process.
<br>&nbsp;
<br><i>gidset</i> is a pointer to a word array to be filled with
retrieved ids.
<br>&nbsp;
<br>The NGROUPS_MAX value is returned by <a href="gemdos_system.html#Sysconf">Sysconf</a>().
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns a number of supplementary group ids for the process on
success or a negative <a href="gemdos_main.html">GEMDOS</a> error code otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Sie steht ab MiNT 1.11 zu Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetgroups">Binding</a> &nbsp; <a href="#Psetgroups">Psetgroups</a> &nbsp; <a href="gemdos_system.html#Sysconf">Sysconf</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetgroups">5.11.9.1 Bindings für Pgetgroups</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pgetgroups">Pgetgroups</a>( int16_t len, int16_t *gidset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       gidset       ; Offset 4
move.w    len,-(sp)    ; Offset 2
move.w    #327,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetpgrp">5.11.10 Pgetpgrp</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetpgrp« - aktuelle Prozess Gruppennummer erfragen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 269
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pgetpgrp ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Es wird die Gruppen-Nummer des aktuell aktiven Prozesses
zurück geliefert. Prozessgruppen werden gewöhnlich für Job-Control
und andere Zwecke benutzt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Prozeß-Gruppen-Nummer des aktiven Prozesses.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetpgrp">Bindings für Pgetpgrp</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Pgetpid">Pgetpid</a> &nbsp; <a href="#Psetpgrp">Psetpgrp</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetpgrp">5.11.10.1 Bindings für Pgetpgrp</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetpgrp">Pgetpgrp</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #269,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetpid">5.11.11 Pgetpid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetpid« - aktuelle Prozess ID erfragen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 267 (0x010b)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pgetpid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert die PID des aktuell aktiven Prozesses,
also desjenigen, der momentan die CPU besitzt; es handelt sich dabei
um den Dateityp, unter dem der aktuelle Prozess im Verzeichnis U:\PROC
geführt wird.
<br>&nbsp;
<br>A PID is dynamically assigned to a process when it is created.
You should make no assumption on the PID a process may have. For the
kernel, the PID is a WORD but when you program in C, you should use
the pid_t type, which complies with the POSIX standard. The FreeMiNT
kernel's PID is always 0.
<br>&nbsp;
<br>The PID is useful when it is important to identify a process
among others in the system. Knowing the PID of a program, it is
possible to do a lot of things: send it a signal with <a href="#Psignal">Psignal</a>(), look
for its name in /proc by searching with a &quot;*.xxx&quot; mask (xxx
is the PID of the program which name we wanna know), etc.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> PID des aktiven Prozesses.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Sie steht in MagiC ab Version 3.0 und unter MiNT zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetpid">Binding</a> &nbsp; <a href="#Pgetpgrp">Pgetpgrp</a> &nbsp; <a href="#Pgetppid">Pgetppid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetpid">5.11.11.1 Bindings für Pgetpid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetpid">Pgetpid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #267,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetppid">5.11.12 Pgetppid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetppid« - Prozess ID für Vater Prozess erfragen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 268 (0x010c)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pgetppid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert die PID des Parent-Prozesses, des z.Zt.
aktiven Prozesses.
<br>&nbsp;
<br>In the FreeMiNT kernel, processes are represented as a tree. The
root of the tree is the kernel itself (PID 0). At boot time, the
kernel launches another process (which can be 'init' in case of a
Unix-like setup, or an <a href="aes_main.html">AES</a>, a shell or whatever) specified by the INIT
or <a href="gem_about.html">GEM</a> keyword in the mint.cnf file. This process will launch other
processes (daemons, accessories, programs etc) that are its so-called
children.
<br>&nbsp;
<br>Therefore, every process (but the kernel, obviously) is created
by its so-called parent. The Pgetppid() (get parent's PID) call allows
to determine the PID of the parent of the calling process. To have a
good illustration of this, you can use the 'ps' command in your shell.
You will see that all accessories's parent is the AES, and that the
daemons are started by the 'init' program.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Prozess-ID des Parent (positiv). Wenn der aktuelle Prozess
direkt vom Kernel gestartet wurde, wird 0 zurück geliefert. Ein
Rückgabewert von -1 signalisiert, daß der Prozess keinen Parent
besitzt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
MagiC ab Version 3.0.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetppid">Binding</a> &nbsp; <a href="#Pgetpgrp">Pgetpgrp</a> &nbsp; <a href="#Pgetpid">Pgetpid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetppid">5.11.12.1 Bindings für Pgetppid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetppid">Pgetppid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #268,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetpriority">5.11.13 Pgetpriority</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetpriority« - gets the current priority value for a
process
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 344 (0x0158)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pgetpriority ( int16_t which, int16_t who);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function gets the priority of the processes specified by
<i>which</i> and <i>who</i>. The interpretation of parameter
<i>who</i> depends on <i>which</i>:
<br>&nbsp;
<a name="PRIO_PROCESS"></a>
<br>PRIO_PROCESS (0) reads the priority of process with process id
<i>who</i>. A <i>who</i> of 0 implies the process id of the calling
process.
<br>&nbsp;
<a name="PRIO_PGRP"></a>
<br>PRIO_PGRP (1) reads the priority of the process group with
process group id <i>who</i>. If the priorities of the process differ,
the lowest valued priority (i. e. the highest CPU usage priority) is
returned. A <i>who</i> of 0 implies the process group id of the
calling process.
<br>&nbsp;
<a name="PRIO_USER"></a>
<br>PRIO_USER (2) reads the priority of the process of the user with
user id <i>who</i>. For multiple processes the lowest valued priority
is returned. A <i>who</i> of 0 implies the user id of the calling
process.
<br>&nbsp;
<br>Library functions should first check for an error condition and
then decrement the returned value by 20.
<br>&nbsp;
<br>This call makes calls <a href="#Pnice">Pnice</a> and <a href="#Prenice">Prenice</a> obsolete.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="VT_52_terminal.html#Return">Return</a> value is either a negative error number in case of
failure or the requested priority + 20 on success.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> MiNT 1.15.0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetpriority">Binding</a> &nbsp; <a href="#Psetpriority">Psetpriority</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetpriority">5.11.13.1 Bindings für Pgetpriority</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pgetpriority">Pgetpriority</a> ( int16_t which, int16_t who);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    who,-(sp)    ; Offset 4
move.w    which,-(sp)  ; Offset 2
move.w    #344,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pgetuid">5.11.14 Pgetuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetuid« - User ID eines Prozesses ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 271
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pgetuid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert die wirkliche User-ID des aktuellen
Prozesses zurück. Dies ist eine Zahl zwischen 0 und 255, die die
Zugriffsrechte des Prozesses festlegt und benutzt werden kann, um in
Multi-User-Systemen die einzelnen Benutzer zu unterscheiden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Der Rückgabewert ist die tatsächliche User-ID des Prozesses.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pgetuid">Binding</a> &nbsp; <a href="#Pgetgid">Pgetgid</a> &nbsp; <a href="#Pgeteuid">Pgeteuid</a> &nbsp; <a href="#Pgetegid">Pgetegid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pgetuid">5.11.14.1 Bindings für Pgetuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetuid">Pgetuid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #271,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pkill">5.11.15 Pkill</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pkill« - Signal zu einem Prozess schicken.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 273
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pkill ( int16_t pid, int16_t sig );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion sendet das Signal <i>sig</i> an einen oder
mehrere Prozesse. Für den Parameter <i>pid</i> gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">pid</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">&gt; 0</td>
<td valign="top"> das Signal wird dem Prozess mit der angegebenen <i>pid</i>
geschickt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">= 0</td>
<td valign="top"> das Signal wird an alle Prozesse der entsprechenden
Prozessgruppe geschickt (dazu gehört auch der Aufrufer selbst !).
</td></tr>

<tr><td nowrap="nowrap" valign="top">&lt; 0</td>
<td valign="top"> das Signal wird an alle Prozesse mit der Gruppennummer -pid
geschickt.

</td></tr>
</table>

<br>Das Signal <a href="gemdos_signals.html#SIGNULL">SIGNULL</a> wird von Pkill nicht in der gewohnten Weise
behandelt. Es kann benutzt werden, um die Existenz eines Prozesses zu
testen. Dazu schickt man diesem ein SIGNULL, und kontrolliert, ob Pkill
mit dem Wert 0 zurückkehrt.
<br>&nbsp;
<br>Seit <a href="magic.html">MagiC</a> 6.01 (1998.10.10) werden auch PIDs &lt; 0
unterstützt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> kein Fehler aufgetreten.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> falls <i>pid</i> &gt; 0 und der angegebene Prozess nicht mehr
existiert bzw. falls <i>pid</i> &lt; 0 und die angegebene
Prozeßgruppe keine Mitglieder mehr besitzt.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> falls <i>pid</i> &gt; 0, und der sendende Prozess keine EUID
von 0 besitzt und außerdem die UID des empfangenden von der des
sendenden Prozesses abweicht.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> <i>sig</i> ist kein gültiges Signal.

</td></tr>
</table>

<br><b>Hinweis:</b> Wenn der aktuelle Prozess das Signal selbst
empfängt und terminiert wird, kehrt die Funktion nicht zurück!
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
<a href="magic.html">MagiC</a> ab Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pkill">Binding</a> &nbsp; <a href="#Psetpgrp">Psetpgrp</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pkill">5.11.15.1 Bindings für Pkill</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pkill">Pkill</a> ( int16_t pid, int16_t sig );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    sig,-(sp)    ; Offset 4
move.w    pid,-(sp)    ; Offset 2
move.w    #273,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pmsg">5.11.16 Pmsg</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pmsg« - Empfangen und Senden von <a href="evnt.html#Nachrichten">Nachrichten</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 293
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pmsg ( int16_t mode, int32_t mbox, void *msg );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion sendet bzw. empfängt eine Nachricht zu bzw. von
einer Mailbox. Die jeweils auszuführende Operation kann über die
Bits des Parameters <i>mode</i> festgelegt werden. Es bedeutet:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> Operation
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x0000</td>
<td valign="top"> Blockiert den Prozess bis aus der übergebenen Mailbox mit der
ID <i>mbox</i> eine Nachricht gelesen werden kann und speichert diese
in der Struktur, auf die <i>msg</i> zeigt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x0001</td>
<td valign="top"> Blockiert den Prozess bis ein Prozess auf eine Nachricht aus
der Mailbox mit der ID <i>mbox</i> wartet und diese Nachricht aus der
Struktur, auf die <i>msg</i> zeigt, ausliest.
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x0002</td>
<td valign="top"> Blockiert den Prozess bis ein Prozess auf eine Nachricht aus
der Mailbox mit der ID <i>mbox</i> wartet und diese Nachricht aus der
Struktur, auf die <i>msg</i> zeigt, ausliest und in der Mailbox mit
der Kennung 0xffffxxxx eine Nachricht liegt (dabei ist xxxx die PID
des aktuellen Prozesses).
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x8000</td>
<td valign="top"> Durch eine ODER-Verknüpfung mit diesem Wert kann die Operation
im nicht-blockierenden Modus ausgeführt werden.

</td></tr>
</table>

<br>Die Nachrichten sind 5 Wörter lang, und zwar zwei Langworte und ein
Short (in dieser Reihenfolge). Dabei können die 2 Langwörter vom
Prozess mit beliebiger Information gefüllt werden, während im Short
die PID des Senders einzutragen ist.
<br>&nbsp;
<br>Nach dem die Nachricht verschickt worden ist, enthält dieses
Short die PID des Prozesses, der die Nachricht gelesen hat. Umgekehrt
enthält dieser nach dem Lesen einer Nachricht die PID des Prozesses,
der die Nachricht geschrieben hat.
<br>&nbsp;
<br>Wenn in <i>mode</i> das höchstwertige Bit gesetzt ist, und es
keinen Leser bzw. Schreiber für die Mailbox <i>mbox</i> gibt, wird
der Wert -1 zurückgeliefert. Anderenfalls wartet eine Leseoperation
bis eine Nachricht geschrieben wurde, bzw. eine Schreiboperation bis
ein lesender Prozess bereit ist.
<br>&nbsp;
<br>Im Modus 2 gibt der Schreiber an, daß er auf eine Antwort
warten möchte. Die Idee dabei ist, daß dieser Prozess sich schlafen
legen kann, und zu einem späteren Zeitpunkt von dem Prozess der die
Nachricht erhält, wieder aufgeweckt werden kann. Dabei wird
garantiert, daß der Prozess, welcher die Original-Nachricht erhält
beim Schreiben der Antwort nicht blockiert wird.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a> :</td>
<td valign="top"> kein Fehler aufgetreten.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EINVFN">EINVFN</a> :</td>
<td valign="top"> ungültiger Wert für den Parameter <i>mode</i>.
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1 :</td>
<td valign="top"> Bit-15 ist gesetzt, und Pmsg würde blockieren.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.90 existiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pmsg">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pmsg">5.11.16.1 Bindings für Pmsg</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pmsg">Pmsg</a> ( int16_t mode, int32_t mbox, void *msg );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       msg          ; Offset 8
move.l    mbox,-(sp)   ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #293,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $C(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pnice">5.11.17 Pnice</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pnice« - Priorität des aktuellen Prozesses verändern.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 266
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pnice ( int16_t delta );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ändert die Priorität des aktuellen Prozesses um
den Wert <i>delta</i>. Eine höhere Priorität bedeutet, daß der
Prozess eine größere Zeitscheibe erhält, also nicht so oft
umgeschaltet wird. Analog bedeutet eine niedrige Priorität, daß die
Zeitscheibe des Prozesses verkleinert wird, und er daher öfter die
CPU abgeben muß.
<br>&nbsp;
<br>Für den Parameter <i>delta</i> muß gelten:
<br>- 20 &lt;= delta &lt;= 20.
<br>&nbsp;
<br>Die Funktion Pnice entspricht <a href="#Prenice">Prenice</a> (<a href="#Pgetpid">Pgetpid</a>(), delta) und ist
zur Abwärtskompatibilität implementiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die aktuelle Prozeß Umschalt-Priorität
zurück. Diese ist per Default auf 0 eingestellt. Größere bzw.
kleinere Werte bedeuten, daß der Prozess eine größere bzw. kleinere
Zeitscheibe besitzt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
<a href="magic.html">MagiC</a> ab Version 6.20 (2000-02-02).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pnice">Binding</a> &nbsp; <a href="#Prenice">Prenice</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pnice">5.11.17.1 Bindings für Pnice</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pnice">Pnice</a> ( int16_t delta );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    delta,-(sp)  ; Offset 2
move.w    #266,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Prenice">5.11.18 Prenice</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Prenice« - Priorität eines Prozesses verändern.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 295
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Prenice ( int16_t pid, int16_t delta );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ändert die Priorität des Prozesses mit der
Kennung <i>pid</i> um den Wert <i>delta</i>. Eine höhere Priorität
bedeutet, daß der Prozess eine größere Zeitscheibe erhält, also
nicht so oft umgeschaltet wird. Analog bedeutet eine niedrige
Priorität, daß die Zeitscheibe des Prozesses verkleinert wird, und
er daher öfter die CPU abgeben muß.
<br>&nbsp;
<br>Für den Parameter <i>delta</i> muß gelten:
<br>- 20 &lt;= delta &lt;= 20.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die aktuelle Prozeß Umschalt-Priorität
zurück. Diese ist per Default auf 0 eingestellt. Größere bzw.
kleinere Werte bedeuten, daß der Prozess eine größere bzw. kleinere
Zeitscheibe besitzt.
<br>&nbsp;
<br>Im Fehlerfall liefert die Funktion:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> der angegebene Prozess existiert nicht.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> der angegebene Prozess besitzt eine andere User-ID als der
aufrufende Prozess.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.90 existiert und <a href="magic.html">MagiC</a> ab Version 6.20 (2000-01-02).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Prenice">Bindings für Prenice</a> &nbsp; <a href="#Pnice">Pnice</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Prenice">5.11.18.1 Bindings für Prenice</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Prenice">Prenice</a> ( int16_t pid, int16_t delta );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    delta,-(sp)  ; Offset 4
move.w    pid,-(sp)    ; Offset 2
move.w    #295,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Prusage">5.11.19 Prusage</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Prusage« - Informationen über Resourcenverbrauch ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 286
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Prusage ( int32_t *r );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert Informationen über den Bedarf an
Systemresourcen des aktuellen Prozesses.
<br>&nbsp;
<br>Die Informationen werden im Array <i>r</i> nach außen
gereicht; es gilt folgende Belegung:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">r[0]:</td>
<td valign="top"> Prozess-Zeit im Kernel
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[1]:</td>
<td valign="top"> Prozess-Zeit im eigenen Programmcode
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[2]:</td>
<td valign="top"> Gesamt-Prozesszeit der Childs im Kernel
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[3]:</td>
<td valign="top"> Gesamt-Prozesszeit der Childs im eigenen Programmcode
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[4]:</td>
<td valign="top"> Speicher der diesem Prozess gehört (in Bytes)
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[5]:</td>
<td valign="top"> reserviert
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[6]:</td>
<td valign="top"> reserviert
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[7]:</td>
<td valign="top"> reserviert

</td></tr>
</table>

<br>Alle Zeiten sind in Milli-Sekunden angegeben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion hat kein direktes Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Prusage">Binding</a> &nbsp; <a href="#Psetlimit">Psetlimit</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Prusage">5.11.19.1 Bindings für Prusage</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Prusage">Prusage</a> ( int32_t *r );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       r            ; Offset 2
move.w    #286,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psemaphore">5.11.20 Psemaphore</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psemaphore« - erzeugen, anwenden, zerstören einer
<a href="powerdos.html#Semaphore">Semaphore</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 308
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psemaphore ( int16_t mode, int32_t id, int32_t timeout
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion implementiert nicht-zählende <a href="powerdos.html#Semaphore">Semaphore</a>. Nur ein
Prozess kann einen Semaphor zur gleichen Zeit besitzen.
<br>&nbsp;
<br>Semaphoren können z.B. benutzt werden, um den Zugriff auf
Datenstrukturen im Shared Memory von unterschiedlichen Teilprozessen
zu synchronisieren: So muß ein Teilprozess, bevor er auf den Speicher
zugreift, versuchen, in den Besitzt des Semaphors zu kommen. Dieser
kann z.B. bei der Initialisierung erzeugt, und bei Programmende wieder
entfernt werden.
<br>&nbsp;
<br><a href="powerdos.html#Semaphore">Semaphore</a> werden durch einen Namen identifiziert. Dieser Name
ist ein Langwort, das auch vier ASCII-Zeichen enthalten kann.
<a href="powerdos.html#Semaphore">Semaphore</a>, deren Namen mit dem Unterstrich '_' beginnen sind dabei
für das Betriebssystem reserviert.
<br>&nbsp;
<br><b>Der Parameter <i>timeout</i> wird nur im Modus 2 benutzt.
Es gilt dabei die folgende Belegung:</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">timeout</td>
<td valign="top"> = &nbsp;0: sofort zurückkehren
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> = -1: kein Timeout (Forever).

</td></tr>
</table>

<br>Andere Werte für <i>timeout</i> geben die Wartezeit in
Millisekunden an, bevor ein Timeout eintritt.
<br>&nbsp;
<br><b>Für den Parameter <i>mode</i> sind folgende Werte
möglich:</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> <a href="powerdos.html#Semaphore">Semaphore</a> mit Kennung <i>id</i> erzeugen (und besitzen).
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> <a href="powerdos.html#Semaphore">Semaphore</a> mit Kennung <i>id</i> entfernen. Dies klappt nur,
wenn der Aufrufer die <a href="powerdos.html#Semaphore">Semaphore</a> besitzt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top"> Besitz der <a href="powerdos.html#Semaphore">Semaphore</a> mit Kennung <i>id</i> beantragen. Dies
blockiert den Aufrufer bis die <a href="powerdos.html#Semaphore">Semaphore</a> frei wird, oder ein Timeout
eintritt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top"> <a href="powerdos.html#Semaphore">Semaphore</a> mit Kennung <i>id</i> freigeben. Dies klappt nur,
wenn der Aufrufer die <a href="powerdos.html#Semaphore">Semaphore</a> besitzt.

</td></tr>
</table>

<br><b>Hinweis:</b> Wenn ein Prozess eine <a href="powerdos.html#Semaphore">Semaphore</a> erzeugt,
besitzt er sie auch sofort. Damit andere Prozesse diese nutzen
können, muß sie zunächst freigegeben werden. Da für das Erzeugen
einer Semphore interner Speicher angefordert werden muss, sollte die
Funktion sparsam verwendet werden.
<br>&nbsp;
<br>Wenn ein blockierter Prozess auf eine <a href="powerdos.html#Semaphore">Semaphore</a> wartet (bevor
der Timeout eintritt), und ein anderer Prozess entfernt die <a href="powerdos.html#Semaphore">Semaphore</a>,
dann kehrt die Funktion Psemaphore mit der Meldung <a href="gemdos_errors.html#ERANGE">ERANGE</a> zurück, da
die angeforderte <a href="powerdos.html#Semaphore">Semaphore</a> nicht länger existiert.
<br>&nbsp;
<br>Wenn ein Prozess terminiert, werden alle <a href="powerdos.html#Semaphore">Semaphore</a> die er
besitzt, automatisch freigegeben (aber nicht zerstört). Der Besitz
einer <a href="powerdos.html#Semaphore">Semaphore</a> kann nicht vererbt werden (etwa mit <a href="#Pfork">Pfork</a>). Wenn ein
Prozess eine <a href="powerdos.html#Semaphore">Semaphore</a> erzeugt und dann abstürzt, bleibt die
<a href="powerdos.html#Semaphore">Semaphore</a> erhalten, und kann nicht mehr entfernt werden.
<br>&nbsp;
<br>In <a href="magic.html">MagiC</a> sorgen Plausibilitätsüberprüfungen dafür, daß
keine System-Semaphoren freigegeben werden können; außerdem werden
z.Zt. nur die Modi 2 und 3 unterstützt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> kein Fehler aufgetreten.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="bios_errors.html#ERROR">ERROR</a> :</td>
<td valign="top"> es wurde eine <a href="powerdos.html#Semaphore">Semaphore</a> beantragt, die der Antragsteller
bereits besitzt.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> es wurde versucht eine <a href="powerdos.html#Semaphore">Semaphore</a> zu erzeugen, die bereits
existiert, der Aufrufer ist nicht im Besitz der <a href="powerdos.html#Semaphore">Semaphore</a> oder ein
Timeout ist eingetreten.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> der angegebene <a href="powerdos.html#Semaphore">Semaphore</a> existiert nicht.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.92 existiert und in <a href="magic.html">MagiC</a> ab Version 3.0.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psemaphore">Binding</a> &nbsp; <a href="magic_semaphore.html">Semaphoren in MagiC</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psemaphore">5.11.20.1 Bindings für Psemaphore</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psemaphore">Psemaphore</a> ( int16_t mode, int32_t id, int32_t timeout
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    timeout,-(sp)  ; Offset 8
move.l    id,-(sp)       ; Offset 4
move.w    mode,-(sp)     ; Offset 2
move.w    #308,-(sp)     ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $C(sp),sp      ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetauid">5.11.21 Psetauid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetauid« - User ID eines Prozesses zu Beginn setzen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 326 (0x0146)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Psetauid ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion setzt die Anfangs-User-ID des aktuellen Prozesses.
Dies kann nur einmal geschehen. Zusammen mit <a href="#Pgetauid">Pgetauid</a> kann damit in
einer Multiuser-Umgebung festgestellt werden, wer der zuerst
eingeloggte Benutzer war. Der Parameter <i>id</i> ist die gewünschte
Anfangs-ID.
<br>&nbsp;
<br><b>Achtung:</b> Diese Funktion ist optional, daher darf ein
Aufruf mit <a href="gemdos_errors.html#EINVFN">EINVFN</a> beantwortet werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> z.Zt. unbekannt
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.92 existiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetauid">Binding</a> &nbsp; <a href="#Pgetauid">Pgetauid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetauid">5.11.21.1 Bindings für Psetauid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Psetauid">Psetauid</a> ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    id,-(sp)     ; Offset 2
move.w    #326,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetegid">5.11.22 Psetegid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetegid« - sets the effective group id for the calling
process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 324 (0x0144)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psetegid ( int16_t egid );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> <i>egid</i> specifies the new effective group id for the
calling process.
<br>&nbsp;
<br>Prior to MiNT version 1.12 this call contained a bug affecting
its functionality. Setting effective group id needs root privileges.
<br>&nbsp;
<br>This call is often used by daemon processes to downgrade their
privileges to user level.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns new egid on success or a negative <a href="gemdos_main.html">GEMDOS</a> error code
otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> MiNT 1.11
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetegid">Binding</a> &nbsp; <a href="#Pseteuid">Pseteuid</a> &nbsp; <a href="#Psetgid">Psetgid</a> &nbsp; <a href="#Psetregid">Psetregid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetegid">5.11.22.1 Bindings für Psetegid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetegid">Psetegid</a> ( int16_t egid );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    egid,-(sp)   ; Offset 2
move.w    #324,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pseteuid">5.11.23 Pseteuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pseteuid« - sets the effective user id for the calling
process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 323 (0x0143)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pseteuid ( int16_t euid );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> <i>euid</i> specifies the new effective user id for the
calling process.
<br>&nbsp;
<br>Prior to MiNT version 1.12 this call contained a bug affecting
its functionality. Setting effective user id needs root privileges.
<br>&nbsp;
<br>This call is often used by daemon processes to downgrade their
privileges to user level.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns new euid on success or a negative <a href="gemdos_main.html">GEMDOS</a> error code
otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> ab MiNT 1.11
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pseteuid">Binding</a> &nbsp; <a href="#Psetegid">Psetegid</a> &nbsp; <a href="#Psetuid">Psetuid</a> &nbsp; <a href="#Psetreuid">Psetreuid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pseteuid">5.11.23.1 Bindings für Pseteuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pseteuid">Pseteuid</a> ( int16_t euid );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    euid,-(sp)   ; Offset 2
move.w    #323,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetgid">5.11.24 Psetgid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetgid« - Gruppen ID eines Prozesses verändern.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 277
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Psetgid ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion setzt die Gruppen-ID des aktuellen Prozesses auf
<i>id</i>. Dies muß eine Zahl von 0 bis 255 sein.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0-255 :</td>
<td valign="top"> kein Fehler aufgetreten (die neue ID).
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> der Prozess hat keine Berechtigung, seine ID zu verändern.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetgid">Binding</a> &nbsp; <a href="#Psetuid">Psetuid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetgid">5.11.24.1 Bindings für Psetgid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Psetgid">Psetgid</a> ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    id,-(sp)     ; Offset 2
move.w    #277,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetgroups">5.11.25 Psetgroups</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetgroups« - sets the supplementary group ids for the
calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 328 (0x0148)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psetgroups( int16_t len, int16_t *gidset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function sets the supplementary group ids for the calling
process.
<br>&nbsp;
<br><i>len</i> specifies the length (in words) of the array
containing the supplementary group ids to be set. This value must be a
positive number not greater than NGROUPS_MAX. If <i>len</i> is a
zero, the call will return the number of supplementary group ids those
have been set.
<br>&nbsp;
<br><i>gidset</i> is a pointer to a word array containing the new
supplementary group ids for the process.
<br>&nbsp;
<br>Setting new supplementary group ids needs root privileges.
<br>&nbsp;
<br>The NGROUPS_MAX value is returned by <a href="gemdos_system.html#Sysconf">Sysconf</a>().
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns a number of new supplementary group ids for the process
on success or a negative <a href="gemdos_main.html">GEMDOS</a> error code otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Sie steht ab MiNT 1.11 zu Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetgroups">Binding</a> &nbsp; <a href="#Pgetgroups">Pgetgroups</a> &nbsp; <a href="gemdos_system.html#Sysconf">Sysconf</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetgroups">5.11.25.1 Bindings für Psetgroups</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetgroups">Psetgroups</a>( int16_t len, int16_t *gidset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>peam      gidset       ; Offset 4
move.w    len,-(sp)    ; Offset 2
move.w    #328,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetlimit">5.11.26 Psetlimit</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetlimit« - Limits der Systemresourcen setzen/erfragen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 287
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psetlimit ( int16_t lim, int32_t value );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion dient dem Setzen/Abfragen einer
Resourcenbegrenzung für den aktuellen Prozess. Der Parameter
<i>lim</i> bestimmt die gewünschte Resource-Art:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">lim</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> max. CPU-Zeit für den Prozess (Millisekunden)
</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top"> max. Gesamtspeicher des Prozesses in Bytes
</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top"> max. allozierbarer Speicher für den Prozess (in Bytes).

</td></tr>
</table>

<br>Der Unterschied zwischen 2 und 3 besteht darin, daß der
Gesamtspeicher auch die TEXT-, DATA- und BSS-Segmente des Prozesses
umfaßt.
<br>&nbsp;
<br>Mit Hilfe dieser Funktion werden die Resource-Begrenzungen
sowohl für den aktuellen Prozess, als auch für alle später
erzeugten Childs einzeln eingestellt. Wenn ein Prozess also ein
CPU-Limit einstellt, und danach mehrere Child-Prozesse erzeugt, dann
gilt dieses CPU-Limit auch für jeden einzelnen Child, und nicht etwa
für alle Childs zusammen.
<br>&nbsp;
<br>Der Parameter <i>value</i> bestimmt den Wert, den eine Resource
annehmen soll. Ein Wert von 0 bedeutet in diesem Zusammenhang, daß
die Resource unbegrenzt ist. Ein negativer Wert läßt die Resource
unverändert.
<br>&nbsp;
<br><b>Hinweis:</b> Es gibt keine Restriktionen beim Vergrößern
der Begrenzungen. Jeder Prozess kann jede seiner Begrenzungen beliebig
verändern oder sogar auf unbegrenzt setzen.
<br>&nbsp;
<br>Speicherbegrenzungen kommen bei <a href="#Pexec">Pexec</a> nicht zur Anwendung. Ist
z.B. ein Prozess auf 256Kbyte begrenzt, kann er dennoch mit <a href="#Pexec">Pexec</a>
einen Tochterprozess starten, der mehr Speicher verbraucht.
<b>Achtung:</b> Dies gilt <i>nicht</i> in <a href="magic.html">MagiC</a>; hier werden
Speicherbegrenzungen bei <a href="#Pexec">Pexec</a> vererbt!
<br>&nbsp;
<br>Speicherbegrenzungen sind nicht rückwirkend gültig. Besitzt
ein Prozess z.B. 256Kbyte und ruft dann Psetlimit auf, um seinen
Bedarf auf 128Kbyte zu reduzieren, dann wird er zwar nicht beendet,
aber er kann keinen Speicher mehr allozieren, bis seine Größe unter
die angegebenen 128Kbyte fällt.
<br>&nbsp;
<br>Begrenzungen der CPU-Zeit wirken hingegen rückwirkend.
Verkürzt ein Prozess seine CPU-Zeit unter den bisher gültigen Wert,
dann empfängt er sofort ein <a href="gemdos_signals.html#SIGXCPU">SIGXCPU</a>-Signal.
<br>&nbsp;
<br><b>Achtung:</b> Ungültige Funktionsnummern und solche, die von
<a href="magic.html">MagiC</a> nicht unterstützt werden, liefern <a href="gemdos_errors.html#EINVFN">EINVFN</a>.
<br>&nbsp;
<br><b>Hinweis zu MagiC:</b> Ist ein Programm mit dem
Dienstprogramm LIMITMEM modifiziert worden, hat diese Einstellung
Vorrang vor dem Speicherlimit des aufrufenden Prozesses. Psetlimit
wird vom erweiterten <a href="shel.html#shel_write">shel_write</a>()-Modus unterstützt; damit können
speicherbeschränkte Applikationen auch parallel gestartet werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den alten Begrenzungswert zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> <a href="magic.html">MagiC</a> ab Version 4.0 (17.09.1996) und ab der ersten in MultiTOS
integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetlimit">Binding</a> &nbsp; <a href="#Prusage">Prusage</a> &nbsp; <a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetlimit">5.11.26.1 Bindings für Psetlimit</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetlimit">Psetlimit</a> ( int16_t lim, int32_t value );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    value,-(sp)  ; Offset 4
move.w    lim,-(sp)    ; Offset 2
move.w    #287,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetpgrp">5.11.27 Psetpgrp</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetpgrp« - Prozess Gruppennummer eines Prozesses
setzen/ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 270
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Psetpgrp ( int16_t pid, int16_t newgrp );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion verändert die Gruppennummer des Prozesses mit der
Kennung <i>pid</i> auf den Wert <i>newgrp</i>, oder gibt den
Gruppennummer zurück, wenn <i>newgrp</i> negativ ist. Der Prozess
muß die gleiche UID wie der aktuelle Prozess besitzen, oder dessen
Parent sein.
<br>&nbsp;
<br>Falls <i>pid</i> = 0 ist, wird die Prozessgruppe des aktuellen
Prozesses gesetzt. Falls <i>newgrp</i> = 0 ist, wird die
Prozessgruppe auf den Wert der PID des aktuellen Prozesses gesetzt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;= 0&nbsp; :</td>
<td valign="top"> kein Fehler (neue oder aktuelle Prozessgruppen-Nummer).
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> der Prozess <i>pid</i> existiert nicht.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> der Prozess <i>pid</i> besitzt eine andere UID, und ist kein
Child des aufrufenden Prozesses.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetpgrp">Binding</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Pgetpgrp">Pgetpgrp</a> &nbsp; <a href="#Pgetpid">Pgetpid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetpgrp">5.11.27.1 Bindings für Psetpgrp</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Psetpgrp">Psetpgrp</a> ( int16_t pid, int16_t newgrp );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    newgrp,-(sp)  ; Offset 4
move.w    pid,-(sp)     ; Offset 2
move.w    #270,-(sp)    ; Offset 0
trap      #1            ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetpriority">5.11.28 Psetpriority</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetpriority« - sets the current priority value for a
process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 345 (0x0159)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psetpriority ( int16_t which, int16_t who, int16_t pri
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function sets the priority <i>pri</i> (not an increment
but an absolute value) for the processes specified by <i>which</i>
and <i>who</i>. The interpretation of parameter <i>who</i> depends
on <i>which</i>:
<br>&nbsp;
<br><a href="gemdos_process.html#PRIO_PROCESS">PRIO_PROCESS</a> (0) sets the priority of process with process id
<i>who</i>. A <i>who</i> of 0 implies the process id of the calling
process.
<br>&nbsp;
<br><a href="gemdos_process.html#PRIO_PGRP">PRIO_PGRP</a> (1) sets the priority of the process group with
process group id <i>who</i>. A <i>who</i> of 0 implies the process
group id of the calling process.
<br>&nbsp;
<br><a href="gemdos_process.html#PRIO_USER">PRIO_USER</a> (2) sets the priority of the process of the user with
user id <i>who</i>. A <i>who</i> of 0 implies the user id of the
calling process.
<br>&nbsp;
<a name="PRIO_MIN"></a>
<a name="PRIO_MAX"></a>
<br>The <i>pri</i> argument is silently changed to the maximum
(resp. minimum) possible value if it is not in the range between
PRIO_MIN (-20) and PRIO_MAX (+20).
<br>&nbsp;
<br>This call makes calls <a href="#Pnice">Pnice</a> and <a href="#Prenice">Prenice</a> obsolete.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> The function returns <a href="gemdos_errors.html#E_OK">E_OK</a> on success or a negative error code
otherwise. The following error conditions are defined:
<br>&nbsp;
<br><a href="gemdos_errors.html#EINVAL">EINVAL</a>, invalid argument for <i>who</i>, <i>which</i> or
<i>pri</i>.
<br>&nbsp;
<br><a href="gemdos_errors.html#EACCES">EACCES</a>, the calling process is not an owner of one or more of
the selected processes. The other selected processes are still
affected. <a href="gemdos_errors.html#EPERM">EPERM</a>, the calling process does not have privileges to
change the priority of one or more of the selected processes. This can
only happen if an attempt was made to change the priority of a process
to a positive value.
<br>&nbsp;
<br><a href="gemdos_errors.html#ESRCH">ESRCH</a>, the combination of <i>which</i> and <i>who</i> does not
match any existing process.
<br>&nbsp;
<br>The error condition reported is the last error condition
encountered (in other words if both <a href="gemdos_errors.html#EACCES">EACCES</a> and <a href="gemdos_errors.html#EPERM">EPERM</a> occur the return
value is arbitrary).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> ab MiNT 1.15.0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetpriority">Binding</a> &nbsp; <a href="#Pgetpriority">Pgetpriority</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetpriority">5.11.28.1 Bindings für Psetpriority</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetpriority">Psetpriority</a> ( int16_t which, int16_t who, int16_t pri
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    pri,-(sp)    ; Offset 6
move.w    who,-(sp)    ; Offset 4
move.w    which,-(sp)  ; Offset 2
move.w    #345,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetregid">5.11.29 Psetregid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetregid« - sets the real and/or effective group id for the
calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 335 (0x014f)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psetregid ( int16_t rgid, int16_t egid);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function sets the real and/or effective group id for the
calling process.
<br>&nbsp;
<br><i>rgid</i> specifies the new real group id and <i>egid</i>
specifies the new effective group id for the calling process. If
either argument is -1, only the other gets changed
<br>&nbsp;
<br>Setting group ids needs root privileges.
<br>&nbsp;
<br>This call is often used by daemon processes to downgrade their
privileges to user level.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns <a href="gemdos_errors.html#E_OK">E_OK</a> on success or a negative error code otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> since MiNT 1.12
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetregid">Binding</a> &nbsp; <a href="#Psetreuid">Psetreuid</a> &nbsp; <a href="#Psetegid">Psetegid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetregid">5.11.29.1 Bindings für Psetregid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetregid">Psetregid</a> ( int16_t rgid, int16_t egid);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    egid,-(sp)   ; Offset 4
move.w    rgid,-(sp)   ; Offset 2
move.w    #335,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetreuid">5.11.30 Psetreuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetreuid« - sets the real and/or effective user id for the
calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 334 (0x014e)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psetreuid ( int16_t ruid, int16_t euid);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function sets the real and/or effective user id for the
calling process.
<br>&nbsp;
<br><i>ruid</i> specifies the new real user id and <i>euid</i>
specifies the new effective user id for the calling process. If either
argument is -1, only the other gets changed.
<br>&nbsp;
<br>Setting user ids needs root privileges.
<br>&nbsp;
<br>This call is often used by daemon processes to downgrade their
privileges to user level.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns <a href="gemdos_errors.html#E_OK">E_OK</a> on success or a negative <a href="gemdos_main.html">GEMDOS</a> error code
otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> since MiNT 1.12
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetreuid">Binding</a> &nbsp; <a href="#Psetregid">Psetregid</a> &nbsp; <a href="#Pseteuid">Pseteuid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetreuid">5.11.30.1 Bindings für Psetreuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetreuid">Psetreuid</a> ( int16_t ruid, int16_t euid);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    euid,-(sp)   ; Offset 4
move.w    ruid,-(sp)   ; Offset 2
move.w    #334,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psetuid">5.11.31 Psetuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetuid« - User ID eines Prozesses verändern.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 272
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Psetuid ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion setzt die User ID des aktuellen Prozesses auf
<i>id</i>. Dies muß eine Zahl von 0 bis 255 sein. Die Funktion
schlägt fehl, wenn die User-ID des Prozesses nicht den Wert 0
besitzt, d.h. einmal gesetzt, kann die User-ID nicht mehr verändert
werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0-255 :</td>
<td valign="top"> kein Fehler aufgetreten (die neue ID).
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> der Prozess hat keine Berechtigung, seine ID zu verändern.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psetuid">Binding</a> &nbsp; <a href="#Psetgid">Psetgid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psetuid">5.11.31.1 Bindings für Psetuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Psetuid">Psetuid</a> ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    id,-(sp)     ; Offset 2
move.w    #272,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psigaction">5.11.32 Psigaction</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigaction« - Art der Signalbehandlung verändern.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 311
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psigaction ( int16_t sig, <a href="gemdos_structures.html#struct_20sigaction">struct sigaction</a> *act, struct
<a href="gemdos_structures.html#sigaction">sigaction</a> *oact );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ändert die Art und Weise, wie auf das Signal
<i>sig</i> reagiert werden soll. Der Parameter <i>act</i> ist dabei
entweder NULL, oder zeigt auf eine <a href="gemdos_structures.html#sigaction">sigaction</a>-Struktur, die das
Verhalten des Signal-Handlings beschreibt. Für die Komponente
<i>sa_handler</i> gilt dabei:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">sa_handler</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> beim Eintreffen des Signals wird die Default-Aktion für das
Signal ausgeführt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> das Signal <i>sig</i> wird ignoriert. Liegt es gerade an, so
wird es gelöscht.

</td></tr>
</table>

<br>Jeder andere Wert von <i>sa_handler</i> wird als die Adresse
einer Funktion interpretiert, die beim Auftreten des Signals
aufgerufen wird. Über den Stack wird dieser Funktion ein Long-Wert
übergeben, der der jeweiligen Signalnummer entspricht. Auf diese Art
und Weise ist es möglich, den Signal-Handler für mehrere <a href="gemdos_signals.html">Signale</a> zu
benutzen.
<br>&nbsp;
<br>Solange ein Signal bearbeitet wird, kann es nicht erneut
gesendet werden. Zu beachten ist ferner, daß (im Gegensatz zu einigen
Unix-Versionen) das Signal-Handling vor der Ausführung des Handlers
nicht auf den Default-Handler zurückgesetzt wird.
<br>&nbsp;
<br>Der Signalhandler muß entweder mit RTS (<a href="VT_52_terminal.html#Return">Return</a> to Sender)
beendet werden, oder <a href="#Psigreturn">Psigreturn</a> aufrufen, um anzuzeigen, daß die
Signalbehandlung abgeschlossen ist. Anschließend wird die Blockierung
des Signals aufgehoben. <a href="#Psigreturn">Psigreturn</a> führt zusätzlich einige interne
Säuberungen des Kernels durch, die notwendig sind, falls der
Signal-Handler nicht beendet wird (longjump).
<br>&nbsp;
<br>Signalhandler können beliebige <a href="bios_main.html">BIOS</a>, <a href="xbios_main.html">XBIOS</a> und <a href="gemdos_main.html">GEMDOS</a> Aufrufe
machen. <a href="aes_main.html">AES</a>- oder <a href="vdi_main.html">VDI</a>-Aufrufe sind hingegen nicht gestattet. Dies gilt
jedoch nicht in <a href="magic.html">MagiC</a>; hier gibt es einige Unterschiede zu beachten.
<br>&nbsp;
<br>Ein Aufruf von Psigaction hat den Nebeneffekt, daß das Signal
demaskiert (d.h. freigegeben) wird. So kann ein Prozess beim
Abarbeiten eines Signals dieses zurücksetzen und es sich erneut
zusenden, um sich beispielsweise selbst zu suspendieren, während ein
Signal für Job-Control bearbeitet wird. Die Signalbearbeitung ist
gegenüber <a href="#Pfork">Pfork</a>/<a href="#Pvfork">Pvfork</a> abgesichert.
<br>&nbsp;
<br>Signale, die von einem Prozess ignoriert werden, werden auch vom
Child nach einem <a href="#Pexec">Pexec</a>-Aufruf ignoriert. Außerdem werden <a href="gemdos_signals.html">Signale</a>, die
von einem Signal-Handler abgefangen werden, im Child-Prozess auf den
Defaultwert zurückgesetzt.
<br>&nbsp;
<br>Die Komponente <i>sa_flags</i> der <a href="gemdos_structures.html#sigaction">sigaction</a>-Struktur definiert
ein zusätzliches, Signal-spezifisches Verhalten. Wenn <i>sig</i> das
Signal <a href="gemdos_signals.html#SIGCHLD">SIGCHLD</a> ist, und in <i>sa_flags</i> das SA_NOCLDSTOP Bit
gesetzt ist, wird <a href="gemdos_signals.html#SIGCHLD">SIGCHLD</a> dem Prozess nur dann gesendet, wenn einer
seiner Childs terminiert (und eben nicht dann, wenn ein Child durch
ein Job-Control-Signal suspendiert wird).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> kein Fehler aufgetreten.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> Signal kann vom Benutzer nicht abgefangen werden.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> <i>sig</i> ist kein gültiges Signal.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.95 existiert und in MagiC ab Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psigaction">Binding</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="#Psigreturn">Psigreturn</a> &nbsp; <a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psigaction">5.11.32.1 Bindings für Psigaction</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigaction">Psigaction</a> ( int16_t sig, <a href="gemdos_structures.html#struct_20sigaction">struct sigaction</a> *act, struct
<a href="gemdos_structures.html#sigaction">sigaction</a> *oact );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       oact         ; Offset 8
pea       act          ; Offset 4
move.w    sig,-(sp)    ; Offset 2
move.w    #311,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $C(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psigblock">5.11.33 Psigblock</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigblock« - Signalmaske verändern.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 278
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psigblock ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion Psigblock blockiert den Empfang ausgewählter
<a href="gemdos_signals.html">Signale</a>. Sie fügt die in <i>mask</i> angegebenen <a href="gemdos_signals.html">Signale</a> der Menge
der aktuell blockierenden Signale hinzu. Dabei repräsentiert jedes Bit
des Parameters <i>mask</i> ein Signal. Wenn Bit n in <i>mask</i>
gesetzt ist, bedeutet dies, daß das Signal mit der Nummer n blockiert
wird.
<br>&nbsp;
<br>Zu beachten ist, daß manche Signale (z.B. <a href="gemdos_signals.html#SIGKILL">SIGKILL</a>) nicht
blockiert werden können. Der Kernel wird diese Signale aus
<i>mask</i> löschen, bevor die jeweilige Änderung der Signalmengen
vorgenommen wird.
<br>&nbsp;
<br>Ferner sei darauf hingewiesen, daß blockierte Signale auch über
<a href="#Pfork">Pfork</a>/<a href="#Pvfork">Pvfork</a> Aufrufe hinweg blockiert bleiben. Nach einem <a href="#Pexec">Pexec</a>-Aufruf
startet der Child stets mit einer leeren Menge zu blockierender
Signale, unabhängig davon, welche <a href="gemdos_signals.html">Signale</a> vom Parent blockiert wurden.
<br>&nbsp;
<br><b>Achtung:</b> Diese Funktion ist optional, daher darf ein
Aufruf mit <a href="gemdos_errors.html#EINVFN">EINVFN</a> beantwortet werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die Menge der blockierten Signale zurück,
die vor dem Aufruf gültig waren. Über einen Aufruf von Psigsetmask kann
so die alte Menge wieder hergestellt werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
sie steht in <a href="magic.html">MagiC</a> ab Version 4.50 zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psigblock">Binding</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp; <a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psigblock">5.11.33.1 Bindings für Psigblock</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigblock">Psigblock</a> ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    mask,-(sp)   ; Offset 2
move.w    #278,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psigintr">5.11.34 Psigintr</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigintr« - assigns a signal to a particular exception
vector.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 318 (0x013e)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psigintr ( int16_t vec, int16_t sig );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function assigns a signal to a particular exception
vector. When the exception occurs, the kernel will send the signal to
the process.
<br>&nbsp;
<br><i>vec</i> specifies the exception vector. This is the same
value as specified for <a href="About_the_BIOS.html#Setexc">Setexc</a>() call. <i>sig</i> specifies the signal
number that is supposed to be delivered when an exception assigned to
the vector <i>vec</i> occurs. When both <i>sig</i> and <i>vec</i>
are zero, all handlers <a href="xbios_sound.html#installed">installed</a> by your program are removed.
<br>&nbsp;
<br>You should install a signal handler prior to making this call,
otherwise your process will most probably get killed by the first
occurrence of the interrupt assigned to vec vector.
<br>Also notice that the function is not available on machines
equipped with 68000 and 68010 processors.
<br>&nbsp;
<br>This function has been totally rewritten as of MiNT version
1.15.1. However, the only change visible to programs is that the old
value of vec is no longer returned (it had little use anyway). Also,
since long stack frames are needed, a 68020 or newer processor is
required.
<br>&nbsp;
<br>The handler set up by Psigintr gets removed when your process
terminates.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Returns <a href="gemdos_errors.html#E_OK">E_OK</a> on success, or a negative <a href="gemdos_main.html">GEMDOS</a> error code
otherwise:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EBADARG">EBADARG</a>:</td>
<td valign="top"> A signal or vector number was specified outside the allowed
range. Only autovectors ($60-$7c), traps ($80-$bc) and user defined
interrupts 0100-$03fc) are allowed (other interrupts already generate
fixed signals).
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENOMEM">ENOMEM</a>:</td>
<td valign="top"> The kernel ran out of memory while trying to allocate RAM for
internal structures needed by this call.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENXIO">ENXIO</a>:</td>
<td valign="top"> The interrupt you want to register has no service routine
installed.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENOSYS">ENOSYS</a>:</td>
<td valign="top"> The function is not available (wrong architecture).

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> When a 'MiNT' cookie with a version of at least 1.11 exists. As
of MiNT version 1.15.1 this call is available only on machines
equipped with 68020 processor or newer.
<br>&nbsp;
<br><span style="color: red;"> This function has been disabled as of FreeMiNT 1.16. </span>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psigintr">Binding</a> &nbsp; <a href="#Pause">Pause</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psigintr">5.11.34.1 Bindings für Psigintr</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigintr">Psigintr</a> ( int16_t vec, int16_t sig );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    sig,-(sp)    ; Offset 4
move.w    vec,-(sp)    ; Offset 2
move.w    #318,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psignal">5.11.35 Psignal</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psignal« - Art der Signalbehandlung verändern.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 274
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psignal ( int16_t sig, int32_t handler );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ändert die Art und Weise, wie auf das Signal
<i>sig</i> reagiert werden soll. Der Parameter <i>handler</i> kann 3
verschiedene Werte annehmen:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handler</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> Das Signal wird mit der Default-Aktion beantwortet.
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> Das Signal wird ignoriert. Liegt es gerade an, so wird es
gelöscht.

</td></tr>
</table>

<br>Jeder andere Wert wird als die Adresse einer Benutzerfunktion
interpretiert, die beim Auftreten des Signals <i>sig</i> aufgerufen
wird. Dieser Funktion wird (über den Stack) ein Long-Wert übergeben,
welcher der Signalnummer entspricht. Auf diese Art ist es möglich,
den Signal-Handler für mehrere <a href="gemdos_signals.html">Signale</a> zu benutzen.
<br>&nbsp;
<br>Solange ein Signal bearbeitet wird, kann es nicht erneut
gesendet werden. Zu beachten ist ferner, daß (im Gegensatz zu einigen
Unix-Versionen) das Signal-Handling vor der Ausführung des Handlers
nicht auf den Default-Handler zurückgesetzt wird.
<br>&nbsp;
<br>Der Signalhandler muß entweder mit RTS (<a href="VT_52_terminal.html#Return">Return</a> to Sender)
beendet werden, oder <a href="#Psigreturn">Psigreturn</a> aufrufen, um anzuzeigen, daß die
Signalbehandlung abgeschlossen ist. Anschließend wird die Blockierung
des Signals aufgehoben. Psigreturn führt zusätzlich einige interne
Säuberungen des Kernels durch, die notwendig sind, falls der
Signal-Handler nicht beendet wird (longjump).
<br>&nbsp;
<br>Signalhandler können beliebige <a href="bios_main.html">BIOS</a>, <a href="xbios_main.html">XBIOS</a> und <a href="gemdos_main.html">GEMDOS</a> Aufrufe
machen. <a href="aes_main.html">AES</a>- oder <a href="vdi_main.html">VDI</a>-Aufrufe sind hingegen nicht gestattet. Dies gilt
jedoch nicht in <a href="magic.html">MagiC</a>; hier gibt es einige Unterschiede zu beachten.
<br>&nbsp;
<br>Ein Aufruf von Psignal hat den Nebeneffekt, daß das Signal
demaskiert (d.h. freigegeben) wird. So kann ein Prozess beim
Abarbeiten eines Signals dieses zurücksetzen und es sich erneut
zusenden, um sich beispielsweise selbst zu suspendieren, während ein
Signal für Job-Control bearbeitet wird. Die Signalbearbeitung ist
gegenüber <a href="#Pfork">Pfork</a>/<a href="#Pvfork">Pvfork</a> abgesichert.
<br>&nbsp;
<br><a href="gemdos_signals.html">Signale</a>, die von einem Prozess ignoriert werden, werden auch vom
Child nach einem <a href="#Pexec">Pexec</a>-Aufruf ignoriert. Außerdem werden <a href="gemdos_signals.html">Signale</a>, die
von einem Signal-Handler abgefangen werden, im Child-Prozess auf den
Defaultwert zurückgesetzt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den alten Wert des Signal-Handlers
zurück. Dies ist entweder 0, 1 oder die Adresse des Handlers.
<br>&nbsp;
<br>Im Fehlerfall werden folgende Werte zurückgeliefert:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> das Signal kann nicht abgefangen werden.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> <i>sig</i> ist kein gültiges Signal.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
in MagiC ab der Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psignal">Binding</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Psigaction">Psigaction</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psigreturn">Psigreturn</a> &nbsp; <a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psignal">5.11.35.1 Bindings für Psignal</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psignal">Psignal</a> ( int16_t sig, int32_t handler );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handler,-(sp)  ; Offset 4
move.w    sig,-(sp)      ; Offset 2
move.w    #274,-(sp)     ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp          ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psigpause">5.11.36 Psigpause</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigpause« - Prozess bis zum Eintreffen eines Signals
suspendieren.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 310
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Psigpause ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion setzt die neue Signalmaske <i>mask</i>, und
suspendiert den aufrufenden Prozess, bis ein Signal eintrifft, welches
nicht maskiert ist oder ignoriert wird.
<br>&nbsp;
<br>Falls per <a href="#Psignal">Psignal</a> für dieses Signal ein Handler installiert
wurde, wird dieser aufgerufen, bevor die Funktion zurückkehrt. Falls
der Handler einen longjump in einen anderen Programmteil ausführt
oder der Prozess terminiert, wird die Funktion niemals zurückkehren.
<br>&nbsp;
<br><b>Hinweis:</b> Wenn die Funktion zurückkehrt, wird die
Signalmaske auf den Wert zurückgesetzt, der vor dem Aufruf von
Psigpause gültig war. Die von der Funktion gesetzte Signalmaske ist
also nur temporär gültig. In <a href="magic.html">MagiC</a> kann es Probleme geben wenn
mehrere Threads gleichzeitig diese Funktion aufrufen, da die
Signalmaske hier prozessglobal ist.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert immer 0 zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.95 existiert und in MagiC ab Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psigpause">Binding</a> &nbsp; <a href="#Pause">Pause</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp; <a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psigpause">5.11.36.1 Bindings für Psigpause</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Psigpause">Psigpause</a> ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mask,-(sp)   ; Offset 2
move.w    #310,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psigpending">5.11.37 Psigpending</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigpending« - feststellen welche Signale abgeschickt, aber
nicht bearbeitet wurden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 291
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psigpending ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert die <a href="gemdos_signals.html">Signale</a>, die dem aufrufenden Prozess
zwar gesendet, aber nicht bearbeitet wurden. (z.B. weil sie per
<a href="#Psigblock">Psigblock</a> blockiert sind oder weil sie gerade in Bearbeitung sind).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die gewünschten Signale als Bitmaske in
einem LONG zurück, für jedes gesetzte Bit <i>n</i> steht das Signal
<i>n</i> zum Bearbeiten an.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
in <a href="magic.html">MagiC</a> ab der Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psigpending">Binding</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp; <a href="gemdos_signals.html">Signale</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psigpending">5.11.37.1 Bindings für Psigpending</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigpending">Psigpending</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #291,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psigreturn">5.11.38 Psigreturn</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigreturn« - Verlassen eines Signal Handlers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 282
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Psigreturn ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion bereitet das Verlassen eines Signal-Handlers vor.
Da dies automatisch geschieht wenn der Handler zurückkehrt, ist ein
Aufruf von Psigreturn nur notwendig, falls der Handler einen
nicht-lokalen Sprung durchführt (etwa per longjump).
<br>&nbsp;
<br>Der Aufruf hat keine Wirkung, wenn z.Zt. kein Signal bearbeitet
wird.
<br>&nbsp;
<br>In MagiC wird der Thread der aktiven Signalbehandlung zum
Haupt-Thread des Prozesses und anschließend entfernt. Alle anderen
Signalbehandlungen werden ebenfalls entfernt (Verschachtelung). Die
gesperrten Semaphoren des Haupt-Thread werden freigegeben, der
Supervisor-Stack wird auf den Wert bei Prozeßstart zurückgesetzt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion besitzt unter MiNT/MultiTOS <i>kein</i> direktes
Ergebnis; in MagiC wird der Wert <a href="gemdos_errors.html#EACCDN">EACCDN</a> zurückgeliefert falls der
Aufrufer <i>keine</i> Signalbehandlungsroutine ist, und anderenfalls
der Wert <a href="gemdos_errors.html#E_OK">E_OK</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
<a href="magic.html">MagiC</a> ab der Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psigreturn">Binding</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="gemdos_signals.html">Signale</a> &nbsp; <a href="gemdos_signals.html#Signalhandler_20in_20MagiC">Signalhandler in MagiC</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psigreturn">5.11.38.1 Bindings für Psigreturn</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Psigreturn">Psigreturn</a> ( void );
<br>int32_t <a href="#Psigreturn">Psigreturn</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #282,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psigsetmask">5.11.39 Psigsetmask</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigsetmask« - Signalmaske ersetzen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 279
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psigsetmask ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ersetzt die Menge der aktuell zu blockierenden
<a href="gemdos_signals.html">Signale</a> vollständig durch die im Parameter <i>mask</i>
spezifizierten Signale.
<br>&nbsp;
<br>Zu beachten ist, daß manche Signale (z.B. <a href="gemdos_signals.html#SIGKILL">SIGKILL</a>) nicht
blockiert werden können. Der Kernel wird diese Signale aus
<i>mask</i> löschen, bevor die jeweilige Änderung der Signalmengen
vorgenommen wird.
<br>&nbsp;
<br>Ferner sei darauf hingewiesen, daß blockierte <a href="gemdos_signals.html">Signale</a> auch
über <a href="#Pfork">Pfork</a>/<a href="#Pvfork">Pvfork</a> Aufrufe hinweg blockiert bleiben. Nach einem
<a href="#Pexec">Pexec</a>-Aufruf startet der Child stets mit einer leeren Menge zu
blockierender Signale, unabhängig davon, welche Signale vom Parent
blockiert wurden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die Menge der blockierten Signale zurück,
die vor dem Aufruf gültig waren.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
in <a href="magic.html">MagiC</a> ab der Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psigsetmask">Binding</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="gemdos_signals.html">Signale</a> &nbsp; <a href="gemdos_signals.html#Signalhandler_20in_20MagiC">Signalhandler in MagiC</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psigsetmask">5.11.39.1 Bindings für Psigsetmask</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigsetmask">Psigsetmask</a> ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    mask,-(sp)   ; Offset 2
move.w    #279,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Psysctl">5.11.40 Psysctl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psysctl« - Get or set system information.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 350 (0x015e)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Psysctl ( int32_t *name, uint32_t namelen, void *old,
uint32_t *oldlenp, void *new, uint32_t newlen );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> The function Psysctl retrieves system information and allows
processes with appropriate privileges to set system information. The
system information may be an integer, a string or a structure.
<br>&nbsp;
<br><i>name</i> and <i>namelen</i> specify the system information
to retrieve. <i>name</i> is an array of longwords which defines a
path to the actual value. The first longword holds the top level name,
the second longword is the second level name... <i>namelen</i> is the
size of this array.
<br>&nbsp;
<br>The information is copied into the buffer specified by
<i>old</i> and <i>oldlenp</i>.
<br>&nbsp;
<br>Before the call, <i>oldlenp</i> points to a long specifiying
the size of the buffer. After the call, this long word is set to the
amount of copied data.
<br>&nbsp;
<br>If both <i>old</i> and <i>oldlenp</i> are set to NULL, the old
value is not returned.
<br>&nbsp;
<br>If only <i>old</i> is set to NULL, <i>oldlenp</i> will be set
to the amount of available data.
<br>&nbsp;
<br>To set a new value, <i>new</i> is set to a pointer to a buffer
of lenght <i>newlen</i>. Otherwise, <i>new</i> should be set to NULL
and <i>newlen</i> set to 0.
<br>&nbsp;
<br>The top level names are defined with the following CTL_ prefix.
<br>&nbsp;
<a name="UDO__25ctl_1"></a>
<br><b>CTL_KERN (1): Kernel</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">KERN_OSTYPE=1</td>
<td valign="top"> (string) System version
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_OSRELEASE=2</td>
<td valign="top"> (string) System release
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_OSREV=3</td>
<td valign="top"> (integer) System revision
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_VERSION=4</td>
<td valign="top"> (string) Compile time information
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_HOSTNAME=5</td>
<td valign="top"> (string) Hostname
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_DOMAINNAME=6</td>
<td valign="top"> (string) (YP) Domainname
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_SECURELVL=7</td>
<td valign="top"> (integer) System security level
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_MAXPROC=8</td>
<td valign="top"> (integer) Max processes
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_MAXFILES=9</td>
<td valign="top"> (integer) Max open files
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_NGROUPS=10</td>
<td valign="top"> (integer) Number of supplemental group IDs
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_IOV_MAX=11</td>
<td valign="top"> (integer) Max <a href="gemdos_structures.html#iovec">iovec</a>'s for readv(2) etc.
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_LOGIN_<a href="wind.html#NAME">NAME</a>_MAX=12</td>
<td valign="top"> (integer) Max length login name + NUL
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_BOOTTIME=13</td>
<td valign="top"> (struct <a href="gemdos_structures.html#timeval">timeval</a>) Time kernel was booted
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_INITIALTPA=14</td>
<td valign="top"> (integer) Max TPA size of a process
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_SYSDIR=15</td>
<td valign="top"> (string) The system directory

</td></tr>
</table>

<a name="UDO__25ctl_2"></a>
<br><b>CTL_HW (2): Generic CPU/IO</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">HW_MACHINE=1</td>
<td valign="top"> (string) Machine class
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_MACHINE_ARCH=2</td>
<td valign="top"> (string) Machine architecture
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_MODEL=3</td>
<td valign="top"> (string) Specific machine model
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_NCPU=4</td>
<td valign="top"> (integer) Number of CPUs
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_BYTEORDER=5</td>
<td valign="top"> (integer) Machine byte order
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_PAGESIZE=6</td>
<td valign="top"> (integer) Software page size
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_FREEPHYSMEM=7</td>
<td valign="top"> (integer) <a href="c_task_royal.html#Free">Free</a> physical memory

</td></tr>
</table>

<a name="UDO__25ctl_3"></a>
<br><b>CTL_MACHDEP (3): Machine dependent (not yet implemented)</b>
<br>&nbsp;
<a name="UDO__25ctl_4"></a>
<br><b>CTL_DEBUG (4): Debugging parameters (not yet
implemented)</b>
<br>&nbsp;
<a name="UDO__25ctl_5"></a>
<br><b>CTL_PROC (5): Per-proc attributes</b>
<br>The second level name specifies the process ID (PROC_CURPROC or
any PID), the third level name specifies the system information
(PROC_PID_DEBUG).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">PROC_CURPROC=0x7fffffff</td>
<td valign="top"> (2^31-1) (integer) Select the current process
</td></tr>

<tr><td nowrap="nowrap" valign="top">Other value</td>
<td valign="top"> (integer) ID of specified process
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">PROC_PID_DEBUG=1</td>
<td valign="top"> (integer) Process debug level

</td></tr>
</table>


</td></tr>
</table>

<a name="UDO__25ctl_6"></a>
<br><b>CTL_KBD (6): Keyboard configuration</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">KBD_PC_STYLE_CAPS=1</td>
<td valign="top"> (integer) CAPS key operate in PC style mode
</td></tr>

<tr><td nowrap="nowrap" valign="top">KBD_<a href="xbios_structures.html#MOUSE">MOUSE</a>_PIXELS=2</td>
<td valign="top"> (integer) Keyboard mouse movement pixels
</td></tr>

<tr><td nowrap="nowrap" valign="top">KBD_PIXELS_FINE=3</td>
<td valign="top"> (integer) Keyboard mouse movement pixels 'fine'

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> No error has arisen
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENOMEM">ENOMEM</a> :</td>
<td valign="top"> The amount of data available is greater than the size of the
buffer supplied
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> An attempt was made to change a read-only value or was made by
a process with insufficient privilege
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> The <i>name</i> array was less than two or greater than
CTL_MAXNAME
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENOTDIR">ENOTDIR</a>:</td>
<td valign="top"> <i>name</i> specifies an intermediate rather than terminal
name
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EOPNOTSUPP">EOPNOTSUPP</a>:</td>
<td valign="top"> <i>name</i> not found
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ESRCH">ESRCH</a></td>
<td valign="top"> Process not found

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Siesteht ab FreeMiNT 1.15.12 zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Psysctl">Binding</a> &nbsp; <a href="gemdos_system.html#Sysconf">Sysconf</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Psysctl">5.11.40.1 Bindings für Psysctl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psysctl">Psysctl</a> ( int32_t *name, uint32_t namelen, void *old,
uint32_ *oldlenp, void *new, uint32_t newlen );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    newlen,-(sp)   ; Offset 22
pea       new,-(sp)      ; Offset 18
pea       oldlenp,-(sp)  ; Offset 14
pea       old,-(sp)      ; Offset 10
move.l    namelen,-(sp)  ; Offset 6
pea       name,-(sp)     ; Offset 2
move.w    #350,-(sp)     ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $1A(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pterm">5.11.41 Pterm</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »process termination« - beendet ein <a href="tos_main.html">TOS</a>-Programm.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 76
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Pterm ( uint16_t retcode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="gemdos_main.html">GEMDOS</a>-Routine Pterm beendet den laufenden Prozess, und
entfernt diesen aus dem Speicher. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">retcode</td>
<td valign="top"> Status, der an das aufrufende Programm zurückgegeben wird.
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">-32 =</td>
<td valign="top"> sollte nicht benutzt werden, da man diesen Wert bei per
Control-C abgebrochenen Programmen erhält.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;-1 =</td>
<td valign="top"> sollte nicht benutzt werden, da dieser Wert ab GEMDOS 0.15 bei
einem Programmabsturz zurückgeliefert wird.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;0 =</td>
<td valign="top"> kein Fehler aufgetreten
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;1 =</td>
<td valign="top"> allgemeiner Fehler
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;2 =</td>
<td valign="top"> Fehler in den Parametern

</td></tr>
</table>


</td></tr>
</table>

<br><b>Hinweis zu MagiC:</b> Bevor irgendwelche Maßnahmen
ergriffen werden, wird über <a href="About_the_BIOS.html#Setexc">Setexc</a> der Vektor <a href="bios_sysvars.html#etv_term">etv_term</a> ermittelt und
über diesen gesprungen. Anschließend wird der Prozeß ordentlich
abgeräumt (einschließlich VDI-Workstations, Informierung aller
XFSs über <a href="magic_xfs.html#xfs_pterm">xfs_pterm</a>, schließen aller geöffneten Dateien und
aktuellen Pfade und Löschen der Prozeßdatei im Verzeichnis U:\PROC).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle GEMDOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pterm">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pterm0">Pterm0</a> &nbsp; <a href="#Ptermres">Ptermres</a> &nbsp; <a href="magic_xfs.html">XFS-Konzept in MagiC</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pterm">5.11.41.1 Bindings für Pterm</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Pterm">Pterm</a> ( uint16_t retcode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    retcode,-(sp)  ; Offset 2
move.w    #76,-(sp)      ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp          ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pterm0">5.11.42 Pterm0</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »process termination« - beendet ein <a href="tos_main.html">TOS</a>-Programm.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Pterm0 ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="gemdos_main.html">GEMDOS</a>-Routine Pterm0 beendet ein <a href="tos_main.html">TOS</a>-Programm und kehrt
nicht wieder zurück. Die Routine liefert den <a href="VT_52_terminal.html#Return">Return</a>-Code 0 zurück.
<br>&nbsp;
<br><b>Hinweis:</b> In <a href="magic.html">MagiC</a> wird diese Funktion direkt als
<a href="#Pterm">Pterm</a>(0) ausgeführt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle GEMDOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pterm0">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pterm">Pterm</a> &nbsp; <a href="#Ptermres">Ptermres</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pterm0">5.11.42.1 Bindings für Pterm0</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Pterm0">Pterm0</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #0,-(sp)     ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Ptermres">5.11.43 Ptermres</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »terminate and stay resident« - Programm beenden, aber im
Speicher behalten.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 49
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Ptermres ( int32_t keepcnt, int16_t retcode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="gemdos_main.html">GEMDOS</a>-Routine Ptermres beendet ein Programm, ein Teil der
TPA des Programms verbleibt jedoch intakt und der verbliebene Speicher
wird aus <a href="gemdos_memory.html">Speicherverwaltung</a> des GEMDOS entfernt. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">keepcnt</td>
<td valign="top"> Anzahl der Bytes, die resident gehalten werden sollen (gilt ab
Anfang der Basepage und schließt die Länge des TEXT, DATA und BSS
Segments des Programms plus der Länge des Stacks ein; Minimum sind
128 Bytes).
<br><b>Achtung:</b> Der nach diesem Aufruf verbliebene Speicher
kann später nicht freigegeben werden, da er komplett aus der
<a href="gemdos_memory.html">Speicherverwaltung</a> des GEMDOS entfernt wurde.
</td></tr>

<tr><td nowrap="nowrap" valign="top">retcode</td>
<td valign="top"> Status, der an das aufrufende Programm zurückgegeben wird.
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">-32 =</td>
<td valign="top"> sollte nicht benutzt werden, da man diesen Wert bei per
Control-C abgebrochenen Programmen erhält.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;-1 =</td>
<td valign="top"> sollte nicht benutzt werden, da dieser Wert ab GEMDOS 0.15 bei
einem Programmabsturz zurückgeliefert wird.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;0 =</td>
<td valign="top"> kein Fehler aufgetreten
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;1 =</td>
<td valign="top"> allgemeiner Fehler
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;2 =</td>
<td valign="top"> Fehler in den Parametern

</td></tr>
</table>


</td></tr>
</table>

<br><b>Hinweis:</b> Im <a href="gemdos_mintnet.html">Netzwerk</a> werden alle Lockings des Prozesses
aufgehoben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle <a href="gemdos_main.html">GEMDOS</a> Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Ptermres">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pterm">Pterm</a> &nbsp; <a href="#Pterm0">Pterm0</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Ptermres">5.11.43.1 Bindings für Ptermres</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Ptermres">Ptermres</a> ( int32_t keepcnt, int16_t retcode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    retcode,-(sp)  ; Offset 6
move.l    keepcnt,-(sp)  ; Offset 2
move.w    #49,-(sp)      ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp          ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Ptrace">5.11.44 Ptrace</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Ptrace« - process tracing and debugging
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 320
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Ptrace(int16_t request, int16_t pid, void * addr,
int32_t data)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Ptrace provides tracing and debugging facilities. It allows one
process (the tracing process) to control another (the traced process).
Most of the time, the traced process runs normally, but when it
receives a signal (see <a href="gemdos_structures.html#sigaction">sigaction</a>(2)), it stops. The tracing process is
expected to notice this via wait(2) or the delivery of a <a href="gemdos_signals.html#SIGCHLD">SIGCHLD</a>
signal, examine the state of the stopped process, and cause it to
terminate or continue as appropriate. Ptrace is the mechanism by which
all this happens.
<br>&nbsp;
<br>The <i>request</i> argument specifies what operation is being
performed; the meaning of the rest of the arguments depends on the
operation, but except for one special case noted below, all ptrace
calls are made by the tracing process, and the pid argument specifies
the process ID of the traced process. <i>request</i> can be:
<br>&nbsp;
<table class="UDO_env_xlist">
<a name="PT_TRACE_ME"></a>
<tr><td nowrap="nowrap" valign="top">PT_TRACE_ME (0)</td>
<td valign="top"> This request is the only one used by the traced process; it
declares that the process expects to be traced by its parent. All the
other arguments are ignored. (If the parent process does not expect to
trace the child, it will probably be rather confused by the results;
once the traced process stops, it cannot be made to continue except
via ptrace.) When a process has used this request and calls execve(2)
or any of the routines built on it (such as execv(3)), it will stop
before executing the first instruction of the new image. Also, any
setuid or setgid bits on the executable being executed will be
ignored.
<br>&nbsp;
<a name="PT_READ_I"></a>
<a name="PT_READ_D"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_READ_I (1), PT_READ_D (2)</td>
<td valign="top">
<br>These requests read a single int of data from the traced process'
address space. Traditionally, ptrace has allowed for machines with
distinct address spaces for instruction and data, which is why there
are two requests: conceptually, PT_READ_I reads from the instruction
space and PT_READ_D reads from the data space. In the current NetBSD
implementation, these two requests are completely identical. The addr
argument specifies the address (in the traced process' virtual address
space) at which the read is to be done. This address does not have to
meet any alignment constraints. The value read is returned as the
return value from ptrace.
<br>&nbsp;
<a name="PT_WRITE_I"></a>
<a name="PT_WRITE_D"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_WRITE_I (4), PT_WRITE_D (5)</td>
<td valign="top">
<br>These requests parallel PT_READ_I and PT_READ_D, except that they
write rather than read. The data argument supplies the value to be
written.
<br>&nbsp;
<a name="PT_CONTINUE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_CONTINUE (7)</td>
<td valign="top"> The traced process continues execution. <i>addr</i> is an
address specifying the place where execution is to be resumed (a new
value for the program counter), or (caddr_t)1 to indicate that
execution is to pick up where it left off. <i>data</i> provides a
signal number to be delivered to the traced process as it resumes
execution, or 0 if no signal is to be sent.
<br>&nbsp;
<a name="PT_KILL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_KILL (8)</td>
<td valign="top"> The traced process terminates, as if PT_CONTINUE had been used
with <a href="gemdos_signals.html#SIGKILL">SIGKILL</a> given as the signal to be delivered.
<br>&nbsp;
<a name="PT_ATTACH"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_ATTACH (9)</td>
<td valign="top"> This request allows a process to gain control of an otherwise
unrelated process and begin tracing it. It does not need any
cooperation from the to-be-traced process. In this case, pid specifies
the process ID of the to-be-traced process, and the other two
arguments are ignored. This request requires that the target process
must have the same real UID as the tracing process, and that it must
not be executing a setuid or setgid executable. (If the tracing
process is running as root, these restrictions do not apply.) The
tracing process will see the newly-traced process stop and may then
control it as if it had been traced all along.
<br>&nbsp;
<br>Two other restrictions apply to all tracing processes, even
those running as root. First, no process may trace the process running
init(8). Second, if a process has its root directory set with
chroot(2), it may not trace another process unless that process's root
directory is at or below the tracing process's root.
<br>&nbsp;
<a name="PT_DETACH"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_DETACH (10)</td>
<td valign="top"> This request is like PT_CONTINUE, except that it does not allow
specifying an alternative place to continue execution, and after it
succeeds, the traced process is no longer traced and continues
execution normally.
<br>&nbsp;
<a name="PT_SYSCALL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_SYSCALL (11)</td>
<td valign="top"> Continue and stop at next return from syscall.
<br>&nbsp;

</td></tr>
</table>

<br>Additionally, machine-specific requests can exist. On the SPARC,
these are:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">PT_GETREGS</td>
<td valign="top"> This request reads the traced process' machine registers into
the struct reg (defined in &lt;machine/reg.h&gt;) pointed to by addr.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_SETREGS</td>
<td valign="top"> This request is the converse of PT_GETREGS; it loads the traced
process' machine registers from the struct reg (defined in
&lt;machine/reg.h&gt;) pointed to by <i>addr</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_GETFPREGS</td>
<td valign="top"> This request reads the traced process' floating-point registers
into the struct fpreg (defined in &lt;machine/reg.h&gt;) pointed to by
<i>addr</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_SETFPREGS</td>
<td valign="top"> This request is the converse of PT_GETFPREGS; it loads the
traced process' floating-point registers from the struct fpreg
(defined in &lt;machine/reg.h&gt;) pointed to by addr.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Some requests can cause ptrace to return -1 as a non-error
value; to disambiguate, errno can be set to 0 before the call and
checked afterwards. The possible errors are:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">ww</td>
<td valign="top"> No process having the specified process ID exists.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EINVAL">EINVAL</a></td>
<td valign="top">
<br>&nbsp;
<ul>
<li> A process attempted to use PT_ATTACH on itself.
</li>
<li> The request was not one of the legal requests.
</li>
<li> The signal number (in <i>data</i>) to PT_CONTINUE was neither
0 nor a legal signal number.
</li>
<li> PT_GETREGS, PT_SETREGS, PT_GETFPREGS, or PT_SETFPREGS was
attempted on a process with no valid register set. (This is normally
true only of system processes.)
</li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EBUSY">EBUSY</a></td>
<td valign="top">
<br>&nbsp;
<ul>
<li> PT_ATTACH was attempted on a process that was already being
traced.
</li>
<li> A request attempted to manipulate a process that was being
traced by some process other than the one making the request.
</li>
<li> A request (other than PT_ATTACH) specified a process that
wasn't stopped.
</li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EPERM">EPERM</a></td>
<td valign="top">
<br>&nbsp;
<ul>
<li> A request (other than PT_ATTACH) attempted to manipulate a
process that wasn't being traced at all.
</li>
<li> An attempt was made to use PT_ATTACH on a process in violation
of the requirements listed under PT_ATTACH above.
</li>
</ul>


</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> This function is available since FreeMiNT 1.15.11.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Ptrace">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Ptrace">5.11.44.1 Bindings für Ptrace</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Ptrace">Ptrace</a>(int16_t request, int16_t pid, void *addr,
int32_t data);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    data,-(sp)    ; Offset 10
pea       addr          ; Offset 6
move.w    pid,-(sp)     ; Offset 4
move.w    request,-(sp) ; Offset 2
move.w    #320,-(sp)    ; Offset 0
trap      #1            ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pumask">5.11.45 Pumask</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pumask« - Datei und Verzeichnis Erstellungsmaske setzen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 307
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pumask ( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ändert die Datei-/Verzeichnis Erstellungsmaske
des aktuellen Prozesses auf <i>mode</i>, welches eine WORD Bitmaske
mit den durch <a href="gemdos_file.html#Fchmod">Fchmod</a> definierten Zugriffsrechten ist. Der neue Wert
der Maske wird an Child-Prozesse vererbt.
<br>&nbsp;
<br>Wenn eine neue Datei (per <a href="gemdos_file.html#Fcreate">Fcreate</a>) oder ein neues Verzeichnis
(per <a href="gemdos_directory.html#Dcreate">Dcreate</a>) erzeugt wird, werden die Zugriffsrechte normalerweise so
gesetzt, daß ein voller Zugriff erlaubt ist. (Ausnahme: neue Dateien
sind normalerweise nicht ausführbar).
<br>&nbsp;
<br>Mit Hilfe von Pumask kann festgelegt werden, welche
Zugriffsrechte bei der Erzeugung einer Datei nicht (!) erlaubt sein
sollen.
<br>&nbsp;
<br>Explizite <a href="gemdos_file.html#Fchmod">Fchmod</a>-Aufrufe werden von Pumask nicht beeinflußt.
<br>&nbsp;
<br><b>Achtung:</b> In <a href="magic.html">MagiC</a> wird die Maske allerdings von keinem
der internen XFS von MagiC ausgewertet und hat ihren Sinn
ausschließlich bei UNIX-ähnlichen Dateisystemen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den Wert der alten Erstellungsmaske.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.92 existiert und in <a href="magic.html">MagiC</a> ab Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pumask">Binding</a> &nbsp; <a href="gemdos_directory.html#Dcreate">Dcreate</a> &nbsp; <a href="gemdos_file.html#Fchmod">Fchmod</a> &nbsp; <a href="gemdos_file.html#Fcreate">Fcreate</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pumask">5.11.45.1 Bindings für Pumask</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pumask">Pumask</a> ( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)   ; Offset 2
move.w    #307,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pusrval">5.11.46 Pusrval</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pusrval« - spezifische Informationen eines Prozesses setzen
bzw. abfragen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 280
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pusrval ( int32_t val );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion erlaubt das Setzen bzw. Abfragen von
Prozessspezifischen Informationen. Diese werden in einem Langwort
gespeichert, und an alle Child-Prozesse weitervererbt.
<br>&nbsp;
<br>Die Bedeutung des Wertes kann vom aufrufenden Programm frei
bestimmt werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den alten Wert zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
in <a href="magic.html">MagiC</a> ab der Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pusrval">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pusrval">5.11.46.1 Bindings für Pusrval</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pusrval">Pusrval</a> ( int32_t val );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)    ; Offset 2
move.w    #280,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pvfork">5.11.47 Pvfork</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pvfork« - Kopie des aktuellen Prozesses erstellen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 275
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Pvfork ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion erzeugt eine Kopie des aktuellen Prozesses.
Parent- und Childprozess teilen sich denselben Adressraum, d.h. jede
Änderung, die der Child an Variablen vornimmt, betreffen auch den
Parent. Der neue Prozess beginnt seine Arbeit, wenn die Funktion
Pvfork zurückkehrt.
<br>&nbsp;
<br>Auch wenn der Parent diese Funktion aus dem Supervisormode
aufruft, läuft das Child im Usermode.
<br>&nbsp;
<br>Da sich beide Prozesse den gleichen Adressraum (und Stack)
teilen, gäbe es Probleme, wenn beide zur gleichen Zeit laufen
würden. Deshalb wird der Parent angehalten, bis der Child-Prozess
entweder beendet wird oder sich mittels <a href="#Pexec">Pexec</a> (Modus 200) selbst mit
einem neuen Prozess in einem neuen Adressraum überschreibt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> im Child-Prozess.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> neue Prozess-ID im Parent-Prozess.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENSMEM">ENSMEM</a>:</td>
<td valign="top"> nicht genug Speicher vorhanden, um den neuen Prozeß zu
erzeugen.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pvfork">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pfork">Pfork</a> &nbsp; <a href="magic_threads.html">Threads</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pvfork">5.11.47.1 Bindings für Pvfork</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pvfork">Pvfork</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #275,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pwait">5.11.48 Pwait</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pwait« - auf Childprozess warten, Exitcode ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 265
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pwait ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion ist äquivalent zu <a href="#Pwait3">Pwait3</a> (2, NULL) und wird aus
Gründen der Abwärtskompatibilität angeboten.
<br>&nbsp;
<br>Laut POSIX sollte die Bibliotheksfunktion 'wait' als <a href="#Pwaitpid">Pwaitpid</a>
(-1, 0, NULL) implementiert werden. Daher sollte Pwait für eine
POSIX-kompatible Bibliothek nicht benutzt werden.
<br>&nbsp;
<br><b>Achtung:</b> In <a href="magic.html">MagiC</a> ist die Funktion als <a href="#Pwaitpid">Pwaitpid</a> (-1, 2,
NULL) implementiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Exit-Status und PID des Childs in den unteren bzw. oberen 16
Bits eines 32-Bit Returnwerts.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Kein Child Prozess ist terminiert.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> es existieren keine Childs.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
in <a href="magic.html">MagiC</a> ab Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pwait">Binding</a> &nbsp; <a href="#Pwait3">Pwait3</a> &nbsp; <a href="#Pwaitpid">Pwaitpid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pwait">5.11.48.1 Bindings für Pwait</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pwait">Pwait</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #265,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pwait3">5.11.49 Pwait3</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pwait3« - auf Childprozess warten, Exitcode ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 284
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pwait3 ( int16_t flag, int32_t *rusage );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion ist äquivalent zu einem Aufruf von <a href="#Pwaitpid">Pwaitpid</a>
(-1, flag, rusage) und ermittelt damit den Exit-Status sowie die
CPU-Auslastung eines terminierten oder beendeten Child-Prozesses.
<br>&nbsp;
<br><i>flag</i> ist eine Bitmaske, die das Verhalten des
Funktionsaufrufs wie folgt festlegt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Wert</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> Wenn gesetzt, blockiert die Funktion nicht den aufrufenden
Prozess und liefert 0 zurück. Wenn nicht gesetzt (gelöscht), wird
der Prozess solange blockiert bis das Child sich beendet oder gestoppt
wurde.
</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top"> Wenn gesetzt, werden die Returnwerte von Prozessen die beendet
wurden genauso wie von gestoppten zurückgeliefert. Wenn gelöscht,
werden nur Returnwerte von Prozessen die aktuell beendet wurden,
zurückgeliefert.

</td></tr>
</table>

<br><i>rusage</i> zeigt auf ein Feld mit zwei LONGS, die mit
Informationen über den Verbrauch von Resourcen des beendeten oder
gestoppten Prozesses gefüllt werden. Der erste LONG enthält die
Anzahl Millisekunden, die vom Child verbraucht wurden. Der zweite LONG
enthält die Anzahl Millisekunden, die der Prozess im Kernelspace
verbracht hat. Wird diese Information nicht gewünscht, kann
<i>rusage</i> auf NULL gesetzt werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Exit-Status und PID des Childs im unteren und oberen 16 bit des
32 Bit Returnwerts.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Kein Child Prozess wurde gestoppt oder beendet, oder, falls
Bit-0 des Parameters <i>flag</i> gesetzt ist, die Funktion würde
beim Warten auf das Exit bzw. Stop des Childs blockiert werden.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> es existieren keine Childs.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Seit der ersten in MultiTOS integrierten MiNT Version 1.04 und
in <a href="magic.html">MagiC</a> ab Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pwait3">Binding</a> &nbsp; <a href="#Pwait">Pwait</a> &nbsp; <a href="#Pwaitpid">Pwaitpid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pwait3">5.11.49.1 Bindings für Pwait3</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pwait3">Pwait3</a> ( int16_t flag, int32_t *rusage );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       rusage       ; Offset 4
move.w    flag,-(sp)   ; Offset 2
move.w    #284,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Pwaitpid">5.11.50 Pwaitpid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pwaitpid« - auf Childprozess warten, Exitcode ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gemdosnummer:</td>
<td valign="top"> 314
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Pwaitpid ( int16_t pid, int16_t flag, int32_t *rusage
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion versucht den Exit-Code von Childprozessen, die
gestoppt oder beendet worden sind, zu ermitteln. Falls Bit-1 des
Parameters <i>flag</i> gesetzt ist, werden z.Zt. gestoppte,
anderenfalls gerade beendete bzw. durch Tracing gestoppte
Childprozesse gemeldet.
<br>&nbsp;
<br>Ein gestoppter Prozess wird i.d.R. einmal gemeldet (sofern er
nicht neu gestartet, und wieder gestoppt wurde). Ebenso wird ein
beendetet Prozess nur einmal gemeldet.
<br>&nbsp;
<br>Wenn Childs vorhanden sind, die weder gestoppt oder beendet sind
(oder auf ein solches Ereignis warten), wird das weitere Verhalten der
Funktion durch Bit-0 des Parameters <i>flag</i> gesteuert. Dabei
gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bit-0 = 0:</td>
<td valign="top"> warten, bis Child stoppt oder beendet wird.
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-0 = 1:</td>
<td valign="top"> sofort zurückkehren.

</td></tr>
</table>

<br><b>Über den Parameter <i>pid</i> können die Childs genauer
spezifiziert werden. Es gilt:</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">pid</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> Status für alle Childs abfragen
</td></tr>

<tr><td nowrap="nowrap" valign="top">&gt;0</td>
<td valign="top"> <i>pid</i> ist die Prozess-Kennung des Childs, dessen Status
erfragt werden soll
</td></tr>

<tr><td nowrap="nowrap" valign="top">=0</td>
<td valign="top"> Status für alle Childs abfragen, deren Gruppen-ID gleich der
des aufrufenden Prozesses ist.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&lt; -1</td>
<td valign="top"> Status für alle Childs abfragen, deren Gruppen-ID dem
Absolutwert (Betrag) von <i>pid</i> entspricht.

</td></tr>
</table>

<br><b>Über den Parameter <i>rusage</i> werden Informationen
über den Verbrauch an CPU-Zeit des Childs abgelegt:</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">rusage[0]:</td>
<td valign="top"> Zeitverbrauch im User-Space (msec)
</td></tr>

<tr><td nowrap="nowrap" valign="top">rusage[1]:</td>
<td valign="top"> Zeitverbrauch im Kernel-Space (msec)

</td></tr>
</table>

<br>Falls ein Child gefunden wurde, wird dessen PID in den oberen
16-Bit und sein Exit-Status in den unteren 16-Bit des Rückgabewertes
abgelegt. Wenn der Prozess durch das Signal mit der Nummer n gestoppt
oder beendet wurde, ist sein Exit-Status 256*n+x mit:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">x = 127,</td>
<td valign="top"> falls der Prozess gestoppt wurde.
</td></tr>

<tr><td nowrap="nowrap" valign="top">x = 0,</td>
<td valign="top"> falls der Prozess beendet wurde.

</td></tr>
</table>

<br><b>Achtung:</b> In <a href="magic.html">MagiC</a> werden angehaltene Child-Prozesse noch
nicht erkannt, sondern nur beendete Childs. Darüber hinaus werden im
Parameter <i>rusage</i> z.Zt. immer nur Null-Werte zurückgegeben.
<br>&nbsp;
<br>Auch Prozeßgruppen werden z.Zt. noch nicht richtig
unterstützt, da die Funktion <a href="#Psetpgrp">Psetpgrp</a>() noch fehlt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion kann folgende Rückgabewerte liefern:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Exit-Status und PID des Childs im unteren und oberen 16 bit des
32 Bit Returnwerts.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Kein Child Prozess wurde gestoppt oder beendet, oder, falls
Bit-0 des Parameters <i>flag</i> gesetzt ist, und die Funktion beim
Warten auf das Exit bzw. Stop des Childs blockiert werden würde.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> es existieren keine Childs.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Verfügbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von
mindestens 0.96 existiert und in <a href="magic.html">MagiC</a> ab Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Prozessfunktionen">Prozessfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Pwaitpid">Binding</a> &nbsp; <a href="#Pwait">Pwait</a> &nbsp; <a href="#Pwait3">Pwait3</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Pwaitpid">5.11.50.1 Bindings für Pwaitpid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pwaitpid">Pwaitpid</a> ( int16_t pid, int16_t flag, int32_t *rusage
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       rusage       ; Offset 6
move.w    flag,-(sp)   ; Offset 4
move.w    pid,-(sp)    ; Offset 2
move.w    #314,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="gemdos_main.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
<a name="UDO_nav_lf_FOOT" href="gemdos_datetime.html"><img src="udo_lf.gif" alt="Datum und Uhrzeit" title="Datum und Uhrzeit" border="0" width="24" height="24">Datum und Uhrzeit</a>
<a name="UDO_nav_rg_FOOT" href="gemdos_memory.html"><img src="udo_rg.gif" alt="Speicherverwaltung" title="Speicherverwaltung" border="0" width="24" height="24">Speicherverwaltung</a>
</body>
</html>
