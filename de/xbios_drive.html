<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 20.12.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Laufwerksfunktionen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_interrupt.html"><img src="udo_lf.gif" alt="Interruptfunktionen" title="Interruptfunktionen" border="0" width="24" height="24">Interruptfunktionen</a>
<a name="UDO_nav_rg_HEAD" href="matrix_XBIOS_extension.html"><img src="udo_rg.gif" alt="MATRIX-XBIOS-Erweiterung" title="MATRIX-XBIOS-Erweiterung" border="0" width="24" height="24">MATRIX-XBIOS-Erweiterung</a>

<hr>

<h1><a name="Laufwerksfunktionen">4.14 Laufwerksfunktionen</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#DMAread">DMAread</a></td>
<td valign="top"> Sektoren von Festplatte lesen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#DMAwrite">DMAwrite</a></td>
<td valign="top"> Sektoren auf Festplate schreiben.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Flopfmt">Flopfmt</a></td>
<td valign="top"> Spur auf einer Diskette formatieren.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Floprate">Floprate</a></td>
<td valign="top"> Seekrate und Timeout der Floppy setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Floprd">Floprd</a></td>
<td valign="top"> Einzelne Sektoren lesen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Flopver">Flopver</a></td>
<td valign="top"> Sektoren einer Diskette überprüfen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Flopwr">Flopwr</a></td>
<td valign="top"> Einzelne Sektoren schreiben.
<a name="MetaDOS-Funktionen"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaclose">Metaclose</a></td>
<td valign="top"> Gibt ein <a href="xbios_metados.html">MetaDOS</a> Gerät wieder frei.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metadiscinfo">Metadiscinfo</a></td>
<td valign="top"> Ermittelt aktuelle Status-Informationen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metagettoc">Metagettoc</a></td>
<td valign="top"> Liefert das Inhaltsverzeichnis eines Gerätes.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metainit">Metainit</a></td>
<td valign="top"> Informationen über MetaDOS Version ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaioctl">Metaioctl</a></td>
<td valign="top"> Schickt <a href="gemdos_main.html">GEMDOS</a>-Opcodes an ein MetaDOS Gerät.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaopen">Metaopen</a></td>
<td valign="top"> Initialisiert ein MetaDOS Gerät.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaread">Metaread</a></td>
<td valign="top"> Liest Daten von einem MetaDOS Gerät.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaseek">Metaseek</a></td>
<td valign="top"> Seeks to a physical address.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metasetsongtime">Metasetsongtime</a></td>
<td valign="top"> Startet eine Audio-Wiedergabe.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metastartaudio">Metastartaudio</a></td>
<td valign="top"> Startet eine Audio-Wiedergabe.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metastatus">Metastatus</a></td>
<td valign="top"> Ermittelt den Status eines MetaDOS Gerätes.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metastopaudio">Metastopaudio</a></td>
<td valign="top"> Beendet eine Audio-Wiedergabe.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metawrite">Metawrite</a></td>
<td valign="top"> Schreibt Daten auf ein MetaDOS Gerät.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Protobt">Protobt</a></td>
<td valign="top"> Bootsektor für Diskette im Speicher generieren.

</td></tr>
</table>

<p>Querverweis: <a href="gemdos_file.html">GEMDOS-Dateifunktionen</a> &nbsp; <a href="gemdos_directory.html">GEMDOS-Verzeichnisfunktionen</a>
</p>
<h3><a name="DMAread">4.14.1 DMAread</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »DMA read« - liest einzelne Sektoren von einer DMA-Einheit.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 42
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t DMAread( int32_t sector, int16_t count, void *buffer,
int16_t devno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine DMAread liest einzelne oder mehrere Sektoren
von einem ACSI-, SCSI- oder IDE-Gerät. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">sector</td>
<td valign="top"> erste Sektornummer
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Anzahl der Sektoren
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Anfangsadresse im Speicher
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Gerätenummer. Es gilt:
<br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0..7:</td>
  <td align="left" valign="top">ACSI-Geräte</td>
</tr>
<tr>
  <td align="left" valign="top">8..15:</td>
  <td align="left" valign="top">SCSI-Geräte (<a href="tos_main.html">TOS</a> 2.06 und ab 3.00)</td>
</tr>
<tr>
  <td align="left" valign="top">16</td>
  <td align="left" valign="top">IDE-Geräte  (<a href="tos_main.html">TOS</a> 2.06 und ab 3.06)</td>
</tr>
</table>
</div>

<br>Alle anderen Werte sind für zukünftige Erweiterungen
reserviert.

</td></tr>
</table>

<br><b>Hinweis:</b> In vielen Fällen ist es sinnvoller, statt
dieser Funktion <a href="About_the_BIOS.html#Rwabs">Rwabs</a> zu verwenden. Der angegebene Speicherbereich
muß für die jeweilige Hardware beschreibbar sein (Stichwort:
<a href="bios_cookiejar.html#Fast-RAM-Buffer">Fast-RAM-Buffer</a>). SCSI-Geräte werden von dieser Funktion nicht per
DMA, sondern per Handshake betrieben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist, ansonsten einen Fehlercode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht erst ab <a href="tos_main.html">TOS</a> 2.00 zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20DMAread">Binding</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20DMAread">4.14.1.1 Bindings für DMAread</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#DMAread">DMAread</a>( int32_t sector, int16_t count, void *buffer,
int16_t devno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    devno,-(sp)  ; Offset 12
pea       buffer       ; Offset  8
move.w    count,-(sp)  ; Offset  6
move.l    sector,-(sp) ; Offset  2
move.w    #42,-(sp)    ; Offset  0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $E(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="DMAwrite">4.14.2 DMAwrite</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »DMA write« - schreibt einzelne Sektoren auf eine
DMA-Einheit.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 43
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t DMAwrite( int32_t sector, int16_t count, void *buffer,
int16_t devno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine DMAwrite schreibt einzelne oder mehrere
Sektoren auf ein ACSI-, SCSI- oder IDE-Gerät. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">sector</td>
<td valign="top"> erste Sektornummer
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Anzahl der Sektoren
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Anfangsadresse im Speicher
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Gerätenummer. Es gilt:
<br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0..7:</td>
  <td align="left" valign="top">ACSI-Geräte</td>
</tr>
<tr>
  <td align="left" valign="top">8..15:</td>
  <td align="left" valign="top">SCSI-Geräte (<a href="tos_main.html">TOS</a> 2.06 und ab 3.00)</td>
</tr>
<tr>
  <td align="left" valign="top">16</td>
  <td align="left" valign="top">IDE-Geräte  (<a href="tos_main.html">TOS</a> 2.06 und ab 3.06)</td>
</tr>
</table>
</div>

<br>Alle anderen Werte sind für zukünftige Erweiterungen
reserviert.

</td></tr>
</table>

<br><b>Hinweis:</b> In vielen Fällen ist es sinnvoller, statt
dieser Funktion <a href="About_the_BIOS.html#Rwabs">Rwabs</a> zu verwenden. Der angegebene Speicherbereich
muß für die jeweilige Hardware lesbar sein (Stichwort:
<a href="bios_cookiejar.html#Fast-RAM-Buffer">Fast-RAM-Buffer</a>). SCSI-Geräte werden von dieser Funktion nicht per
DMA, sondern per Handshake betrieben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist, ansonsten einen Fehlercode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht erst ab <a href="tos_main.html">TOS</a> 2.00 zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20DMAwrite">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20DMAwrite">4.14.2.1 Bindings für DMAwrite</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#DMAwrite">DMAwrite</a>( int32_t sector, int16_t count, void *buffer,
int16_t devno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    devno,-(sp)  ; Offset 12
pea       buffer       ; Offset  8
move.w    count,-(sp)  ; Offset  6
move.l    sector,-(sp) ; Offset  2
move.w    #43,-(sp)    ; Offset  0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $E(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Flopfmt">4.14.3 Flopfmt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy format« - formatiert einzelne Spuren auf einer
Diskette.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 10
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Flopfmt( void *buf, int32_t filler, int16_t devno,
int16_t spt, int16_t trackno, int16_t sideno, int16_t interlv, int32_t
magic, int16_t virgin );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Flopfmt formatiert eine oder mehrere Spuren
auf einer Diskette. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top"> Zeiger auf einen Bereich, in dem die Daten für die Spur
gespeichert werden können.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top"> bei allen <a href="tos_main.html">TOS</a>-Versionen &lt; 1.02 unbenutzt, und auf 0 zu
setzen. Ab dem Blitter-<a href="tos_main.html">TOS</a> gilt: wenn <i>interlv</i> = -1 ist, so ist
<i>filler</i> als Zeiger auf eine Tabelle von Sektornummern anzusehen
(16Bit-Worte). Dadurch ergibt sich die Möglichkeit, die Reihenfolge
der Sektoren auf der Spur frei zu wählen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> 0 = Laufwerk-A, 1 = Laufwerk-B
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">spt</td>
<td valign="top"> Sektoren pro Spur (normal: 9). Falls der Cookie <a href="bios_cookiejar.html#Cookie_2C_20_FDC">_FDC</a> gesetzt
ist, sind auch Werte von 18 (High-Density) bzw. 36
(Extra-High-Density) Sektoren erlaubt. Die Umschaltung der
verschiedenen Schreibverfahren findet bei 13 (HD) bzw. 26 (ED) statt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top"> Nummer der Spur (0..79)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top"> 0: Seite-1
<br>1: Seite-2 (bei doppelseitigen Disketten)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">interlv</td>
<td valign="top"> bestimmt, wie viele physikalische Sektoren jeweils zwischen
zwei logischen Sektoren liegen (normal: 1)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">magic</td>
<td valign="top"> 0x87654321, sonst wird nicht formatiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">virgin</td>
<td valign="top"> Bitmuster, welches beim Formatieren in jeden Sektor geschrieben
wird (normal: 0xe5e5). Die oberen vier Bits dürfen nicht gesetzt
werden, da dies sonst vom Controller als Kommando interpretiert
würde.
<br>&nbsp;

</td></tr>
</table>

<br><b>Hinweis:</b> Ab dem Blitter-<a href="tos_main.html">TOS</a> erlaubt es das Desktop, eine
Liste von Sektornummern zu übergeben, um Spuren derart zu
spiralisieren, daß beim Spurwechsel möglichst wenig Zeit mit dem
Warten auf den nächsten Sektor verloren wird.
<br>&nbsp;
<br>Bei einem normalen Format (9 Sektoren pro Spur) muss der über
den Parameter <i>buf</i> angegebene Speicherbereich eine Größe von
mindestens 8 Kbyte besitzen; in anderen Fällen muss der Puffer evtl.
noch vergrößert werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist. Im Fehlerfall wird eine durch 0 abgeschlossene Liste der
fehlerhaften Sektoren in den Puffer geschrieben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Flopfmt">Binding</a> &nbsp; <a href="#Flopwr">Flopwr</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Flopfmt">4.14.3.1 Bindings für Flopfmt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Flopfmt">Flopfmt</a>( void *buf, int32_t filler, int16_t devno,
int16_t spt, int16_t trackno, int16_t sideno, int16_t interlv, int32_t
magic, int16_t virgin );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    virgin,-(sp)  ; Offset 24
move.l    magic,-(sp)   ; Offset 20
move.w    interlv,-(sp) ; Offset 18
move.w    sideno,-(sp)  ; Offset 16
move.w    trackno,-(sp) ; Offset 14
move.w    spt,-(sp)     ; Offset 12
move.w    devno,-(sp)   ; Offset 10
move.l    filler,-(sp)  ; Offset  6
pea       buf           ; Offset  2
move.w    #10,-(sp)     ; Offset  0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $1A(sp),sp    ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(10,L:buf%,L:filler%,W:devno%,W:spt%,W:trackno%,W:sideno%,W:interlv%,L:magic%,W:virgin%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Floprate">4.14.4 Floprate</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy rate« - liest oder setzt die seek rate eines
Floppylaufwerks.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 41
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Floprate( int16_t devno, int16_t newrate );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Floprate liefert bzw. setzt die aktuelle
Seekrate. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Laufwerksnummer
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Laufwerk-A</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Laufwerk-B usw.</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">newrate</td>
<td valign="top">
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">-1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Seekrate nicht verändern</td>
</tr>
<tr>
  <td align="right" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Rate von  6ms</td>
</tr>
<tr>
  <td align="right" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Rate von 12ms</td>
</tr>
<tr>
  <td align="right" valign="top">2</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Rate von  2ms</td>
</tr>
<tr>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Rate von  3ms</td>
</tr>
</table>
</div>


</td></tr>
</table>

<a name="Floppy_2C_20Timeout_20der"></a>
<a name="Timeout_20der_20Floppy"></a>
<br><b>Hinweis:</b> Ab <a href="magic.html">MagiC</a> 3 kann darüberhinaus per Floprate
(-1, newrate) der <b>Timeout</b> für die Floppy eingestellt werden;
ein Wert von 300 bedeutet 1,5 Sekunden (dies ist der Wert, der beim
Booten per Default eingestellt ist).
<br>&nbsp;
<br>Bei älteren ROM-<a href="tos_main.html">TOS</a>-Versionen muß man die vorher
undokumentierten Systemvariablen verwenden:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top"><a href="tos_main.html">TOS</a>-Version</td>
  <td align="center" valign="top">Laufwerk A</td>
  <td align="center" valign="top">Laufwerk B</td>
</tr>
<tr>
  <td align="center" valign="top">RAM-<a href="tos_main.html">TOS</a></td>
  <td align="center" valign="top">0x6ca</td>
  <td align="center" valign="top">0x6ce</td>
</tr>
<tr>
  <td align="center" valign="top">1.00</td>
  <td align="center" valign="top">0xa08</td>
  <td align="center" valign="top">0xa0c</td>
</tr>
<tr>
  <td align="center" valign="top">1.02</td>
  <td align="center" valign="top">0xa4e</td>
  <td align="center" valign="top">0xa52</td>
</tr>
</table>
</div>

<br>Zum portablen Setzen kann man die folgende <a href="#Seekrate_20f_C3_BCr_20alle_20TOS-Versionen">Beispielroutine</a> nutzen.
<br>&nbsp;
<br>Das MilanTOS 4.08 (2003.09.03) macht nichts mit den Werten und
liefert immer null zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die vorherige Seekrate als Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht erst ab <a href="tos_main.html">TOS</a> 1.04 zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Floprate">Binding</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopver">Flopver</a> &nbsp; <a href="#Flopfmt">Flopfmt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Floprate">4.14.4.1 Bindings für Floprate</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Floprate">Floprate</a>( int16_t devno, int16_t newrate );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    newrate,-(sp) ; Offset 4
move.w    devno,-(sp)   ; Offset 2
move.w    #41,-(sp)     ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h4><a name="Seekrate_20f_C3_BCr_20alle_20TOS-Versionen">4.14.4.2 Seekrate für alle TOS-Versionen</a></h4>
<pre>/* Portables Setzen der Floppy-Seekrate für alle TOS-Versionen
   (außer RAM-<a href="tos_main.html">TOS</a> 1.00).
   Parameter: genau wie bei <a href="xbios_main.html">XBIOS</a>-Funktion &quot;<a href="#Floprate">Floprate</a>()&quot; */

int16_t SeekRate ( int16_t devno, int16_t newrate )
{
  int32_t stack;
  int16_t version;
  <a href="OSHEADER.html">OSHEADER</a> *sys;

  /* Zeiger auf OS-Header holen */
  stack = <a href="gemdos_system.html#Super">Super</a> (0L);
  sys = *((<a href="OSHEADER.html">OSHEADER</a> **) 0x4f2);
  version = sys-&gt;os_version;
  <a href="gemdos_system.html#Super">Super</a> ((void *)stack);

  /* bei neuem <a href="tos_main.html">TOS</a> einfach &quot;<a href="#Floprate">Floprate</a>()&quot; aufrufen */
  if ( version &gt;= 0x0104 )
    return <a href="#Floprate">Floprate</a> ( devno, newrate );
  else
  {
    /* sonst Zeiger auf interne <a href="gemdos_main.html">GEMDOS</a>-Variablen
       berechnen */
    int16_t *sk, merk;

    if ( version == 0x0102 )
      sk = (int16_t *) 0x0a4e;
    else
      sk = (int16_t *) 0x0a08;

    /* Laufwerk B: 2 int16_t dahinter */
    if ( devno ) sk = &amp;(sk[2]);

    merk = *sk;
    /* Wert nur bei ungleich -1 eintragen */
    if ( newrate != -1 ) *sk = newrate;

    /* alten Wert immer zurückliefern */
    return merk;
  }
}
</pre>
<h3><a name="Floprd">4.14.5 Floprd</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy read« - liest einzelne Sektoren von einer
Platteneinheit.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 8
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Floprd( void *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Floprd liest einen oder mehrere physikalische
Sektoren von einer Diskette. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top"> Zeiger auf Speicherbereich für die eingelesenen Sektoren
</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top"> unbenutzt
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Laufwerk (0 = Laufwerk-A usw.)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top"> Startsektor (normal zwischen 1 und 9)
</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top"> Tracknummer (normal zwischen 0 und 79)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top"> Seite der Diskette (0 oder 1)
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Anzahl der zu lesenden Sektoren

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist, ansonsten einen Fehlercode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Floprd">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Floprd">4.14.5.1 Bindings für Floprd</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Floprd">Floprd</a>( void *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)   ; Offset 18
move.w    sideno,-(sp)  ; Offset 16
move.w    trackno,-(sp) ; Offset 14
move.w    sectno,-(sp)  ; Offset 12
move.w    devno,-(sp)   ; Offset 10
move.l    filler,-(sp)  ; Offset  6
pea       buf           ; Offset  2
move.w    #8,-(sp)      ; Offset  0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $14(sp),sp    ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(8,L:buf%,L:filler%,W:devno%,W:sectno%,W:trackno%,W:sideno%,W:count%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Flopver">4.14.6 Flopver</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy verify« - überprüft Disketten.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 19
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Flopver( void *buf, int32_t filler, int16_t devno,
int16_ sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Flopver überprüft, ob eine Reihe von
Sektoren fehlerfrei von einem Disketten-Laufwerk gelesen werden kann.
Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top"> Zeiger auf einen 1024 Byte großen Speicherbereich, in den die
zu verifizierenden Sektoren eingelesen werden können.
</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top"> unbenutzt (sollte auf 0 gesetzt werden)
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Laufwerk
<br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Laufwerk-A</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Laufwerk-B</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top"> Startsektor (normal zwischen 1 und 9)
</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top"> Tracknummer (normal zwischen 0 und 79)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top"> Seite der Diskette (0 oder 1)
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Anzahl der zu überprüfenden Sektoren

</td></tr>
</table>

<br><b>Hinweis:</b> Nach dem Aufruf findet man im Parameter
<i>buf</i> eine durch Null abgeschlossene Liste von 16-Bit Worten mit
den Nummern der defekten Sektoren. Die Funktion vergleicht also
<i>keine</i> Sektoren mit einem Speicherbereich; stattdessen liest
sie die Sektoren in den immer selben Puffer ein. Dabei wird nur
überprüft, ob die Sektoren korrekt gelesen werden können, oder ob
beim Lesen Lesefehler auftreten.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis den Wert 0, wenn die im
Parameter <i>buf</i> abgelegte Liste gültig ist und anderenfalls
einen Wert ungleich Null.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Flopver">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Flopver">4.14.6.1 Bindings für Flopver</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Flopver">Flopver</a>( void *buf, int32_t filler, int16_t devno,
int16_ sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)    ; Offset 18
move.w    sideno,-(sp)   ; Offset 16
move.w    trackno,-(sp)  ; Offset 14
move.w    sectno,-(sp)   ; Offset 12
move.w    devno,-(sp)    ; Offset 10
move.l    filler,-(sp)   ; Offset  6
pea       buf            ; Offset  2
move.w    #19,-(sp)      ; Offset  0
trap      #14            ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $14(sp),sp     ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(19,L:buf%,L:filler%,W:devno%,W:sectno,W:trackno%,W:sideno%,W:count%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Flopwr">4.14.7 Flopwr</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy write« - schreibt einzelne Sektoren auf eine
Platteneinheit.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 9
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Flopwr( VOID *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Flopwr schreibt einen oder mehrere
physikalische Sektoren auf eine Diskette. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top"> Zeiger auf Speicherbereich mit den zu schreibenden Sektoren
</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top"> unbenutzt
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Laufwerk (0=Laufwerk-A, 1=Laufwerk-B)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top"> Startsektor (normal zwischen 1 und 9)
</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top"> Tracknummer (normal zwischen 0 und 79)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top"> Seite der Diskette (0 oder 1)
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Anzahl der zu schreibenden Sektoren

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis eine 0, wenn kein Fehler
passiert ist, ansonsten einen Fehlercode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Flopwr">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Floprd">Floprd</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Flopwr">4.14.7.1 Bindings für Flopwr</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Flopwr">Flopwr</a>( VOID *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)    ; Offset 18
move.w    sideno,-(sp)   ; Offset 16
move.w    trackno,-(sp)  ; Offset 14
move.w    sectno,-(sp)   ; Offset 12
move.w    devno,-(sp)    ; Offset 10
move.l    filler,-(sp)   ; Offset  6
pea       buf            ; Offset  2
move.w    #9,-(sp)       ; Offset  0
trap      #14            ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $14(sp),sp     ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(9,L:buf%,L:filler%,W:devno%,W:sectno%,W:trackno%,W:sideno,W:count%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Metaclose">4.14.8 Metaclose</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaclose« - gibt ein MetaDOS-Gerät wieder frei.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 50
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metaclose( int16_t drive );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion gibt das Laufwerk <i>drive</i> wieder frei.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metaclose">Binding</a> &nbsp; <a href="#Metaopen">Metaopen</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaclose">4.14.8.1 Bindings für Metaclose</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaclose">Metaclose</a>( int16_t drive );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    drive,-(sp)  ; Offset 2
move.w    #50,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metadiscinfo">4.14.9 Metadiscinfo</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metadiscinfo« - ermittelt aktuelle Status-Informationen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 63
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metadiscinfo( int16_t drive, <a href="xbios_structures.html#CD_DISC_INFO">CD_DISC_INFO</a> *p );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ermittelt Informationen über den Status eines
<a href="xbios_metados.html">MetaDOS</a>-Gerätes. Es gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">gewünschtes Laufwerk</td>
</tr>
<tr>
  <td align="left" valign="top">p</td>
  <td align="left" valign="top">Adresse des aufnehmenden Puffers</td>
</tr>
</table>
</div>

<br><b>Hinweis:</b> Die Positionsangaben innerhalb der Struktur
sind im BCD-MSF-Format codiert. Die Komponente <i>index</i> wird von
alten BOS-Treibern nicht gesetzt, und die Komponente <i>disctype</i>
ist bei SCSI-CD-ROMs nicht gesetzt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem MetaDOS zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metadiscinfo">Binding</a> &nbsp; <a href="#Metastatus">Metastatus</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metadiscinfo">4.14.9.1 Bindings für Metadiscinfo</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metadiscinfo">Metadiscinfo</a>( int16_t drive, <a href="xbios_structures.html#CD_DISC_INFO">CD_DISC_INFO</a> *p );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       p            ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #63,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metagettoc">4.14.10 Metagettoc</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metagettoc« - liefert das Inhaltsverzeichnis eines Gerätes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 62
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metagettoc( int16_t drive, int16_t flag, <a href="xbios_structures.html#CD_TOC_ENTRY">CD_TOC_ENTRY</a>
*buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert das Inhaltsverzeichnis eines Laufwerks zurück. Es
gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">gewünschtes Laufwerk</td>
</tr>
<tr>
  <td align="left" valign="top">flag</td>
  <td align="left" valign="top">reserviert für CDAR504</td>
</tr>
<tr>
  <td align="left" valign="top">buffer</td>
  <td align="left" valign="top">Puffer zur Aufnahme des Verzeichnisses</td>
</tr>
</table>
</div>

<br><b>Hinweis:</b> Der aufnehmende Puffer sollte Platz für 128
Einträge bieten. Jeder Eintrag besteht aus einer Tracknummer und
MSF-Adresse (jeweils im BCD-Format). Für die Tracknummer gilt dabei:
<br>0 = Record hat keine Bedeutung
<br>0x01...0x99 = Tracknummer in BCD-Codierung
<br>0xa0 = erster Track bei programmierter Reihenfolge
<br>0xa2 = Ende der CD.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metagettoc">Binding</a> &nbsp; <a href="#Metaread">Metaread</a> &nbsp; <a href="#Metawrite">Metawrite</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metagettoc">4.14.10.1 Bindings für Metagettoc</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metagettoc">Metagettoc</a>( int16_t drive, int16_t flag, <a href="xbios_structures.html#CD_TOC_ENTRY">CD_TOC_ENTRY</a>
*buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 6
move.w    flag,-(sp)   ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #62,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metainit">4.14.11 Metainit</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metainit« - Informationen über die installierte Version von
<a href="xbios_metados.html">MetaDOS</a> ermitteln.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 48
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Metainit( <a href="xbios_structures.html#META_INFO_1">META_INFO_1</a> *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Metainit ermittelt Informationen über die
aktuell installierte Version von <a href="xbios_metados.html">MetaDOS</a>, und der ihr bekannten
Geräte.
<br>&nbsp;
<br>Es bietet sich folgendes Verfahren an:
<br>&nbsp;
<ul>
<li> Inhalt der <a href="xbios_structures.html#META_INFO_1">META_INFO_1</a> Struktur komplett löschen
</li>
<li> Funktion Metainit aufrufen
</li>
<li> Testen, ob die Komponente <i>version</i> noch einen Nullzeiger
enthält (dann ist <i>kein</i> MetaDOS installiert).
</li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein direktes Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metainit">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metainit">4.14.11.1 Bindings für Metainit</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Metainit">Metainit</a>( <a href="xbios_structures.html#META_INFO_1">META_INFO_1</a> *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 2
move.w    #48,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metaioctl">4.14.12 Metaioctl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaioctl« - schickt GEMDOS-Opcodes an ein MetaDOS Gerät.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 55
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metaioctl( int16_t drive, int32_t magic, int16_t
opcode, void *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion erlaubt es, Opcodes der GEMDOS-Routinen Dcntl
bzw. Fcntl an ein <a href="xbios_metados.html">MetaDOS</a> Gerät abzusetzen. Es gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">gewünschtes Laufwerk</td>
</tr>
<tr>
  <td align="left" valign="top">magic</td>
  <td align="left" valign="top">muss Wert 'FCTL' besitzen</td>
</tr>
<tr>
  <td align="left" valign="top">opcode</td>
  <td align="left" valign="top">abzusetzender Opcode</td>
</tr>
<tr>
  <td align="left" valign="top">buffer</td>
  <td align="left" valign="top">abhängig vom Opcode</td>
</tr>
</table>
</div>

<br><b>Hinweis:</b> Die <a href="gemdos_file.html#CD-ROM-Funktionen">Liste der CD-ROM Kommandos</a> ist eine Aufstellung aller bekannten
Opcodes, die bei der Arbeit mit CD-ROMs anfallen können.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert im Fehlerfall einen der folgenden Werte
zurück:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EINVFN">EINVFN</a>:</td>
<td valign="top"> der angegebene Opcode wird nicht unterstützt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="bios_errors.html#EUNCMD">EUNCMD</a>:</td>
<td valign="top"> die Funktion selbst (!) wird nicht unterstützt.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem MetaDOS zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metaioctl">Binding</a> &nbsp; <a href="gemdos_directory.html#Dcntl">Dcntl</a> &nbsp; <a href="gemdos_file.html#Fcntl">Fcntl</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaioctl">4.14.12.1 Bindings für Metaioctl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaioctl">Metaioctl</a>( int16_t drive, int32_t magic, int16_t
opcode, void *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 10
move.w    opcode,-(sp) ; Offset  8
move.l    magic,-(sp)  ; Offset  4
move.w    drive,-(sp)  ; Offset  2
move.w    #55,-(sp)    ; Offset  0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $E(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metaopen">4.14.13 Metaopen</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaopen« - initialisiert ein MetaDOS-Gerät.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 49
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metaopen( int16_t drive, <a href="xbios_structures.html#META_DRVINFO">META_DRVINFO</a> *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion initialisiert ein MetaDOS-Gerät. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> gewünschtes Laufwerk
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Puffer zur Aufnahme des Namens des Treibers

</td></tr>
</table>

<br><b>Hinweis:</b> Falls der Treibername mit 'CD' beginnt, darf
man davon ausgehen, daß es sich um einen CD-ROM-Treiber handelt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert 0 wenn alles OK
oder eine negative Fehlernummer.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metaopen">Binding</a> &nbsp; <a href="#Metaclose">Metaclose</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaopen">4.14.13.1 Bindings für Metaopen</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaopen">Metaopen</a>( int16_t drive, <a href="xbios_structures.html#META_DRVINFO">META_DRVINFO</a> *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #49,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metaread">4.14.14 Metaread</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaread« - liest Daten von einem MetaDOS-Gerät.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 51
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metaread( int16_t drive, void *buffer, int32_t blockno,
int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liest Daten von einem MetaDOS-Gerät. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> gewünschtes Laufwerk
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Puffer zur Aufnahme der Daten
</td></tr>

<tr><td nowrap="nowrap" valign="top">blockno</td>
<td valign="top"> Nummer des Startblocks
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Anzahl der zu lesenden Blöcke

</td></tr>
</table>

<br><b>Hinweis:</b> Die Blockgröße beträgt bei CD-ROMs 2048
Bytes; dies kann jedoch leider nicht gezielt abgefragt werden.
Aufgrund einer Begrenzung in Atari's BOS-Treibern können maximal 63
Blöcke an einem Stück gelesen werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metaread">Binding</a> &nbsp; <a href="#Metawrite">Metawrite</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaread">4.14.14.1 Bindings für Metaread</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaread">Metaread</a>( int16_t drive, void *buffer, int32_t blockno,
int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)   ; Offset 10
move.l    blockno,-(sp) ; Offset  8
pea       buffer        ; Offset  4
move.w    drive,-(sp)   ; Offset  2
move.w    #51,-(sp)     ; Offset  0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $E(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metaseek">4.14.15 Metaseek</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaseek« - Seeks to a physical address.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 53
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Binding:</td>
<td valign="top"> int32_t Metaseek( int16_t drive, int32_t blockno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> The function will seek the physical unit to a physical address.
The function call will return once the seek has been completed or on
an error condition. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> gewünschtes Laufwerk
</td></tr>

<tr><td nowrap="nowrap" valign="top">blockno</td>
<td valign="top"> Block number to seek to

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metaseek">Binding</a> &nbsp; <a href="#Metaread">Metaread</a> &nbsp; <a href="#Metawrite">Metawrite</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metaseek">4.14.15.1 Bindings für Metaseek</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaseek">Metaseek</a>( int16_t drive, int32_t blockno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    blockno,-(sp)    ; Offset 4
move.w    drive            ; Offset 2
move.w    #53,-(sp)        ; Offset 0
trap      #14              ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp            ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metasetsongtime">4.14.16 Metasetsongtime</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metasetsongtime« - startet eine Audio-Wiedergabe.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 61
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Binding:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metasetsongtime">Bindings für Metasetsongtime</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion startet eine Audio-Wiedergabe. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> gewünschtes Laufwerk
</td></tr>

<tr><td nowrap="nowrap" valign="top">repeat</td>
<td valign="top"> Repeat
<br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">ohne Wiederholung</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">mit Wiederholung</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">starttime</td>
<td valign="top"> BCD-Anfangszeit in MSF-Codierung
</td></tr>

<tr><td nowrap="nowrap" valign="top">endtime</td>
<td valign="top"> BCD-Endzeit in MSF-Codierung

</td></tr>
</table>

<br><b>Hinweis:</b> Der Repeat-Modus wird anscheinend nur von
CDARGEN.BOS und auch nur für das Atari-CDAR504 unterstützt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metasetsongtime">Binding</a> &nbsp; <a href="#Metastartaudio">Metastartaudio</a> &nbsp; <a href="#Metastopaudio">Metastopaudio</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metasetsongtime">4.14.16.1 Bindings für Metasetsongtime</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metasetsongtime">Metasetsongtime</a>( int16_t drive, int16_t repeat, int32_t
starttime, int32_t endtime );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    endtime,-(sp)    ; Offset 10
move.l    starttime,-(sp)  ; Offset  6
move.w    repeat           ; Offset  4
move.w    drive            ; Offset  2
move.w    #61,-(sp)        ; Offset  0
trap      #14              ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $E(sp),sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metastartaudio">4.14.17 Metastartaudio</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metastartaudio« - startet eine Audio-Wiedergabe.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 59
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Binding:</td>
<td valign="top"> int32_t Metastartaudio( int16_t drive, int16_t flag, uint8_t
*bytearray);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion startet eine Audio-Wiedergabe. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> gewünschtes Laufwerk
</td></tr>

<tr><td nowrap="nowrap" valign="top">flag</td>
<td valign="top"> Modus
</td></tr>

<tr><td nowrap="nowrap" valign="top">bytearray</td>
<td valign="top"> abhängig vom Parameter flag

</td></tr>
</table>

<br><b>Hinweis:</b> Auf SCSI-Geräten existiert nur ein Modus (flag
= 0). In diesem Fall übergibt man in <i>bytearray[0]</i> die Anzahl
der Lieder, und in <i>bytearray[1]</i> die Nummer des ersten Liedes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metastartaudio">Binding</a> &nbsp; <a href="#Metasetsongtime">Metasetsongtime</a> &nbsp; <a href="#Metastopaudio">Metastopaudio</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metastartaudio">4.14.17.1 Bindings für Metastartaudio</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metastartaudio">Metastartaudio</a>( int16_t drive, int16_t flag, uint8_t
*bytearray);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       bytearray    ; Offset 6
move.w    flag,-(sp)   ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #59,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metastatus">4.14.18 Metastatus</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metastatus« - ermittelt den Status eines MetaDOS Gerätes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 54
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metastatus( int16_t drive, void *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion ermittelt den Status eines MetaDOS Gerätes. Es
gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> gewünschtes Laufwerk
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> abhängig von der Implementierung des BOS-Treibers

</td></tr>
</table>

<br><b>Achtung:</b> Diese Funktion ist optional. Sie steht nur bei
installiertem <a href="xbios_metados.html">MetaDOS</a> zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen 32-Bit Wert zurück,
der wie folgt codiert ist:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">High-Word:</td>
<td valign="top">
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0x0000</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">alles ok</td>
</tr>
<tr>
  <td align="left" valign="top">0xffff</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Fehler aufgetreten</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Low-Word :</td>
<td valign="top">
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Bit-15</td>
  <td align="left" valign="top">(Fehler)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-07</td>
  <td align="left" valign="top">(Timeout)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-02</td>
  <td align="left" valign="top">(Medienwechsel)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-01</td>
  <td align="left" valign="top">(Busy)</td>
</tr>
</table>
</div>


</td></tr>
</table>

<br>Alle anderen Bits des Low-Words sind z.Zt. reserviert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metastatus">Binding</a> &nbsp; <a href="#Metadiscinfo">Metadiscinfo</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metastatus">4.14.18.1 Bindings für Metastatus</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metastatus">Metastatus</a>( int16_t drive, void *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #54,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metastopaudio">4.14.19 Metastopaudio</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metastopaudio« - beendet eine Audio-Wiedergabe.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 60
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metastopaudio( int16_t drive );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion beendet die Audio-Wiedergabe für das Laufwerk
<i>drive</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metastopaudio">Binding</a> &nbsp; <a href="#Metastartaudio">Metastartaudio</a> &nbsp; <a href="#Metasetsongtime">Metasetsongtime</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metastopaudio">4.14.19.1 Bindings für Metastopaudio</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metastopaudio">Metastopaudio</a>( int16_t drive );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    drive,-(sp)  ; Offset 2
move.w    #60,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Metawrite">4.14.20 Metawrite</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metawrite« - schreibt Daten auf ein MetaDOS-Gerät.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 52
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Metawrite( int16_t drive, void *buffer, int32_t
blockno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion schreibt Daten auf ein MetaDOS-Gerät. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> gewünschtes Laufwerk
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Adresse des Datenpuffers
</td></tr>

<tr><td nowrap="nowrap" valign="top">blockno</td>
<td valign="top"> Nummer des Startblocks
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Anzahl der zu schreibenden Blöcke

</td></tr>
</table>

<br><b>Hinweis:</b> Bei einem CD-ROM hat diese Funktion natürlich
keine Wirkung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis einen Wert vom Typ int32_t
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Diese Funktion steht nur bei installiertem <a href="xbios_metados.html">MetaDOS</a> zur
Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Metawrite">Binding</a> &nbsp; <a href="#Metaread">Metaread</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Metawrite">4.14.20.1 Bindings für Metawrite</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metawrite">Metawrite</a>( int16_t drive, void *buffer, int32_t
blockno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)   ; Offset 10
move.l    blockno,-(sp) ; Offset  8
pea       buffer        ; Offset  4
move.w    drive,-(sp)   ; Offset  2
move.w    #52,-(sp)     ; Offset  0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $E(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Protobt">4.14.21 Protobt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »prototype boot sector« - Standard-Boot-Sektor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 18
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Protobt( void *buf, int32_t serialno, int16_t disktype,
int16_t execflag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Protobt legt einen Boot-Sektor auf einer
Diskette an. Das Argument <i>buf</i> verweist auf einen 512 Byte
großen Puffer mit dem Inhalt des Boot-Sektors. Der Parameter
<i>serialno</i> dient dazu, eine Seriennummer im Bootsektor
abzuspeichern. Wenn die Variable <i>serialno</i> größer als
0x01000000 ist, dann wird eine Zufallszahl abgelegt. Mit
<i>disktype</i> wird eine der folgenden Diskettenarten ausgewählt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">disktype</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;-1</td>
<td valign="top"> nicht verändern
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;0</td>
<td valign="top"> 40 Spuren, einseitig&nbsp;&nbsp;&nbsp; (180 Kbyte)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;1</td>
<td valign="top"> 40 Spuren, doppelseitig (360 Kbyte)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;2</td>
<td valign="top"> 80 Spuren, einseitig&nbsp;&nbsp;&nbsp; (360 Kbyte)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;3</td>
<td valign="top"> 80 Spuren, doppelseitig (720 Kbyte)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;4</td>
<td valign="top"> <b>High-Density</b> (1,44 Mbyte)
<br>Wird nur unterstützt, wenn im Cookie <a href="bios_cookiejar.html#Cookie_2C_20_FDC">_FDC</a> der Wert für
HD-Unterstützung eingetragen ist.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;5</td>
<td valign="top"> <b>Extra-High-Density</b> (2,88 Mbyte)
<br>Wird nur unterstützt, wenn im Cookie _FDC der Wert für
ED-Unterstützung eingetragen ist.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;6</td>
<td valign="top"> 80 Spuren, doppelseitig, 10 Sektoren (800 Kbyte)
<br>Wird nur von EmuTOS seit 2024/12/28 unterstützt.

</td></tr>
</table>

<br>Der Parameter <i>execflag</i> legt schließlich fest, ob die
Informationen im Boot-Sektor als Programm ausgeführt werden können.
Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">execflag</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> Bootsektor nicht verändern
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top"> Bootsektor nicht ausführen
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top"> Bootsektor ausführbar

</td></tr>
</table>

<br><b>Hinweis:</b> Damit Disketten auch auf MSDOS-Systemen gelesen
werden können, müssen in die ersten 3 Bytes des Bootsektors die
Werte 0xE9, 0x00 und 0x4E oder 0xEB, 0x34 und 0x90 eingetragen werden;
auf diese Art und Weise behandelte Disketten sind unter <a href="tos_main.html">TOS</a> dann
allerdings <i>nicht</i> mehr bootbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Laufwerksfunktionen">Laufwerksfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Protobt">Binding</a> &nbsp; <a href="#Flopfmt">Flopfmt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Protobt">4.14.21.1 Bindings für Protobt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Protobt">Protobt</a>( void *buf, int32_t serialno, int16_t disktype,
int16_t execflag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    execflag,-(sp)  ; Offset 12
move.w    disktype,-(sp)  ; Offset 10
move.l    serialno,-(sp)  ; Offset  6
pea       buf             ; Offset  2
move.w    #18,-(sp)       ; Offset  0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $E(sp),sp       ; Stack korrigieren
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top"> Fehler%=Xbios(18,L:buf%,L:serialno%,W:disktype%,W:execflag%)
<br>&nbsp;

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_interrupt.html"><img src="udo_lf.gif" alt="Interruptfunktionen" title="Interruptfunktionen" border="0" width="24" height="24">Interruptfunktionen</a>
<a name="UDO_nav_rg_FOOT" href="matrix_XBIOS_extension.html"><img src="udo_rg.gif" alt="MATRIX-XBIOS-Erweiterung" title="MATRIX-XBIOS-Erweiterung" border="0" width="24" height="24">MATRIX-XBIOS-Erweiterung</a>
</body>
</html>
