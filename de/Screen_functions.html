<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 20.12.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Bildschirmfunktionen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_trap.html"><img src="udo_lf.gif" alt="xbios-Trap" title="xbios-Trap" border="0" width="24" height="24">xbios-Trap</a>
<a name="UDO_nav_rg_HEAD" href="CENTScreen_XBIOS_extension.html"><img src="udo_rg.gif" alt="CENTScreen-XBIOS-Erweiterung" title="CENTScreen-XBIOS-Erweiterung" border="0" width="24" height="24">CENTScreen-XBIOS-Erweiterung</a>

<hr>

<h1><a name="Bildschirmfunktionen">4.5 Bildschirmfunktionen</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Cursconf">Cursconf</a></td>
<td valign="top"> Cursordarstellung ändern oder ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EgetPalette">EgetPalette</a></td>
<td valign="top"> Farbtabelle lesen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EgetShift">EgetShift</a></td>
<td valign="top"> Shift Mode Register lesen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetBank">EsetBank</a></td>
<td valign="top"> Farbtabelle setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetColor">EsetColor</a></td>
<td valign="top"> Farbtabelleneintrag setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetGray">EsetGray</a></td>
<td valign="top"> Farbinterpretation setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetPalette">EsetPalette</a></td>
<td valign="top"> Farbtabelle laden.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetShift">EsetShift</a></td>
<td valign="top"> Shift Mode Register setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetSmear">EsetSmear</a></td>
<td valign="top"> Farbverwischung setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Getrez">Getrez</a></td>
<td valign="top"> Auflösung ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Initmouse">Initmouse</a></td>
<td valign="top"> Mauszeiger initialisieren.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Logbase">Logbase</a></td>
<td valign="top"> Adresse des logischen Bildschirmspeichers ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#mon_type">mon_type</a></td>
<td valign="top"> Monitortyp ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Physbase">Physbase</a></td>
<td valign="top"> Adresse des physikal. Bildschirmspeichers ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Setcolor">Setcolor</a></td>
<td valign="top"> Farbe einstellen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Setpalette">Setpalette</a></td>
<td valign="top"> Farbpalette auswählen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Setscreen">Setscreen</a></td>
<td valign="top"> Festlegen der Bildschirmauflösung und -adressen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#ValidMode">ValidMode</a></td>
<td valign="top"> Validates a mode code.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VgetRGB">VgetRGB</a></td>
<td valign="top"> RGB-Wert einer Farbe ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetScreen">VsetScreen</a></td>
<td valign="top"> Festlegen der Bildschirmauflösung und -adressen
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VgetSize">VgetSize</a></td>
<td valign="top"> Größe des Bildschirmpuffers ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetMask">VsetMask</a></td>
<td valign="top"> Transparenz für True-Color setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetMode">VsetMode</a></td>
<td valign="top"> Videohardwareregister setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetRGB">VsetRGB</a></td>
<td valign="top"> RGB-Wert einer Farbe setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetSync">VsetSync</a></td>
<td valign="top"> Synchronisationsart setzen.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Vsync">Vsync</a></td>
<td valign="top"> Vertikales Synchronisationssignal abfragen.

</td></tr>
</table>

<h3><a name="Cursconf">4.5.1 Cursconf</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »cursor configuration« - legt die Arbeitsweise des Cursors
fest.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 21
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Cursconf( int16_t func, int16_t rate );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Routine Cursconf verändert das Aussehen und
wahlweise die Blinkgeschwindigkeit des Cursors. Der Parameter
<i>func</i> kann folgende Werte annehmen:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">func</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top"> Cursor abschalten
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top"> Cursor einschalten
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;2</td>
<td valign="top"> Cursor blinkt
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;3</td>
<td valign="top"> Cursor blinkt nicht
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;4</td>
<td valign="top"> Die Blinkgeschwindigkeit des Cursors wird auf den Wert
<i>rate</i> gesetzt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;5</td>
<td valign="top"> Liefert die aktuelle Blinkfrequenz
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;6</td>
<td valign="top"> Die Blinkverzögerung des Cursors wird auf den Wert
<i>rate</i> gesetzt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;7</td>
<td valign="top"> Liefert die aktuelle Blinkverzögerung

</td></tr>
</table>

<br><b>Hinweis:</b> Der Parameter <i>rate</i> soll in Schritten
der Wiederholfrequenz des Bildschirms verwendet werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert nur dann ein definiertes Ergebnis,
nämlich die Blinkfrequenz, wenn im Parameter <i>func</i> die Zahl 5
oder 7 übergeben wurde.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>Parameter 6 and 7 sind verfügbar mit TOS Version &gt;= 1.02.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Cursconf">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Cursconf">4.5.1.1 Bindings für Cursconf</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Cursconf">Cursconf</a>( int16_t func, int16_t rate );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    rate,-(sp)   ; Offset 4
move.w    func,-(sp)   ; Offset 2
move.w    #21,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="EgetPalette">4.5.2 EgetPalette</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get look up table registers« - Liest mehrere Einträge aus
der Farbtabelle.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 85
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void EgetPalette( int16_t colorNum, int16_t count, int16_t
*palettePtr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine EgetPalette liest einen zusammenhängenden
Bereich aus den TT-Farbregistern aus.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">colorNum</td>
<td valign="top"> erstes auszulesendes Farbregister
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Anzahl der auszulesenden Farbregister
</td></tr>

<tr><td nowrap="nowrap" valign="top">palettePtr</td>
<td valign="top"> Zeiger auf zu übertragende Farbpalette (dieser muß gerade
sein).

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht nur im <a href="tos_main.html">TOS</a> des Atari-TT zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20EgetPalette">Binding</a> &nbsp; <a href="#EsetPalette">EsetPalette</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EgetPalette">4.5.2.1 Bindings für EgetPalette</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#EgetPalette">EgetPalette</a>( int16_t colorNum, int16_t count, int16_t
*palettePtr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       palettePtr      ; Offset 6
move.w    count,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #85,-(sp)       ; Offset 0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $A(sp),sp       ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="EgetShift">4.5.3 EgetShift</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get current shift mode value« - Liest das Shift Mode
Register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 81
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t EgetShift( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine EgetShift liest das Shift Mode Register aus
und liefert den Inhalt des <a href="xbios_dhs.html#Registers">Registers</a> als Ergebnis zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den Wert des <a href="xbios_dhs.html#Registers">Registers</a> gemäß folgender
Belegung:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">0..3</td>
  <td align="left" valign="top">Nummer der Farbregister-Bank</td>
</tr>
<tr>
  <td align="left" valign="top">8..10</td>
  <td align="left" valign="top">Modus, gemäß <a href="#Getrez">Getrez</a></td>
</tr>
<tr>
  <td align="left" valign="top">12</td>
  <td align="left" valign="top">Hyper-Mono  (vgl. <a href="#EsetGray">EsetGray</a>)</td>
</tr>
<tr>
  <td align="left" valign="top">15</td>
  <td align="left" valign="top">Smear-Modus (vgl. <a href="#EsetSmear">EsetSmear</a>)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht nur im <a href="tos_main.html">TOS</a> des Atari-TT zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20EgetShift">Binding</a> &nbsp; <a href="#EsetShift">EsetShift</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EgetShift">4.5.3.1 Bindings für EgetShift</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EgetShift">EgetShift</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #81,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="EsetBank">4.5.4 EsetBank</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set color look up bank« - Setzt Bank für Farbtabelle.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 82
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t EsetBank( int16_t bankNum );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine EsetBank setzt die Banknummer für die
Farbtabelle des TT auf den Wert <i>bankNum</i>. Der erlaubte Wert von
bankNum liegt zwischen 0 und 15. Ist <i>bankNum</i> negativ, wird die
aktuelle Einstellung nicht verändert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die vorherige Einstellung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht nur im <a href="tos_main.html">TOS</a> des Atari-TT zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20EsetBank">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetBank">4.5.4.1 Bindings für EsetBank</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetBank">EsetBank</a>( int16_t bankNum );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    bankNum,-(sp)  ; Offset 2
move.w    #82,-(sp)      ; Offset 0
trap      #14            ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp          ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="EsetColor">4.5.5 EsetColor</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set color entry« - Schreibt einen Eintrag in die
Farbtabelle.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 83
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t EsetColor( int16_t colorNum, int16_t color );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine EsetColor setzt den Farbeintrag
<i>colorNum</i> (0..255) in der Farbtabelle auf den Wert
<i>color</i>; ein negativer Wert verändert den Eintag nicht.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die vorherige Einstellung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht nur im <a href="tos_main.html">TOS</a> des Atari-TT zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20EsetColor">Binding</a> &nbsp; <a href="#Setcolor">Setcolor</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetColor">4.5.5.1 Bindings für EsetColor</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetColor">EsetColor</a>( int16_t colorNum, int16_t color );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    color,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #83,-(sp)       ; Offset 0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp           ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="EsetGray">4.5.6 EsetGray</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set/clear gray mode« - Schaltet die Farbinterpretation ein
bzw. aus.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 86
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t EsetGray( int16_t switch );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine EsetGray schaltet die Farbinterpretation in
der Farbtabelle als Graustufe ein (1) bzw. aus (0). Ein negativer Wert
verändert die Einstellung nicht.
<br>&nbsp;
<br>Im Graustufen-Modus kann anstelle von 4096 Farbtönen aus einer
Palette von 256 Graustufen gewählt werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die bisherige Einstellung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht nur im <a href="tos_main.html">TOS</a> des Atari-TT zur Verfügung (when
the high word of the '_VDO' cookie has the value of 2).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20EsetGray">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetGray">4.5.6.1 Bindings für EsetGray</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetGray">EsetGray</a>( int16_t switch );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    switch,-(sp) ; Offset 2
move.w    #86,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="EsetPalette">4.5.7 EsetPalette</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set palette registers« - Setzt mehrere Einträge in der
Farbtabelle.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 84
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void EsetPalette( int16_t colorNum, int16_t count, int16_t
*palettePtr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine EsetPalette setzt <i>count</i> Farbeinträge
ab <i>colorNum</i> in der Farbtabelle auf die Werte im Array
<i>palettePtr</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion hat kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht nur im <a href="tos_main.html">TOS</a> des Atari-TT zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20EsetPalette">Binding</a> &nbsp; <a href="#EgetPalette">EgetPalette</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetPalette">4.5.7.1 Bindings für EsetPalette</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#EsetPalette">EsetPalette</a>( int16_t colorNum, int16_t count, int16_t
*palettePtr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       palettePtr      ; Offset 6
move.w    count,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #84,-(sp)       ; Offset 0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $A(sp),sp       ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="EsetShift">4.5.8 EsetShift</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set shift mode register« - Setzt das Shift Mode Register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 80
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t EsetShift( int16_t shftMode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Routine EsetShift schreibt in das Shift Mode
Register des TT den Wert <i>shftMode</i>. shftMode ist ein Bitfeld
mit folgender Bedeutung:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">0..3</td>
  <td align="left" valign="top">Nummer der Farbregister-Bank</td>
</tr>
<tr>
  <td align="left" valign="top">8..10</td>
  <td align="left" valign="top">Modus, gemäß <a href="#Getrez">Getrez</a></td>
</tr>
<tr>
  <td align="left" valign="top">12</td>
  <td align="left" valign="top">Hyper-Mono  (vgl. <a href="#EsetGray">EsetGray</a>)</td>
</tr>
<tr>
  <td align="left" valign="top">15</td>
  <td align="left" valign="top">Smear-Modus (vgl. <a href="#EsetSmear">EsetSmear</a>)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den vorherigen Wert des <a href="xbios_dhs.html#Registers">Registers</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht nur im TOS des Atari-TT zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20EsetShift">Binding</a> &nbsp; <a href="#EgetShift">EgetShift</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetShift">4.5.8.1 Bindings für EsetShift</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetShift">EsetShift</a>( int16_t shftMode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    shftMode,-(sp)  ; Offset 2
move.w    #80,-(sp)       ; Offset 0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp           ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="EsetSmear">4.5.9 EsetSmear</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set/clear video smear mode« - Schaltet die Farbverwischung
ein bzw. aus.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 87
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t EsetSmear( int16_t switch );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Routine EsetSmear erlaubt die Umschaltung des
Smear-Modus des TT-Videobausteins. Im Smear-Modus wird anstelle der
Hintergrundfarbe (Farbe 0) die jeweils zuletzt dargestellte Farbe
gezeichnet. Es gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">switch</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">&lt;0</td>
  <td align="left" valign="top">bisherigen Wert abfragen</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Smear-Modus aus</td>
</tr>
<tr>
  <td align="center" valign="top">&gt;0</td>
  <td align="left" valign="top">Smear-Modus ein</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die bisherige Einstellung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion steht nur im TOS des Atari-TT zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20EsetSmear">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20EsetSmear">4.5.9.1 Bindings für EsetSmear</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetSmear">EsetSmear</a>( int16_t switch );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    switch,-(sp)  ; Offset 2
move.w    #87,-(sp)     ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Getrez">4.5.10 Getrez</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »get resolution« - ermittelt die Auflösung des Bildschirms.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 4
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Getrez( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Getrez ermittelt die Auflösung des
Bildschirms.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis folgende Werte:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">Werte</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">&nbsp;320*200 (vier Planes)</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">&nbsp;640*200 (zwei Planes)</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">&nbsp;640*400 (ein Plane)</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">&nbsp;640*480 (vier Planes, nur TT)</td>
</tr>
<tr>
  <td align="center" valign="top">6</td>
  <td align="left" valign="top">1280*960 (ein Plane,   nur TT)</td>
</tr>
<tr>
  <td align="center" valign="top">7</td>
  <td align="left" valign="top">&nbsp;320*480 (acht Planes, nur TT)</td>
</tr>
</table>
</div>

<br>Alle anderen Werte sind für zukünftige Erweiterungen
reserviert.
<br>&nbsp;
<br><b>Hinweis:</b> Vom Standpunkt der sauberen Programmierung
betrachtet, <i>sollte diese Funktion auf keinen Fall benutzt
werden</i>. Insbesondere beim Einsatz von Grafikkarten hat sie
praktisch keinen Aussagewert. Stattdessen sollte die Auflösung des
Bildschirms über das <a href="About_the_VDI.html">VDI</a> (<a href="vdi_control.html#v_opnvwk">v_opnvwk</a>) ermittelt werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Getrez">Binding</a> &nbsp; <a href="vdi_control.html#v_opnvwk">v_opnvwk</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Getrez">4.5.10.1 Bindings für Getrez</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;portab.h&gt;
<br>#include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Getrez">Getrez</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #4,-(sp)     ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Initmouse">4.5.11 Initmouse</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »initialize mouse« - initialisiert die Maus.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Initmouse( int16_t type, <a href="xbios_structures.html#MOUSE">MOUSE</a> *par, void (*mousevec)() );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Initmouse ist eine XBIOS-Routine zur Low-Level-Initialisierung
der Maus. Der Parameter <i>type</i> legt die Betriebsart der Maus
fest. Es gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">type</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Maus abschalten</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Maus einschalten, Relativ-Modus</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Maus einschalten, Absolut-Modus</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">reserviert</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">Maus einschalten, Tastaturemulation</td>
</tr>
</table>
</div>

<br>Die Bytes von 4 bis 11 des Parameters <i>par</i> werden nur
dann verwendet, wenn die Maus im Absolut-Modus arbeiten soll. Mit
<i>mousevec</i> kann ein neuer Interrupt-Vektors der Maus gesetzt
werden. Der Vektor wird zurückgesetzt wenn die Maus abgeschaltet wird
(type=0).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert -1 alles OK ist oder 0 falls ein Fehler
aufgetreten ist.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Initmouse">Binding</a> &nbsp; <a href="xbios_structures.html#MOUSE">MOUSE</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Initmouse">4.5.11.1 Bindings für Initmouse</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Initmouse">Initmouse</a>( int16_t type, <a href="xbios_structures.html#MOUSE">MOUSE</a> *par, void (*mousevec)() );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       mousevec     ; Offset 8
pea       par          ; Offset 4
move.w    type,-(sp)   ; Offset 2
move.w    #0,-(sp)     ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Logbase">4.5.12 Logbase</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »logical screen RAM base« - ermittelt die logische
Anfangsadresse des Videospeichers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 3
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void *Logbase( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Routine Logbase ermittelt die logische
Anfangsadresse des momentan als Videospeicher verwendeten
RAM-Bereichs.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis die Anfangsadresse des
logischen Bildschirmspeichers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Logbase">Binding</a> &nbsp; <a href="#Physbase">Physbase</a> &nbsp; <a href="#Setscreen">Setscreen</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Logbase">4.5.12.1 Bindings für Logbase</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void *<a href="#Logbase">Logbase</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #3,-(sp)     ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="mon_type">4.5.13 mon_type</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »mon_type« - Typ des Monitors ermitteln
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 89
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t mon_type( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Funktion mon_type ermittelt den angeschlossenen
Monitortyp anhand von Pin 18(M1) und 19(M0) des Video-Ports. Ein 0-Bit
bedeutet Masse am entsprechenden Pin, 1-Bit bedeutet keine Verbindung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den angeschlossenen Monitortyp zurück.
Dabei gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">Wert</td>
  <td align="left" valign="top">Bedeutung</td>
  <td align="left" valign="top">Pin</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">ST-Monochrommonitor</td>
  <td align="left" valign="top">M1:0 M0:0</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">ST-Farbmonitor</td>
  <td align="left" valign="top">M1:0 M0:1</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">VGA-Monitor</td>
  <td align="left" valign="top">M1:1 M0:0</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">TV-Gerät</td>
  <td align="left" valign="top">M1:1 M0:1</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">LCD</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">DVI</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
</table>
</div>

<br>Die Werte vier und fünf sind nur verfügbar mit dem ct60 und
Radeon Treiber.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20mon_type">Binding</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20mon_type">4.5.13.1 Bindings für mon_type</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#mon_type">mon_type</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #89,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Physbase">4.5.14 Physbase</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »physical screen ram base« - ermittelt die Anfangsadresse des
Video-Speichers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 2
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void *Physbase( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Physbase ermittelt die physikalische
Anfangsadresse des momentan als Videospeicher verwendeten
RAM-Bereichs.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion Physbase liefert als Ergebnis die Adresse des
physikalischen Bildschirmspeichers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Physbase">Binding</a> &nbsp; <a href="#Logbase">Logbase</a> &nbsp; <a href="#Setscreen">Setscreen</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Physbase">4.5.14.1 Bindings für Physbase</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void *<a href="#Physbase">Physbase</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #2,-(sp)     ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Setcolor">4.5.15 Setcolor</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Setcolor« - legt eine von 16 Farben fest.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 7
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Setcolor( int16_t colornum, int16_t color );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Setcolor erfragt den Wert eines Farbregisters
bzw. setzt dieses auf einen neuen Wert. Es gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">colornum</td>
  <td align="left" valign="top">Nummer des Farbregisters (0..15)</td>
</tr>
<tr>
  <td align="left" valign="top">color</td>
  <td align="left" valign="top">neuer Farbwert (-1 = nicht ändern)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den bisherigen Wert des Farbregisters.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Setcolor">Binding</a> &nbsp; <a href="#Setpalette">Setpalette</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Setcolor">4.5.15.1 Bindings für Setcolor</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Setcolor">Setcolor</a>( int16_t colornum, int16_t color );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    color,-(sp)    ; Offset 4
move.w    colornum,-(sp) ; Offset 2
move.w    #7,-(sp)       ; Offset 0
trap      #14            ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp          ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Setpalette">4.5.16 Setpalette</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set palette« - wählt 16 Farben aus.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 6
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Setpalette( void *pallptr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Setpalette erlaubt es, eine neue Farbpalette
an die Videohardware zu übergeben.
<br>&nbsp;
<br>Der Parameter <i>pallptr</i> zeigt auf eine Tabelle von
sechzehn 16-Bit Worten, die die neue Palette enthalten. Die untersten
12-Bits werden dabei für die RGB-Werte benutzt. <i>pallptr</i> muß
auf eine gerade Adresse zeigen.
<br>&nbsp;
<br>Da die Daten von der Funktion nicht sofort verarbeitet werden,
muß dafür gesorgt werden, daß der Zeiger <i>pallptr</i> selbst im
nächsten Vertical Blank noch auf etwas sinnvolles zeigt.
<br>&nbsp;
<br><b>Hinweis:</b> Es sollte besser auf die entsprechenden
Funktionen des VDI zurückgegriffen werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert keinen Wert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Setpalette">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Setpalette">4.5.16.1 Bindings für Setpalette</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Setpalette">Setpalette</a>( void *pallptr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pallptr      ; Offset 2
move.w    #6,-(sp)     ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Setscreen">4.5.17 Setscreen</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set screen« - initialisiert den Bildschirm.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 5
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Setscreen( void *laddr, void *paddr, int16_t rez );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Setscreen dient dazu, Auflösung und
Bildschirmspeicheradressen zu verändern. Es gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">laddr</td>
  <td align="left" valign="top">Adresse des log. Bildschirmspeichers</td>
</tr>
<tr>
  <td align="left" valign="top">paddr</td>
  <td align="left" valign="top">Adresse des phys. Bildschirmspeichers</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">0 = ST-Niedrig</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">1 = ST-Mittel</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">2 = ST-Hoch</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">4 = TT-Medium</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">6 = TT-High</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">7 = TT-Low</td>
</tr>
</table>
</div>

<br>Ein Wert von -1 bedeutet in diesem Zusammenhang, daß die
entsprechende Adresse bzw. Auflösung nicht verändert wird.
<br>&nbsp;
<br><b>Hinweis:</b> Es sollte stets kontrolliert werden, ob
eventuelle Veränderungen wirklich erfolgreich ausgeführt werden
konnten. Bei einer Änderung der Auflösung wird automatisch der
<a href="VT_52_terminal.html">VT-52 Emulator</a> initialisiert.
<br>&nbsp;
<br>Unter bestimmten Umständen gibt es eine erweiterte Version
dieser Funktion (<a href="#VsetScreen">VsetScreen</a>).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Setscreen">Binding</a> &nbsp; <a href="#Physbase">Physbase</a> &nbsp; <a href="#Logbase">Logbase</a> &nbsp; <a href="#Getrez">Getrez</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Setscreen">4.5.17.1 Bindings für Setscreen</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Setscreen">Setscreen</a>( void *laddr, void *paddr, int16_t rez );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    rez,-(sp)    ; Offset 10
move.l    paddr,-(sp)  ; Offset  6
move.l    laddr,-(sp)  ; Offset  2
move.w    #5,-(sp)     ; Offset  0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $C(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Setscreen_2C_20Milan">4.5.18 Setscreen, Milan</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set screen« - initialisiert den Bildschirm.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 5
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Setscreen( void *par1, void *par2, int16_t rez, int16_t
command );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese XBIOS-Routine entspricht der Funktion <a href="#Setscreen">Setscreen</a>
allerdings mit einem zusätzlichen Parameter und dient dazu,
Auflösung und Bildschirmspeicheradressen zu verändern.
<br>&nbsp;
<a name="MI_MAGIC"></a>
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">par1</td>
  <td align="left" valign="top">Je nach Funktion, s.u.</td>
</tr>
<tr>
  <td align="left" valign="top">par2</td>
  <td align="left" valign="top">Je nach Funktion, s.u.</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">immer 0x4D49 (MI_MAGIC)</td>
</tr>
<tr>
  <td align="left" valign="top">command</td>
  <td align="left" valign="top">Kommando</td>
</tr>
</table>
</div>

<br>Folgende Werte sind für <i>command</i> definiert:
<br>&nbsp;
<dl class="UDO_env_description">
<dd><a name="CMD_GETMODE"></a></dd>
<dt><b>CMD_GETMODE (0)</b></dt>
<dd>
<p> Getting current mode
<br>&nbsp;
<br>int32_t mode;
<br>Setscreen(-1, &amp;mode, MI_MAGIC, CMD_GETMODE);
<br>&nbsp;
<dd><a name="CMD_SETMODE"></a></dd>
</p>

</dd>
<dt><b>CMD_SETMODE (1)</b></dt>
<dd>
<p> Set new graphic mode
<br>&nbsp;
<br>int32_t mode=0x1023 /* 800*608*16 */
<br>Setscreen(-1, mode, MI_MAGIC, CMD_SETMODE)
<br>&nbsp;
<br><a href="bios_main.html">BIOS</a> and <a href="vdi_main.html">VDI</a> will be initialised. Not the <a href="aes_main.html">AES</a>.
<br>&nbsp;
<dd><a name="CMD_GETINFO"></a></dd>
</p>

</dd>
<dt><b>CMD_GETINFO (2)</b></dt>
<dd>
<p> Get screen info structure for mode
<br>&nbsp;
<pre><a href="xbios_structures.html#SCREENINFO">SCREENINFO</a> si;
/* Structure size has to be set         */
si.size=sizeof(<a href="xbios_structures.html#SCREENINFO">SCREENINFO</a>);
/* ID of the mode or 0 for current mode */
si.devID=0x1023;
/* status of the operation              */
si.scrFlags=0;
<a href="#Setscreen">Setscreen</a>(-1, &amp;si, MI_MAGIC, CMD_GETINFO);
if(si.scrFlags &amp; <a href="xbios_structures.html#SCRINFO_OK">SCRINFO_OK</a>)
  puts(&quot;OK&quot;);
else
  puts(&quot;Error&quot;);
</pre>
<dd><a name="CMD_ALLOCPAGE"></a></dd>
</p>

</dd>
<dt><b>CMD_ALLOCPAGE (3)</b></dt>
<dd>
<p> Allocate 2nd screenpage
<br>&nbsp;
<pre>int32_t adr=0;      /* Frame address or -1 */
<a href="#Setscreen">Setscreen</a>(&amp;adr, mode, MI_MAGIC, CMD_ALLOCPAGE);
if(adr)
  puts(&quot;OK&quot;);
else
  puts(&quot;Error&quot;);
</pre>
<br>This only allocates one page. A further call will only return
the frame address.
<br>&nbsp;
<dd><a name="CMD_FREEPAGE"></a></dd>
</p>

</dd>
<dt><b>CMD_FREEPAGE (4)</b></dt>
<dd>
<p> Release 2nd screenpage
<br>&nbsp;
<br>Setscreen(-1, -1, MI_MAGIC, CMD_FREEPAGE)
<br>&nbsp;
<br>The graphics card memory will be released again. If the second
page had still been active the call will switch back to the first page
with <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> set.
<br>&nbsp;
<dd><a name="CMD_FLIPPAGE"></a></dd>
</p>

</dd>
<dt><b>CMD_FLIPPAGE (5)</b></dt>
<dd>
<p> Switch to 2nd screenpage
<br>&nbsp;
<br>Setscreen(-1, -1, MI_MAGIC, CMD_FLIPPAGE)
<br>&nbsp;
<br>Will switch to the second screenpage. <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> will
be set.
<br>&nbsp;
<dd><a name="CMD_ALLOCMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_ALLOCMEM (6)</b></dt>
<dd>
<p> Allocate memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a> blk;

blk.size=sizeof(<a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a>);
/* alloc a block of 200 lines*/
blk.blk_y=200;

<a href="#Setscreen">Setscreen</a>(-1, &amp;blk, MI_MAGIC, CMD_ALLOCMEM);
if(blk.blk_start)
  puts(&quot;OK&quot;);
else
  puts(&quot;Out of memory&quot;);
</pre>
<br>The width of the block is currently always the width of the
virtual screen. For the hardware functions this block will be like a
screen (0,0,blk_w,blk_h), the coordinates start in the top left corner
(0,0). It will be internally recalculated.
<br>&nbsp;
<dd><a name="CMD_FREEMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_FREEMEM (7)</b></dt>
<dd>
<p> Release graphics card memory
<br>&nbsp;
<br>Setscreen(-1, &amp;blk, MI_MAGIC, CMD_FREEMEM)
<br>blk of the block to be released.
<br>&nbsp;
<dd><a name="CMD_SETADR"></a></dd>
</p>

</dd>
<dt><b>CMD_SETADR (8)</b></dt>
<dd>
<p> Set screen to fixed address
<br>&nbsp;
<pre>/* logical address or -1  */
int32_t logbase=blk.blk_start;
/* physical address or -1 */
int32_t physbase=blk.blk_start;

<a href="#Setscreen">Setscreen</a>(logbase, physbase, MI_MAGIC, CMD_SETADR);
</pre>
<dd><a name="CMD_ENUMMODES"></a></dd>
<dd><a name="ENUMMODE_EXIT"></a></dd>
<dd><a name="ENUMMODE_CONT"></a></dd>
</p>

</dd>
<dt><b>CMD_ENUMMODES (9)</b></dt>
<dd>
<p> Requests all available modes, since 13.01.2000
<br>&nbsp;
<pre>int32_t <a href="proto_xfsl.html#cdecl">cdecl</a> enumfunc(<a href="xbios_structures.html#SCREENINFO">SCREENINFO</a> *inf,int32_t flag)
{
  printf(&quot;%s\n&quot;,inf-&gt;name);
  return ENUMMODE_CONT;
}

<a href="#Setscreen">Setscreen</a>(-1, &amp;enumfunc, MI_MAGIC, CMD_ENUMMODES);
</pre>
<br>The function &quot;enumfunc&quot; will be called once for every
available mode. ENUMMODE_EXIT (0) will cancel CMD_ENUMMODES.
ENUMMODE_CONT (1) will continue. The parameters are handed over to the
stack using the C standard.
<br>&nbsp;
</p>

</dd>
</dl>
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="VT_52_terminal.html#Return">Return</a> value undefined.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist ab dem MilanTOS 4.08 verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Setscreen">Setscreen</a> &nbsp; <a href="#VsetScreen">VsetScreen</a> &nbsp; <a href="#Setscreen_2C_20ct60">Setscreen, ct60</a>
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Setscreen_2C_20ct60">4.5.19 Setscreen, ct60</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set screen« - initialisiert den Bildschirm.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 5
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Setscreen( void *par1, void *par2, int16_t rez, int16_t
command );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese XBIOS-Routine entspricht der Funktion <a href="#Setscreen">Setscreen</a>
allerdings mit einem zusätzlichen Parameter und dient dazu,
Auflösung und Bildschirmspeicheradressen zu verändern.
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">par1</td>
  <td align="left" valign="top">Je nach Funktion, s.u.</td>
</tr>
<tr>
  <td align="left" valign="top">par2</td>
  <td align="left" valign="top">Je nach Funktion, s.u.</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">immer 0x564E ('VN' für <a href="#VsetScreen">VsetScreen</a> New)</td>
</tr>
<tr>
  <td align="left" valign="top">command</td>
  <td align="left" valign="top">Kommando</td>
</tr>
</table>
</div>

<br>Folgende Werte sind für <i>command</i> definiert:
<br>&nbsp;
<dl class="UDO_env_description">
<dt><b><a href="Screen_functions.html#CMD_GETMODE">CMD_GETMODE</a> (0)</b></dt>
<dd>
<p> Getting current mode
<br>&nbsp;
<br>int32_t mode;
<br>Setscreen(-1,&amp;mode,0x564E,<a href="Screen_functions.html#CMD_GETMODE">CMD_GETMODE</a>); This function is
identical to <a href="#VsetMode">VsetMode</a>(-1);
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_SETMODE">CMD_SETMODE</a> (1)</b></dt>
<dd>
<p> Set new graphic mode
<br>&nbsp;
<br>int32_t mode=0x1023 /* 800*608*16 */
<br>Setscreen(-1,mode,0x564E,<a href="Screen_functions.html#CMD_SETMODE">CMD_SETMODE</a>)
<br>&nbsp;
<br>This function is identical to <a href="#VsetScreen">VsetScreen</a>(0, 0, 3, modecode);
<br><a href="bios_main.html">BIOS</a> and <a href="vdi_main.html">VDI</a> will be initialised. Not the <a href="aes_main.html">AES</a>.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_GETINFO">CMD_GETINFO</a> (2)</b></dt>
<dd>
<p> Get screen info structure for mode
<br>&nbsp;
<pre><a href="xbios_structures.html#SCREENINFO">SCREENINFO</a> si;
/* Structure size has to be set         */
si.size=sizeof(<a href="xbios_structures.html#SCREENINFO">SCREENINFO</a>);
/* ID of the mode or 0 for current mode */
si.devID=0x1023;
/* status of the operation              */
si.scrFlags=0;
<a href="#Setscreen">Setscreen</a>(-1,&amp;si,0x564E,<a href="Screen_functions.html#CMD_GETINFO">CMD_GETINFO</a>);
if(si.scrFlags &amp; <a href="xbios_structures.html#SCRINFO_OK">SCRINFO_OK</a>)
  puts(&quot;OK&quot;);
else
  puts(&quot;Error&quot;);
</pre>
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_ALLOCPAGE">CMD_ALLOCPAGE</a> (3)</b></dt>
<dd>
<p> Allocate screenpage
<br>&nbsp;
<pre>/* Frame address or -1 */
int32_t adr=0;
<a href="#Setscreen">Setscreen</a>(&amp;adr,mode,0x564E,<a href="Screen_functions.html#CMD_ALLOCPAGE">CMD_ALLOCPAGE</a>);
if(adr)
  puts(&quot;OK&quot;);
else
  puts(&quot;Error&quot;);
</pre>
<br>This only allocates one page. A further call will only return
the frame address.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_FREEPAGE">CMD_FREEPAGE</a> (4)</b></dt>
<dd>
<p> Release screenpage
<br>&nbsp;
<br>Setscreen(-1,-1,0x564E,<a href="Screen_functions.html#CMD_FREEPAGE">CMD_FREEPAGE</a>)
<br>&nbsp;
<br>The graphics card memory will be released again. If the second
page had still been active the call will switch back to the first page
with <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> set.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_FLIPPAGE">CMD_FLIPPAGE</a> (5)</b></dt>
<dd>
<p> Switch to screenpage
<br>&nbsp;
<br>Setscreen(-1,-1,0x564E,<a href="Screen_functions.html#CMD_FLIPPAGE">CMD_FLIPPAGE</a>)
<br>&nbsp;
<br>Will switch to the second screenpage. <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> will
be set.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_ALLOCMEM">CMD_ALLOCMEM</a> (6)</b></dt>
<dd>
<p> Allocate memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a> blk;

blk.size=sizeof(<a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a>);
/* alloc a block of 200 lines*/
blk.blk_y=200;

<a href="#Setscreen">Setscreen</a>(-1,&amp;blk,0x564E,<a href="Screen_functions.html#CMD_ALLOCMEM">CMD_ALLOCMEM</a>);
if(blk.blk_start)
  puts(&quot;OK&quot;);
else
  puts(&quot;Out of memory&quot;);
</pre>
<br>The width of the block is currently always the width of the
virtual screen. For the hardware functions this block will be like a
screen (0,0,blk_w,blk_h), the coordinates start in the top left corner
(0,0). It will be internally recalculated.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_FREEMEM">CMD_FREEMEM</a> (7)</b></dt>
<dd>
<p> Release graphics card memory
<br>&nbsp;
<br>Setscreen(-1,&amp;blk,0x564E,<a href="Screen_functions.html#CMD_FREEMEM">CMD_FREEMEM</a>)
<br>blk of the block to be released.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_SETADR">CMD_SETADR</a> (8)</b></dt>
<dd>
<p> Set screen to fixed address
<br>&nbsp;
<pre>/* logical address or -1  */
int32_t logbase=blk.blk_start;
/* physical address or -1 */
int32_t physbase=blk.blk_start;

<a href="#Setscreen">Setscreen</a>(logbase,physbase,0x564E,<a href="Screen_functions.html#CMD_SETADR">CMD_SETADR</a>);
</pre>
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a> (9)</b></dt>
<dd>
<p> Requests all available modes, since 13.01.2000
<br>&nbsp;
<pre>int32_t <a href="proto_xfsl.html#cdecl">cdecl</a> enumfunc(<a href="xbios_structures.html#SCREENINFO">SCREENINFO</a> *inf,int32_t flag)
{
  printf(&quot;%s\n&quot;,inf-&gt;name);
  return <a href="Screen_functions.html#ENUMMODE_CONT">ENUMMODE_CONT</a>;
}

<a href="#Setscreen">Setscreen</a>(-1,&amp;enumfunc,0x564E,<a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a>);
</pre>
<br>The function &quot;enumfunc&quot; will be called once for every
available mode. <a href="Screen_functions.html#ENUMMODE_EXIT">ENUMMODE_EXIT</a> (0) will cancel <a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a>.
<a href="Screen_functions.html#ENUMMODE_CONT">ENUMMODE_CONT</a> (1) will continue. The parameters are handed over to the
stack using the C standard.
<br>&nbsp;
<dd><a name="CMD_TESTMODE"></a></dd>
</p>

</dd>
<dt><b>CMD_TESTMODE (10)</b></dt>
<dd>
<p> Test a graphic mode
<br>&nbsp;
<pre>/* 800*600*16M */
int32_t modecode=VESA_600+HORFLAG2+VGA+COL80+BPS32;
<a href="#Setscreen">Setscreen</a>(-1,modecode,0x564E,CMD_TESTMODE);
</pre>
<br>Only the <a href="bios_main.html">BIOS</a> is initialised, and a screen test arrives with
colored wide lines.
<br>&nbsp;
<br>This function not exist inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_COPYPAGE"></a></dd>
</p>

</dd>
<dt><b>CMD_COPYPAGE (11)</b></dt>
<dd>
<p> Copy screenpage
<br>&nbsp;
<pre><a href="#VsetScreen">VsetScreen</a>(-1,0,0x564E,CMD_COPYPAGE);
Copy first screenpage to second screenpage
<a href="#VsetScreen">VsetScreen</a>(-1,1,0x564E,CMD_COPYPAGE);
Copy second screenpage to first screenpage
</pre>
<br>This function not exist inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_FILLMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_FILLMEM (12)</b></dt>
<dd>
<p> Fill memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRFILLMEMBLK">SCRFILLMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRFILLMEMBLK">SCRFILLMEMBLK</a>);
blk.blk_op = BLK_COPY;
blk.blk_color = 0x112233;  /* background fill color */

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_SETMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Fill a block with a color with the GPU at (blk_x, blk_y), size
is blk_w, blk_h.
<br>Note that this structure has the same size and same entry the the
structure <a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a> for the entry for size, blk_status, blk_x, blk_y,
blk_y, blk_w and blk_h for use the allocated structure with a cast.
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_COPYMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_COPYMEM (13)</b></dt>
<dd>
<p> Copy memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRCOPYMEMBLK">SCRCOPYMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRCOPYMEMBLK">SCRCOPYMEMBLK</a>);

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_COPYMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Copy a block with the GPU at (blk_src_x, blk_src_y) to
(blk_dst_x, blk_dst_y), size is blk_w, blk_h.
<br>Note that this structure has the same size and same entry the the
structure <a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a> for the entry for size, blk_status, blk_x, blk_y,
blk_y, blk_w and blk_h for use the allocated structure with a cast
when blk_x is blk_dst_x and blk_y is blk_dst_y.
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_TEXTUREMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_TEXTUREMEM (14)</b></dt>
<dd>
<p> Put texture in memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRTEXTUREMEMBLK">SCRTEXTUREMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRTEXTUREMEMBLK">SCRTEXTUREMEMBLK</a>);

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_TEXTUREMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Copy a 65K texture from CPU local area to a 65K screen or an
ARGB texture to a 32M screen pixel format multiple times (best results
are with little source texture and big screen for destination).
<br>&nbsp;
<br>This function need a texture support inside the <a href="tos_main.html">TOS</a>.
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_GETVERSION"></a></dd>
</p>

</dd>
<dt><b>CMD_GETVERSION (15)</b></dt>
<dd>
<p>
<br>&nbsp;
<pre>/* if the function is not implemented, 0x0100 is the first release */
long version = 0x0100;
<a href="#VsetScreen">VsetScreen</a>(-1,&amp;version,0x564E,CMD_GETVERSION);
</pre>
<br>Return  the version of the video <a href="xbios_main.html">XBIOS</a>.
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_LINEMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_LINEMEM (16)</b></dt>
<dd>
<p> Draw line on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRLINEMEMBLK">SCRLINEMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRLINEMEMBLK">SCRLINEMEMBLK</a>);
blk.blk_fbcolor = 0x112233;  /* foreground fill color */
blk.blk_bgcolor = 0;  /* background fill color */
blk.blk_pattern = 0xffffffff;  /* solid line */

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_LINEMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Draw a line with colors with the GPU at (blk_x1, blk_y1) to
(blk_x2, blk_y2).
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_CLIPMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_CLIPMEM (17)</b></dt>
<dd>
<p> Set clipping rectangle on the graphic card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRCLIPMEMBLK">SCRCLIPMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRCLIPMEMBLK">SCRCLIPMEMBLK</a>);
blk.blk_clip_on = 1; /* clipping flag 1:on,
                                      0:off */

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_CLIPMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Enable or diable clipping rectange at (blk_x, blk_y), size is
blk_w, blk_h.
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_SYNCMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_SYNCMEM (18)</b></dt>
<dd>
<p> <a href="powerdos.html#Wait">Wait</a> an empty GPU fifo for sync the drawing engine with the
memory.
<br>&nbsp;
<pre><a href="#VsetScreen">VsetScreen</a>(-1,-1,0x564E,CMD_SYNCMEM);
</pre>
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_BLANK"></a></dd>
</p>

</dd>
<dt><b>CMD_BLANK (19)</b></dt>
<dd>
<p> Blank / unblank screen.
<br>&nbsp;
<pre>int32_t blank = 1; /* (0): unblank
                      (1): blank normal
                      (2): VSYNC suspend
                      (3): HSYNC suspend
                      (4): powerdown */
<a href="#VsetScreen">VsetScreen</a>(-1,blank,0x564E,CMD_BLANK);
</pre>
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
</p>

</dd>
</dl>
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Nothing (or current modecode in TOS mode)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Only valid with internal TOS Radeon driver (PCI.HEX) for the
ct60 (2007-01-24).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Setscreen">Setscreen</a> &nbsp; <a href="#VsetScreen">VsetScreen</a> &nbsp; <a href="#Setscreen_2C_20Milan">Setscreen, Milan</a>
<br>&nbsp;

</td></tr>
</table>

<h3><a name="ValidMode">4.5.20 ValidMode</a></h3>
<a name="VcheckMode"></a>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »ValidMode« - Validates a mode code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 95
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t ValidMode( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> The XBIOS function ValidMode returns a valid version of the
specified mode code, depending on the monitor that is connected. The
bits of the parameter <i>mode</i> have the following meaning:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="right" valign="top">0-2</td>
  <td align="left" valign="top">Anzahl der Farbebenen:</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">0 = 1 Ebene       2 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">1 = 2 Ebenen      4 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">2 = 4 Ebenen     16 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">3 = 8 Ebenen    256 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">4 = 16 Ebenen 65536 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top">Gesetzt:  Bildbreite mindestens 640 Pixel</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: Bildbreite 320 Pixel</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">4</td>
  <td align="left" valign="top">Gesetzt:  VGA-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: TV-Modus (auch Atari-SC-Monitore)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">5</td>
  <td align="left" valign="top">Gesetzt:  PAL-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: NTSC-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">6</td>
  <td align="left" valign="top">Gesetzt:  Overscan aktiv</td>
</tr>
<tr>
  <td align="right" valign="top">7</td>
  <td align="left" valign="top">Gesetzt:  ST-kompatible Grafik</td>
</tr>
<tr>
  <td align="right" valign="top">8</td>
  <td align="left" valign="top">Gesetzt:  Interlace-Modus aktiv</td>
</tr>
</table>
</div>

<br><b>Note:</b> This function is not officially documented and
some development tools may also call it Validmode or VcheckMode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> The function returns a valid mode code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie, Milan und
CT60 verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20ValidMode">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a> &nbsp; <a href="#VsetMode">VsetMode</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20ValidMode">4.5.20.1 Bindings für ValidMode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#ValidMode">ValidMode</a>( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)    ; Offset 2
move.w    #95,-(sp)     ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="VgetRGB">4.5.21 VgetRGB</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VgetRGB« - RGB Wert einer Farbe ermitteln
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 94
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void VgetRGB( int16_t index, int16_t count, int32_t *array );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Funktion VgetRGB ermittelt die RGB-Werte für
<i>count</i> Farben ab dem Farbindex <i>index</i>. Die
resultierenden Werte werden in <i>array</i> abgelegt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20VgetRGB">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VgetRGB">4.5.21.1 Bindings für VgetRGB</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VgetRGB">VgetRGB</a>( int16_t index, int16_t count, int32_t *array );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    array,-(sp)  ; Offset 6
move.w    count,-(sp)  ; Offset 4
move.w    index,-(sp)  ; Offset 2
move.w    #94,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="VsetScreen">4.5.22 VsetScreen</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set screen« - initialisiert den Bildschirm.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 5
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t VsetScreen( void *laddr, void *paddr, int16_t rez,
int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine VsetScreen entspricht der Funktion <a href="#Setscreen">Setscreen</a>
allerdings mit einem zusätzlichen Parameter und dient dazu,
Auflösung und Bildschirmspeicheradressen zu verändern. Es gilt:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">laddr</td>
  <td align="left" valign="top">Adresse des log. Bildschirmspeichers</td>
</tr>
<tr>
  <td align="left" valign="top">paddr</td>
  <td align="left" valign="top">Adresse des phys. Bildschirmspeichers</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">0 = ST-Niedrig</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">1 = ST-Mittel</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">2 = ST-Hoch</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">3 = benutzte Auflösung aus <i>mode</i> (Falcon)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">5 = benutzte Auflösung aus <i>mode</i> (Milan)</td>
</tr>
<tr>
  <td align="left" valign="top">mode</td>
  <td align="left" valign="top">modecode (siehe <a href="#VsetMode">VsetMode</a>)</td>
</tr>
</table>
</div>

<br>Ein Wert von -1 bedeutet in diesem Zusammenhang, daß die
entsprechende Adresse bzw. Auflösung nicht verändert wird.
<br>&nbsp;
<br><b>Hinweis:</b> Es sollte stets kontrolliert werden, ob
eventuelle Veränderungen wirklich erfolgreich ausgeführt werden
konnten. Bei einer Änderung der Auflösung wird automatisch der VT-52
Emulator initialisiert.
<br>&nbsp;
<br>Der zusätzliche Parameter <i>mode</i> steht nur zur
Verfügung, wenn der Cookie '<a href="bios_cookiejar.html#Cookie_2C_20_VDO">_VDO</a>' den Wert 0x00030000 oder größer
hat.
<br>&nbsp;
<br>Beim <a href="tos_main.html">TOS</a> des Milans gibt es zusätzliche Funktionen bei <a href="#Setscreen_2C_20Milan">Setscreen</a>,
entsprechendes gilt auch für den <a href="#Setscreen_2C_20ct60">ct60</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion gibt den vorherigen Videl-Mode zurück oder -1 im
Fehlerfall/wenn sich der Videl-Mode nicht ändert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20VsetScreen">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VsetScreen">4.5.22.1 Bindings für VsetScreen</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#VsetScreen">VsetScreen</a>( void *laddr, void *paddr, int16_t rez,
int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)   ; Offset 12
move.w    rez,-(sp)    ; Offset 10
move.l    paddr,-(sp)  ; Offset  6
move.l    laddr,-(sp)  ; Offset  2
move.w    #5,-(sp)     ; Offset  0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="VgetSize">4.5.23 VgetSize</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VgetSize« - Größe des Bildschirmpuffers ermitteln
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 91
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t VgetSize( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Funktion VgetSize ermittelt die Größe des
Bildschirmpuffers in Bytes für den Grafikmodus <i>mode</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die Größe des Bildschirmpuffers in Bytes
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20VgetSize">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VgetSize">4.5.23.1 Bindings für VgetSize</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#VgetSize">VgetSize</a>( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)    ; Offset 2
move.w    #91,-(sp)     ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="VsetMask">4.5.24 VsetMask</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VsetMask« - Transparenz für TrueColor setzen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 150
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void VsetMask( int32_t ormask, int32_t andmask, int16_t overlay
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Funktion VsetMask setzt Masken, die benutzt werden,
um die durch die VDI-Funktion <a href="vdi_attribute.html#vs_color">vs_color</a> gesetzten Farben zu
modifizieren. <a href="vdi_attribute.html#vs_color">vs_color</a> ermittelt zu seinem Parameter einen RGB-Wert.
Dieser wird bitweise mit <i>ormask</i> verodert und mit
<i>andmask</i> verundet. Somit können Farben im True-Color-Modus
transparent erscheinen. Ist <i>overlay</i> ungleich Null, wird in den
Overlaymodus geschalten bzw. mit Null zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20VsetMask">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp;
<a href="#VsetRGB">VsetRGB</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VsetMask">4.5.24.1 Bindings für VsetMask</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VsetMask">VsetMask</a>( int32_t ormask, int32_t andmask, int16_t overlay
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    overlay,-(sp) ; Offset 10
move.l    andmask,-(sp) ; Offset 6
move.l    ormask,-(sp)  ; Offset 2
move.w    #150,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="VsetMode">4.5.25 VsetMode</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VsetMode« - Videohardwareregister setzen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 88
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t VsetMode( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Funktion VsetMode programmiert das
Videohardwareregister der Falcon-Computer. Die Bits des Parameters
<i>mode</i> haben folgende Bedeutung:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="right" valign="top">0-2</td>
  <td align="left" valign="top">Anzahl der Farbebenen:</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">0 = 1 Ebene       2 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">1 = 2 Ebenen      4 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">2 = 4 Ebenen     16 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">3 = 8 Ebenen    256 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">4 = 16 Ebenen 65536 Farben</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top">Gesetzt:  Bildbreite mindestens 640 Pixel</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: Bildbreite 320 Pixel</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">4</td>
  <td align="left" valign="top">Gesetzt:  VGA-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: TV-Modus (auch Atari-SC-Monitore)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">5</td>
  <td align="left" valign="top">Gesetzt:  PAL-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Gelöscht: NTSC-Modus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">6</td>
  <td align="left" valign="top">Gesetzt:  Overscan aktiv</td>
</tr>
<tr>
  <td align="right" valign="top">7</td>
  <td align="left" valign="top">Gesetzt:  ST-kompatible Grafik</td>
</tr>
<tr>
  <td align="right" valign="top">8</td>
  <td align="left" valign="top">Gesetzt:  Interlace-Modus aktiv</td>
</tr>
</table>
</div>

<a name="VM_INQUIRE"></a>
<br>Wird als <i>mode</i> VM_INQUIRE (-1) übergeben erhält man die
aktuelle Auflösung, ohne das etwas verändert wird.
<br>&nbsp;
<br><b>Hinweis:</b> Es findet keine Überprüfung auf die
Richtigkeit der Kodierung für den angeschlossenen Monitor statt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den alten Inhalt des
Videohardwareregisters zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20VsetMode">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VsetMode">4.5.25.1 Bindings für VsetMode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#VsetMode">VsetMode</a>( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)    ; Offset 2
move.w    #88,-(sp)     ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="VsetRGB">4.5.26 VsetRGB</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VsetRGB« - RGB Wert einer Farbe setzen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 93
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void VsetRGB( int16_t index, int16_t count, int32_t *array );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Funktion VsetRGB setzt die RGB-Werte für
<i>count</i> Farben ab dem Farbindex <i>index</i>. Die Farbwerte
sind in <i>array</i> abgelegt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20VsetRGB">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VsetRGB">4.5.26.1 Bindings für VsetRGB</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VsetRGB">VsetRGB</a>( int16_t index, int16_t count, int32_t *array );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    array,-(sp)  ; Offset 6
move.w    count,-(sp)  ; Offset 4
move.w    index,-(sp)  ; Offset 2
move.w    #93,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       $A(sp),sp    ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="VsetSync">4.5.27 VsetSync</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VsetSync« - Art der Synchronisation setzen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 90
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void VsetSync( int16_t flag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Funktion VsetSync legt fest, auf welche Art eine
Synchronisation erfolgen soll. Der Parameter <i>flag</i> wird wie
folgt kodiert:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung für gesetzte Bits</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Externer Takt</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Vertikale Synchronisation</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Horizontale Synchronisation</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern der Falcon-Serie verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20VsetSync">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20VsetSync">4.5.27.1 Bindings für VsetSync</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VsetSync">VsetSync</a>( int16_t flag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    flag,-(sp)   ; Offset 2
move.w    #90,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Vsync">4.5.28 Vsync</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »vertical sync« - wartet auf das nächste vertikale
<a href="gemdos_system.html#Sync">Sync</a>-Signal.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 37
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Vsync( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Routine Vsync wartet auf den nächsten
Bildschirm-Refresh (Vertical-Blank Interrupt). Damit ist es möglich,
Bildschirmoperationen mit dem Betriebssystem synchronisieren.
<br>&nbsp;
<br><b>Hinweis:</b> Für zeitkritische Abfragen (Scrolling) sollte
besser direkt auf den Zeilenzähler im Shifter zurückgegriffen
werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Bildschirmfunktionen">Bildschirmfunktionen</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Vsync">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Vsync">4.5.28.1 Bindings für Vsync</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Vsync">Vsync</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #37,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Konstanten_20zur_20Videohardware_20des_20Falcons">4.5.29 Konstanten zur Videohardware des Falcons</a></h3>
<p>Zur vereinfachten Programmierung des Videohardwareregisters des
Falcons mittels der Funktion <a href="#VsetMode">VsetMode</a> sind in der Headerdatei tos.h
die folgenden Konstanten definiert, die mit | kombiniert werden:
</p>
<pre>    #define VERTFLAG  0x0100  /* Interlace aktivieren          */
    #define STMODES   0x0080  /* ST-kompatible Grafik          */
    #define OVERSCAN  0x0040  /* Overscan aktivieren           */
    #define PAL       0x0020  /* PAL-Modus                     */
    #define FALC_VGA  0x0010  /* VGA-Modus                     */
    #define TV        0x0000  /* TV-Modus                      */

    #define COL80     0x0008  /* Bildbreite mind. 640 Pixel    */
    #define COL40     0x0000  /* Bildbreite 320 Pixel          */

    #define BPS16     4       /* 16 Farbebenen: 65536 Farben   */
    #define BPS8      3       /*  8 Farbebenen:   256 Farben   */
    #define BPS4      2       /*  4 Farbebenen:    16 Farben   */
    #define BPS2      1       /*  2 Farbebenen:     4 Farben   */
    #define BPS1      0       /*  1 Farbebenen:     2 Farben   */
</pre>
<p>Mit der folgenden Konstante kann die Anzahl der Farbebenen
ausmaskiert werden:
</p>
<pre>    #define NUMCOLS   7       /* if (( mode &amp; NUMCOLS ) == 0 ) */
                              /*   puts( &quot;monochrome mode&quot; );  */
</pre>
<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_trap.html"><img src="udo_lf.gif" alt="xbios-Trap" title="xbios-Trap" border="0" width="24" height="24">xbios-Trap</a>
<a name="UDO_nav_rg_FOOT" href="CENTScreen_XBIOS_extension.html"><img src="udo_rg.gif" alt="CENTScreen-XBIOS-Erweiterung" title="CENTScreen-XBIOS-Erweiterung" border="0" width="24" height="24">CENTScreen-XBIOS-Erweiterung</a>
</body>
</html>
