<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 20.12.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: AES-Strukturen
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="aes_main.html"><img src="udo_up.gif" alt="AES" title="AES" border="0" width="24" height="24">AES</a>
<a name="UDO_nav_lf_HEAD" href="aes_functions.html"><img src="udo_lf.gif" alt="AES-Funktionsliste" title="AES-Funktionsliste" border="0" width="24" height="24">AES-Funktionsliste</a>
<a name="UDO_nav_rg_HEAD" href="xcontrol_main.html"><img src="udo_rg.gif" alt="XCONTROL" title="XCONTROL" border="0" width="24" height="24">XCONTROL</a>

<hr>

<h1><a name="AES-Strukturen">8.27 AES-Strukturen</a></h1>
<ul class="content">
	<li> 8.27.1 <a href="#AESPB">AESPB</a>
	<li> 8.27.2 <a href="#ANI_MOUSE">ANI_MOUSE</a>
	<li> 8.27.3 <a href="#APPFLAGS">APPFLAGS</a>
	<li> 8.27.4 <a href="#APFLG">APFLG</a>
	<li> 8.27.5 <a href="#APPLRECORD">APPLRECORD</a>
	<li> 8.27.6 <a href="#Die_20Bit-Block-Struktur">Die Bit-Block-Struktur</a>
	<li> 8.27.7 <a href="#CICON">CICON</a>
	<li> 8.27.8 <a href="#CICONBLK">CICONBLK</a>
	<li> 8.27.9 <a href="#CLRCAT">CLRCAT</a>
	<li> 8.27.10 <a href="#DIALOG">DIALOG</a>
	<li> 8.27.11 <a href="#DITHER_MODE">DITHER_MODE</a>
	<li> 8.27.12 <a href="#DRV_ENTRY">DRV_ENTRY</a>
	<li> 8.27.13 <a href="#DRV_INFO">DRV_INFO</a>
	<li> 8.27.14 <a href="#EVNT">EVNT</a>
	<li> 8.27.15 <a href="#FNTS_ITEM">FNTS_ITEM</a>
	<li> 8.27.16 <a href="#FNT_DIALOG">FNT_DIALOG</a>
	<li> 8.27.17 <a href="#G_VECTORS">G_VECTORS</a>
	<li> 8.27.18 <a href="#HNDL_OBJ">HNDL_OBJ</a>
	<li> 8.27.19 <a href="#ICONBLK">ICONBLK</a>
	<li> 8.27.20 <a href="#KEYCODE">KEYCODE</a>
	<li> 8.27.21 <a href="#LBOX_ITEM">LBOX_ITEM</a>
	<li> 8.27.22 <a href="#LIST_BOX">LIST_BOX</a>
	<li> 8.27.23 <a href="#MEDIA_SIZE">MEDIA_SIZE</a>
	<li> 8.27.24 <a href="#MEDIA_TYPE">MEDIA_TYPE</a>
	<li> 8.27.25 <a href="#MENU">MENU</a>
	<li> 8.27.26 <a href="#MFORM">MFORM</a>
	<li> 8.27.27 <a href="#MN_SET">MN_SET</a>
	<li> 8.27.28 <a href="#OBJECT">OBJECT</a>
	<li> 8.27.29 <a href="#OB_PREFER">OB_PREFER</a>
	<li> 8.27.30 <a href="#PARMBLK">PARMBLK</a>
	<li> 8.27.31 <a href="#PDLG_HNDL">PDLG_HNDL</a>
	<li> 8.27.32 <a href="#PDLG_INIT">PDLG_INIT</a>
	<li> 8.27.33 <a href="#PDLG_RESET">PDLG_RESET</a>
	<li> 8.27.34 <a href="#PDLG_SUB">PDLG_SUB</a>
	<li> 8.27.35 <a href="#POPINFO">POPINFO</a>
	<li> 8.27.36 <a href="#PRN_DIALOG">PRN_DIALOG</a>
	<li> 8.27.37 <a href="#PRN_ENTRY">PRN_ENTRY</a>
	<li> 8.27.38 <a href="#PRN_MODE">PRN_MODE</a>
	<li> 8.27.39 <a href="#PRN_SETTINGS">PRN_SETTINGS</a>
	<li> 8.27.40 <a href="#PRN_SWITCH">PRN_SWITCH</a>
	<li> 8.27.41 <a href="#PRN_TRAY">PRN_TRAY</a>
	<li> 8.27.42 <a href="#RSHDR">RSHDR</a>
	<li> 8.27.43 <a href="#RSXHDR">RSXHDR</a>
	<li> 8.27.44 <a href="#SCANX">SCANX</a>
	<li> 8.27.45 <a href="#SETTINGS">SETTINGS</a>
	<li> 8.27.46 <a href="#SET_ITEM">SET_ITEM</a>
	<li> 8.27.47 <a href="#SHELTAIL">SHELTAIL</a>
	<li> 8.27.48 <a href="#SHELW">SHELW</a>
	<li> 8.27.49 <a href="#SLCT_ITEM">SLCT_ITEM</a>
	<li> 8.27.50 <a href="#SWINFO">SWINFO</a>
	<li> 8.27.51 <a href="#TEDINFO">TEDINFO</a>
	<li> 8.27.52 <a href="#USERBLK">USERBLK</a>
	<li> 8.27.53 <a href="#UTXT_FN">UTXT_FN</a>
	<li> 8.27.54 <a href="#WIND_TREE">WIND_TREE</a>
	<li> 8.27.55 <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a>
	<li> 8.27.56 <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a>
	<li> 8.27.57 <a href="#WININFO">WININFO</a>
	<li> 8.27.58 <a href="#XAESMSG">XAESMSG</a>
	<li> 8.27.59 <a href="#XDO_INF">XDO_INF</a>
	<li> 8.27.60 <a href="#XFONTINFO">XFONTINFO</a>
	<li> 8.27.61 <a href="#XFSL_FILTER">XFSL_FILTER</a>
	<li> 8.27.62 <a href="#XSHW_COMMAND">XSHW_COMMAND</a>
	<li> 8.27.63 <a href="#XTED">XTED</a>
	<li> 8.27.64 <a href="#X_BUF_V2">X_BUF_V2</a>
	</li>
</ul>
<br>
<h3><a name="AESPB">8.27.1 AESPB</a></h3>
<pre>typedef struct
{
    int16_t *cb_pcontrol;  /* Zeiger auf control-Array */
    int16_t *cb_pglobal;   /* Zeiger auf global-Array  */
    int16_t *cb_pintin;    /* Zeiger auf int_in-Array  */
    int16_t *cb_pintout;   /* Zeiger auf int_out-Array */
    int16_t *cb_padrin;    /* Zeiger auf adr_in-Array  */
    int16_t *cb_padrout;   /* Zeiger auf adr_out-Array */
} AESPB;
</pre>
<h3><a name="ANI_MOUSE">8.27.2 ANI_MOUSE</a></h3>
<p>Describes (animated) mouse shape
</p>
<pre>typedef struct
{
   int16_t frames;      /* Number of frames in shape          */
   int16_t delay;       /* 50Hz tics to pause between frames  */
   <a href="#MFORM">MFORM</a> form[32];      /* List of mouse forms                */
} ANI_MOUSE;
</pre>
<p>Querverweis: <a href="graf.html#graf_mouse">graf_mouse</a>
</p>
<h3><a name="APPFLAGS">8.27.3 APPFLAGS</a></h3>
<p>Describes application flags
</p>
<pre>typedef struct
{
  unit8_t name[13];       /* Filename pattern to use these flags       */
  unit8_t desc[17];       /* User-defined description of flags         */
  <a href="#APFLG">APFLG</a> flags;            /* Execution flags                           */
  <a href="#KEYCODE">KEYCODE</a> open_key;       /* Open application when this key is pressed */
  <a href="#KEYCODE">KEYCODE</a> reserve_key[3]; /* Application uses these keys, so don't let */
                          /* Geneva process them                       */
} APPFLAGS;
</pre>
<p>Querverweis: <a href="appl.html#x_appl_flags">x_appl_flags</a> &nbsp; <a href="#APFLG">APFLG</a> &nbsp; <a href="#KEYCODE">KEYCODE</a>
</p>
<h3><a name="APFLG">8.27.4 APFLG</a></h3>
<p>Application bit flags
</p>
<pre>typedef <a href="proto_xfsl.html#union">union</a>
{
   struct
   {
     unsigned multitask    :1;  /* 1: Multitasking                       */
     unsigned special_types:1;  /* 1: Use extended object types          */
     unsigned round_buttons:1;  /* 1: Use rounded <a href="aes_fundamentals.html#EXIT">EXIT</a> buttons           */
     unsigned kbd_equivs   :1;  /* 1: Use auto keyboard equivs           */
     unsigned undo_equivs  :1;  /* 1: Undraw when <a href="form.html#form_do">form_do</a> exits          */
     unsigned off_left     :1;  /* 1: Allow windows off left edge        */
     unsigned exit_redraw  :1;  /* 1: Redraw everything at quit          */
     unsigned AES40_msgs   :1;  /* 1: New messages for <a href="aes_main.html">AES</a> 4.0 OK        */
     unsigned limit_handles:1;  /* 1: Limit window handles to 1-7        */
     unsigned limit_memory :1;  /* 1: Limit <a href="gemdos_memory.html#Malloc">Malloc</a>'s                     */
     unsigned keep_deskmenu:1;  /* 1: Keep desktop/menu bar              */
     unsigned clear_memory :1;  /* 1: Clear <a href="gemdos_memory.html#Malloc">Malloc</a>'d memory              */
     unsigned maximize_wind:1;  /* 1: Omit unnecessary gadgets           */
     unsigned optim_redraws:1;  /* 1: Optimize window redraws (rel 004)  */
     unsigned unused       :2;  /* Reserved for future use               */
     unsigned mem_limit    :16; /* Kb to limit memory allocation         */
   } s;
   unit32_t l;                  /* longword to access all bits           */
} APFLG;
</pre>
<p>The <i>multitask</i> and <i>limit_handles</i> flags must not
be changed for a process which is already in memory.
</p>
<p><i>optim_redraws</i> is present since release 004.
</p>
<p>Querverweis: <a href="appl.html#x_appl_flags">x_appl_flags</a> &nbsp; <a href="#APPFLAGS">APPFLAGS</a>
</p>
<h3><a name="APPLRECORD">8.27.5 APPLRECORD</a></h3>
<p>Diese Struktur ist wie folgt definiert:
</p>
<pre>typedef struct
{
    int32_t type;      /* Art des Ereignisses */
    int32_t what;      /* genaue Beschreibung des Ereignisses */
} APPLRECORD
</pre>
<p><b>Für die Komponenten gilt dabei:</b>
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><i>type</i> Bedeutung</td>
<td valign="top"> <i>what</i>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0&nbsp;&nbsp; Timer-Event</td>
<td valign="top"> Anzahl von 20-Millisekunden Ticks
</td></tr>

<tr><td nowrap="nowrap" valign="top">1&nbsp;&nbsp; Button-Event</td>
<td valign="top"> Status der Maustaste (High-Word), und zwar: 0 = nicht
gedrückt, 1 = gedrückt:
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Linke Maustaste:</td>
<td valign="top"> 0x0001
</td></tr>

<tr><td nowrap="nowrap" valign="top">Rechte Maustaste:</td>
<td valign="top"> 0x0002

</td></tr>
</table>

<br>Das (low-WORD) enthält die Anzahl der Clicks.
</td></tr>

<tr><td nowrap="nowrap" valign="top">2&nbsp;&nbsp; Maus-Event</td>
<td valign="top"> X-Koordinate (High-Word), Y-Koordinate (Low-Word).
</td></tr>

<tr><td nowrap="nowrap" valign="top">3&nbsp;&nbsp; Tastatur-Event</td>
<td valign="top">
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bits 24-31</td>
<td valign="top"> Scan-Code
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bits 16-23</td>
<td valign="top"> ASCII Code
</td></tr>

<tr><td nowrap="nowrap" valign="top">Low-Word</td>
<td valign="top"> Zustand der Umschaltasten (0 = nicht gedrückt, 1 = gedrückt):
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Shift-Rechts:</td>
<td valign="top"> 0x0001
</td></tr>

<tr><td nowrap="nowrap" valign="top">Shift-Links:</td>
<td valign="top"> 0x0002
</td></tr>

<tr><td nowrap="nowrap" valign="top">Control:</td>
<td valign="top"> 0x0004
</td></tr>

<tr><td nowrap="nowrap" valign="top">Alternate:</td>
<td valign="top"> 0x0008

</td></tr>
</table>


</td></tr>
</table>


</td></tr>
</table>

<p><b>Hinweis:</b> Unter PC-<a href="gem_about.html">GEM</a> belegt jedes Ereignis nur 6 Bytes,
da die Komponente <i>type</i> von APPLRECORD dort als int16_t
definiert ist.
</p>
<p>Querverweis: <a href="appl.html#appl_tplay">appl_tplay</a> &nbsp; <a href="appl.html#appl_trecord">appl_trecord</a>
</p>
<h3><a name="Die_20Bit-Block-Struktur">8.27.6 Die Bit-Block-Struktur</a></h3>
<a name="BITBLK"></a>
<p>Ein Bit-Image kann immer dort eingesetzt werden, wo ein nicht
anwählbares Icon stehen könnte; der entscheidende Unterschied ist
nämlich, daß es zu einem Bit-Image <i>keine Maske</i> gibt.
</p>
<pre>typedef struct
{
  int16_t  *bi_pdata;     /* Zeiger auf die Grafikdaten    */
  int16_t  bi_wb;         /* Breite des Bildes in Bytes    */
  int16_t  bi_hl;         /* Höhe in Zeilen                */
  int16_t  bi_x;          /* x-Position                    */
  int16_t  bi_y;          /* y-Position                    */
  int16_t  bi_color;      /* Farbe                         */
} BITBLK;
</pre>
<p><b>Hinweis:</b> Die Breite eines Bit-Images (Komponente
<i>bi_wb</i>) muß stets durch 2 teilbar sein.
</p>
<p>Querverweis: <a href="#OBJECT">OBJECT</a> &nbsp; <a href="aes_fundamentals.html#Objektarten_20des_20AES">Objektarten des AES</a>
</p>
<h3><a name="CICON">8.27.7 CICON</a></h3>
<p>Diese Struktur ist wie folgt definiert:
</p>
<pre>typedef struct cicon_data
{
  int16_t num_planes;   /* Anzahl der Planes für die folgenden Daten */
  int16_t *col_data;    /* Zeiger auf Farb-Bitmap in Standardform    */
  int16_t *col_mask;    /* Zeiger auf einzelne Farb-Plane Maske      */
  int16_t *sel_data;    /* Zeiger auf Farb-Bitmap des selekt. Icons  */
  int16_t *sel_mask;    /* Zeiger auf einzelne Plane-Maske des Icons */
  struct cicon_data *next_res; /* Zeiger auf Icon anderer Auflösung */
} CICON;
</pre>
<p>Querverweis: <a href="#CICONBLK">CICONBLK</a> &nbsp; <a href="#ICONBLK">ICONBLK</a> &nbsp; <a href="#OBJECT">OBJECT</a>
</p>
<h3><a name="CICONBLK">8.27.8 CICONBLK</a></h3>
<p>Diese Struktur ist wie folgt definiert:
</p>
<pre>typedef struct cicon_blk
{
   <a href="#ICONBLK">ICONBLK</a> monoblk;    /* Default: monochrome Icons */
   <a href="#CICON">CICON</a>   *mainlist;  /* Farb-Icons für verschiedene Auflösungen */
} CICONBLK;
</pre>
<p>Querverweis: <a href="#OBJECT">OBJECT</a> &nbsp; <a href="aes_fundamentals.html#Die_20Objekt-Struktur">Objektstruktur im AES</a>
</p>
<h3><a name="CLRCAT">8.27.9 CLRCAT</a></h3>
<pre>typedef struct clrcat
{
  int16_t cc_foreground     /* Foreground colour    */
  int16_t cc_background     /* Background colour    */
  int16_t cc_style          /* Fill style           */
  int16_t cc_pattern        /* Fill pattern         */
} CLRCAT;
</pre>
<p>The CLRCAT is used internally by <a href="gem_about.html#ViewMAX">ViewMAX</a>/2 and later to store
the colour categories.
</p>
<p>Querverweise: <a href="#X_BUF_V2">X_BUF_V2</a>
</p>
<h3><a name="DIALOG">8.27.10 DIALOG</a></h3>
<pre>typedef void *DIALOG;
</pre>
<h3><a name="DITHER_MODE">8.27.11 DITHER_MODE</a></h3>
<pre>typedef struct _dither_mode
{
   struct _dither_mode  *next;    /* Zeiger auf Nachfolger     */
   int32_t       length;          /* Strukturlänge             */
   int32_t       format;          /* Datenformat               */
   int32_t       reserved;        /* reserviert                */
   int32_t       dither_id;       /* Kennung                   */
   int32_t       color_modes;     /* unterstützte Farbtiefen   */
   int32_t       reserved1;       /* reserviert                */
   int32_t       reserved2;       /* reserviert                */
   int8_t        name[32];        /* Name des Rasterverfahrens */
} DITHER_MODE;
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_printers">pdlg_add_printers</a>
</p>
<h3><a name="DRV_ENTRY">8.27.12 DRV_ENTRY</a></h3>
<pre>typedef struct _drv_entry
{
   struct _drv_entry *next; /* Zeiger auf Nachfolger */
} DRV_ENTRY;
</pre>
<h3><a name="DRV_INFO">8.27.13 DRV_INFO</a></h3>
<pre>typedef struct
{
   int32_t     magic;           /* 'pdnf'                           */
   int32_t     length;          /* Strukturlänge                    */
   int32_t     format;          /* Datenformat                      */
   int32_t     reserved;        /* reserviert                       */
   int16_t     driver_id;       /* Treibernummer fürs <a href="vdi_main.html">VDI</a>           */
   int16_t     driver_type;     /* Treibertyp                       */
   int32_t     reserved1;       /* reserviert                       */
   int32_t     reserved2;       /* reserviert                       */
   int32_t     reserved3;       /* reserviert                       */
   <a href="#PRN_ENTRY">PRN_ENTRY</a>   *printers;       /* zum Treiber gehörenden Drucker   */
   <a href="#DITHER_MODE">DITHER_MODE</a> *dither_modes;   /* unterstützte Rasterverfahren     */
   int32_t     reserved4;       /* reserviert                       */
   int32_t     reserved5;       /* reserviert                       */
   int32_t     reserved6;       /* reserviert                       */
   int32_t     reserved7;       /* reserviert                       */
   int32_t     reserved8;       /* reserviert                       */
   int32_t     reserved9;       /* reserviert                       */
   int8_t      device[128];     /* Ausgabedatei des Druckertreibers */
} DRV_INFO;
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_printers">pdlg_add_printers</a>
</p>
<h3><a name="EVNT">8.27.14 EVNT</a></h3>
<pre>typedef struct
{
    int16_t mwhich;         /* Art der Ereignisse                */
    int16_t mx;             /* x-Koordinate des Mauszeigers      */
    int16_t my;             /* y-Koordinate des Mauszeigers      */
    int16_t mbutton;        /* gedrückte Maustaste               */
    int16_t kstate;         /* Status der Sondertasten (kbshift) */
    int16_t key;            /* Scancode der gedrückten Taste     */
    int16_t mclicks;        /* Anzahl der Mausklicks             */
    int16_t reserved[9];    /* reserviert                        */
    int16_t msg[16];        /* <a href="proto_ssp.html#Message">Message</a>-Buffer                    */
} EVNT;
</pre>
<p>Querverweis: <a href="fnts.html#fnts_evnt">fnts_evnt</a> &nbsp; <a href="fslx.html#fslx_evnt">fslx_evnt</a> &nbsp; <a href="wdlg.html#wdlg_evnt">wdlg_evnt</a>
</p>
<h3><a name="FNTS_ITEM">8.27.15 FNTS_ITEM</a></h3>
<pre>typedef struct _fnts_item
{
  /* Zeiger auf den nächsten Font oder 0L */
  struct   _fnts_item  *next;
  /* Anzeige-Funktion für eigene Fonts */
  <a href="#UTXT_FN">UTXT_FN</a>  display;
  /* ID des Fonts */
  int32_t  id;
  /* muß 0 sein, da kein <a href="vdi_main.html">VDI</a>-Font */
  int16_t  index;
  /* Flag für äquidistante Fonts */
  int8_t   mono;
  /* Flag für Vektorfont */
  int8_t   outline;
  /* Anzahl der vordefinierten Punkthöhen */
  int16_t  npts;
  /* Zeiger auf den vollständigen Namen */
  int8_t   *full_name;
  /* Zeiger auf den Familiennamen */
  int8_t   *family_name;
  /* Zeiger auf den Stilnamen */
  int8_t   *style_name;
  /* Zeiger auf Feld mit Punkthöhen */
  int8_t   *pts;
  /* reserviert, müssen 0 sein */
  int32_t  reserved[4];
} FNTS_ITEM;
</pre>
<p>Querverweis: <a href="fnts.html#fnts_add">fnts_add</a> &nbsp; <a href="fnts.html">Zeichensatzauswahl</a>
</p>
<h3><a name="FNT_DIALOG">8.27.16 FNT_DIALOG</a></h3>
<pre>typedef void *FNT_DIALOG;
</pre>
<h3><a name="G_VECTORS">8.27.17 G_VECTORS</a></h3>
<a name="G_vectors"></a>
<pre>typedef struct G_vectors        /* Release 004 */
{
  int16_t used;
  int16_t (*keypress)( int32_t *key );
  int16_t (*app_switch)( int8_t *process_name, int16_t apid );
  int16_t (*gen_event)(void);
} G_VECTORS;
</pre>
<a name="X_WM_VECKEY"></a>
<a name="X_WM_VECSW"></a>
<a name="X_WM_VECEVNT"></a>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">used:</td>
<td valign="top"> A bitmap of which vectors in the rest of the structure are used
by this version of Geneva. Currently this is 7, to indicate that the
first 3 vectors are used.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">keypress:</td>
<td valign="top"> This function is called whenever Geneva receives a key from the
keyboard. The A0 register points to a longword containing the keycode
of the key which was pressed:
<br>&nbsp;
<br>bits 31-24 23-16 15-8 7-0
<br>shift scan code unused ASCII
<br>&nbsp;
<br>This is just like the result of <a href="About_the_BIOS.html#Bconin">Bconin</a>(2) with the result of
<a href="About_the_BIOS.html#Kbshift">Kbshift</a>(-1) stored in the high byte.
<br>&nbsp;
<br>If the <i>keypress</i> function changes this longword to 0L,
then the keypress will be ignored. If the longword is changed to some
other value, then the new value will be processed.
<br>&nbsp;
<br>If the <i>keypress</i> function returns a value &gt;= 0, then
the application with that ID will receive a X_WM_VECKEY message during
its next event loop.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">app_switch:</td>
<td valign="top"> This function is called whenever the user performs some action
that causes the topmost application to change, like selecting a name
from the Desk menu or topping another application's window.
<br>&nbsp;
<br>When called, the A0 register points to a string in <a href="appl.html#appl_find">appl_find</a>
format which is the name of the process that was switched to. The D0
register contains the application ID of the process.
<br>&nbsp;
<br>Under some circumstances, this function may be called even
though the &quot;new&quot; application is already the topmost one. It
is also possible for the &quot;apid&quot; in D0 to be -1, if Geneva is
in the process of shutting down.
<br>&nbsp;
<br>If the <i>app_switch</i> function returns a value &gt;= 0, then
the application with that ID will receive a X_WM_VECSW message during
its next event loop.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">gen_event:</td>
<td valign="top"> This function is called continually by Geneva. It provides a
way for an application to have Geneva poll a certain condition and
generate an event if something occurs.
<br>&nbsp;
<br>This can take the place of using <a href="evnt.html#evnt_multi">evnt_multi</a> with small timer
values in order to poll a condition, and is much more efficient. It
can be used in things like a corner clock to see when the time has
changed to a new minute.
<br>&nbsp;
<br>If the <i>gen_event</i> function returns a value &gt;= 0, then
the application with that ID will receive a X_WM_VECEVNT message
during its next event loop.
<br>&nbsp;

</td></tr>
</table>

<p>Notes about using vectors:
</p>
<ul>
<li><p> A vector routine can change registers D0-D2/A0-A1. All others
must be preserved.
<br>&nbsp;
</p></li>
<li><p> No vector routine can call the <a href="aes_main.html">AES</a>. The keypress and app_switch
vectors must not call <a href="gemdos_main.html">GEMDOS</a> functions. All other <a href="tos_main.html">TOS</a> services can be
used.
<br>&nbsp;
</p></li>
<li><p> If a vector does not wish to generate an event, then it must
return a negative number, like -1.
<br>&nbsp;
</p></li>
<li><p> A vector MUST follow the XBRA protocol. The only exception to
this is Geneva itself, which installs default vectors that do nothing
but return -1.
<br>&nbsp;
</p></li>
<li><p> An application is responsible for removing itself from the
vector chain when it terminates. Failure to do so will most likely
cause a crash in the future. An application should use <a href="shel.html#shel_write">shel_write</a> mode
9 to tell Geneva that it knows about the <a href="evnt.html#AP_TERM">AP_TERM</a> message and respond
to that message by removing itself from the list before quitting.
<br>&nbsp;
</p></li>
<li><p> If your vector routine does not wish to generate an event, then
it should pass control through to the previous routine in the XBRA
chain.
<br>&nbsp;
</p></li>
<li><p> If Geneva is running without MiNT, then the vector routines are
always called in supervisor mode. If running with MiNT, then the CPU
is in user mode. When MiNT is in memory protection mode, an
application which uses vectors must at least be in Readable mode, and
should most likely in Global mode.
<br>&nbsp;
</p></li>
</ul>

<p>See the files VECTEST.C and VECTESTS.S for an example.
</p>
<p>Querverweis: <a href="bios_cookiejar.html#Cookie_2C_20Gnva">Cookie, Gnva</a>
</p>
<h3><a name="HNDL_OBJ">8.27.18 HNDL_OBJ</a></h3>
<pre>typedef int16_t (<a href="proto_xfsl.html#cdecl">cdecl</a> *HNDL_OBJ) ( void *dialog, <a href="#EVNT">EVNT</a> *events,
                                 int16_t obj,
                                 int16_t clicks, void *data );
</pre>
<p>Dabei gilt:
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>dialog</i></td>
<td valign="top"> Zeiger auf eine Dialogstruktur. Auf diese sollte nicht direkt,
sondern nur mit Hilfe der wdlg_xxx Funktionen zugegriffen werden.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>events</i></td>
<td valign="top"> Zeiger auf die <a href="#EVNT">EVNT</a>-Strukur, die bei <a href="wdlg.html#wdlg_evnt">wdlg_evnt</a> übergeben wurde
(falls der Parameter <i>obj</i> &gt;= 0 ist), oder NULL.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>obj</i></td>
<td valign="top">
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;=0:</td>
<td valign="top"> Objektnummer
</td></tr>

<tr><td nowrap="nowrap" valign="top">&lt;0:</td>
<td valign="top"> Funktionsnummer:
<pre> -1 = <a href="#HNDL_INIT">HNDL_INIT</a>    // Dialog initialisieren
 -2 = <a href="#HNDL_MESG">HNDL_MESG</a>    //
 -3 = <a href="#HNDL_CLSD">HNDL_CLSD</a>    // Dialogfenster wurde geschlossen
 -5 = <a href="#HNDL_OPEN">HNDL_OPEN</a>    // Dialog-Initialisierung abschließen
 -6 = <a href="#HNDL_EDIT">HNDL_EDIT</a>    // Zeichen für ein Editfeld prüfen
 -7 = <a href="#HNDL_EDDN">HNDL_EDDN</a>    // Zeichen wurde ins Editfeld gesetzt
 -8 = <a href="#HNDL_EDCH">HNDL_EDCH</a>    // Editfeld wurde gewechselt
 -9 = <a href="#HNDL_MOVE">HNDL_MOVE</a>    // Dialog wurde verschoben
-10 = <a href="#HNDL_TOPW">HNDL_TOPW</a>    // Dialogfenster kam nach oben
-11 = <a href="#HNDL_UNTP">HNDL_UNTP</a>    // Dialogfenster ist nicht aktiv
</pre>

</td></tr>
</table>

<br>Von diesen Funktionsnummern muß nur auf <a href="#HNDL_CLSD">HNDL_CLSD</a> reagiert
werden; alle anderen Ereignisse können je nach Bedarf beachtet
werden.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>clicks</i></td>
<td valign="top"> Anzahl der Mausklicks, falls es sich bei <i>obj</i> um eine
Objektnummer handelt.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>data</i></td>
<td valign="top"> Falls der Parameter <i>obj</i> eine positive Objektnummer ist,
wird hier die Variable <i>user_data</i> aus der Funktion <a href="wdlg.html#wdlg_create">wdlg_create</a>
übergeben. Anderenfalls ist der Wert von der entsprechenden
Funktionsnummer abhängig.

</td></tr>
</table>

<p><b>Hinweis:</b> Die Funktion wird aufgerufen, wenn auf ein
<a href="aes_fundamentals.html#EXIT">EXIT</a>- oder <a href="aes_fundamentals.html#TOUCHEXIT">TOUCHEXIT</a> Objekt geklickt wurde (in diesem Fall ist
<i>obj</i> eine positive Objektnummer) oder wenn ein den Dialog
betreffendes Ereignis eingetreten ist (dann ist <i>obj</i> negativ
und enthält eine entsprechende Funktionsnummer (s.o.)).
</p>
<p>Die Parameter werden über den Stack übergeben und die Routine
darf die Register d0-d2/a0-a2 verändern. Falls die Funktion mit einer
unbekannten Funktionsnummer in <i>obj</i> aufgerufen wird oder eine
der obigen Funktionsnummern ignoriert werden soll, muß der Wert 1
zurückgeliefert werden.
</p>
<p>Querverweis: <a href="#Beispiel_20zu_20HNDL_OBJ">Beispiel-Implementation</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="Beispiel_20zu_20HNDL_OBJ">8.27.18.1 Beispiel zu HNDL_OBJ</a></h4>
<pre>/* Der folgende Code ist ein Beispiel für eine Implementation
   der handle_exit Funktion, wie sie z.B. als Parameter bei
   <a href="wdlg.html#wdlg_create">wdlg_create</a> vorkommt. */

int16_t <a href="proto_xfsl.html#cdecl">cdecl</a> handle_exit ( void *dialog, <a href="#EVNT">EVNT</a> *events, int16_t obj,
                         int16_t clicks, void *data )
{
    /*
     * Ereignis oder Objektnummer?
     * Alle Ereignisse außer <a href="#HNDL_CLSD">HNDL_CLSD</a> werden bei diesem Beispiel
     * ignoriert
     */

    if ( obj &lt; 0 )
    {
        if ( obj == <a href="#HNDL_CLSD">HNDL_CLSD</a> )     /* Closer betätigt? */
            return( 0 );            /* beenden */
        if ( obj == <a href="#HNDL_EDIT">HNDL_EDIT</a> )
        {
            /*  In Fensterdialogen kann es nützlich sein, Tasten-
                kombinationen mit Control in Eingabefeldern zu igno-
                rieren, damit Shortcuts wie z.B. Ctrl-U, Ctrl-W oder
                Ctrl-Q in der Eventschleife des Programms abgearbei-
                tet werden können. In diesem Fall sollte nach <a href="#HNDL_EDIT">HNDL_EDIT</a>
                eine 0 zurückgeliefert werden, damit die Taste nicht
                von <a href="objc.html#objc_edit">objc_edit</a> bearbeitet wird.
            */
        }
    }
    else
    {                         /* ein Objekt ist angewählt worden  */
        switch ( obj )        /* Aktionen einleiten (falls nötig) */
        {
            case ...
              .
              .
              .
            case MY_<a href="aes_fundamentals.html#EXIT">EXIT</a>_<a href="#OBJECT">OBJECT</a>:    ..... return( 0 );  /* beenden */
        }
    }
    return( 1 ); /* weitermachen */
}
</pre>
<h4><a name="HNDL_INIT">8.27.18.2 HNDL_INIT</a></h4>
<p><i>data</i> ist die bei <b>wdlg_init</b> übergebene Variable.
Falls handle_exit den Wert 0 zurückliefert, legt <b><a href="wdlg.html#wdlg_create">wdlg_create</a></b>
keine Dialog-Struktur an (Fehler). Die Variable code wird in
<i>clicks</i> übergeben.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_MESG">8.27.18.3 HNDL_MESG</a></h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="wdlg.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück. <i>events</i> zeigt auf die bei <a href="wdlg.html#wdlg_evnt">wdlg_evnt</a>
übergebene <a href="#EVNT">EVNT</a>-Struktur.
</p>
<p><b>Hinweis:</b> Dieser Code wird nur dann übergeben, wenn ein
Nachrichtencode zwischen 20 und 39 empfangen wurde, der nicht mit den
anderen Opcodes bearbeitet wird. Er wird z.B. für die Ikonifizierung
benötigt.
</p>
<p><b>Achtung:</b> Dieser Opcode wird erst seit der <a href="magic.html">MagiC</a> Version
4.50 vom 18.04.96 unterstützt.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_OPEN">8.27.18.4 HNDL_OPEN</a></h4>
<p><i>data</i> ist die bei <b><a href="wdlg.html#wdlg_open">wdlg_open</a></b> übergebene Variable.
Die Variable code wird in <i>clicks</i> übergeben.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_CLSD">8.27.18.5 HNDL_CLSD</a></h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="wdlg.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück.
</p>
<p><i>events</i> zeigt auf die bei <a href="wdlg.html#wdlg_evnt">wdlg_evnt</a> überg.
<a href="#EVNT">EVNT</a>-Struktur.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_MOVE">8.27.18.6 HNDL_MOVE</a></h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="wdlg.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück.
</p>
<p><i>events</i> zeigt auf die bei <a href="wdlg.html#wdlg_evnt">wdlg_evnt</a> überg.
<a href="#EVNT">EVNT</a>-Struktur.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_TOPW">8.27.18.7 HNDL_TOPW</a></h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="wdlg.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück.
</p>
<p><i>events</i> zeigt auf die bei <a href="wdlg.html#wdlg_evnt">wdlg_evnt</a> überg.
<a href="#EVNT">EVNT</a>-Struktur.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_UNTP">8.27.18.8 HNDL_UNTP</a></h4>
<p><i>data</i> ist user_data. Falls handle_exit den Wert 0
zurückliefert, wird der Dialog geschlossen - <b><a href="wdlg.html#wdlg_evnt">wdlg_evnt</a></b>
liefert den Wert 0 zurück.
</p>
<p><i>events</i> zeigt auf die bei <a href="wdlg.html#wdlg_evnt">wdlg_evnt</a> überg.
<a href="#EVNT">EVNT</a>-Struktur.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_EDIT">8.27.18.9 HNDL_EDIT</a></h4>
<p><i>data</i> zeigt auf ein Wort mit dem Tastencode. Falls
handle_exit den Wert 1 zurückliefert, wird der Tastendruck
verarbeitet, bei 0 ignoriert.
</p>
<p><i>events</i> zeigt auf die bei <b><a href="wdlg.html#wdlg_evnt">wdlg_evnt</a></b> überg.
<a href="#EVNT">EVNT</a>-Struktur.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_EDDN">8.27.18.10 HNDL_EDDN</a></h4>
<p><i>data</i> zeigt auf ein Wort mit dem Tastencode.
<i>events</i> zeigt auf die bei <b><a href="wdlg.html#wdlg_evnt">wdlg_evnt</a></b> überg.
<a href="#EVNT">EVNT</a>-Struktur.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h4><a name="HNDL_EDCH">8.27.18.11 HNDL_EDCH</a></h4>
<p><i>data</i> zeigt auf ein Wort mit der Objektnummer des neuen
Edit-Felds.
</p>
<p>Querweise: <a href="#HNDL_OBJ">HNDL_OBJ</a> &nbsp; <a href="wdlg.html#wdlg_create">wdlg_create</a>
</p>
<h3><a name="ICONBLK">8.27.19 ICONBLK</a></h3>
<pre>typedef struct
{
  uint16_t  *ib_pmask;    /* Zeiger auf die Icon-Maske     */
  uint16_t  *ib_pdata;    /* Zeiger auf das Icon-Bild      */
  int8_t    *ib_ptext;    /* Zeiger auf den Icon-Text      */
  uint16_t  ib_char;      /* Zeichen das im Icon erschei-
                             nen soll, sowie Vorder- und
                             Hintergrundfarbe des Icons    */
  uint16_t  ib_xchar;     /* x-Koordinate des Buchstabens  */
  uint16_t  ib_ychar;     /* y-Koordinate des Buchstabens  */
  uint16_t  ib_xicon;     /* x-Koordinate des Icons        */
  uint16_t  ib_yicon;     /* y-Koordinate des Icons        */
  uint16_t  ib_wicon;     /* Breite des Icons              */
  uint16_t  ib_hicon;     /* Höhe des Icons                */
  int16_t   ib_xtext;     /* x-Koordinate des Textes       */
  int16_t   ib_ytext;     /* y-Koordinate des Textes       */
  uint16_t  ib_wtext;     /* Breite des Textes             */
  uint16_t  ib_htext;     /* Höhe des Textes               */
  uint16_t  ib_resvd;     /* reserviert                    */
} ICONBLK;
</pre>
<p><b>Hinweise zu einzelnen Komponenten:</b>
</p>
<ul>
<li><p> <b>ib_pmask:</b> Zeiger auf ein Feld von 16-Bit-Werten, in
denen das Bit-Image der Icon-Maske abgelegt ist. Die Icon-Maske legt
fest, an welchen Stellen das Icon überhaupt gezeichnet werden soll
und welche Pixel transparent bleiben sollen. Erzielt wird dieser
Effekt dadurch, daß der Iconhintergrund zunächst mit den Bits der
Maske 'undiert' und dann mit den Icondaten 'geodert' wird.
<br>&nbsp;
</p></li>
<li><p> <b>ib_char:</b>
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Bits</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">15..12</td>
  <td align="left" valign="top">Vordergrundfarbe des Icons</td>
</tr>
<tr>
  <td align="left" valign="top">11..08</td>
  <td align="left" valign="top">Hintergrundfarbe des Icons</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;7..&nbsp;0</td>
  <td align="left" valign="top">Zeichen das im Icon erscheinen soll</td>
</tr>
</table>
</div>

</p></li>
<li><p> <b>ib_resvd:</b> unbenutzt, wird allerdings von den meisten
RCS-Programmen beim Schreiben in die Resourcedatei aufgenommen.
<br>&nbsp;
</p></li>
</ul>

<p>Für Farbicon unter PC <a href="gem_about.html">GEM</a> gilt:
<br>In a colour icon, ib_pdata and ib_pmask point to <a href="vdi_structures.html#MFDB">MFDB</a> objects.
Otherwise, they point to the lines of the bitmap.
</p>
<p>Querverweis: <a href="#CICONBLK">CICONBLK</a> &nbsp; <a href="#OBJECT">OBJECT</a>
</p>
<h3><a name="KEYCODE">8.27.20 KEYCODE</a></h3>
<p>Keypress description
</p>
<pre>typedef struct
{
  uint8_t shift;        /* bit 0: Right Shift key held */
                        /* bit 1: Left Shift key held  */
                        /* bit 2: Control key held     */
                        /* bit 3: Alternate key held   */
  uint8_t scan;         /* Scan code or zero           */
  uint8_t ascii;        /* ASCII value or zero         */
} KEYCODE;
</pre>
<p><i>ascii</i> is compared first with the ASCII value of the key
which was pressed. If this fails, the scan code is compared.
Currently, the key will match if either bit 0 or bit 1 of
&quot;shift&quot; is set, and either [Shift] key is held by the user.
</p>
<p>Querverweis: <a href="appl.html#x_appl_flags">x_appl_flags</a> &nbsp; <a href="#APPFLAGS">APPFLAGS</a> &nbsp; <a href="geneva_function.html#x_settings">x_settings</a> &nbsp; <a href="#SETTINGS">SETTINGS</a>
</p>
<h3><a name="LBOX_ITEM">8.27.21 LBOX_ITEM</a></h3>
<pre>typedef struct _lbox_item
{
   struct _lbox_item *next;  /* Zeiger auf den nächsten Eintrag */
                             /* in der Scroll-Liste             */
   int16_t  selected;        /* Objekt selektiert?              */
   int16_t  data1;           /* Daten für das Programm          */
   void     *data2;
   void     *data3;
} LBOX_ITEM;
</pre>
<p><b>Hinweis:</b> Die Struktur kann aber, wenn bei den Aufrufen
entsprechend gecastet wird, durchaus wie das folgende Beispiel
aussehen:
</p>
<pre>typedef struct
{
   void     *next;
   int16_t   selected;

   ... ab hier nach Belieben der Applikation...
} LB_EXAMPLE;
</pre>
<p>Es ist lediglich darauf zu achten, daß als erstes Element ein
Zeiger auf den Nachfolger, und als zweites Element ein Wort das
angibt, ob der entsprechende Eintrag selektiert ist, vorhanden ist.
</p>
<p>Querverweis:
<br><a href="lbox.html#lbox_create">lbox_create</a> &nbsp; <a href="lbox.html#lbox_free_list">lbox_free_list</a> &nbsp; <a href="lbox.html#lbox_get_idx">lbox_get_idx</a> &nbsp; <a href="lbox.html#lbox_get_item">lbox_get_item</a> &nbsp;
<a href="lbox.html#lbox_get_items">lbox_get_items</a>
</p>
<h3><a name="LIST_BOX">8.27.22 LIST_BOX</a></h3>
<pre>typedef void *LIST_BOX;
</pre>
<h3><a name="MEDIA_SIZE">8.27.23 MEDIA_SIZE</a></h3>
<p>Diese Struktur dient der Beschreibung eines Papierformates, und
ist wie folgt definiert:
</p>
<pre>typedef struct _media_size
{
   struct _media_size *next;   /* Zeiger auf Nachfolger     */
   int32_t       size_id;      /* Kennung des Papierformats */
   int8_t        name[32];     /* Name des Papierformats    */
} MEDIA_SIZE;
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_printers">pdlg_add_printers</a>
</p>
<h3><a name="MEDIA_TYPE">8.27.24 MEDIA_TYPE</a></h3>
<p>Diese Struktur dient der Beschreibung eines Papiertyps bzw.
Druckmediums, und ist wie folgt definiert:
</p>
<pre>typedef struct _media_type
{
   struct _media_type   *next;    /* Zeiger auf Nachfolger     */
   int32_t              type_id;  /* Kennung des Papierformats */
   int8_t               name[32]; /* Name des Papierformats    */
} MEDIA_TYPE;
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_printers">pdlg_add_printers</a>
</p>
<h3><a name="MENU">8.27.25 MENU</a></h3>
<pre>typedef struct
{
    <a href="#OBJECT">OBJECT</a>  *mn_tree;    /* Adresse des Menü-Objektbaumes  */
    int16_t mn_menu;     /* <a href="indexudo.html">Index</a> des Parent-Objektes      */
    int16_t mn_item;     /* Anfangs-Menüeintrag (bestimmt  */
                         /* die Position des Menüs         */
    int16_t mn_scroll;   /* 0 = nicht scrollen             */
                         /* &gt;0 = scrollen (ohne scrollbar) */
                         /* -1 = scrollen (mit scrollbar)  */
                         /*     (<a href="aes_main.html">AES</a> &gt;= 4.1)               */
    int16_t mn_keystate; /* Tastaturstatus (Shift, Control */
                         /* bzw. Alternate)                */
} MENU;
</pre>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="menu.html#menu_attach">menu_attach</a> &nbsp; <a href="menu.html#menu_popup">menu_popup</a>
</p>
<h3><a name="MFORM">8.27.26 MFORM</a></h3>
<p>Die Struktur MFORM legt das Aussehen des Mauszeigers fest, und
ist wie folgt definiert:
</p>
<pre>typedef struct mfstr
{
    int16_t  mf_xhot;       /* X-Pos. Aktionspunkt */
    int16_t  mf_yhot;       /* Y-Pos. Aktionspunkt */
    int16_t  mf_nplanes;    /* Anzahl der Planes   */
    int16_t  mf_fg;         /* Maskenfarbe         */
    int16_t  mf_bg;         /* Zeigerfarbe         */
    int16_t  mf_mask[16];   /* Maskenform          */
    int16_t  mf_data[16];   /* Zeigerform          */
} MFORM;
</pre>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="graf.html#graf_mouse">graf_mouse</a>
</p>
<h3><a name="MN_SET">8.27.27 MN_SET</a></h3>
<pre>typedef struct
{
    int32_t display;    /* Anzeigeverzögerung              */
    int32_t drag;       /* Auswahlverzögerung              */
    int32_t delay;      /* Einfachklick Scroll-Verzögerung */
    int32_t speed;      /* Scroll-Verzögerung              */
    int16_t height;     /* Scroll-Höhe (Anzahl der darzu-  */
                        /* stellenden Einträge)            */
} MN_SET;
</pre>
<p>Alle Verzögerungszeiten werden in Millisekunden gemessen.
</p>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="menu.html#menu_settings">menu_settings</a>
</p>
<h3><a name="OBJECT">8.27.28 OBJECT</a></h3>
<pre>typedef struct
{
   int16_t    ob_next;   /* das nächste Objekt            */
   int16_t    ob_head;   /* erstes Kind                   */
   int16_t    ob_tail;   /* letztes Kind                  */
   uint16_t   ob_type;   /* Objektart                     */
   uint16_t   ob_flags;  /* Manipulationsflags            */
   uint16_t   ob_state;  /* Objektstatus                  */
   void       *ob_spec;  /* mehr unter Objektart          */
   int16_t    ob_x;      /* x-Koordinate des Objekts      */
   int16_t    ob_y;      /* y-Koordinate des Objekts      */
   int16_t    ob_width;  /* Breite des Objekts            */
   int16_t    ob_height; /* Höhe des Objekts              */
} OBJECT;
</pre>
<table class="UDO_env_blist">
<tr><td nowrap="nowrap" valign="top"><b>ob_next:</b></td>
<td valign="top"> Nummer des folgenden Objekts gleicher Ebene oder -falls es das
letzte Element in der Ebene ist - des Parent-Objekts.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_head:</b></td>
<td valign="top"> Nummer des erstes Kind des Objekts, falls keines -1
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_next:</b></td>
<td valign="top"> Nummer des letzen Kind des Objekts, falls keines -1
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_type:</b></td>
<td valign="top"> Objektarten des AES
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_flags:</b></td>
<td valign="top"> Objektflags des AES
</td></tr>

<tr><td nowrap="nowrap" valign="top"><b>ob_state:</b></td>
<td valign="top"> Objektstati des AES

</td></tr>
</table>

<p>Querverweis: <a href="aes_fundamentals.html#Die_20Objekt-Struktur">Objektstruktur im AES</a>
</p>
<h3><a name="OB_PREFER">8.27.29 OB_PREFER</a></h3>
<p>Extended object description
</p>
<pre>typedef <a href="proto_xfsl.html#union">union</a>
{
  struct                       /* Bitmapped flags                   */
  {
    unsigned outlined   :1;    /* Object is <a href="aes_fundamentals.html#OUTLINED">OUTLINED</a>                */
    unsigned shadowed   :1;    /* Object is <a href="aes_fundamentals.html#SHADOWED">SHADOWED</a>                */
    unsigned draw_3D    :1;    /* Object is draw in 3D              */
    unsigned rounded    :1;    /* Object has round corners          */
    unsigned atari_3D   :1;    /* Display the object using Atari                */
                                                                                                                 /* <a href="aes_main.html">AES</a> 4 style 3D                    */
    unsigned shadow_text:1;    /* Draw the text with a shadow                           */
                                                                                                                         /* underneath it                     */
    unsigned bold_shadow:1;    /* Text is bold (can be combined                 */
                                                                                                                         /* with shadow_text)                 */
    unsigned reserved   :9;    /* Reserved for future use           */
    unsigned framecol   :4;    /* Color of frame                    */
    unsigned textcol    :4;    /* Color of text                     */
    unsigned textmode   :1;    /* 0: transparent, 1: replace        */
    unsigned fillpattern:3;    /* Fill pattern index                */
    unsigned interiorcol:4;    /* Color of interior                 */
  } s;
  uint32_t l;                  /* Longword for accessing all flags  */
} OB_PREFER;
</pre>
<p><i>atari_3D</i>, <i>shadow_text</i> and <i>bold_shadow</i>
present since Release 004.
</p>
<p>Querverweis: <a href="appl.html#x_appl_flags">x_appl_flags</a> &nbsp; <a href="#APPFLAGS">APPFLAGS</a> &nbsp; <a href="geneva_function.html#x_settings">x_settings</a> &nbsp; <a href="#SETTINGS">SETTINGS</a>
</p>
<h3><a name="PARMBLK">8.27.30 PARMBLK</a></h3>
<pre>typedef struct
{
   <a href="#OBJECT">OBJECT</a>   *pb_tree;        /* Zeiger auf den Objektbaum        */
   int16_t  pb_obj;          /* Nummer des Objekts               */
   int16_t  pb_prevstate;    /* vorheriger Objektstatus          */
   int16_t  pb_currstate;    /* neuer Objektstatus               */
   int16_t  pb_x;            /* x-Position des Objektes          */
   int16_t  pb_y;            /* y-Position des Objektes          */
   int16_t  pb_w;            /* Breite des Objektes              */
   int16_t  pb_h;            /* Höhe des Objektes                */
   int16_t  pb_xc;           /* x-Position des <a href="VDI_fundamentals.html#Clipping">Clipping</a>-Bereichs */
   int16_t  pb_yc;           /* y-Position des <a href="VDI_fundamentals.html#Clipping">Clipping</a>-Bereichs */
   int16_t  pb_wc;           /* Breite des <a href="VDI_fundamentals.html#Clipping">Clipping</a>-Bereichs     */
   int16_t  pb_hc;           /* Höhe des <a href="VDI_fundamentals.html#Clipping">Clipping</a>-Bereichs       */
   int32_t  pb_parm;         /* Parameter der <a href="#USERBLK">USERBLK</a>-Struktur   */
} PARMBLK;
</pre>
<p><b>Hinweis:</b> Das Objekt muß nur neu gezeichnet werden, wenn
alter und neuer Status identisch sind; anderenfalls reicht ein
'Update' des Objektbaums aus. Ferner sollten folgende Punkte beachtet
werden:
</p>
<ul>
<li><p> die eigene Funktion muß im Datenregister d0 dem AES
zurückliefern, welche Aspekte des Objektstatus noch aktualisiert
werden müssen. Damit ist es nicht unbedingt nötig, in der eigenen
Ausgabefunktion den Code zum invertieren des Objektes
auszuprogrammieren. Im allgemeinen wird man einige Bits des
Objektstatus selbst bearbeiten wollen, und andere dem AES
überlassen.
<br>&nbsp;
</p></li>
<li><p> die Funktion erhält den PARMBLK-Zeiger auf dem Stack, und muß
daher in Pure-C als '<a href="proto_xfsl.html#cdecl">cdecl</a>' deklariert werden.
<br>&nbsp;
</p></li>
<li><p> ein vollständiges Neuzeichnen des Objektes ist nur dann
nötig, wenn die Komponenten <i>pb_prevstate</i> und
<i>pb_currstate</i> gleich sind; anderenfalls hat sich nur der
Objektstatus geändert (zum Beispiel durch Anklicken).
<br>&nbsp;
</p></li>
<li><p> die eigene Funktion wird de facto als Unterprogramm der AES
ausgeführt. Daher sollte man im Hinblick auf die Stackbenutzung
vorsichtig sein. Außerdem darf man natürlich <i>keine</i> weiteren
AES-Aufrufe machen, da das AES <i>nicht</i> re-entrant ist.
Aufrufe der <a href="vdi_main.html">VDI</a>-<a href="vdi_input.html">Eingabefunktionen</a> sind hingegen an dieser Stelle
erlaubt.
<br>&nbsp;
</p></li>
<li><p> die Komponente <i>pb_parm</i> dient dazu, der eigenen Funktion
weitere Informationen (wie etwa einen Zeiger auf einen String) mit auf
den Weg zu geben.
<br>&nbsp;
</p></li>
<li><p> man sollte sich nie zu weit von der ursprünglichen Optik von
GEM entfernen. Abgerundete Rechtecke oder kursive Texte passen
sicherlich nicht in das normale Erscheinungsbild einer
GEM-Applikation.
<br>&nbsp;
</p></li>
</ul>

<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="gem_about.html">GEM</a> &nbsp; <a href="#USERBLK">USERBLK</a>
</p>
<h3><a name="PDLG_HNDL">8.27.31 PDLG_HNDL</a></h3>
<pre>typedef int32_t (<a href="proto_xfsl.html#cdecl">cdecl</a> *PDLG_HNDL)( struct _prn_settings *settings,
                                 struct _pdlg_sub *sub,
                                 int16_t exit_obj );
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a>
</p>
<h3><a name="PDLG_INIT">8.27.32 PDLG_INIT</a></h3>
<pre>typedef int32_t (<a href="proto_xfsl.html#cdecl">cdecl</a> *PDLG_INIT) (struct _prn_settings *settings,
                                 struct _pdlg_sub *sub );
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a>
</p>
<h3><a name="PDLG_RESET">8.27.33 PDLG_RESET</a></h3>
<pre>typedef int32_t (<a href="proto_xfsl.html#cdecl">cdecl</a> *PDLG_RESET) ( struct _prn_settings *settings,
                                   struct _pdlg_sub *sub );
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a> &nbsp; <a href="#PDLG_SUB">PDLG_SUB</a>
</p>
<h3><a name="PDLG_SUB">8.27.34 PDLG_SUB</a></h3>
<p>Diese Struktur dient der Beschreibung einer Geräteeinstellung,
und ist wie folgt definiert:
</p>
<pre>typedef struct _pdlg_sub
{
   struct _pdlg_sub *next;      /* Zeiger auf Nachfolger           */
   int32_t     length;          /* Strukturlänge                   */
   int32_t     format;          /* Datenformat                     */
   int32_t     reserved;        /* reserviert                      */
   void        *drivers;        /* nur für interne Dialoge         */
   int16_t     option_flags;    /* verschiedene Flags              */
   int16_t     sub_id;          /* Kennung des Unterdialogs        */
   <a href="#DIALOG">DIALOG</a>      *dialog;         /* Zeiger auf die Struktur des
                                   Fensterdialogs oder 0L          */
   <a href="#OBJECT">OBJECT</a>      *tree;           /* Zeiger auf den Objektbaum       */
   int16_t     index_offset;    /* Offset des Unterdialogs         */
   int16_t     reserved1;       /* reserviert                      */
   int32_t     reserved2;       /* reserviert                      */
   int32_t     reserved3;       /* reserviert                      */
   int32_t     reserved4;       /* reserviert                      */
   <a href="#PDLG_INIT">PDLG_INIT</a>   init_dlg;        /* Initialisierungsfunktion        */
   <a href="#PDLG_HNDL">PDLG_HNDL</a>   do_dlg;          /* Behandlungsfunktion             */
   <a href="#PDLG_RESET">PDLG_RESET</a>  reset_dlg;       /* Zurücksetzfunktion              */
   int32_t     reserved5;       /* reserviert                      */
   <a href="#OBJECT">OBJECT</a>      *sub_icon;       /* Zeiger auf das Icon der Listbox */
   <a href="#OBJECT">OBJECT</a>      *sub_tree;       /* Objektbaum des Unterdialogs     */
   int32_t     reserved6;       /* reserviert                      */
   int32_t     reserved7;       /* reserviert                      */
   int32_t     private1;        /* dialogeigene Informationen-1    */
   int32_t     private2;        /* dialogeigene Informationen-2    */
   int32_t     private3;        /* dialogeigene Informationen-3    */
   int32_t     private4;        /* dialogeigene Informationen-4    */
} PDLG_SUB;
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_sub_dialogs">pdlg_add_sub_dialogs</a>
</p>
<h3><a name="POPINFO">8.27.35 POPINFO</a></h3>
<pre>typedef struct
{
    <a href="#OBJECT">OBJECT</a>  *tree;     /* <a href="xcontrol.html#Popup">Popup</a>-Menü                  */
    int16_t  obnum;    /* aktuelles Objekt von &lt;tree&gt; */
} POPINFO;
</pre>
<p><b>Hinweis:</b> Die Komponente tree zeigt auf einen Objektbaum,
der etwa für <a href="form.html#form_popup">form_popup</a> als Eingabe dienen könnte. D.h. die Box
sollte als Objekt 0 eine <a href="aes_fundamentals.html#G_BOX">G_BOX</a> oder <a href="aes_fundamentals.html#G_IBOX">G_IBOX</a> enthalten, die von den
anderen Objekten vollständig bedeckt wird. Objekte die nicht
auswählbar sind, sollten wie im Dropdownmenü den Status <a href="aes_fundamentals.html#DISABLED">DISABLED</a>
erhalten.
</p>
<p>Alle wählbaren Objekte müssen den Status <a href="aes_fundamentals.html#SELECTABLE">SELECTABLE</a> haben.
Zusätzlich müssen bei der Verwendung durch G_POPUP alle
selektierbaren Objekte vom Typ <a href="aes_fundamentals.html#G_STRING">G_STRING</a> (bzw. <a href="aes_fundamentals.html#G_SHORTCUT">G_SHORTCUT</a>) oder
<a href="aes_fundamentals.html#G_BUTTON">G_BUTTON</a> sein und mit zwei Leerstellen beginnen, letzteres wegen des
Häkchens, das von <a href="form.html#form_button">form_button</a> bzw. <a href="form.html#form_do">form_do</a> automatisch gesetzt wird!
</p>
<p>Wichtig ist, daß ob_x und ob_y von Objekt 0 des Menüs relativ
zum G_POPUP-Objekt angegeben werden, d.h. sie werden meistens beide 0
sein. Es wird empfohlen, einen Schatten und einen Rand der Stärke -1
anzugeben.
</p>
<p>Querverweis: <a href="magic.html">MagiC</a> &nbsp; <a href="aes_fundamentals.html#G_POPUP">G_POPUP</a>
</p>
<h3><a name="PRN_DIALOG">8.27.36 PRN_DIALOG</a></h3>
<pre>typedef void *PRN_DIALOG;
</pre>
<h3><a name="PRN_ENTRY">8.27.37 PRN_ENTRY</a></h3>
<pre>typedef struct _prn_entry
{
   /* Zeiger auf Nachfolger */
   struct _prn_entry *next;
   /* Strukturlänge */
   int32_t     length;
   /* Datenformat */
   int32_t     format;
   /* reserviert */
   int32_t     reserved;
   /* Treiberkennung */
   int16_t     driver_id;
   /* Treibertyp */
   int16_t     driver_type;
   /* Druckerkennung */
   int32_t     printer_id;
   /* Druckereigenschaften */
   int32_t     printer_capabilities;
   /* reserviert */
   int32_t     reserved1;
   /* verschiedene Flags */
   int32_t     flags;
   /* Zeiger auf Unterdialoge */
   struct _pdlg_sub  *sub_dialogs;
   /* Unterdialog bei Druckerwechsel initialisieren */
   <a href="#PRN_SWITCH">PRN_SWITCH</a>  setup_panel;
   /* Unterdialog bei Druckerwechsel  schließen */
   <a href="#PRN_SWITCH">PRN_SWITCH</a>  close_panel;
   /* Liste vorhand. Auflösungen */
   <a href="#PRN_MODE">PRN_MODE</a>    *modes;
   /* Liste vorhand. <a href="VDI_fundamentals.html#Papierformate">Papierformate</a> */
   <a href="#MEDIA_SIZE">MEDIA_SIZE</a>  *papers;
   /* Liste der Einzüge */
   <a href="#PRN_TRAY">PRN_TRAY</a>    *input_trays;
   /* Liste der Auswürfe */
   <a href="#PRN_TRAY">PRN_TRAY</a>    *output_trays;
   /* Name des Druckers */
   int8_t      name[32];
} PRN_ENTRY;
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_printers">pdlg_add_printers</a>
</p>
<h3><a name="PRN_MODE">8.27.38 PRN_MODE</a></h3>
<p>Diese Struktur dient der Beschreibung eines Druckermodus, und
ist wie folgt definiert:
</p>
<pre>typedef struct _prn_mode
{
   struct _prn_mode *next;         /* Zeiger auf Nachfolger             */
   int32_t     mode_id;            /* Modus (<a href="indexudo.html">Index</a> innerhalb der Datei) */
   int16_t     hdpi;               /* horizontale Auflösung in dpi      */
   int16_t     vdpi;               /* vertikale Auflösung in dpi        */
   int32_t     mode_capabilities;  /* Moduseigenschaften                */
   int32_t     color_capabilities; /* einstellbare Farbmodi             */
   int32_t     dither_flags;       /* Flags, die angeben, ob der
                                      korrespondierende Farbmodus mit
                                      oder ohne Dithern ansprechbar ist */
   <a href="#MEDIA_TYPE">MEDIA_TYPE</a>  *paper_types;       /* geeignete Papiertypen             */
   int32_t     reserved;           /* reserviert                        */
   int8_t      name[32];           /* Modusname                         */
} PRN_MODE;
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_printers">pdlg_add_printers</a>
</p>
<h3><a name="PRN_SETTINGS">8.27.39 PRN_SETTINGS</a></h3>
<pre>typedef struct _prn_settings
{
   int32_t  magic;            /* 'pset'                                 */
   int32_t  length;           /* (+) Strukturlänge                      */
   int32_t  format;           /* Strukturtyp                            */
   int32_t  reserved;         /* reserviert                             */
   int32_t  page_flags;       /* (+) Flags, u.a. gerade/ungerade Seiten
                                 0x0001 = nur Seiten mit gerader Nummer
                                 0x0002 = dto. mit ungeraden Nummern    */
   int16_t  first_page;       /* (+) erste zu druckende Seite (min.1)   */
   int16_t  last_page;        /* (+) dto. letzte Seite (max. 9999)      */
   int16_t  no_copies;        /* (+) Anzahl der Kopien                  */
   int16_t  orientation;      /* (+) Drehung
                                  0x0000 = <a href="proto_xfsl.html#Ausrichtung">Ausrichtung</a> unbekannt und
                                           nicht verstellbar
                                  0x0001 = Seite im <a href="vdi_escape.html#Hochformat">Hochformat</a> ausgeben
                                  0x0002 = Seite im <a href="vdi_escape.html#Querformat">Querformat</a> ausgeben */
   int32_t  scale;            /* (+) Skalierung: 0x10000L = 100%        */
   int16_t  driver_id;        /* (+) <a href="appl.html#VDI-Ger_C3_A4tenummer">VDI-Gerätenummer</a>                   */
   int16_t  driver_type;      /* Typ des eingestellten Treibers         */
   int32_t  driver_mode;      /* Flags, u.a. für Hintergrunddruck       */
   int32_t  reserved1;        /* reserviert                             */
   int32_t  reserved2;        /* reserviert                             */
   int32_t  printer_id;       /* Druckernummer                          */
   int32_t  mode_id;          /* Modusnummer                            */
   int16_t  mode_hdpi;        /* horizontale Auflösung in dpi           */
   int16_t  mode_vdpi;        /* vertikale Auflösung in dpi             */
   int32_t  quality_id;       /* Druckmodus (hardwäremäßige Qualität,
                                 z.B. Microweave oder Econofast)        */
   int32_t  color_mode;       /* Farbmodus                              */
   int32_t  plane_flags;      /* Flags für auszugebende Farbebenen
                                 (z.B. nur cyan)                        */
   int32_t  dither_mode;      /* Rasterverfahren                        */
   int32_t  dither_value;     /* Parameter für das Rasterverfahren      */
   int32_t  size_id;          /* Papierformat                           */
   int32_t  type_id;          /* Papiertyp (normal, glossy)             */
   int32_t  input_id;         /* Papiereinzug                           */
   int32_t  output_id;        /* Papierauswurf                          */
   int32_t  contrast;         /* Kontrast:   0x10000L = normal          */
   int32_t  brightness;       /* Helligkeit: 0x1000L  = normal          */
   int32_t  reserved3;        /* reserviert                             */
   int32_t  reserved4;        /* reserviert                             */
   int32_t  reserved5;        /* reserviert                             */
   int32_t  reserved6;        /* reserviert                             */
   int32_t  reserved7;        /* reserviert                             */
   int32_t  reserved8;        /* reserviert                             */
   int8_t   device[128];      /* Dateiname für den Ausdruck             */
   #ifdef __PRINTING__
   TPrint   mac_settings;     /* Einstellung des Mac-Druckertreibers    */
   #else
   struct
   {
      uint8_t inside[120];
   } mac_settings;
   #endif
} PRN_SETTINGS;
</pre>
<p><b>Hinweis:</b> Die mit (+) gekennzeichneten Strukturelemente
können von der Applikation ausgelesen werden. Auf alle anderen
Einträge sollte <i>nicht</i> zugegriffen werden. Daten wie z.B. die
Druckerauflösung oder die Farbanzahl sollten <i>nicht</i> der
Einstellstruktur entnommen werden, sondern beim Start des Ausdrucks
vom Drucker erfragt werden (es wäre z.B. möglich, daß der
Druckertreiber durch Speichermangel gezwungen wird, die
Druckauflösung gegenüber der in PRN_SETTINGS eingetragenen
Einstellung zu verringern).
</p>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_open">pdlg_open</a>
</p>
<h3><a name="PRN_SWITCH">8.27.40 PRN_SWITCH</a></h3>
<pre>typedef int32_t (<a href="proto_xfsl.html#cdecl">cdecl</a> *PRN_SWITCH) ( struct _drv_entr *drivers,
                                   struct _prn_settings *settings,
                                   struct _prn_entry *old_printer,
                                   struct _prn_entry *new_printer );
</pre>
<p><b>Hinweis:</b> Die Komponente <i>old_printer</i> kann auch 0L
sein!
</p>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_printers">pdlg_add_printers</a>
</p>
<h3><a name="PRN_TRAY">8.27.41 PRN_TRAY</a></h3>
<p>Diese Struktur dient der Beschreibung eines Einzugs bzw.
Auswurfs, und ist wie folgt definiert:
</p>
<pre>typedef struct _prn_tray
{
   struct _prn_tray  *next;    /* Zeiger auf Nachfolger       */
   int32_t           tray_id;  /* Nummer des Einzugs/Auswurfs */
   int8_t            name[32]; /* Name des Schachts           */
} PRN_TRAY;
</pre>
<p>Querverweis: <a href="pdlg.html">Druckdialoge</a> &nbsp; <a href="pdlg.html#pdlg_add_printers">pdlg_add_printers</a>
</p>
<h3><a name="RSHDR">8.27.42 RSHDR</a></h3>
<a name="Resource-Header"></a>
<a name="Resource-Kopf"></a>
<a name="Header_20einer_20Resource-Datei"></a>
<a name="Kopf_20einer_20Resource-Datei"></a>
<pre>typedef struct
{
   uint16_t rsh_vrsn;      /* Null                              */
   uint16_t rsh_object;    /* Position des Objekt-Feldes        */
   uint16_t rsh_tedinfo;   /* Position der <a href="#TEDINFO">TEDINFO</a>-Strukturen   */
   uint16_t rsh_iconblk;   /* Position der <a href="#ICONBLK">ICONBLK</a>-Strukturen   */
   uint16_t rsh_bitblk;    /* Position der <a href="aes_structures.html#BITBLK">BITBLK</a>-Strukturen    */
   uint16_t rsh_frstr;     /* Position der freien Strings       */
   uint16_t rsh_string;    /* unbenutzt                         */
   uint16_t rsh_imdata;    /* Position der Image-Daten          */
   uint16_t rsh_frimg;     /* Position der freien Images        */
   uint16_t rsh_trindex;   /* Position der Objektbaumtabelle    */
   uint16_t rsh_nobs;      /* Gesamtzahl der Objekte            */
   uint16_t rsh_ntree;     /* Gesamtzahl der Objektbäume        */
   uint16_t rsh_nted;      /* Gesamtzahl der <a href="#TEDINFO">TEDINFO</a>-Strukturen */
   uint16_t rsh_nib;       /* Gesamtzahl der <a href="#ICONBLK">ICONBLK</a>-Strukturen */
   uint16_t rsh_nbb;       /* Gesamtzahl der <a href="aes_structures.html#BITBLK">BITBLK</a>-Strukturen  */
   uint16_t rsh_nstring;   /* Gesamtzahl der Strings            */
   uint16_t rsh_nimages;   /* Gesamtzahl der Images             */
   uint16_t rsh_rssize;    /* Gesamtlänge der RSC-Datei         */
} RSHDR;
</pre>
<p><b>Hinweis:</b> Alle Positionsangaben sind relativ zum
Dateianfang zu verstehen. Noch ein Wort zu den 'freien Strings': zu
diesen gehören nicht nur die Zeichenketten, in denen sich die Daten
für die Alarmboxen befinden, sondern auch alle anderen Strings, die
ein Programm zu seiner Arbeit benutzt. Ein Beispiel dafür wäre der
Dateiname einer einzulesenden Datei oder ein Eintrag, der mit
<a href="menu.html#menu_text">menu_text</a> in einem Menü vorgenommen wird.
</p>
<a name="Resourcedateien_2C_20Gr_C3_B6_C3_9Fe_20von"></a>
<p>Diesem Kopf folgen die eigentlichen Resource-Daten. Man beachte
dabei, daß eine Resource-Datei aufgrund der Verwendung von
16-Bit-Werten als Zeiger nur eine Gesamtgröße von <i>maximal 64
Kbyte</i> erreichen kann. Dateien dieses Formats werden von allen
RCS-Programmen abgespeichert.
</p>
<p>Anwender des Programms Interface und RSM (Resource Master)
können auch mit Resource-Dateien &gt; 64 Kbyte arbeiten. Auch das
Betriebssystem <a href="magic.html">MagiC</a> unterstützt ab Version 3 Resourcedateien von
mehr als 64 Kbyte; das Laden der Resource erfolgt wie üblich per
<a href="rsrc.html#rsrc_load">rsrc_load</a>, der Rest wird völlig transparent vom System übernommen.
</p>
<p>Querverweis: <a href="rsrc.html#rsrc_rcfix">rsrc_rcfix</a> &nbsp; <a href="#RSXHDR">RSXHDR</a>
</p>
<h3><a name="RSXHDR">8.27.43 RSXHDR</a></h3>
<pre>typedef struct
{
  uint16_t rsh_vrsn;     /* should be 3                                 */
  uint16_t rsh_extvrsn;  /* not used                                    */
                         /* initialized to 'IN' für Interface,          */
                         /* 'RM' für ResourceMaster,                    */
                         /* 'OR' für ORCS                               */
  uint32_t rsh_object;
  uint32_t rsh_tedinfo;
  uint32_t rsh_iconblk;  /* list of ICONBLKS                            */
  uint32_t rsh_bitblk;
  uint32_t rsh_frstr;
  uint32_t rsh_string;
  uint32_t rsh_imdata;   /* image data                                  */
  uint32_t rsh_frimg;
  uint32_t rsh_trindex;
  uint32_t rsh_nobs;     /* counts of various structs                   */
  uint32_t rsh_ntree;
  uint32_t rsh_nted;
  uint32_t rsh_nib;
  uint32_t rsh_nbb;
  uint32_t rsh_nstring;
  uint32_t rsh_nimages;
  uint32_t rsh_rssize;   /* Gesamtlänge der RSC-Datei                   */
} RSXHDR;
</pre>
<p>Querverweis: <a href="rsrc.html#rsrc_load">rsrc_load</a> &nbsp; <a href="#RSHDR">RSHDR</a>
</p>
<h3><a name="SCANX">8.27.44 SCANX</a></h3>
<pre>typedef struct
{
    int8_t   scancode;
    int8_t   nclicks;
    int16_t  objnr;
} SCANX;
</pre>
<p><b>Hinweis:</b> Die Struktur enthält die Zuordnung für die
Taste mit dem Scancode <i>scancode</i>, bei deren Betätigung ein
<i>nclicks</i>-facher Mausklick auf das Objekt mit der Nummer
<i>objnr</i> ausgeführt wird. Das Ende der Tabelle wird durch einen
Scancode von Null markiert.
</p>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="magic.html">MagiC</a> &nbsp; <a href="#XDO_INF">XDO_INF</a> &nbsp; <a href="scancode.html">Scan-Code Tabelle</a>
</p>
<h3><a name="SETTINGS">8.27.45 SETTINGS</a></h3>
<p>Describes Geneva's global settings
</p>
<pre>typedef struct Settings
{
  int16_t version;                    /* Version SETTINGS is for, in BCD    */
  int16_t struct_len;                 /* Total # of bytes in SETTINGS       */
  int16_t boot_rez;                   /* ST/TT resolution at startup        */
  int16_t falcon_rez;                 /* Falcon video mode at startup       */
  <a href="proto_xfsl.html#union">union</a>                               /* Preferences                        */
  {
    struct                            /* Bitmapped flags                    */
    {
      unsigned pulldown          :1;  /* use pulldown menus                 */
      unsigned insert_mode       :1;  /* insert in dialog edits             */
      unsigned long_titles       :1;  /* long underlines X_<a href="aes_fundamentals.html#UNDERLINE">UNDERLINE</a>        */
      unsigned alerts_under_mouse:1;  /* alerts appear under mouse          */
      unsigned fsel_1col         :1;  /* column in Item Selector            */
      unsigned grow_shrink       :1;  /* 1: <a href="form.html#FMD_GROW">FMD_GROW</a>/SHRINK on              */
      unsigned tear_aways_topped :1;  /* 1: tear aways always usable        */
      unsigned auto_update_shell :1;  /*                                    */
      unsigned alert_mode_change :1;  /*                                    */
      unsigned ignore_video_mode :1;  /*                                    */
      unsigned no_alt_modal_equiv:1;  /* rel 004                            */
      unsigned no_alt_modeless_eq:1;  /* rel 004                            */
      unsigned preserve_palette  :1;  /* rel 004                            */
      unsigned mouse_on_off      :1;  /* rel 004                            */
      unsigned top_all_at_once   :1;  /* rel 005                            */
      unsigned child_pexec_single:1;  /* rel 006                            */
    } s;
    uint16_t i;                       /* Word for accessing all flags       */
  } flags;                            /* Preferences                        */
  int16_t gadget_pause;               /* # of 50 Hz timer tics to wait      */
  <a href="#KEYCODE">KEYCODE</a> menu_start;                 /* Key to start menus                 */
  <a href="#KEYCODE">KEYCODE</a> app_switch;                 /* Key to toggle between apps         */
  <a href="#KEYCODE">KEYCODE</a> app_sleep;                  /*                                    */
  <a href="#KEYCODE">KEYCODE</a> ascii_table;                /* Key to open ASCII table            */
  <a href="#KEYCODE">KEYCODE</a> redraw_all;                 /* Key to redraw whole screen         */
  <a href="#KEYCODE">KEYCODE</a> wind_keys[13];              /* Keys for window events             */

  <a href="#OB_PREFER">OB_PREFER</a> color_3D[4];              /* Colors for 3D objects              */
  <a href="#OB_PREFER">OB_PREFER</a> color_root[4];            /* Colors for root objects            */
  <a href="#OB_PREFER">OB_PREFER</a> color_exit[4];            /* Colors for <a href="aes_fundamentals.html#EXIT">EXIT</a> objects            */
  <a href="#OB_PREFER">OB_PREFER</a> color_other[4];           /* Colors for other objects           */

  int8_t sort_type                    /* fsel sort type, 0(Name) - 4(None)  */
  int8_t find_file[26]                /* fsel Search string                 */
  int8_t fsel_path[10][35]            /* Item Selector paths                */
  int8_t fsel_ext[10][6];             /* Item Selector extension strings    */

  <a href="#KEYCODE">KEYCODE</a> cycle_in_app;               /* rel 004                            */
  <a href="#KEYCODE">KEYCODE</a> iconify;                    /* rel 004                            */
  <a href="#KEYCODE">KEYCODE</a> alliconify;                 /* rel 004                            */
  <a href="#KEYCODE">KEYCODE</a> procman;                    /* rel 006                            */
  <a href="#KEYCODE">KEYCODE</a> unused[4];

  int8_t  graymenu;                   /* rel 004                            */
  int8_t  reserved;                   /* rel 004                            */

  <a href="proto_xfsl.html#union">union</a>                               /* rel 006                            */
  {
    struct
    {
      unsigned procman_details  :1;
      unsigned reserved         :31;
    } s;
    unsigned int32_t l;
  } flags2;

} SETTINGS;
</pre>
<p>The <i>color_xx</i> arrays are indexed depending upon the
number of bitplanes in the current resolution: 1-plane=0, 2-planes=1,
4-planes=2, &gt;4-planes=3.
</p>
<p>The <i>wind_keys</i> array is indexed using the following
constants:
</p>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">XS_UPPAGE</td>
  <td align="right" valign="top">0</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for up page key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_DNPAGE</td>
  <td align="right" valign="top">1</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for down page key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_UPLINE</td>
  <td align="right" valign="top">2</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for up line key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_DNLINE</td>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for down line key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_LFPAGE</td>
  <td align="right" valign="top">4</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for page left key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_RTPAGE</td>
  <td align="right" valign="top">5</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for page right key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_LFLINE</td>
  <td align="right" valign="top">6</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for line left key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_RTLINE</td>
  <td align="right" valign="top">7</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for line right key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_CLOSE</td>
  <td align="right" valign="top">8</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for close box key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_CYCLE</td>
  <td align="right" valign="top">9</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for cycle window key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_FULL</td>
  <td align="right" valign="top">10</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for full window key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_LFINFO</td>
  <td align="right" valign="top">11</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for info left key</td>
</tr>
<tr>
  <td align="left" valign="top">XS_RTINFO</td>
  <td align="right" valign="top">12</td>
  <td align="left" valign="top"><a href="indexudo.html">Index</a> for info right key</td>
</tr>
</table>
</div>

<p>Querverweis: <a href="geneva_function.html#x_settings">x_settings</a> &nbsp; <a href="#KEYCODE">KEYCODE</a> &nbsp; <a href="#OB_PREFER">OB_PREFER</a>
</p>
<h3><a name="SET_ITEM">8.27.46 SET_ITEM</a></h3>
<pre>typedef int16_t (<a href="proto_xfsl.html#cdecl">cdecl</a> *SET_ITEM)( <a href="#LIST_BOX">LIST_BOX</a> *box, <a href="#OBJECT">OBJECT</a> *tree,
                                struct _lbox_item *item,
                                int16_t obj_index, void *user_data,
                                <a href="GRECT.html">GRECT</a> *rect, int16_t first );
</pre>
<p>Dabei gilt:
</p>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top"><i>box</i></td>
  <td align="left" valign="top">Zeiger auf die Listbox-Struktur</td>
</tr>
<tr>
  <td align="left" valign="top"><i>tree</i></td>
  <td align="left" valign="top">Zeiger auf den Objektbaum des Dialogs</td>
</tr>
<tr>
  <td align="left" valign="top"><i>item</i></td>
  <td align="left" valign="top">Zeiger auf <a href="#LBOX_ITEM">LBOX_ITEM</a>-Struktur des zu setzenden Eintrags</td>
</tr>
<tr>
  <td align="left" valign="top"><i>obj_index</i></td>
  <td align="left" valign="top">Nummer des zu setzenden Objektes</td>
</tr>
<tr>
  <td align="left" valign="top"><i>user_data</i></td>
  <td align="left" valign="top">Zeiger der bei <a href="lbox.html#lbox_create">lbox_create</a> übergeben wurde</td>
</tr>
<tr>
  <td align="left" valign="top"><i>rect</i></td>
  <td align="left" valign="top">Rechteck für das Objekt-Redraw (oder NULL)</td>
</tr>
<tr>
  <td align="left" valign="top"><i>first</i></td>
  <td align="left" valign="top">Nummer des ersten sichtbaren Elements für Slider-B</td>
</tr>
</table>
</div>

<p><b>Hinweis:</b> Bei einer Listbox, die nur Text-Strings
enthält, ist dies typischerweise eine Funktion, die einen String, auf
den die <a href="#LBOX_ITEM">LBOX_ITEM</a> Struktur verweist, in das Objekt <i>obj_index</i>
kopiert. Der Parameter <i>rect</i> ist 0L, wenn ein Redraw der
Dialogbox durchgeführt wird oder wenn <a href="lbox.html#lbox_update">lbox_update</a> aufgerufen wurde.
Er ist hingegen <i>nicht</i> 0L, wenn der Anwender ein Objekt
selektiert oder deselektiert hat, und zeigt auf das <a href="GRECT.html">GRECT</a> für den
Redraw.
</p>
<p>Der Rückgabewert der Funktion ist die Nummer des Startobjekts
für die Funktion <a href="objc.html#objc_draw">objc_draw</a> bzw. <a href="wdlg.html#wdlg_redraw">wdlg_redraw</a>.
</p>
<p>Bei Einträgen in der Listbox, die aus mehreren Objekten
bestehen, ist es manchmal sinnvoll bei Selektion/Deselektion eines
Objekts das Redrawrechteck zu verkleinern oder das Startobjekt zu
ändern, um unnötige Zeichenoperationen und unnötiges Geflacker zu
vermeiden. In den meisten Fällen rufen die Listbox-Routinen nach der
oben beschriebenen Funktion die Routinen <a href="objc.html#objc_draw">objc_draw</a> bzw. <a href="wdlg.html#wdlg_redraw">wdlg_redraw</a>
auf, um den geänderten Inhalt anzuzeigen.
</p>
<p>Der Parameter <i>first</i> enthält die Nummer des ersten
sichtbaren Elements für Slider B, wenn die Listbox 2 Slider hat. Bei
einer (vertikalen) Listbox mit Text-Strings und zwei Slidern gibt man
z.B. beim Aufruf von <a href="lbox.html#lbox_create">lbox_create</a> die Anzahl der sichtbaren Zeichen in
<i>visible_b</i>, die gesamte Stringlänge in <i>entries_b</i> und
den <a href="indexudo.html">Index</a> des ersten sichtbaren Zeichens in <i>first_b</i> an. Wird
der Text horizontal gescrollt, wird die Funktion für alle sichtbaren
Strings aufgerufen und der Bereich neugezeichnet bzw. verschoben. Wenn
die Listbox nur einen Slider hat, ist first immer 0.
</p>
<p>Querverweis: <a href="lbox.html">Listboxen</a> &nbsp; <a href="lbox.html#lbox_create">lbox_create</a>
</p>
<h3><a name="SHELTAIL">8.27.47 SHELTAIL</a></h3>
<pre>typedef struct
{
    int16_t dummy;       /* ein Nullwort               */
    int32_t magic;       /* 'SHEL', wenn Shell...      */
    int16_t isfirst;     /* erster Aufruf der Shell    */
    int32_t lasterr;     /* letzter Fehler             */
    int16_t wasgr;       /* Programm war Grafikapp.    */
} SHELTAIL;
</pre>
<p><b>Hinweis:</b> Diese Informationen bekommt ein alternatives
Desktop von <a href="magic.html">MagiC</a> beim Programmstart übermittelt (per <a href="shel.html#shel_read">shel_read</a> zu
ermitteln). Gibt die Shell einen negativen Fehlercode zurück, so wird
MAGXDESK wieder aktiviert.
</p>
<p>Wenn die Komponente <i>isfirst</i> gesetzt ist, ist der Status
etwa aus der DESKTOP.INF-Datei zu lesen, anderenfalls aus einer
temporären Datei bzw. dem Shell-Puffer.
</p>
<p>Die Komponente <i>lasterr</i> entspricht dem Rückgabewert des
vorher gelaufenen Programms. Wenn dies ein <a href="gem_about.html">GEM</a>-Programm war, ist der
Fehler bereits per Alertbox angezeigt worden. Das Langwort ist
negativ, wenn der Fehler beim <a href="gemdos_process.html#Pexec">Pexec</a> selbst auftrat; ein
Programm-Rückgabewert besitzt immer ein High-Word von 0.
</p>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="gem_about.html">GEM</a> &nbsp; <a href="shel.html#shel_wdef">shel_wdef</a>
</p>
<h3><a name="SHELW">8.27.48 SHELW</a></h3>
<a name="xshelw"></a>
<pre>typedef struct xshelw
{
    const char *newcmd;   /* command line */
    int32_t psetlimit;    /* value for Psetlmit() */
    int32_t prenice;      /* value for <a href="gemdos_process.html#Prenice">Prenice</a>() */
    const char *defdir;   /* default diretory */
    char *env;            /* environment */
    int16_t uid;          /* New child's UID */
    int16_t gid;          /* New child's GID */
} SHELW;
</pre>
<h3><a name="SLCT_ITEM">8.27.49 SLCT_ITEM</a></h3>
<pre>typedef void (<a href="proto_xfsl.html#cdecl">cdecl</a> *SLCT_ITEM)( <a href="#LIST_BOX">LIST_BOX</a> *box, <a href="#OBJECT">OBJECT</a> *tree,
                                 struct _lbox_item *item,
                                 void *user_data, int16_t obj_index,
                                 int16_t last_state );
</pre>
<p>Dabei gilt:
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>box</i></td>
<td valign="top"> Zeiger auf Listbox-Struktur
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>tree</i></td>
<td valign="top"> Zeiger auf den Objektbaum des Dialogs
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>item</i></td>
<td valign="top"> Zeiger auf die <a href="#LBOX_ITEM">LBOX_ITEM</a>-Struktur des ausgewählten Eintrags
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>user_data</i></td>
<td valign="top"> Zeiger der bei <a href="lbox.html#lbox_create">lbox_create</a> übergeben wurde
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>obj_index</i></td>
<td valign="top"> ist die Nummer des angewählten Objekts. Bei einem Doppelklick ist
ähnlich wie nach <a href="form.html#form_do">form_do</a> das oberste Bit gesetzt. Wenn
<i>obj_index</i> 0 ist, heißt das, daß dem Eintrag kein Objekt
zugeordnet ist; er ist nicht sichtbar. Normalerweise ist das nur der
Fall, wenn gescrollt wird und durch Auswahl eines neuen Objekts die
(mittlerweile nicht mehr sichtbare) Selektion gelöscht werden muß.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>last_state</i></td>
<td valign="top"> ist der vorhergehende Status des Objekts. <i>last_state</i>
kann auch den gleichen Wert wie item-&gt;selected haben. In diesem
Fall kann die Funktion slct normalerweise sofort verlassen werden.

</td></tr>
</table>

<p>Querverweis: <a href="lbox.html#lbox_create">lbox_create</a>
</p>
<h3><a name="SWINFO">8.27.50 SWINFO</a></h3>
<pre>typedef struct
{
    int8_t  *string;     /* etwa &quot;<a href="tos_main.html">TOS</a>|KAOS|MAG!X&quot;          */
    int16_t  num;        /* Nr. der aktuellen Zeichenkette */
    int16_t  maxnum;     /* maximal erlaubtes &lt;num&gt;        */
} SWINFO;
</pre>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="gem_about.html">GEM</a> &nbsp; <a href="aes_fundamentals.html#G_SWBUTTON">G_SWBUTTON</a>
</p>
<h3><a name="TEDINFO">8.27.51 TEDINFO</a></h3>
<p>Die TEDINFO-Struktur wird benutzt um ein Textobjekt näher zu
beschreiben, und ist wie folgt definiert:
</p>
<pre>typedef struct
{
    int8_t    *te_ptext;          /* Zeiger auf einen String          */
    int8_t    *te_ptmplt;         /* Zeiger auf die Stringmaske       */
    int8_t    *te_pvalid;         /* Zeiger auf den Gültigkeitsstring */
    int16_t    te_font;           /* Zeichensatz                      */
    int16_t    te_fontid;         /* GDOS Font-ID                     */
    int16_t    te_just;           /* Justierung des Textes:
                                     0 = linksbündig
                                     1 = rechtsbündig
                                     2 = zentriert                    */
    int16_t    te_color;          /* Farbe                            */
    int16_t    te_fontsize;       /* GDOS Font-Größe in Punkten       */
    int16_t    te_thickness;      /* Rahmenbreite                     */
    int16_t    te_txtlen;         /* Maximale Länge des Textes        */
    int16_t    te_tmplen;         /* Länge der Stringmaske            */
} TEDINFO;
</pre>
<p>Dabei gilt es, die folgenden Einzelheiten zu beachten:
</p>
<ul>
<li><p> <i>te_ptext:</i> Wenn das erste Zeichen ein Klammeraffe (@)
ist, werden alle folgenden Zeichen als Platzhalter angesehen, und der
zunächst ausgegebene String besteht aus Leerzeichen. Folge: Der
Klammeraffe kann niemals am Anfang eines Edit-Feldes stehen!
<br>&nbsp;
</p></li>
<li><p> <i>te_ptmplt:</i> Schablone (template). Sie wird nur bei
<a href="aes_fundamentals.html#G_FTEXT">G_FTEXT</a> und <a href="aes_fundamentals.html#G_FBOXTEXT">G_FBOXTEXT</a> verwendet, d.h. bei <a href="aes_fundamentals.html#G_TEXT">G_TEXT</a> und <a href="aes_fundamentals.html#G_BOXTEXT">G_BOXTEXT</a> kann
hier ein Null-Zeiger stehen. Bei der Ausgabe werden alle '_' Zeichen
in der Schablone sukzessive durch die Zeichen in <i>te_ptext</i>
ersetzt, d.h. es wird eine Misch-Zeichenkette gebildet. I.A. wird die
Schablone also soviele '_' Zeichen enthalten, wie der Puffer für
<i>te_ptext</i> lang ist (ohne abschließendes Nullbyte).
<br>&nbsp;
</p></li>
<li><p> <i>te_pvalid:</i> String, der für jedes Zeichen in
<i>te_ptext</i> eine Zeichenkette enthält, die über die Gültigkeit
verschiedener Zeichen an dieser Stringposition Auskunft gibt. Es gilt:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Zeichen</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">1 - 9</td>
<td valign="top"> Accept any digit from 0 to that number. This is handy for doing
octal ('7') or binary ('1') validation. (Geneva)
</td></tr>

<tr><td nowrap="nowrap" valign="top">9</td>
<td valign="top"> nur Ziffern
</td></tr>

<tr><td nowrap="nowrap" valign="top">A</td>
<td valign="top"> nur Großbuchstaben/Leerzeichen
</td></tr>

<tr><td nowrap="nowrap" valign="top">a</td>
<td valign="top"> nur Buchstaben/Leerzeichen
</td></tr>

<tr><td nowrap="nowrap" valign="top">N</td>
<td valign="top"> Großbuchstaben, Ziffern, Leerzeichen
</td></tr>

<tr><td nowrap="nowrap" valign="top">n</td>
<td valign="top"> Buchstaben, Ziffern, Leerzeichen
</td></tr>

<tr><td nowrap="nowrap" valign="top">F</td>
<td valign="top"> alle Zeichen, die zu einem Dateinamen gehören und '*', '?' und
':'.
</td></tr>

<tr><td nowrap="nowrap" valign="top">f</td>
<td valign="top"> alle Zeichen, die zu einem Dateinamen, ohne '*', '?' und ':'.
</td></tr>

<tr><td nowrap="nowrap" valign="top">h</td>
<td valign="top"> Hexadezimale Zeichen. (Geneva)
</td></tr>

<tr><td nowrap="nowrap" valign="top">H</td>
<td valign="top"> Hexadezimal Zeichen. Kleinbuchstaben a - f werden in
Großbuchstaben A - F umgewandelt. (Geneva)
</td></tr>

<tr><td nowrap="nowrap" valign="top">P</td>
<td valign="top"> alle Zeichen, die zu einem Pfadnamen gehören
</td></tr>

<tr><td nowrap="nowrap" valign="top">p</td>
<td valign="top"> analog 'P', aber ohne die Zeichen '?' und '*'
</td></tr>

<tr><td nowrap="nowrap" valign="top">m</td>
<td valign="top"> alle Zeichen, die für einen langen Dateinamen gültig sind;
d.h. alle Zeichen außer Steuerzeichen (ASCII &lt; 32), sowie außer
':' und '\'. Dieser Code wird z.Zt. nur von <a href="magic.html">MagiC</a> unterstützt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">X</td>
<td valign="top"> alle Zeichen
</td></tr>

<tr><td nowrap="nowrap" valign="top">x</td>
<td valign="top"> alle Zeichen, Kleinbuchstaben werden automatisch in
Großbuchstaben umgewandelt. (Geneva)

</td></tr>
</table>

</p></li>
<li><p> <i>te_font:</i>
<br>3 = normal
<br>5 = kleiner Zeichensatz
<br>&nbsp;
<br>Für weiters siehe unten.
<br>&nbsp;
</p></li>
<li><p> <i>te_fontid:</i>
<br>Für weiters siehe unten.
<br>&nbsp;
</p></li>
<li><p> <i>te_color:</i> Für die Farbe des begrenzenden Rechteckes
gilt die folgende Belegung:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bit</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">12..15</td>
<td valign="top"> Rahmenfarbe (0..15)
</td></tr>

<tr><td nowrap="nowrap" valign="top">08..11</td>
<td valign="top"> Textfarbe (0..15)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;7</td>
<td valign="top"> Text (0 = transparent, 1 = deckend)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;4..&nbsp;6</td>
<td valign="top"> Intensität
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0&nbsp;&nbsp;&nbsp; =</td>
<td valign="top"> hohl
</td></tr>

<tr><td nowrap="nowrap" valign="top">1..6 =</td>
<td valign="top"> ansteigende Intensität
</td></tr>

<tr><td nowrap="nowrap" valign="top">7&nbsp;&nbsp;&nbsp; =</td>
<td valign="top"> solide Fläche

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0..&nbsp;3</td>
<td valign="top"> Innenfarbe (0..15)

</td></tr>
</table>

</p></li>
<li><p> <i>te_thickness:</i> Für den Rahmen sind folgende Werte
gültig:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Wert</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;0</td>
  <td align="left" valign="top">kein Rahmen</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;1..&nbsp;128</td>
  <td align="left" valign="top">Rand liegt 1 bis 128 Pixel im Inneren</td>
</tr>
<tr>
  <td align="left" valign="top">-1..-127</td>
  <td align="left" valign="top">Rand liegt 1 bis 127 Pixel außerhalb des Objektes</td>
</tr>
</table>
</div>

</p></li>
</ul>

<a name="GDOS-Fonts_20in_20Dialogen"></a>
<a name="Dialogen_2C_20GDOS-Fonts_20in"></a>
<a name="Zeichens_C3_A4tze_20in_20Dialogen"></a>
<p><b>Hinweis:</b> Die Komponenten <i>te_fontid</i> und
<i>te_fontsize</i> waren bisher reserviert. Ab <a href="aes_main.html">AES</a>-Version 4.1 ist es
möglich, beliebige GDOS-Fonts für TEDINFO-Objekte zu benutzen.
</p>
<p>Dazu ist über die Komponente <i>te_font</i> die Art des
Zeichensatzes zu spezifizieren:
</p>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top"><i>te_font</i></td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">SpeedoGDOS Font</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">SpeedoGDOS Font (monospaced)</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">GDOS Bitmap-Font</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">System-Zeichensatz</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">kleiner System-Zeichensatz</td>
</tr>
</table>
</div>

<p>Für Werte im Bereich 0..2 von <i>te_font</i> kann dann über
die Komponenten <i>te_fontid</i> bzw. <i>te_fontsize</i> der
gewünschte Zeichensatz und die gewünschte Punktgröße eingestellt
werden.
</p>
<p>Das Vorhandensein der neuen Möglichkeiten kann am einfachsten
per <a href="appl.html#UDO__25apgi_13">appl_getinfo</a> (Opcode 13) ermittelt werden.
</p>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="gem_about.html">GEM</a> &nbsp; <a href="#OBJECT">OBJECT</a> &nbsp; <a href="#XTED">XTED</a> &nbsp; <a href="magic_scroll.html">Scrollende Eingabefelder</a>
</p>
<h3><a name="USERBLK">8.27.52 USERBLK</a></h3>
<pre>typedef struct
{
   int16_t <a href="proto_xfsl.html#cdecl">cdecl</a> (*ub_code)(<a href="#PARMBLK">PARMBLK</a> *parmblock);
   int32_t ub_parm;
} USERBLK;
</pre>
<p><b>Hinweis:</b> Die Funktion <i>ub_code</i> wird bei jedem
Aufruf von <a href="objc.html#objc_draw">objc_draw</a> und <a href="objc.html#objc_change">objc_change</a> für das entsprechende Objekt
aufgerufen. Die Komponente <i>ub_parm</i> kann als optionaler
Parameter angesehen werden.
</p>
<h3><a name="UTXT_FN">8.27.53 UTXT_FN</a></h3>
<p>Diese Funktion ist wie folgt deklariert:
</p>
<pre>typedef void (<a href="proto_xfsl.html#cdecl">cdecl</a> *UTXT_FN) (int16_t x, int16_t y, int16_t *clip_rect,
                               int32_t id, int32_t pt, int32_t ratio,
                               int8_t *string);
</pre>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="fnts.html#fnts_add">fnts_add</a> &nbsp; <a href="#FNTS_ITEM">FNTS_ITEM</a> &nbsp; <a href="fnts.html">Zeichensatzauswahl</a>
</p>
<h3><a name="WIND_TREE">8.27.54 WIND_TREE</a></h3>
<pre>typedef struct WindTree
{
  int16_t handle;   /* Handle of window being modified  */
  int16_t count;    /* Number of objects in window      */
  int16_t flag;     /* Location to copy to/from         */
  <a href="#OBJECT">OBJECT</a> *tree;
} WIND_TREE;
</pre>
<a name="X_WTFL_RESIZE"></a>
<a name="X_WTFL_CLICKS"></a>
<a name="X_WTFL_SLIDERS"></a>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>flag</i></td>
<td valign="top">
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bit 0:</td>
<td valign="top"> Auto resize (X_WTFL_RESIZE=1)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit 1:</td>
<td valign="top"> Process clicks (X_WTFL_CLICKS=2)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit 2:</td>
<td valign="top"> Resize sliders, info (X_WTFL_SLIDERS=4)

</td></tr>
</table>


</td></tr>
</table>

<p>Querverweis: <a href="wind.html#x_wind_tree">x_wind_tree</a>
</p>
<h3><a name="WINFRAME_HANDLER">8.27.55 WINFRAME_HANDLER</a></h3>
<p>Übergabe-Struktur zum Einklinken
</p>
<pre>typedef struct {
  int16_t   version;                  /* Versionsnummer der Struktur       */
  int32_t   wsizeof;                  /* Größe der WINDOW-Struktur         */
  int16_t   whshade;                  /* Höhe eines ge-shade-ten Fensters  */
  void      (*wbm_create)( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_skind) ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_ssize) ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_sslid) ( <a href="#WININFO">WININFO</a> *w, int16_t vertical );
  void      (*wbm_sstr)  ( <a href="#WININFO">WININFO</a> *w );
  void      (*wbm_sattr) ( <a href="#WININFO">WININFO</a> *w, int16_t chbits );
  void      (*wbm_calc)  ( int16_t kind, int16_t *fg );
  int16_t   (*wbm_obfind)( <a href="#WININFO">WININFO</a> *w, int16_t x, int16_t y );
} WINFRAME_HANDLER;
</pre>
<p>Querverweis:
<br><a href="magic_function.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WININFO">WININFO</a> &nbsp; <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a>
</p>
<h3><a name="WINFRAME_SETTINGS">8.27.56 WINFRAME_SETTINGS</a></h3>
<pre>typedef struct {
  int16_t   flags;
  int16_t   h_inw;
  void      *finfo_inw;
} WINFRAME_SETTINGS;
</pre>
<p>Bits von <i>flags</i>:
<br>#define NO_BDROP 1
</p>
<p>Querverweis:
<br><a href="magic_function.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a> &nbsp; <a href="#WININFO">WININFO</a>
</p>
<h3><a name="WININFO">8.27.57 WININFO</a></h3>
<p>WINDOW-Struktur für <a href="magic.html">MagiC</a>-Kernel
</p>
<pre>typedef struct {
  int16_t   state;
  int16_t   attr;
  void      *own;         /* (APPL *)                     */
  int16_t   kind;         /* von <a href="wind.html#wind_create">wind_create</a>()            */
  char      *name;        /* Zeiger auf Titelzeile        */
  char      *info;        /* Zeiger auf Infozeile         */
  <a href="GRECT.html">GRECT</a>     curr;
  <a href="GRECT.html">GRECT</a>     prev;
  <a href="GRECT.html">GRECT</a>     full;
  <a href="GRECT.html">GRECT</a>     work;
  <a href="GRECT.html">GRECT</a>     overall;      /* Umriß                        */
  <a href="GRECT.html">GRECT</a>     unic;
  <a href="GRECT.html">GRECT</a>     min;          /* Minimale Größe               */
  int16_t   oldheight;    /* alte Höhe vor Shading        */
  int16_t   hslide;       /* horizontale Schieberposition */
  int16_t   vslide;       /* vertikale Schieberposition   */
  int16_t   hslsize;      /* horizontale Schiebergröße    */
  int16_t   vslsize;      /* vertikale Schiebergröße      */
  void      *wg;          /* Rechteckliste                */
  void      *nextwg;      /* nächstes Rechteck der Liste  */
  int16_t   whdl;
  <a href="#OBJECT">OBJECT</a>    tree[N_OBJS];
  int16_t   is_sizer;
  int16_t   is_info;
  int16_t   is_rgtobjects;
  int16_t   is_botobjects;
  <a href="#TEDINFO">TEDINFO</a>   ted_name;
  <a href="#TEDINFO">TEDINFO</a>   ted_info;
} WININFO;
</pre>
<p>Bits von <i>state</i>:
<br>#define OPENED 1
<br>#define COVERED 2
<br>#define ACTIVE 4
<br>#define LOCKED 8
<br>#define ICONIFIED 32
<br>#define SHADED 64
</p>
<p>Querverweis:
<br><a href="magic_function.html#sys_set_winframe_manager">sys_set_winframe_manager</a> &nbsp; <a href="#WINFRAME_HANDLER">WINFRAME_HANDLER</a> &nbsp; <a href="#WINFRAME_SETTINGS">WINFRAME_SETTINGS</a>
</p>
<h3><a name="XAESMSG">8.27.58 XAESMSG</a></h3>
<p>Diese Struktur ist wie folgt definiert:
</p>
<pre>typedef struct
{
   int16_t  dst_apid;       /* ID der Ziel-Applikation    */
   int16_t  unique_flg;     /* <a href="evnt.html#Nachrichten">Nachrichten</a> überschreiben? */
   void     *attached_mem;  /* Zeiger auf Speicherblock   */
   int16_t  *msgbuf;        /* Nachrichenpuffer           */
} XAESMSG;
</pre>
<p><b>Hinweis:</b> Die Komponente <i>unique_flg</i> gibt an, ob
gleichartige <a href="evnt.html#Nachrichten">Nachrichten</a> (d.h. solche mit gleichem Nachrichtentyp
msgbuf[0]) von der neuen Nachricht überschrieben werden sollen.
</p>
<p>Wenn <i>attached_mem</i> nicht NULL ist, wird damit ein per
<a href="gemdos_memory.html#Malloc">Malloc</a> allozierter Speicherblock angegeben, der die erweiterten
Nachrichten-Informationen enthält. Die Länge dieses Blocks ist beliebig
und für das System uninteressant, sie könnte z.B. als erstes
Langwort des Blocks oder in <i>msgbuf</i> [4,5] übergeben werden.
Das System weist den Speicherblock der Zielapplikation zu und
übermittelt dessen Adresse in msgbuf[6,7].
</p>
<p><b>Wichtig:</b> Die aufrufende Applikation muß davon ausgehen,
daß <i>msgbuf[6,7]</i> nach dem Aufruf von <a href="appl.html#appl_write">appl_write</a> zerstört
sind. Das System behält sich vor, den Inhalt des Speicherblocks
umzukopieren und den übergebenen Block freizugeben. Der Aufrufer darf
nach dem appl_write <b>nicht mehr</b> auf den Block zugreifen und ihn auf
gar keinen Fall freigeben!
</p>
<p>Gibt <a href="appl.html#appl_write">appl_write</a> einen Fehlercode zurück, so ist der Block
<i>nicht</i> übergeben worden und gehört nach wie vor der
aufrufenden Applikation. Ein Fehler tritt dann auf, wenn:
</p>
<ul>
<li><p> die Zielapplikation ungültig (nicht existent oder eingefroren)
ist
<br>&nbsp;
</p></li>
<li><p> der Nachrichtenpuffer der Zielapplikation voll ist
<br>&nbsp;
</p></li>
<li><p> die Zielapplikation kein Prozeß ist (z.B. der <a href="aes_fundamentals.html#Der_20Screen-Manager">SCRENMGR</a>) und ein
attached memory block angegeben worden ist.
<br>&nbsp;
</p></li>
</ul>

<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="appl.html#appl_write">appl_write</a> &nbsp; <a href="gem_about.html">GEM</a>
</p>
<h3><a name="XDO_INF">8.27.59 XDO_INF</a></h3>
<pre>typedef struct
{
    <a href="#SCANX">SCANX</a> *unsh;    /* Tabellen für UnShift-Kombinationen   */
    <a href="#SCANX">SCANX</a> *shift;   /* Tabellen für Shift-Kombinationen     */
    <a href="#SCANX">SCANX</a> *ctrl;    /* Tabellen für Control-Kombinationen   */
    <a href="#SCANX">SCANX</a> *alt;     /* Tabellen für Alternate-Kombinationen */
    void  *resvd;   /* reserviert */
} XDO_INF;
</pre>
<p><b>Hinweis:</b> In dieser Struktur liegen Zeiger auf Tabellen,
die einem Scancode eine Objektnummer der Dialogbox zuordnen. Hiermit
ist es auf einfache Weise möglich, Dialoge vollständig über die
Tastatur zu bedienen. Der Parameter <i>resvd</i> ist für spätere
Zwecke reserviert, und muss immer NULL sein.
</p>
<p>Querverweis: <a href="aes_main.html">AES</a> &nbsp; <a href="form.html#form_keybd">form_keybd</a> &nbsp; <a href="form.html#form_xdo">form_xdo</a> &nbsp; <a href="magic.html">MagiC</a> &nbsp; <a href="scancode.html">Scan-Code Tabelle</a>
</p>
<h3><a name="XFONTINFO">8.27.60 XFONTINFO</a></h3>
<p>Describes font being used and window gadget borders
</p>
<pre>typedef struct
{
   int16_t font_id;     /* <a href="vdi_main.html">VDI</a> font ID#                                       */
   int16_t point_size;  /* Point size of the font                             */
   int16_t gadget_wid;  /* Width of border around a char in a window gadget   */
   int16_t gadget_ht;   /* Height of border around a char in a window gadget  */
} XFONTINFO;
</pre>
<p><i>gadget_wid</i> and <i>gadget_ht</i> are added to the width
and height of the characters. These values should always be &gt;= 0.
</p>
<p>Querverweis: <a href="appl.html#x_appl_font">x_appl_font</a>
</p>
<h3><a name="XFSL_FILTER">8.27.61 XFSL_FILTER</a></h3>
<pre>typedef int16_t (<a href="proto_xfsl.html#cdecl">cdecl</a> XFSL_FILTER) (int8_t *path, int8_t *name,
       <a href="gemdos_structures.html#XATTR">XATTR</a> *xa);
</pre>
<p>Querverweis: <a href="fslx.html#fslx_do">fslx_do</a> &nbsp; <a href="fslx.html#fslx_open">fslx_open</a>
</p>
<h3><a name="XSHW_COMMAND">8.27.62 XSHW_COMMAND</a></h3>
<pre>typedef struct
{
   int8_t  *command;
   int32_t limit;
   int32_t nice;
   int8_t  *defdir;
   int8_t  *env;
} XSHW_COMMAND;
</pre>
<p>Querverweis: <a href="shel.html#shel_write">shel_write</a>
</p>
<h3><a name="XTED">8.27.63 XTED</a></h3>
<p>Diese Struktur wird im Zusammenhang mit scrollbaren
Texteditfeldern benötigt.
</p>
<pre>typedef struct _xted
{
   int8_t  *xte_ptmplt;
   int8_t  *xte_pvalid;
   int16_t xte_vislen;
   int16_t xte_scroll;
} XTED;
</pre>
<p>Querverweis: <a href="magic_scroll.html">Scrollende Eingabefelder</a> &nbsp; <a href="#TEDINFO">TEDINFO</a>
</p>
<h3><a name="X_BUF_V2">8.27.64 X_BUF_V2</a></h3>
<a name="ABLE_GETINFO"></a>
<a name="ABLE_PROP"></a>
<a name="ABLE_WTREE"></a>
<a name="ABLE_X3D"></a>
<a name="ABLE_XSHL"></a>
<a name="ABLE_PROP2"></a>
<a name="ABLE_EMSDESK"></a>
<a name="ABLE_XBVSET"></a>
<pre>typedef struct x_buf_v2
{
int16_t  buf_len   /* Length of the structure, including this word.      */
                   /* Future versions of this structure (X_BUF_V3 etc.)  */
                   /* may be bigger.                                     */
int16_t  arch      /* 16 for 16-bit <a href="aes_main.html">AES</a>, 32 for hypothetical 32-bit <a href="aes_main.html">AES</a>. */
<a href="#CLRCAT">CLRCAT</a>   *cc       /* Address of an array of 16 <a href="#CLRCAT">CLRCAT</a> structures.       */
                   /* This is so that they can be read by a program; in  */
                   /* <a href="gem_about.html#ViewMAX">ViewMAX</a>, the colors could be set but not reread.   */
<a href="#OBJECT">OBJECT</a>   *w_active /* Address of an object tree (19 elements) used to    */
                   /* draw window elements. Included so a program can    */
                   /* change symbols on window buttons.                  */
int8_t   *info     /* Address of a 0-terminated ASCII string (at most    */
                   /* 40 characters, no newlines) describing the <a href="aes_main.html">AES</a>     */
int32_t  abilities /* A bitmapped field describing what optional         */
                   /* functions this <a href="aes_main.html">AES</a> provides:                       */
/* ABLE_GETINFO  1    bit 0 : <a href="appl.html#xapp_getinfo">xapp_getinfo</a> supported                     */
/* ABLE_PROP     2    bit 1 : <a href="prop.html#prop_get">prop_get</a>, <a href="prop.html#prop_put">prop_put</a> and <a href="prop.html#prop_del">prop_del</a> supported  */
/* ABLE_WTREE    4    bit 2 : <a href="wind.html#wind_get">wind_get</a> and <a href="wind.html#wind_set">wind_set</a> can change glyphs    */
/* ABLE_X3D      8    bit 3 : <a href="gem_about.html#GEM_2F5">GEM/5</a> 3D using <a href="aes_fundamentals.html#DRAW3D">DRAW3D</a>                      */
/* ABLE_XSHL    16    bit 4 : <a href="xshl.html#xshl_getshell">xshl_getshell</a> &amp; xshl_putshell              */
/* ABLE_PROP2   32    bit 5 : <a href="prop.html#prop_gui_get">prop_gui_get</a>, <a href="prop.html#prop_gui_set">prop_gui_set</a>                 */
/* ABLE_EMSDESK 64    bit 6 : <a href="xgrf.html#xgrf_dtimage">xgrf_dtimage</a> supports EMS                  */
/* ABLE_XBVSET 128    bit 7 : supports 32 disc drives                    */
} X_BUF_V2;
</pre>
<p>An initialised X_BUF_V2 is one in which all members are 0 except
buf_len. This initialised buffer is then passed to <a href="appl.html#appl_init">appl_init</a>. On
return, if arch is 0 then the structure was not filled in by the <a href="aes_main.html">AES</a>;
otherwise it was. The buf_len field may be reduced, if the <a href="aes_main.html">AES</a> was
expecting an earlier version of the structure (ie, X_BUF_V1); this
should not be a problem because the structures are forward and
backward compatible.
</p>
<p>Querverweis: <a href="appl.html#appl_init">appl_init</a>
</p>
<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="aes_main.html"><img src="udo_up.gif" alt="AES" title="AES" border="0" width="24" height="24">AES</a>
<a name="UDO_nav_lf_FOOT" href="aes_functions.html"><img src="udo_lf.gif" alt="AES-Funktionsliste" title="AES-Funktionsliste" border="0" width="24" height="24">AES-Funktionsliste</a>
<a name="UDO_nav_rg_FOOT" href="xcontrol_main.html"><img src="udo_rg.gif" alt="XCONTROL" title="XCONTROL" border="0" width="24" height="24">XCONTROL</a>
</body>
</html>
