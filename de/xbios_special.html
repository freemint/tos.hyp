<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 02.08.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: Spezialbefehle
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_sound.html"><img src="udo_lf.gif" alt="Soundroutinen" title="Soundroutinen" border="0" width="24" height="24">Soundroutinen</a>
<a name="UDO_nav_rg_HEAD" href="xbios_keyboard.html"><img src="udo_rg.gif" alt="Tastaturfunktionen" title="Tastaturfunktionen" border="0" width="24" height="24">Tastaturfunktionen</a>

<hr>

<h1><a name="Spezialbefehle">4.20 Spezialbefehle</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Blitmode">Blitmode</a></td>
<td valign="top"> Blitterkonfiguration ändern oder ermitteln.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#CacheCtrl">CacheCtrl</a></td>
<td valign="top"> CPU Cacheverwaltung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#CJar">CJar</a></td>
<td valign="top"> Erzeugen, Abfragen und Löschen von Cookies
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dbmsg">Dbmsg</a></td>
<td valign="top"> Debugmeldungen ausgeben
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Janus">Janus</a></td>
<td valign="top"> Funktion des &quot;<a href="#Janus">Janus</a>&quot; Emulator
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Puntaes">Puntaes</a></td>
<td valign="top"> <a href="aes_main.html">AES</a> im ROM abschalten.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Random">Random</a></td>
<td valign="top"> Zufallszahlengenerator
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Ssbrk">Ssbrk</a></td>
<td valign="top"> Speicherplatz reservieren (nur intern verwendet).
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Supexec">Supexec</a></td>
<td valign="top"> Unterprogramm im Supervisor-Modus starten.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Trapper">Trapper</a></td>
<td valign="top"> Einklinken in <a href="gemdos_system.html">Systemfunktionen</a>.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#WdgCtrl">WdgCtrl</a></td>
<td valign="top"> Einstellen des Hardware-Watchdog

</td></tr>
</table>

<p>Querverweis: <a href="xbios_interface.html">Schnittstellenprogrammierung</a>
</p>
<h3><a name="Blitmode">4.20.1 Blitmode</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »blitter mode« - Blitter-Chip konfigurieren.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 64
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t Blitmode( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Blitmode ist eine <a href="xbios_main.html">XBIOS</a>-Routine um den Blitter einzuschalten
oder seine Existenz festzustellen. Wenn im Parameter <i>mode</i> der
Wert -1 angegeben wird, dann erhält man den Status des Blitter-Chips.
Bei allen anderen Werten wird der Blitter konfiguriert:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">Bit</td>
  <td align="left" valign="top">Beschreibung</td>
</tr>
<tr>
  <td align="right" valign="top">0</td>
  <td align="left" valign="top">0 = Blitter aus</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">1 = Blitter ein</td>
</tr>
<tr>
  <td align="right" valign="top">1-14</td>
  <td align="left" valign="top">reserviert</td>
</tr>
<tr>
  <td align="right" valign="top">15</td>
  <td align="left" valign="top">muss immer 0 sein</td>
</tr>
</table>
</div>

<br><b>Hinweis:</b> Lt. Atari darf die Funktion ohne
Versionsabfrage benutzt werden (obwohl sie beispielsweise im <a href="tos_main.html">TOS</a> 1.0
nicht vorhanden ist). Ermöglicht wird dies durch einen Seiteneffekt
im <a href="the_system_vectors.html#Dispatcher_2C_20XBIOS-">Dispatcher des XBIOS</a>. Besser ist es allerdings, sich nicht darauf zu verlassen,
da der entsprechende Trap ja von anderen Programmen verbogen werden
kann, und dann evtl. nicht der richtige Return-Wert zurückgeliefert
wird.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis durch gesetzte Bits
Eigenschaften des Blitters-Chips:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">Bit</td>
  <td align="left" valign="top">Bedeutung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">0: Blitter aus</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">1: Blitter an</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">0: Blitter nicht vorhanden</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">1: Blitter vorhanden</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">15</td>
  <td align="left" valign="top">immer 0</td>
</tr>
</table>
</div>

<br>Alle weiteren Bits sind reserviert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Offiziell ist diese Funktion erst ab <a href="tos_main.html">TOS</a>-Version 1.02
vorhanden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Blitmode">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Blitmode">4.20.1.1 Bindings für Blitmode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Blitmode">Blitmode</a>( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)   ; Offset 2
move.w    #64,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="CacheCtrl">4.20.2 CacheCtrl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »CacheCtrl« - CPU Cacheverwaltung
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 160
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t CacheCtrl( int16_t OpCode, int16_t Param );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine CacheCtrl dient zur Verwaltung der CPU-Caches
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">OpCode</td>
  <td align="left" valign="top">Beschreibung</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Liefert 0 zurück, wenn die Funktion vorhanden ist.</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Zurückschreiben des Datencaches</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Zurückschreiben des Befehlscaches</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">Zurückschreiben des Daten- und Befehlscaches</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">Abfrage, ob Datencache aktiv ist</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">Aktivieren/Deaktivieren des Datencaches</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 0, ausschalten</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 1, einschalten</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top">Zurückschreiben des Caches falls notwendig</td>
</tr>
<tr>
  <td align="center" valign="top">6</td>
  <td align="left" valign="top">Abrage, ob Befehlscache aktiv ist</td>
</tr>
<tr>
  <td align="center" valign="top">7</td>
  <td align="left" valign="top">Aktivieren/Deaktivieren des Befehlscaches</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 0, ausschalten</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 1, einschalten</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top">Zurückschreiben des Caches falls notwendig</td>
</tr>
</table>
</div>

<br><b>Bemerkung:</b>
<br>Im CT60 XBIOS hat der OpCode 5/7 dieselbe Funktionalität:
<br>mode: 0 = deaktivieren aller Caches.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 = aktivieren aller Caches.
<br>Betroffen sind die folgenden Caches: Data Cache, Store Buffer,
Branch Cache, Instruction Cache.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Im Erfolgsfall liefert die Funktion den Wert 0 oder <a href="bios_errors.html#EBADRQ">EBADRQ</a>,
wenn für <i>OpCode</i> ein Wert größer sieben übergeben wird.
<br>&nbsp;
<br>Als Alternative steht auch der Treiber &quot;CPU Cache Control
Driver v1.10&quot; von Robert Federle und Thomas Tempelmann für
andere Rechner zur Verfügung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar</td>
<td valign="top"> Die Funktion ist auf dem Milan seit TOS 4.06 verfügbar. Im
CT60 XBIOS ab Version v0.98a.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20CacheCtrl">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20CacheCtrl">4.20.2.1 Bindings für CacheCtrl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#CacheCtrl">CacheCtrl</a>( int16_t OpCode, int16_t Param );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    Param,-(sp)  ; Offset 4
move.w    OpCode,-(sp) ; Offset 2
move.w    #160,-(sp)   ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="CJar">4.20.3 CJar</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »CJar« - Erzeugen, Abfragen und Löschen von Cookies
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 17226 (0x434A)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t CJar( int16_t mode, int32_t cookie, int32_t *value );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine CJar dient auf komfortable Weise zum
Erzeugen, Abfragen und Löschen von Cookies.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Bedeutung
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> Modus 0:
<br>Ermittelt den Wert des Kekses und legt in an der angegebenen
Adresse ab. Übergibt man für <i>value</i> einen Nullzeiger, so wird
lediglich die Existenz des Kekses überprüft.
<br>Bei erfolgreicher Ermittlung des Kekses, liefert der Aufruf 0x6172
(=&quot;CJar_OK&quot;) zurück, sonst einen anderen Wert.
<br>Modus 1:
<br>Erzeugt einen neuen Keks (cookie). <i>Value</i> <b>zeigt</b> auf
einen Wert, der in den Jar eingetragen wird. WICHTIG! Es wird nicht
<i>value</i> eingetragen, sondern der Wert auf den 'value' weist! Bei
Übergabe eines NULL-Pointers wird 0 als Kekswert eingetragen.
Existiert der Keks bereits, so wird sein alter Inhalt überschrieben!
<br>Die Funktion liefert &quot;CJar_OK&quot; bei erfolgreicher
Eintragung. -1 wird für den Fall geliefert, daß der <a href="bios_cookiejar.html">Cookie-Jar</a> voll
ist.
<br>Modus 2:
<br>Entfernt den Keks <i>cookie</i> aus dem Jar. Der Wert von
<i>value</i> ist egal. Liefert bei erfolgreicher Entfernung
&quot;CJar_OK&quot;, sonst einen anderen Wert.
<br>Ist nur Verfügbar, wenn die Systemerweiterung Liberty (Cookie
'Lity') installiert ist.
</td></tr>

<tr><td nowrap="nowrap" valign="top">cookie</td>
<td valign="top"> Cookiebezeichnung
</td></tr>

<tr><td nowrap="nowrap" valign="top">value</td>
<td valign="top"> Adresse des Puffers, in dem die Daten abgelegt werden sollen.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Im Erfolgsfall liefert die Funktion den Wert CJar_OK (0x6172)
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar</td>
<td valign="top"> Die Funktion ist verfügbar, wenn der Cookie 'CJar' ($434A6172)
vorhanden ist. Dieser wird von JARxxx (Cookie Jar Manager) oder
Liberty erzeugt.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20CJar">Binding</a> &nbsp; <a href="gemdos_system.html#S_GETCOOKIE">Cookie Funktionen</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20CJar">4.20.3.1 Bindings für CJar</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#CJar">CJar</a>( int16_t mode, int32_t cookie, int32_t *value );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       value          ; Offset 8
move.l    cookie,-(sp)   ; Offset 4
move.w    mode,-(sp)     ; Offset 2
move.w    #17226,-(sp)   ; Offset 0
trap      #14            ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp      ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Dbmsg">4.20.4 Dbmsg</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dbmsg« -
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 11
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Dbmsg( int16_t rsrvd, int16_t msg_num, int32_t msg_arg )
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dbmsg() erlaubt es, spezielle Debuggingkommandos an einen
residenten Debugger zu schicken.
<br>&nbsp;
<br><i>srsrvd</i> ist zur Zeit reserviert und sollte immer den Wert
5 haben.
<br>&nbsp;
<br><i>msg_num</i> ist die Nachrichtennummer, die an den
Debugginghost geschickt wird. Werte von 0x0000 bis 0xEFFF werden für
applikationsspezifische <a href="evnt.html#Nachrichten">Nachrichten</a> benutzt. Werte von 0xF000 bis
0xFFFF werden für spezielle Debuggingnachrichten benutzt. Wenn
<i>msg_num</i> im Bereich der für die Applikation reservierten Werte
liegt, werden der Wert und der int32_t aus <i>msg_arg</i> angezeigt
und die Applikation wird angehalten. Wenn <i>msg_num</i> zwischen
0xF001 und 0xF0FF inklusive liegt, wird <i>msg_arg</i> als ein Zeiger
auf einen String, der vom Debugger ausgegeben werden soll,
interpretiert und das Debuggen untrerbrochen. Die Länge des Strings
wird im unteren Byte von <i>msg_num</i> angegeben.
<br>&nbsp;
<br>Wenn <i>msg_num</i> den Wert DB_NULLSTRING (0xF000) hat, wird
der String bis zur abschließenden 0 ausgegeben.
<br>&nbsp;
<br>Wenn <i>msg_num</i> den Wert DB_COMMAND (0xF100) hat, wird
<i>msg_arg</i> als ein Zeiger auf eine Zeichenkette mit einem
Debugger Kommando interpretiert. Das Format des Kommandos hängt von
dem bneutzten Debugger ab. Eine Anwendung bei Verwendung des Atari
Debuggers ist die Ausgabe eines Strings, ohne das Debuggen zu beenden:
<br>&nbsp;
<br>Dbmsg( 5, DB_COMMAND, &quot;echo 'Debugging <a href="proto_ssp.html#Message">Message</a>';g&quot; );
<br>&nbsp;
<br>Der Atari Debugger bis zur Version 3 kennt nur den Wert
DB_COMMAND (0xF100) für <i>msg_num</i>. Normalerweise ist es kein
Problem, ein Programm mit Debugging Messages ohne Debugger laufen zu
lassen, aus der endgültigen Version sollten diese Anweisungen
allerdings entfernt werden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Wenn ein Debugger geladen ist, der diese Funktion unterstützt.
Der einzige Debugger, der zur Zeit diese Funktion unterstützt, ist
der Atari Debugger.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Dbmsg">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Dbmsg">4.20.4.1 Bindings für Dbmsg</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dbmsg">Dbmsg</a>( int16_t rsrvd, int16_t msg_num, int32_t msg_arg )
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    msg_arg,-(sp)  ; Offset 6
move.w    msg_num,-(sp)  ; Offset 4
move.w    srsrvd,-(sp)   ; Offset 2
move.w    #11,-(sp)      ; Offset 0
trap      #14            ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp      ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Janus">4.20.5 Janus</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Janus« -
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 43
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Janus( int16_t mode )
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion stellt der Hardware-Emulator Janus zur
Verfügung. Laut einem Artikel in der ST-Computer 1996-04, S. 44 kann
man damit folgendes erzielt werden.
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">mode</td>
  <td align="left" valign="top">Beschreibung</td>
</tr>
<tr>
  <td align="right" valign="top">-1</td>
  <td align="left" valign="top">Ermitteln der aktiven parallele Schnittstelle</td>
</tr>
<tr>
  <td align="right" valign="top">1</td>
  <td align="left" valign="top">Umschaltung auf die erste parallele Schnittstelle</td>
</tr>
<tr>
  <td align="right" valign="top">2</td>
  <td align="left" valign="top">Umschaltung auf die zweite parallele Schnittstelle</td>
</tr>
<tr>
  <td align="right" valign="top">256</td>
  <td align="left" valign="top">Verlassen von Janus</td>
</tr>
</table>
</div>

<br><b>Hinweis:</b> Alle Angabe ohne Gewähr, da der Artikel nicht
sehr ausführlich ist.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Unbekannt bzw. siehe oben.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Nur unter dem Hardware-Emulator Janus.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Janus">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Janus">4.20.5.1 Bindings für Janus</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Janus">Janus</a>( int16_t mode )
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)    ; Offset 2
move.w    #43,-(sp)     ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Puntaes">4.20.6 Puntaes</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »punt AES« - <a href="aes_main.html">AES</a> abschalten.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 39
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void Puntaes( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die <a href="xbios_main.html">XBIOS</a>-Routine Puntaes schaltet das AES-Betriebssystem
ab. <a href="aes_about.html">Das AES</a> wird nur gestart, wenn &quot;os_magic&quot; im <a href="OSHEADER.html">OSHEADER</a>
auf die korrekte magische Zahl (0x87654321) zeigt. Puntaes setzt
dieses Flag (sofern möglich) zurück und boote dann das System neu.
<br>&nbsp;
<br><b>Hinweis:</b> Ab <a href="magic.html">MagiC</a> 4.00 wurde diese Funktion verändert
und besitzt verschiedene Unterfunktionen. Zum Aufruf muss zusätzlich
der Wert 'AnKr' übergeben werden. Bei einer falschen Funktionsnummer
wird <a href="gemdos_errors.html#EINVFN">EINVFN</a> zurückgeliefert.
<br>&nbsp;
<br>int32_t Puntaes ( 'AnKr', subfn, ... )
<br>
<br>&nbsp;
<ul>
<li><p> int32_t Puntaes ( 'AnKr', 0 )
<br>System beenden und zurück zum MacOS bzw. Windows
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 1, int16_t keycode )
<br>Wandle folgenden Alt-Tastencode in ASCII u.
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 2 )
<br>Neustart (warm_boot, nur für Atari)
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 3 )
<br>Kaltstart (cold_boot, nur für Atari)
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 4, int32_t key ) seit 12.04.1998
<br>Ermittle Cookie
<br>Liefert den Zeiger des Cookies <i>key</i> oder 0L wenn er nicht
vorhanden ist.
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 5 )
<br>Date2str: initialisiert die interne Variable datemode von <a href="magic.html">MagiC</a>
und liefert einen Zeiger auf die interne Funktion date2str.
<br>&nbsp;
<br>void date2str ( int8_t *s, int16_t date );
<br>DOS-Datum in eine Zeichenkette umwandeln.
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 6, vtsys *pointer )
<br>VT52 anmelden, alten Vektor zurückgeben. Ist <i>pointer</i> -1
dann wird nur der alte Vektor zurückgeliefert, bei 0 wird er
gelöscht.
<br>&nbsp;
</p></li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Puntaes">Binding</a> &nbsp; <a href="gemdos_system.html#S_GETCOOKIE">Cookie Funktionen</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Puntaes">4.20.6.1 Bindings für Puntaes</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Puntaes">Puntaes</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #39,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Random">4.20.7 Random</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »random generator« - Zufallsgenerator.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 17
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Random( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Routine Random liefert (basierend auf einem
Zeitgeber des Rechners) eine 24-Bit-Zufallszahl zurück.
<br>&nbsp;
<br><b>Hinweis:</b> Es handelt sich bei dieser Funktion
<i>nicht</i> um einen Hardware-Zufallszahlengenerator, sondern um
eine Software-Version, die den folgenden Algorithmus benutzt:
<br>&nbsp;
<pre>X = (X * 3.1415926...) + 1
</pre>
<br>Zurückgeliefert wird der um 8 Bits nach rechts verschobene Wert
X. Das Verhalten für die gesamte Zahl ist übrigens recht gut, die
Abfrage einzelner Bits im Sinne einer verminderten Zufälligkeit
jedoch <i>nicht</i> ratsam.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert als Ergebnis eine 24-Bit-Zufallszahl.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Random">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Random">4.20.7.1 Bindings für Random</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#Random">Random</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #17,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Ssbrk">4.20.8 Ssbrk</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set memory break point« - Speicherplatz reservieren.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 1
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> void *Ssbrk( int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Routine Ssbrk reserviert Speicherplatz. Die Anzahl
der Bytes muß dabei in <i>count</i> übergeben werden. Diese
Funktion muß vor der Initialisierung des <a href="gemdos_main.html">GEMDOS</a> aufgerufen werden,
und sollte daher in Anwenderprogrammen <i>nicht</i> verwendet werden.
In allen Atari-ROM-Versionen ist diese Funktion lediglich als
Dummy-Routine implementiert.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert die Anfangsadresse des allozierten
Speicherbereiches zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Ssbrk">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Ssbrk">4.20.8.1 Bindings für Ssbrk</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void *<a href="#Ssbrk">Ssbrk</a>( int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)  ; Offset 2
move.w    #1,-(sp)     ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #4,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Supexec">4.20.9 Supexec</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »supervisor execute« - führt Routine im Supervisor-Modus
aus.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 38
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t Supexec( int32_t (*func)( ) );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die XBIOS-Routine Supexec führt die Routine unter
<i>func</i> im Supervisor-Modus aus.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Die Funktion liefert den Return-Wert der aufgerufenen Funktion
zurück.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Alle TOS Versionen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Supexec">Binding</a> &nbsp; <a href="gemdos_system.html#Super">Super</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Supexec">4.20.9.1 Bindings für Supexec</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#Supexec">Supexec</a>( int32_t (*func)( ) );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       func         ; Offset 2
move.w    #38,-(sp)    ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="Trapper">4.20.10 Trapper</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Trapper« - Hook into system functions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 555
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t <a href="xbios_trap.html#xbios">xbios</a>( 555, int16_t layer, int16_t install, int16_t
opcode, void *function );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Mit Hilfe von Trapper können sich andere Programme effektiv
und einfach vor und hinter Systemaufrufe hängen, diese sogar ganz
ersetzen, oder dem System neue Systemaufrufe hinzufügen.
<br>&nbsp;
<br>Bei Trapper handelt sich es um ein externes Programm!
<br>&nbsp;
<br>Mehr Information in der dortigen Anleitung.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist nur auf Computern vorhanden bei denen das
Programm Trapper installiert ist.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20Trapper">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20Trapper">4.20.10.1 Bindings für Trapper</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="xbios_trap.html#xbios">xbios</a>( 555, int16_t layer, int16_t install, int16_t
opcode, void *function );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea (a2)                  ; <a href="tos_main.html">TOS</a> does not save A2 in traps
move.l    function,-(sp)  ; Offset 8
move.w    opcode,-(sp)    ; Offset 6
move.w    install,-(sp)   ; Offset 4
move.w    layer,-(sp)     ; Offset 2
move.w    #555,-(sp)      ; Offset 0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp       ; Stack korrigieren
move.l    (sp)+,a2        ; restore A2
</pre>

</td></tr>
</table>

<h3><a name="WdgCtrl">4.20.11 WdgCtrl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »WdgCtrl« - Einstellen des Hardware-Watchdog
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 161
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Binding:</td>
<td valign="top"> int32_t WdgCtrl ( int16_t OpCode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion de- oder aktiviert den Hardware-Watchdog.
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">wert</td>
</tr>
<tr>
  <td align="left" valign="top">OpCode</td>
  <td align="left" valign="top">0x0000 - return 0 to check that WdgCtrl is present</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0x1234 - enable watchdog</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0xdead - disable watchdog</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0x4242 - re-trigger watchdog</td>
</tr>
</table>
</div>

<br><b>Hinweis:</b> Die Funktion ist für die Hardware des Milans
2.1. Die Version gibt es allerdings nur als Spezialversion und ist
nicht frei verfügbar.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top">
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a> (0)</td>
<td valign="top"> - OK
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="bios_errors.html#EUNDEV">EUNDEV</a> (-15)</td>
<td valign="top"> - Watchdog nicht vorhanden
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="bios_errors.html#EBADRQ">EBADRQ</a> (-5)</td>
<td valign="top"> - OpCode nicht implementiert

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> Die Funktion ist ab dem MilanTOS mit dem Datum 2002-06-09
vorhanden.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#Spezialbefehle">Spezialbefehle</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20WdgCtrl">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20WdgCtrl">4.20.11.1 Bindings für WdgCtrl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#WdgCtrl">WdgCtrl</a> ( int16_t OpCode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea (a2)                  ; <a href="tos_main.html">TOS</a> does not save A2 in traps
move.w    OpCode,-(sp)    ; Offset 2
move.w    #161,-(sp)      ; Offset 0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       4(sp),sp        ; Stack korrigieren
move.l    (sp)+,a2        ; restore A2
</pre>

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_sound.html"><img src="udo_lf.gif" alt="Soundroutinen" title="Soundroutinen" border="0" width="24" height="24">Soundroutinen</a>
<a name="UDO_nav_rg_FOOT" href="xbios_keyboard.html"><img src="udo_rg.gif" alt="Tastaturfunktionen" title="Tastaturfunktionen" border="0" width="24" height="24">Tastaturfunktionen</a>
</body>
</html>
