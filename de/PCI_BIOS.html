<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 20.12.2025 -->
<html lang="de">
<head>
<title>
Die Anleitung zum TOS: PCI-BIOS
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_overscan.html"><img src="udo_lf.gif" alt="OverScan-XBIOS-Erweiterungen" title="OverScan-XBIOS-Erweiterungen" border="0" width="24" height="24">OverScan-XBIOS-Erweiterungen</a>
<a name="UDO_nav_rg_HEAD" href="xbios_interface.html"><img src="udo_rg.gif" alt="Schnittstellenprogrammierung" title="Schnittstellenprogrammierung" border="0" width="24" height="24">Schnittstellenprogrammierung</a>

<hr>

<h1><a name="PCI-BIOS">4.17 PCI-BIOS</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#bus_to_virt">bus_to_virt</a></td>
<td valign="top"> Convert PCI bus to virtual address
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_byte">fast_read_config_byte</a></td>
<td valign="top"> Read configuration byte fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_longword">fast_read_config_longword</a></td>
<td valign="top"> Read configuration longword fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_word">fast_read_config_word</a></td>
<td valign="top"> Read configuration word fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_io_byte">fast_read_io_byte</a></td>
<td valign="top"> Read IO byte fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_io_longword">fast_read_io_longword</a></td>
<td valign="top"> Read IO longword fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_io_word">fast_read_io_word</a></td>
<td valign="top"> Read IO word fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_mem_byte">fast_read_mem_byte</a></td>
<td valign="top"> Read memory byte fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_mem_longword">fast_read_mem_longword</a></td>
<td valign="top"> Read memory longword fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_mem_word">fast_read_mem_word</a></td>
<td valign="top"> Read memory word fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#find_pci_classcode">find_pci_classcode</a></td>
<td valign="top"> Find PCI class code
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#find_pci_device">find_pci_device</a></td>
<td valign="top"> Find PCI device
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_card_used">get_card_used</a></td>
<td valign="top"> Get card used flag
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_machine_id">get_machine_id</a></td>
<td valign="top"> Get machine ID
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_pagesize">get_pagesize</a></td>
<td valign="top"> Get pagesize
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_resource">get_resource</a></td>
<td valign="top"> Get resource Data
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_routing">get_routing</a></td>
<td valign="top"> Get interrupt routing options
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#hook_interrupt">hook_interrupt</a></td>
<td valign="top"> Hook interrupt vector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#phys_to_virt">phys_to_virt</a></td>
<td valign="top"> Convert physical CPU to virtual address
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_byte">read_config_byte</a></td>
<td valign="top"> Read configuration byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_longword">read_config_longword</a></td>
<td valign="top"> Read configuration longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_word">read_config_word</a></td>
<td valign="top"> Read configuration word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_io_byte">read_io_byte</a></td>
<td valign="top"> Read IO byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_io_longword">read_io_longword</a></td>
<td valign="top"> Read IO longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_io_word">read_io_word</a></td>
<td valign="top"> Read IO word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_mem_byte">read_mem_byte</a></td>
<td valign="top"> Read memory byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_mem_longword">read_mem_longword</a></td>
<td valign="top"> Read memory longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_mem_word">read_mem_word</a></td>
<td valign="top"> Read memory word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#set_card_used">set_card_used</a></td>
<td valign="top"> Set card used flag
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#set_interrupt">set_interrupt</a></td>
<td valign="top"> Set hardware interrupt
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#special_cycle">special_cycle</a></td>
<td valign="top"> Generates special cycle
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#unhook_interrupt">unhook_interrupt</a></td>
<td valign="top"> Unhook interrupt vector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#virt_to_bus">virt_to_bus</a></td>
<td valign="top"> Convert virtual to PCI bus address
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#virt_to_phys">virt_to_phys</a></td>
<td valign="top"> Convert virtual to physical CPU address
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_byte">write_config_byte</a></td>
<td valign="top"> Write configuration byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_longword">write_config_longword</a></td>
<td valign="top"> Write configuration longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_word">write_config_word</a></td>
<td valign="top"> Write configuration word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_io_byte">write_io_byte</a></td>
<td valign="top"> Write IO byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_io_longword">write_io_longword</a></td>
<td valign="top"> Write IO longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_io_word">write_io_word</a></td>
<td valign="top"> Write IO word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_mem_byte">write_mem_byte</a></td>
<td valign="top"> Write memory byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_mem_longword">write_mem_longword</a></td>
<td valign="top"> Write memory longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_mem_word">write_mem_word</a></td>
<td valign="top"> Write memory word

</td></tr>
</table>

<p>Querverweis: <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20_PCI">Cookie _PCI</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20XPCI">Cookie XPCI</a>
</p>
<h3><a name="bus_to_virt">4.17.1 bus_to_virt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Bus To Virtual« - Convert PCI bus to virtual address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 340
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t bus_to_virt (int32_t handle, uint32_t address, uint32_t
*pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function converts from PCI bus addresses to virtual
addresses (as the CPU uses them). This is necessary since the memory
may be mapped non-linear by the PMMU even when not using virtual
memory (it is on the MILAN).
<br>&nbsp;
<br>It is required that a resource (ie. a region of memory or IO
space on a PCI card) is mapped contiguously, so that a simple offset
can be used when copying to/from memory on a PCI card.
<br>&nbsp;
<br>This function might be limited to TOS or TOS-like
operating systems. If an operating system uses a different memory
layout, it may need to provide its own functions which drivers can
use.
<br>&nbsp;
<br>When using this function, the driver does not need to care about
DMA offsets at all.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> PCI bus address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">pointer</td>
<td valign="top"> Pointer to mem-struct for results
<br>&nbsp;

</td></tr>
</table>

<br><b>Note:</b> This function is the reverse of <a href="#virt_to_bus">virt_to_bus</a>. It
might be slow, so the driver should avoid using it if it can determine
the address by other means.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>. If successful, mem-struct is filled as
follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> CPU (virtual) address
</td></tr>

<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> length of contiguous mapped area

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20bus_to_virt">Binding</a> &nbsp; <a href="#get_pagesize">get_pagesize</a> &nbsp; <a href="#phys_to_virt">phys_to_virt</a> &nbsp; <a href="#virt_to_bus">virt_to_bus</a> &nbsp;
<a href="#virt_to_phys">virt_to_phys</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20bus_to_virt">4.17.1.1 Bindings für bus_to_virt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#bus_to_virt">bus_to_virt</a> (int32_t handle, uint32_t address, uint32_t
*pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 10
move.l    address,-(sp) ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #340,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_byte">4.17.2 fast_read_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration byte fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 305
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int8_t fast_read_config_byte (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion erlaubt das Lesen von Registern im
Konfigurationsbereich ohne aufwendige Fehler- und
Plausibilitätschecks und ist daher auch etwas schneller als ihre
Schwester (daher besonders geeignet für Interrupt-Routinen und wenn
man ganz genau weiß, was man tut ;-).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Adresse des Konfigurationsregisters
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> Fehlercode
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_config_byte">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_config_byte">4.17.2.1 Bindings für fast_read_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int8_t <a href="#fast_read_config_byte">fast_read_config_byte</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #305,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_longword">4.17.3 fast_read_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration longword fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 307
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t fast_read_config_longword (int32_t handle, uint8_t
reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion erlaubt das Lesen von Registern im
Konfigurationsbereich ohne aufwendige Fehler- und
Plausibilitätschecks und ist daher auch etwas schneller als ihre
Schwester (daher besonders geeignet für Interrupt-Routinen und wenn
man ganz genau weiß, was man tut ;-).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Adresse des Konfigurationsregisters (0,4,8,... für
Langwort-Zugriffe)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> Fehlercode
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_config_longword">4.17.3.1 Bindings für fast_read_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#fast_read_config_longword">fast_read_config_longword</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #307,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_word">4.17.4 fast_read_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration word fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 306
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int16_t fast_read_config_word (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Diese Funktion erlaubt das Lesen von Registern im
Konfigurationsbereich ohne aufwendige Fehler- und
Plausibilitätschecks und ist daher auch etwas schneller als ihre
Schwester (daher besonders geeignet für Interrupt-Routinen und wenn
man ganz genau weiß, was man tut ;-).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Adresse des Konfigurationsregisters (0,2,4,... für
Wort-Zugriffe)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> Fehlercode
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_config_word">4.17.4.1 Bindings für fast_read_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#fast_read_config_word">fast_read_config_word</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #306,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_io_byte">4.17.5 fast_read_io_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO Byte Fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 331
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> uint8_t fast_read_io_byte (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function is alternative for the normal IO read function.
It returns the read value in D0 and returns no error code, which makes
it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Read data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_io_byte">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp; <a href="#fast_read_io_word">fast_read_io_word</a> &nbsp;
<a href="#read_io_longword">read_io_longword</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_io_byte">4.17.5.1 Bindings für fast_read_io_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint8_t <a href="#fast_read_io_byte">fast_read_io_byte</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #331,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_io_longword">4.17.6 fast_read_io_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO Longword Fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 333
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> uint32_t <a href="#read_io_longword">read_io_longword</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function is alternative for the normal IO read function.
It returns the read value in D0 and returns no error code, which makes
it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Read value.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_io_longword">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp;
<a href="#fast_read_io_word">fast_read_io_word</a> &nbsp; <a href="#read_io_longword">read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_io_longword">4.17.6.1 Bindings für fast_read_io_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint32_t <a href="#fast_read_io_longword">fast_read_io_longword</a> (int32_t handle, uint32_t
offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #333,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_io_word">4.17.7 fast_read_io_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO Word Fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 332
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> uint16_t <a href="#read_io_word">read_io_word</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function is alternative for the normal IO read function.
It returns the read value in D0 and returns no error code, which makes
it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Read value.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_io_word">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp;
<a href="#read_io_longword">read_io_longword</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_io_word">4.17.7.1 Bindings für fast_read_io_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint16_t <a href="#fast_read_io_word">fast_read_io_word</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #332,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_mem_byte">4.17.8 fast_read_mem_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory byte fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 322
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> uint8_t fast_read_mem_byte (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function is alternative for the normal memory read
function. It returns the read value in D0 and returns no error code,
which makes it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Read data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_mem_byte">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp; <a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp;
<a href="#read_mem_longword">read_mem_longword</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_mem_byte">4.17.8.1 Bindings für fast_read_mem_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint8_t <a href="#fast_read_mem_byte">fast_read_mem_byte</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #322,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_mem_longword">4.17.9 fast_read_mem_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory longword fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 324
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> uint32_t <a href="#read_mem_longword">read_mem_longword</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function is alternative for the normal memory read
function. It returns the read value in D0 and returns no error code,
which makes it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Read value.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_mem_longword">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp;
<a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_mem_longword">4.17.9.1 Bindings für fast_read_mem_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint32_t <a href="#fast_read_mem_longword">fast_read_mem_longword</a> (int32_t handle, uint32_t
offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #324,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="fast_read_mem_word">4.17.10 fast_read_mem_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory word fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 323
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> uint16_t <a href="#read_mem_word">read_mem_word</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function is alternative for the normal memory read
function. It returns the read value in D0 and returns no error code,
which makes it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Read value.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20fast_read_mem_word">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp;
<a href="#read_mem_longword">read_mem_longword</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20fast_read_mem_word">4.17.10.1 Bindings für fast_read_mem_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint16_t <a href="#fast_read_mem_word">fast_read_mem_word</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #323,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="find_pci_classcode">4.17.11 find_pci_classcode</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »find_pci_classcode« - Liefert ein Devicehandle für ein
Gerät einer bestimmten Geräteklasse.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 301
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t find_pci_classcode( int32_t classcode, int16_t index );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert ein Devicehandle für ein Gerät, das dem
angegebenen Gerät entspricht.
<br>&nbsp;
<br>Der Treiber kann diese Funktion mehrmals für eine Geräte ID
aufrufen und den index = 0,1,2,... für jeden Aufruf hochzählen, bis
die Funktion <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> liefert.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">classcode</td>
<td valign="top"> Class code in Bits 23..0
<br>
<br>&nbsp;
<br>Bit 23 ..16 Base class (0 - $FF)
<br>Bit 15 .. 8 Sub class (0 - $FF)
<br>Bit 7 .. 0 Programming Interface (0 - $FF)
<br>&nbsp;
<br>Maske in Bits 26..24
<br>Bit 26: (0: base class testen, 1: ignorieren)
<br>Bit 25: (0: sub class testen, 1: ignorieren)
<br>Bit 24: (0: Progr. Interface testen, 1: ignorieren)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"> Kartenindex (0 - Anzahl Karten mit diesen IDs)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Devicehandle für das Gerät oder <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20find_pci_classcode">Binding</a> &nbsp; <a href="#find_pci_device">find_pci_device</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20find_pci_classcode">4.17.11.1 Bindings für find_pci_classcode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#find_pci_classcode">find_pci_classcode</a>( int32_t classcode, int16_t index );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    index,-(sp)       ; Offset 6
move.l    classcode,-(sp)   ; Offset 2
move.w    #301,-(sp)        ; Offset 0
trap      #14               ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp             ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="find_pci_device">4.17.12 find_pci_device</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »find_pci_device« - Liefert ein Devicehandle für ein Gerät,
das dem angegebenen Gerät und der Hersteller ID entspricht.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 300
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t find_pci_device( int32_t id, int16_t index);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Die Funktion liefert ein Devicehandle für ein Gerät, das dem
angegebenen Gerät und der Hersteller ID entspricht. Der Treiber kann
diese Funktion mehrmals für eine Geräte und Hersteller ID aufrufen
und den index = 0,1,2,... für jeden Aufruf hochzählen, bis die
Funktion <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> liefert.
<br>&nbsp;
<br>Als Spezialfall kann die Hersteller ID $FFFF benutzt weren, um
alle Geräte abzufragen. Die Geräte ID wird in diesem Fall ignoriert.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">id</td>
<td valign="top"> Geräte ID in Bits 31..16 (0 - $FFFF)
<br>Hersteller ID in Bits 15..0 (0 - $FFFE)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"> Kartenindex (0 - Anzahl Karten mit diesen IDs)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Devicehandle für das Gerät oder <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20find_pci_device">Binding</a> &nbsp; <a href="#find_pci_classcode">find_pci_classcode</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20find_pci_device">4.17.12.1 Bindings für find_pci_device</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#find_pci_device">find_pci_device</a>( int32_t id, int16_t index);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    index,-(sp)  ; Offset 6
move.l    id,-(sp)     ; Offset 2
move.w    #300,-(sp)   ; Offset 0
trap      #14          ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp        ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="get_card_used">4.17.13 get_card_used</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get card used flag«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 317
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t get_card_used (int32_t handle, uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function is used to manage which card is in use by which
driver. A driver can provide a means by which a call-back function can
be called from another driver to deactivate this driver. This is
necessary for the first driver to unhook from interrupt chains etc.,
before the new driver can take over.
<br>&nbsp;
<br>The returned status is either 0 (the card is free), 1 (the card
is in use), 2 (the card is in use, but the driver can be uninstalled)
or 3 (the card is in use, but can be taken over without further
actions).
<br>&nbsp;
<br>Case 3 means that the driver which brought the card to this
state may not hook into interrupt chains or other system resources
which need to be unhooked when another driver takes over the card.
<br>&nbsp;
<br>If the return code is 2, the call-back function entry of the
driver is returned in the memory pointer to by <i>address</i>.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> Pointer to longword where call-back address is stored
<br>&nbsp;

</td></tr>
</table>

<br><b>Call-back handlers:</b> Call-back functions are invoked by
calling the call-back entry point, they return with RTS. Call-back
functions may only modify those registers which are used to pass
arguments or results. Call-back functions must be called in supervisor
mode with at least 1024 bytes stack available. The call-back function
number is passed in D0.L. If the driver supports call-back functions,
the following functions are mandatory:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Call-back</td>
<td valign="top"> Description
</td></tr>

<tr><td nowrap="nowrap" valign="top">Get Driver ID (0)</td>
<td valign="top"> call_back0:
<br>Input: D0.L = call-back function number, ie. 0
<br>Output: D0.L = driver ID (same as the driver's XBRA ID)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Try to remove driver (1)</td>
<td valign="top"> call_back1:
<br>Input: D0.L = call-back function number, ie. 1
<br>Output: D0.L = result code: 0=success (card is free), 1=can't
uninstall

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20get_card_used">Binding</a> &nbsp; <a href="#set_card_used">set_card_used</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20get_card_used">4.17.13.1 Bindings für get_card_used</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_card_used">get_card_used</a> (int32_t handle, uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #317,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="get_machine_id">4.17.14 get_machine_id</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Machine ID«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 337
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t get_machine_id ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function can be used to get a unique machine ID for the
computer the driver is running on.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Machine ID oder 0 (keine ID verfügbar) oder <a href="#PCI-BIOS">PCI-BIOS</a>
Fehlercodes
<br>&nbsp;
<br>Positive, non-zero values are machine IDs. They contain a
manufacturer code in bit 24..31 and a unique serial number which is
set by the manufacturer during production in bit 0..23.
<br>&nbsp;
<br>The following manufacturer codes are defined:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">Medusa/Hades</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">Milan</td>
</tr>
<tr>
  <td align="left" valign="top">2</td>
  <td align="left" valign="top">PAK/Panther 2</td>
</tr>
<tr>
  <td align="left" valign="top">3</td>
  <td align="left" valign="top">ARAnyM</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20get_machine_id">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20get_machine_id">4.17.14.1 Bindings für get_machine_id</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_machine_id">get_machine_id</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #337,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="get_pagesize">4.17.15 get_pagesize</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Pagesize«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 338
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t get_pagesize ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function can be used to get the active pagesize.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> Active pagesize, or 0 (paging is not active), <a href="#PCI-BIOS">PCI-BIOS</a>
error-codes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20get_pagesize">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20get_pagesize">4.17.15.1 Bindings für get_pagesize</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_pagesize">get_pagesize</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #338,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #2,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="get_resource">4.17.16 get_resource</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Resource Data«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 316
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t get_resource ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Liefert sämtliche Infos zu den Resourcen einer PCI-Karte (bzw.
eines PCI-Gerätes im Fall von Multifunktionskarten). Die
zurückgelieferten Infos dürfen von den Geräte-Treibern keinesfalls
verändert werden. Der Geräte-Treiber kann an Hand der angebotenen
Informationen (Byte ordering usw.) die Karte dann direkt ansprechen.
Eine weitere Möglichkeit ist die Verwendung der <a href="bios_main.html">BIOS</a>-Routinen
read_mem_..., write_mem_..., read_io_... und write_io_..., wobei man
sich dann um keinerlei Nebenbedingungen selbst kümmern muß.
<br>Die Routine liefert einen Zeiger auf den ersten Resource
Deskriptor des gewünschten PCI-Gerätes. Der Geräte-Treiber kann
dann die weiteren Deskriptoren über einen Offset (Länge eines
Deskriptors) erreichen. Der letzte Deskriptor des Geräts ist
wiederrum speziell markiert. Die Reihenfolge der Despriptoren
entspricht derer der Basisadreßregister im PCI-Konfigurationsbereich.
Ein PCI-Gerät kann auch mehrere Resourcen des gleichen Typs
anfordern/verwenden.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> positiv - Zeiger auf Resourcen-Informationen (erster
Deskriptor)
<br>negativ - <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20get_resource">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20get_resource">4.17.16.1 Bindings für get_resource</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_resource">get_resource</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #316,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="get_routing">4.17.17 get_routing</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Interrupt Routing Options«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 314
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t get_routing ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> To be defined. Not for use by device drivers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20get_routing">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20get_routing">4.17.17.1 Bindings für get_routing</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_routing">get_routing</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #314,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="hook_interrupt">4.17.18 hook_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Hook Interrupt Vector«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 311
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t hook_interrupt (int32_t handle, uint32_t *routine,
uint32_t *parameter);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function hooks the driver into the interrupt chain to
which a specific interrupt on the given card is routed. The interrupt
is enabled on the system level, however, it is the drivers
responsibility to enable the interrupt on the card as needed.
<br>&nbsp;
<br>The driver should first hook into the interrupt chain, and then
enable the interrupt on the card, in order not to cause spurious
interrupts.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">routine</td>
<td valign="top"> Zeiger auf den Interrupt-Handler des Treibers
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">parameter</td>
<td valign="top"> Zeiger auf Parameter für Interrupt-Handler, dies ist ein vom
Treiber frei zu wählender Wert, der bei jedem Aufruf des Handlers vom
<a href="bios_main.html">BIOS</a> mitübergeben wird.
<br>&nbsp;
<br>Dadurch könnteein einziger Interrupt-Handler auch mehrere
baugleiche PCI-Geräte bedienen.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20hook_interrupt">Binding</a> &nbsp; <a href="#unhook_interrupt">unhook_interrupt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20hook_interrupt">4.17.18.1 Bindings für hook_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#hook_interrupt">hook_interrupt</a> (int32_t handle, uint32_t *routine,
uint32_t *parameter);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    parameter,-(sp) ; Offset 10
move.l    routine,-(sp)   ; Offset 6
move.l    handle,-(sp)    ; Offset 2
move.w    #311,-(sp)      ; Offset 0
trap      #14             ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp       ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="phys_to_virt">4.17.19 phys_to_virt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Physical To Virtual« - Convert physical CPU to virtual
address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 342
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t phys_to_virt (uint32_t address, uint32_t *pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function converts from physical CPU addresses to virtual
addresses. This is necessary since the memory may be mapped non-linear
by the PMMU even when not using virtual memory (it is on the MILAN).
<br>&nbsp;
<br>It does not depend on a special device, thus it does not get a
device handle.
<br>&nbsp;
<br>This function might be limited to TOS or TOS-like
operating systems. If an operating system uses a different memory
layout, it may need to provide its own functions which drivers can
use.
<br>&nbsp;
<br>When using this function, the driver does not need to care about
DMA offsets at all.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> Physical CPU address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">pointer</td>
<td valign="top"> Pointer to mem-struct for results
<br>&nbsp;

</td></tr>
</table>

<br><b>Note:</b> This function is the reverse of <a href="#virt_to_phys">virt_to_phys</a>. It
might be slow, so the driver should avoid using it if it can determine
the address by other means.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>. If successful, mem-struct is filled as
follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> CPU (virtual) address
</td></tr>

<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> length of contiguous mapped area

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20phys_to_virt">Binding</a> &nbsp; <a href="#bus_to_virt">bus_to_virt</a> &nbsp; <a href="#get_pagesize">get_pagesize</a> &nbsp; <a href="#virt_to_bus">virt_to_bus</a> &nbsp;
<a href="#virt_to_phys">virt_to_phys</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20phys_to_virt">4.17.19.1 Bindings für phys_to_virt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#phys_to_virt">phys_to_virt</a> (uint32_t address, uint32_t *pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 6
move.l    address,-(sp) ; Offset 2
move.w    #342,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_config_byte">4.17.20 read_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 302
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_config_byte (int32_t handle, uint8_t reg, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Funktion erlaubt den Lesezugriffe auf die
Konfigurationsregister eines PCI-Gerätes, dessen Geräte-Handle zuvor
mittels <a href="#find_pci_device">find_pci_device</a> oder <a href="#find_pci_classcode">find_pci_classcode</a> ermittelt wurde.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Zeiger auf Ergebnisvariable
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_config_byte">Binding</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_config_byte">4.17.20.1 Bindings für read_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_byte">read_config_byte</a> (int32_t handle, uint8_t reg, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #302,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_config_longword">4.17.21 read_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 304
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_config_longword (int32_t handle, uint8_t reg,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Funktion erlaubt den Lesezugriffe auf die
Konfigurationsregister eines PCI-Gerätes, dessen Geräte-Handle zuvor
mittels <a href="#find_pci_device">find_pci_device</a> oder <a href="#find_pci_classcode">find_pci_classcode</a> ermittelt wurde.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters (0,4,8,... für
Langwort-Zugriffe)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Zeiger auf Ergebnisvariable
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_config_longword">4.17.21.1 Bindings für read_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_longword">read_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #304,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_config_word">4.17.22 read_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 303
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_config_word (int32_t handle, uint8_t reg, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Funktion erlaubt den Lesezugriffe auf die
Konfigurationsregister eines PCI-Gerätes, dessen Geräte-Handle zuvor
mittels <a href="#find_pci_device">find_pci_device</a> oder <a href="#find_pci_classcode">find_pci_classcode</a> ermittelt wurde.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Zeiger auf Ergebnisvariable
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_config_word">4.17.22.1 Bindings für read_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_word">read_config_word</a> (int32_t handle, uint8_t reg, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #303,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_io_byte">4.17.23 read_io_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO Byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 328
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_io_byte (int32_t handle, uint32_t offset, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function reads 8-bit values from a IO region.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_io_byte">Binding</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp; <a href="#fast_read_io_word">fast_read_io_word</a> &nbsp;
<a href="#read_io_longword">read_io_longword</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_io_byte">4.17.23.1 Bindings für read_io_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_io_byte">read_io_byte</a> (int32_t handle, uint32_t offset, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #328,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_io_longword">4.17.24 read_io_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO Longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 330
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_io_longword (int32_t handle, uint32_t offset,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function reads 32-bit values from a IO region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_io_longword">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp;
<a href="#fast_read_io_word">fast_read_io_word</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_io_longword">4.17.24.1 Bindings für read_io_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_io_longword">read_io_longword</a> (int32_t handle, uint32_t offset,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #330,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_io_word">4.17.25 read_io_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO Word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 329
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_io_word (int32_t handle, uint32_t offset, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function reads 16-bit values from a IO region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_io_word">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#fast_read_io_word">fast_read_io_word</a> &nbsp;
<a href="#read_io_longword">read_io_longword</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_io_word">4.17.25.1 Bindings für read_io_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_io_word">read_io_word</a> (int32_t handle, uint32_t offset, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #329,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_mem_byte">4.17.26 read_mem_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 319
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_mem_byte (int32_t handle, uint32_t offset, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function reads 8-bit values from a memory region. A driver
can use this function for access to registers and small buffers. For
larger amounts of data, the driver can choose to use his own copy
routines.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>. If successful, read data at buffer
pointed to by <i>address</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_mem_byte">Binding</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp;
<a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_mem_byte">4.17.26.1 Bindings für read_mem_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_mem_byte">read_mem_byte</a> (int32_t handle, uint32_t offset, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #319,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_mem_longword">4.17.27 read_mem_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 321
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_mem_longword (int32_t handle, uint32_t offset,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function reads 32-bit values from a memory region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use. A driver can use this function
for access to registers and small buffers. For larger amounts of data,
the driver can choose to use his own copy routines, provided it knows
the byte order in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>. If successful, read data at buffer
pointed to by <i>address</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_mem_longword">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp;
<a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_mem_longword">4.17.27.1 Bindings für read_mem_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_mem_longword">read_mem_longword</a> (int32_t handle, uint32_t offset,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #321,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="read_mem_word">4.17.28 read_mem_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 320
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t read_mem_word (int32_t handle, uint32_t offset,
uint16_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function reads 16-bit values from a memory region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use. A driver can use this function
for access to registers and small buffers. For larger amounts of data,
the driver can choose to use his own copy routines, provided it knows
the byte order in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>. If successful, read data at buffer
pointed to by <i>address</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20read_mem_word">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp;
<a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20read_mem_word">4.17.28.1 Bindings für read_mem_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_mem_word">read_mem_word</a> (int32_t handle, uint32_t offset, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #320,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="set_card_used">4.17.29 set_card_used</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set card used flag«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 318
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t set_card_used (int32_t handle, uint32_t *callback);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function is used to manage which card is in use by which
driver. A driver can provide a means by which a call-back function can
be called from another driver to deactivate this driver. This is
necessary for the first driver to unhook from interrupt chains etc.,
before the new driver can take over.
<br>&nbsp;
<br>If the call-back entry is 0L, 1L or 3L, the card status is set
to that value. Only a driver which 'owns' the card may use this. If
any other value is passed, it is assumed to be a pointer to the
drivers call back entry point, and the card status is set to 2 (in
use, can be uninstalled).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">callback</td>
<td valign="top"> Address of call-back entry (not pointer to address!) or 0L, 1L
or 3L
<br>&nbsp;

</td></tr>
</table>

<br><b>Call-back handlers:</b> Call-back functions are invoked by
calling the call-back entry point, they return with RTS. Call-back
functions may only modify those registers which are used to pass
arguments or results. Call-back functions must be called in supervisor
mode with at least 1024 bytes stack available. The call-back function
number is passed in D0.L. If the driver supports call-back functions,
the following functions are mandatory:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Call-back</td>
<td valign="top"> Description
</td></tr>

<tr><td nowrap="nowrap" valign="top">Get Driver ID (0)</td>
<td valign="top"> call_back0:
<br>Input: D0.L = call-back function number, ie. 0
<br>Output: D0.L = driver ID (same as the driver's XBRA ID)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Try to remove driver (1)</td>
<td valign="top"> call_back1:
<br>Input: D0.L = call-back function number, ie. 1
<br>Output: D0.L = result code: 0=success (card is free), 1=can't
uninstall

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20set_card_used">Binding</a> &nbsp; <a href="#get_card_used">get_card_used</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20set_card_used">4.17.29.1 Bindings für set_card_used</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#set_card_used">set_card_used</a> (int32_t handle, uint32_t *callback);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       callback      ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #318,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="set_interrupt">4.17.30 set_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set Hardware Interrupt«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 315
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t set_interrupt ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> To be defined. Not for use by device drivers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20set_interrupt">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20set_interrupt">4.17.30.1 Bindings für set_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#set_interrupt">set_interrupt</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #315,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="special_cycle">4.17.31 special_cycle</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Generates special cycle«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 313
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t special_cycle ( unit8_t bus, uint32_t data );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function generates a special cycle on the PCI bus.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Bus number
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">data</td>
<td valign="top"> Cspecial cycle data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20special_cycle">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20special_cycle">4.17.31.1 Bindings für special_cycle</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#special_cycle">special_cycle</a> ( unit8_t bus, uint32_t data );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    data,-(sp)    ; Offset 4
move.w    bus,-(sp)     ; Offset 2
move.w    #313,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #8,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="unhook_interrupt">4.17.32 unhook_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> » «
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 312
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t unhook_interrupt (int32_t handle);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Mit dieser Routine kann man einen mittels <a href="#hook_interrupt">hook_interrupt</a>
angemeldeten Interrupt-Handler wieder entfernen. Der Treiber muß
allerdings beachten, daß die Interrupts auf dem PCI-Gerät schon vor
dem Aufruf dieser <a href="bios_main.html">BIOS</a>-Funktion deaktiviert werden müssen, da es
sonst zu spurious interrupts kommen kann.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20unhook_interrupt">Binding</a> &nbsp; <a href="#hook_interrupt">hook_interrupt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20unhook_interrupt">4.17.32.1 Bindings für unhook_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#unhook_interrupt">unhook_interrupt</a> (int32_t handle);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #305,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
addq.l    #6,sp         ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="virt_to_bus">4.17.33 virt_to_bus</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Virtual To Bus« - Convert virtual to PCI bus address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 339
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t virt_to_bus (int32_t handle, uint32_t address, uint32_t
*pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function converts from virtual addresses (as the CPU uses
them) to PCI bus addresses. This is necessary since the memory may be
mapped non-linear by the PMMU even when not using virtual memory (it
is on the MILAN).
<br>&nbsp;
<br>It is required that a resource (ie. a region of memory or IO
space on a PCI card) is mapped contiguously, so that a simple offset
can be used when copying to/from memory on a PCI card.
<br>&nbsp;
<br>This function might be limited to TOS or TOS-like
operating systems. If an operating system uses a different memory
layout, it may need to provide its own functions which drivers can
use.
<br>&nbsp;
<br>When using this function, the driver does not need to care about
DMA offsets at all.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> Address in virtual CPU space
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">pointer</td>
<td valign="top"> Pointer to mem-struct for results
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>. If successful, mem-struct is filled as
follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> PCI bus address
</td></tr>

<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> length of contiguous mapped area, 0 if no DMA is possible at
this address

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20virt_to_bus">Binding</a> &nbsp; <a href="#bus_to_virt">bus_to_virt</a> &nbsp; <a href="#get_pagesize">get_pagesize</a> &nbsp; <a href="#phys_to_virt">phys_to_virt</a> &nbsp;
<a href="#virt_to_phys">virt_to_phys</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20virt_to_bus">4.17.33.1 Bindings für virt_to_bus</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#virt_to_bus">virt_to_bus</a> (int32_t handle, uint32_t address, uint32_t
*pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 10
move.l    address,-(sp) ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #339,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="virt_to_phys">4.17.34 virt_to_phys</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Virtual To Physical« - Convert virtual to physical CPU
address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 341
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t virt_to_phys (uint32_t address, uint32_t *pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function converts from virtual addresses to physical CPU
addresses. This is necessary since the memory may be mapped non-linear
by the PMMU even when not using virtual memory (it is on the MILAN).
<br>&nbsp;
<br>It does not depend on a special device, thus it does not get a
device handle.
<br>&nbsp;
<br>This function might be limited to TOS or TOS-like
operating systems. If an operating system uses a different memory
layout, it may need to provide its own functions which drivers can
use.
<br>&nbsp;
<br>When using this function, the driver does not need to care about
DMA offsets at all.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> Address in virtual CPU space
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">pointer</td>
<td valign="top"> Pointer to mem-struct for results
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>. If successful, mem-struct is filled as
follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> physical CPU address
</td></tr>

<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> length of contiguous mapped area, 0 if not mapped

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20virt_to_phys">Binding</a> &nbsp; <a href="#bus_to_virt">bus_to_virt</a> &nbsp; <a href="#get_pagesize">get_pagesize</a> &nbsp; <a href="#phys_to_virt">phys_to_virt</a> &nbsp;
<a href="#virt_to_bus">virt_to_bus</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20virt_to_phys">4.17.34.1 Bindings für virt_to_phys</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#virt_to_phys">virt_to_phys</a> (uint32_t address, uint32_t *pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 6
move.l    address,-(sp) ; Offset 2
move.w    #341,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_config_byte">4.17.35 write_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> &lt;Write Configuration Byte&gt;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 308
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_config_byte (int32_t handle, uint8_t reg, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Routine dient zum Schreiben von Konfigurationsregistern
eines PCI-Gerätes.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters (0,1,2,... für
Byte-Zugriffe)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> zu schreibender Registerwert
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_config_byte">Binding</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_config_byte">4.17.35.1 Bindings für write_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_byte">write_config_byte</a> (int32_t handle, uint8_t reg, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 7
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #308,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_config_longword">4.17.36 write_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 310
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_config_longword (int32_t handle, uint8_t reg,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Routine dient zum Schreiben von Konfigurationsregistern
eines PCI-Gerätes.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters (0,4,8,... für
Langwort-Zugriffe)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> zu schreibender Registerwert
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_config_longword">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_config_longword">4.17.36.1 Bindings für write_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_longword">write_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #310,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_config_word">4.17.37 write_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 309
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_config_word (int32_t handle, uint8_t reg,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> Dies Routine dient zum Schreiben von Konfigurationsregistern
eines PCI-Gerätes.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Geräte-Handle des gewählten PCI-Gerätes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Adresse des Konfigurationsregisters (0,2,4,... für
Wort-Zugriffe)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> zu schreibender Registerwert
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_config_word">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_config_word">4.17.37.1 Bindings für write_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_word">write_config_word</a> (int32_t handle, uint8_t reg, uint16_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #309,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_io_byte">4.17.38 write_io_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write IO Byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 334
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_io_byte (int32_t handle, uint32_t offset, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function writes 8-bit values to a IO region.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (8 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_io_byte">Binding</a> &nbsp; <a href="#write_io_word">write_io_word</a> &nbsp; <a href="#write_io_longword">write_io_longword</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp;
<a href="#read_io_word">read_io_word</a> &nbsp; <a href="#read_io_longword">read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_io_byte">4.17.38.1 Bindings für write_io_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_io_byte">write_io_byte</a> (int32_t handle, uint32_t offset, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #334,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_io_longword">4.17.39 write_io_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write IO Longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 336
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_io_longword (int32_t handle, uint32_t offset,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function writes 32-bit values to a IO region and take care
of the byte ordering - ie. the data and address are converted as if
Motorola byte ordering was in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (32 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_io_longword">Binding</a> &nbsp; <a href="#write_io_byte">write_io_byte</a> &nbsp; <a href="#write_io_word">write_io_word</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp;
<a href="#read_io_word">read_io_word</a> &nbsp; <a href="#read_io_longword">read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_io_longword">4.17.39.1 Bindings für write_io_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_io_longword">write_io_longword</a> (int32_t handle, uint32_t offset,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #336,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_io_word">4.17.40 write_io_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write IO Word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 335
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_io_word (int32_t handle, uint32_t offset,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function writes 16-bit values to a IO region and take care
of the byte ordering - ie. the data and address are converted as if
Motorola byte ordering was in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (16 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_io_word">Binding</a> &nbsp; <a href="#write_io_byte">write_io_byte</a> &nbsp; <a href="#write_io_longword">write_io_longword</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp;
<a href="#read_io_word">read_io_word</a> &nbsp; <a href="#read_io_longword">read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_io_word">4.17.40.1 Bindings für write_io_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_io_word">write_io_word</a> (int32_t handle, uint32_t offset, uint16_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #335,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_mem_byte">4.17.41 write_mem_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write Memory Byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 325
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_mem_byte (int32_t handle, uint32_t offset,
uint8_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function writes 8-bit values to a memory region. A driver
can use this function for access to registers and small buffers. For
larger amounts of data, the driver can choose to use his own copy
routines.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (8 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_mem_byte">Binding</a> &nbsp; <a href="#write_mem_word">write_mem_word</a> &nbsp; <a href="#write_mem_longword">write_mem_longword</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp;
<a href="#read_mem_word">read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_mem_byte">4.17.41.1 Bindings für write_mem_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_mem_byte">write_mem_byte</a> (int32_t handle, uint32_t offset, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #325,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_mem_longword">4.17.42 write_mem_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write Memory Longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 327
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_mem_longword (int32_t handle, uint32_t offset,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function writes 32-bit values to a memory region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use. A driver can use this function
for access to registers and small buffers. For larger amounts of data,
the driver can choose to use his own copy routines, provided it knows
the byte order in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (32 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_mem_longword">Binding</a> &nbsp; <a href="#write_mem_byte">write_mem_byte</a> &nbsp; <a href="#write_mem_word">write_mem_word</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp;
<a href="#read_mem_word">read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_mem_longword">4.17.42.1 Bindings für write_mem_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_mem_longword">write_mem_longword</a> (int32_t handle, uint32_t offset,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #327,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       14(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_mem_word">4.17.43 write_mem_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write Memory Word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Xbiosnummer:</td>
<td valign="top"> 326
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Deklaration:</td>
<td valign="top"> int32_t write_mem_word (int32_t handle, uint32_t offset,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Beschreibung:</td>
<td valign="top"> This function writes 16-bit values to a memory region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use. A driver can use this function
for access to registers and small buffers. For larger amounts of data,
the driver can choose to use his own copy routines, provided it knows
the byte order in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (16 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Ergebnis:</td>
<td valign="top"> <a href="#PCI-BIOS_20Fehlercodes">PCI-BIOS Fehlercodes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Verfügbar:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Gruppe:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Querverweis:</td>
<td valign="top"> <a href="#Bindings_20f_C3_BCr_20write_mem_word">Binding</a> &nbsp; <a href="#write_mem_byte">write_mem_byte</a> &nbsp; <a href="#write_mem_longword">write_mem_longword</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp;
<a href="#read_mem_word">read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20f_C3_BCr_20write_mem_word">4.17.43.1 Bindings für write_mem_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_mem_word">write_mem_word</a> (int32_t handle, uint32_t offset,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #326,-(sp)    ; Offset 0
trap      #14           ; <a href="xbios_main.html">XBIOS</a> aufrufen
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="PCI-BIOS_20Fehlercodes">4.17.44 PCI-BIOS Fehlercodes</a></h3>
<p>Die folgende Fehlercodes können im Fehlerfall von den
<a href="bios_main.html">BIOS</a>-Routinen zurückgeliefert werden.
</p>
<a name="PCI_SUCCESSFUL"></a>
<a name="PCI_FUNC_NOT_SUPPORTED"></a>
<a name="PCI_BAD_VENDOR_ID"></a>
<a name="PCI_DEVICE_NOT_FOUND"></a>
<a name="PCI_BAD_REGISTER_NUMBER"></a>
<a name="PCI_SET_FAILED"></a>
<a name="PCI_BUFFER_TOO_SMALL"></a>
<a name="PCI_GENERAL_ERROR"></a>
<a name="PCI_BAD_HANDLE"></a>
<div align="left"><table border="1" frame="box" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0x00000000</td>
  <td align="left" valign="top">PCI_SUCCESSFUL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFE</td>
  <td align="left" valign="top">PCI_FUNC_NOT_SUPPORTED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFD</td>
  <td align="left" valign="top">PCI_BAD_VENDOR_ID</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFC</td>
  <td align="left" valign="top">PCI_DEVICE_NOT_FOUND</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFB</td>
  <td align="left" valign="top">PCI_BAD_REGISTER_NUMBER</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFA</td>
  <td align="left" valign="top">PCI_SET_FAILED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF9</td>
  <td align="left" valign="top">PCI_BUFFER_TOO_SMALL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF8</td>
  <td align="left" valign="top">PCI_GENERAL_ERROR</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF7</td>
  <td align="left" valign="top">PCI_BAD_HANDLE</td>
</tr>
</table>
</div>

<p>Die folgenden beiden Fehlercodes werden zwar nicht von den
<a href="bios_main.html">BIOS</a>-Routinen selbst verwendet, sind aber für eine PCI-Library
reserviert.
</p>
<a name="PCI_BIOS_NOT_INSTALLED"></a>
<a name="PCI_BIOS_WRONG_VERSION"></a>
<div align="left"><table border="1" frame="box" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0xFFFFF001</td>
  <td align="left" valign="top">PCI_BIOS_NOT_INSTALLED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFF000</td>
  <td align="left" valign="top">PCI_BIOS_WRONG_VERSION</td>
</tr>
</table>
</div>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_overscan.html"><img src="udo_lf.gif" alt="OverScan-XBIOS-Erweiterungen" title="OverScan-XBIOS-Erweiterungen" border="0" width="24" height="24">OverScan-XBIOS-Erweiterungen</a>
<a name="UDO_nav_rg_FOOT" href="xbios_interface.html"><img src="udo_rg.gif" alt="Schnittstellenprogrammierung" title="Schnittstellenprogrammierung" border="0" width="24" height="24">Schnittstellenprogrammierung</a>
</body>
</html>
