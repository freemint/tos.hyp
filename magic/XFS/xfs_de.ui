!begin_node Das XFS-Konzept von MagiC
!label MagiC, XFS-Konzept in

(!nolink [MagiC]) erm”glicht wie MultiTOS die Einbindung alternativer Dateisysteme, und
damit prinzipiell die Verwendung langer Dateinamen. Aus verschiedenen
Grnden wurde in MagiC jedoch ein anderer Ansatz gew„hlt, als in Atari's
L”sung. Dies hat leider zur Folge, da die fr MultiTOS vorhandenen XFS's
(Minix-XFS, CD-ROM-XFS, ...) unter (!nolink [MagiC]) (!I)nicht(!i) eingesetzt werden
k”nnen. Dieses Kapitel beschreibt die folgenden Punkte:

!begin_itemize !short
!item (!link [Allgemeines] [Allgemeines zum XFS-Konzept von MagiC])
!item (!link [Aufbau eines XFS] [Der Aufbau eines XFS])
!item (!link [Datenstrukturen] [Datenstrukturen fr ein XFS])
!item (!link [Installation eines XFS] [XFS, Installation eines])
!item Kernelfunktionen fr ein XFS
!item (!link [Symbolische Links] [Symbolische Links und das XFS-Konzept])
!end_itemize

Querverweis:
VFAT-XFS in MagiC ~  (!link [DFS-Konzept in MagiC][Das DFS-Konzept von MagiC])



!begin_node Allgemeines zum XFS-Konzept von MagiC
!label XFS-Konzept, Allgemeines

Das GEMDOS war bisher der konservativste Teil des Betriebssystems MagiC.
Fr Netzwerktreiber muten praktisch s„mtliche DOS-Aufrufe einschlielich
Pexec nachgebildet werden, ohne auf einer tieferen Ebene eingreifen zu
k”nnen. In (!nolink [MagiC]) 1.x (wie in TOS) war das DOS nicht einmal reentrant, da
ein statisch angelegter Stack verwendet wurde.

In MultiTOS/MiNT wird das Problem dermaen umgangen, da gewissermaen
ber das (!nolink [GEMDOS]) ein System gelegt wird, das alle h”heren Verwaltungsaufgaben
erledigt, andere Dateisysteme einbinden kann und das (!nolink [GEMDOS]) nur noch als
dummen Dateisystemtreiber verwendet. Vorteil dieses Systems ist seine
groe Flexibilit„t und Erweiterbarkeit, ein entscheidender Nachteil aber
der gewaltive Overhead bei der Verwendung von 'normalen' DOS-Dateisystemen.
Dies sind aber gerade diejenigen, die mit Abstand am h„ufigsten eingesetzt
werden. Hinzu kommt, da das (!nolink [GEMDOS])-Dateisystem mit dem Einsatz von MiNT
nichts an Funktionalit„t, Komfort oder Geschwindigkeit gewinnen kann, da ja
die alten Routinen nur mit zus„tzlichem Overhead ablaufen. Die
Dateisystemzugriffe unter MiNT sind also i.a. (!I)nicht(!i) reentrant, d.h.
jeder Diskettenzugriff legt wie unter MS-Windows den gesamten Rechner lahm.

Eine weitere Eigenschaft von MiNT ist das Bemhen, die Funktionen, die alle
Dateisysteme gemeinsam haben, in den Kernel zu bernehmen. Dabei bleiben
zwar die Dateisystemtreiber (MiNT-XFSs) kompakt, aber durch den
Inode-orientierten Aufbau der Kernelfunktionen wird den Dateitreibern eine
unter Umst„nden ungnstige Struktur aufgezwungen, auerdem sind i.a. viele
Aufrufe des Dateisystemtreibers fr einen DOS-Aufruf notwendig. Schlielich
ist der MiNT-Kernel selbst sehr lang, liegt aber zum groen Teil brach,
solange keine anderen Dateisysteme als DOS eingesetzt werden.

(!B)Unter (!nolink [MagiC]) wurde ein anderer Ansatz gew„hlt(!b), der darin bestand, das
gesamte (!nolink [GEMDOS]) einschlielich der Lowlevel-Funktionen fr die
Sektorpufferung von Grund auf neu zu schreiben und in insgesamt drei, vier
oder fnf Schichten zu zerlegen, in die von auen (durch nachgeladene
Treiber) eingegriffen werden kann. Als Nebeneffekt kam eine Erweiterung der
Funktionalit„t des DOS-Dateisystems und ein zus„tzliches Dateisystem auf dem
logischen Laufwerk U: heraus.

(!B)Das gesamte Konzept einschlielich der Zugriffe auf DOS-Dateisysteme ist
reentrant und l„uft im Hintergrund ab(!b). So ist es m”glich, auf Laufwerk
A: Dateien zu bearbeiten, ohne den Rechner bei den Diskettenzugriffen
merklich zu bremsen. Dabei ist MagiC bisher nur um 10k l„nger geworden. Im
Vergleich zu MiNT wurden aber mehr Funktionen in die Dateisystemtreiber
ausgelagert, was diese zwar l„nger macht, aber ihnen die M”glichkeit gibt,
die Funktionen wesentlich effizienter auszufhren. Das DOS-Dateisystem ist
eher noch etwas schneller als langsamer geworden.

Obwohl vollst„ndig in Assembler realisiert, handelt es sich um ein
objektorientiertes System mit virtuellen Funktionen und mehrstufigen
Vererbungen. Ein Dateideskriptor, wie ihn der Kernel verwendet und das XFS
zur Verfgung stellt, ist ein Objekt mit speziellen Daten und Funktionen.
Das XFS realisiert aber ein abgeleitetes Objekt mit weiteren Datenfeldern
und Funktionen. Der DFS-Untertreiber des DOS_XFS schlielich mu wiederum
weitere Funktionen und Daten im FD unterbringen und leitet die Klasse weiter
ab. Genauso sieht es mit dem DMD (drive medium descriptor) aus. Der Kernel
ben”tigt nur wenige Angaben, die unteren Schichten jedoch wesentlich mehr,
aber immer wieder verschiedene.

(!B)Die Schichten im einzelnen:(!b)

!begin_enumerate !short
!item (!B)Der DOS-Kernel(!b). Er liegt in (!nolink [MagiC]) selbst und wird direkt von
      den Anwenderprogrammen ber Trap #1 aufgerufen. Er enth„lt Module fr
      die Speicherverwaltung, fr die Prozeverwaltung und fr die
      Dateiverwaltung. Letztere hat die folgenden Unterschichten.
!item (!B)Das Dateisystem(!b) (XFS = eXtended File System). Sein Aufbau ist
      grunds„tzlich verschieden von einem MiNT-XFS, erfllt aber denselben
      Zweck. (!nolink [MagiC]) fr Ataris enth„lt nur ein einziges XFS, das sogenannte
      DOS_XFS, andere k”nnen eingebunden werden. Die Macintosh-Version
      (MagiC Mac) enth„lt (!I)zus„tzlich(!i) ein Mac-XFS. Speziell dieses
      Dateisystem greift wieder auf Untertreiber zu:
!begin_enumerate
!item Ein DOS- Dateisystem (DFS) wird vom DOS_XFS aufgerufen. Hier stehen
      nur die Dateifunktionen, w„hrend die Verzeichnisverwaltung im
      wesentlichen vom DOS_XFS bernommen wird. MagiC direkt enth„lt zwei
      DFSs. Eines fr Laufwerk U:, ein zweites fr FAT-Dateisysteme, die auf
      BIOS Laufwerken liegen. Weitere DFSs k”nnen eingebunden werden. Der
      Aufwand fr ein DFS ist wesentlich geringer als fr ein XFS, da viele
      Funktionen vom DOS_XFS bereits ausgefhrt werden. Die wesentliche
      Voraussetzung ist eine DOS-konforme Verzeichnisstruktur (mit 32-Byte
      Eintr„gen und Dateinamen des Formats 8+3). Der Kernel selbst kommt
      mit dem DFS (!I)nicht(!i) in Berhrung, sondern steuert ihn
      transparent ber das DOS-XFS an.
!end_enumerate
!item (!B)Die Dateitreiber(!b) (MX_DEV), die im wesentlichen das Lesen und
      Schreiben einer Datei erledigen. Sie werden vom XFS angelegt und
      verwaltet, aber bei Funktionen wie Fread() und Fwrite() direkt vom
      Kernel aufgerufen, wodurch extrem wenig Overhead entsteht. Das DOS_XFS
      enth„lt tats„chlich nur einen Dateitreiber. Dieser erledigt z.B. bei
      Schreibzugriffen die Aktualisierung des Verzeichnisses und ruft wieder
      Untertreiber (MX_DDEV) auf.
!begin_enumerate
!item Der Untertreiber MX_DDEV wird nur vom DOS-Dateitreiber des
      Dateisystems DOS_XFS aufgerufen. Der Benutzer kann eigene MX_DDEVs
      ber das Verzeichnis U:\\DEV einbinden. Der Kernel selbst kommt mit
      den Untertreibern brigens nicht in Berhrung.
!end_enumerate
!end_enumerate

(!B)Bemerkungen:(!b)

!begin_itemize
!item Im Gegensatz zu MiNT sind U:\PROC, U:\DEV usw. keine eigenen
      Dateisysteme sondern einfach nur Unterverzeichnisse des DFS fr
      Laufwerk U:. Je nach Unterverzeichnis legt das U-DFS verschiedene
      Dateitypen und -treiber an. Da die Verzeichniskontrolle dem DOS_XFS
      obliegt, werden Schreibzugriffe auf z.B. ein Device im Verzeichnis per
      Dateidatum protokolliert. Das geht sogar soweit, da ein
      Schreibzugriff auf das Wurzelverzeichnis von Laufwerk A: automatisch
      das Dateidatum von U:\A ver„ndert.

      Devices, Pipes und Shared-Memory-Bl”cke k”nnen verschoben, gel”scht
      oder umbenannt werden. In allen Verzeichnissen von Laufwerk U: k”nnen
      symbolische Links angelegt werden, z.B. kann man mit
      "ln -s U:\CON U:\CONSOLE" einen Alias fr die Ger„tedatei CON anlegen.
      Man kann auch einfach leere Dateien anlegen, jedoch keine Ordner, weil
      das Laufwerk U: keinen Speicher hat.
!item Im Gegensatz zu MiNT ist U:\ kein eigenes, spezielles Dateisystem. Es
      wird lediglich darauf geachtet, da nur symbolische Links angelegt
      werden k”nnen. Die Verzeichnisse U:\A usw. sind lediglich symbolische
      Links, die auch entfernt oder umbenannt werden k”nnen.
!item Alle Verzeichnisse von U: sind z.Zt. auf 32 Eintr„ge beschr„nkt.
!item Der Aufbau aller internen Strukturen und die schnelle registerbasierte
      Parameterbergabe und -rckgabe erfordert eine Implementation aller
      Dateisysteme und -treiber in Assembler, zumindest fr die meisten
      Funktionen.
!item Der Aufbau des MX_DDEV-Dateitreibers hat sich seit (!nolink [MagiC]) V2.10
      ge„ndert. Der Beispieltreiber DEV_LPT1 darf unter (!nolink [MagiC]) 3.00 nicht
      verwendet werden. Die Konzepte sind jedoch identisch geblieben, nur
      ein paar Konstanten haben sich ge„ndert. Ein neuer Beispieltreiber ist
      noch nicht fertig.
!end_itemize

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])  ~
(!link [Test auf Pipes][Pipes, Test auf])
!end_node


!begin_node Der Aufbau eines XFS
!label MagiC, Aufbau eines XFS in

Da die Implementation eines XFS nur in Assembler erfolgen kann, wird dessen
Beschreibung in Assembler-Syntax angegeben:

!begin_verbatim
xfs_name:       DS.B      8    /* Name des Dateisystems               */
xfs_next:       DS.L      1    /* n„chster Treiber                    */
xfs_flags:      DS.L      1    /* Flags analog zu MiNT                */
xfs_init:       DS.L      1    /* Initialisierung                     */
xfs_sync:       DS.L      1    /* Synchronisation des Dateisystems    */
xfs_pterm:      DS.L      1    /* teilt ein Programmende mit          */
xfs_garbcoll:   DS.L      1    /* Garbage-Collection oder NULL        */
xfs_freeDD:     DS.L      1    /* DD freigeben                        */
xfs_drv_open:   DS.L      1    /* DMD (Mediach) testen/initialisieren */
xfs_drv_close:  DS.L      1    /* erzwingt einen Disk-Wechsel         */
xfs_path2DD:    DS.L      1    /* gibt einen DD zum Pfadnamen zurck  */
xfs_sfirst:     DS.L      1    /* sucht die erste passende Datei      */
xfs_snext:      DS.L      1    /* sucht die n„chste passende Datei    */
xfs_fopen:      DS.L      1    /* ”ffnet oder erstellt eine Datei     */
xfs_fdelete:    DS.L      1    /* l”scht eine Datei                   */
xfs_link:       DS.L      1    /* fr Frename und Flink ben”tigt      */
xfs_xattr:      DS.L      1    /* fr Fxattr ben”tigt                 */
xfs_attrib:     DS.L      1    /* fr Fattrib ben”tigt                */
xfs_chown:      DS.L      1    /* fr Fchown ben”tigt                 */
xfs_chmod:      DS.L      1    /* fr Fchmod ben”tigt                 */
xfs_dcreate:    DS.L      1    /* erstellt ein Verzeichnis            */
xfs_ddelete:    DS.L      1    /* l”scht ein Verzeichnis              */
xfs_DD2name:    DS.L      1    /* gibt den absoluten Pfadnamen zurck */
xfs_dopendir:   DS.L      1    /* ”ffnet ein Verzeichnis              */
xfs_dreaddir:   DS.L      1    /* liest n„chsten Verzeichnis-Eintrag  */
xfs_drewinddir: DS.L      1    /* setzt das dirhandle auf 1. Eintrag  */
xfs_dclosedir:  DS.L      1    /* schliet das dirhandle              */
xfs_dpathconf:  DS.L      1    /* ermittelt verschiedene Limits       */
xfs_dfree:      DS.L      1    /* Anzahl freier Bl”cke etc. ermitteln */
xfs_wlabel:     DS.L      1    /* schreibt den Disk-Namen             */
xfs_rlabel:     DS.L      1    /* liest den Disk-Namen                */
xfs_symlink:    DS.L      1    /* erstellt einen symbolischen Link    */
xfs_readlink:   DS.L      1    /* liest einen symbolischen Link       */
xfs_dcntl:      DS.L      1    /* fr Dcntl ben”tigt                  */
!end_verbatim

Querverweis:
(!link [Aufbau eines DFS][Der Aufbau eines DFS]) ~
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])



!begin_node xfs_attrib

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_attrib® - fr (!nolink [Fattrib]) notwendig

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [d0 =]
int rwflag
!item [d1 =]
int attrib
!item [-> d0 =]
char attr  oder long errcode
!item [-> a0 =]
SYMLINK *
!end_xlist

!item [Beschreibung:]
Im Gegensatz zu MiNT fhrt MagiC diese Funktion nicht auf Fxattr zurck,
weil dies u.U. einen gewaltigen Overhead bedeutet. Hierbei mssen
symbolische Links verfolgt werden, d.h. die Rckgabe von ELINK ist zul„ssig.

Diese Funktion wird vom XFS_DOS noch nicht ordentlich durchfhrt, es werden
keine symbolischen Links erkannt.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Fattrib ~  Fxattr

(!ende_liste)
!end_node



!begin_node xfs_chmod

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_chmod® - fr (!nolink [Fchmod]) notwendig

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [d0 =]
int mode
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
ndert die Zugriffsrechte einer Datei. Die Parameter entsprechen denen von
Fchmod. Symbolische Links werden nicht verfolgt.

Wird vom XFS_DOS (!I)nicht(!i) untersttzt.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Fchmod

(!ende_liste)
!end_node



!begin_node xfs_chown

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_chown® - fr (!nolink [Fchown]) notwendig.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [d0 =]
uid
!item [d1 =]
gid
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
ndert den Eigner (User-ID und Group-ID) einer Datei. Die Parameter
entsprechen denen von Fchown. Symbolische Links werden nicht verfolgt, d.h.
Eigner und Gruppe des symbolischen Links werden modifiziert.

Wird vom XFS_DOS (!I)nicht(!i) untersttzt.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Fchown

(!ende_liste)
!end_node



!begin_node xfs_dclosedir

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_dclosedir® - schliet ein Verzeichnis

!item [Parameter:]
!begin_xlist !short [a0 =]
!item [a0 =]
(!link [DHD][Der Directory-Handle-Deskriptor (DHD)]) *dhd
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Analog zu MiNT.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Dclosedir

(!ende_liste)
!end_node



!begin_node xfs_dcntl

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_dcntl® - fr (!nolink [Dcntl]) notwendig.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [d0 =]
int cmd
!item [d1 =]
long arg
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Fr Dcntl. Jedes XFS sollte FUTIME untersttzen.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_dcreate

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_dcreate® - erstellt ein Verzeichnis

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name (ohne Pfad)
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Fr Dcreate ben”tigt.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Dcreate

(!ende_liste)
!end_node



!begin_node xfs_ddelete

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_ddelete® - l”scht ein Verzeichnis

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Diese Funktion musste ab MagiC Version 4.01 ge„ndert werden. Fr (!nolink [MagiC]) <
4.01 (Kernelversion < 3) gilt:

Beim L”schen ist darauf zu achten, da kein Verzeichnis durch den Kernel
referenziert sein darf auer durch den Aufruf selbst (d.h. es mu dd_refcnt
== 1 sein). Auerdem ist darauf zu achten, da keine Dateien im Verzeichnis
liegen. ELINK darf nicht zurckgegeben werden, symbolische Links drfen
nicht behandelt werden. Die Zugriffsberechtigung mu (falls eine existiert)
vom XFS geprft werden.

Fr (!nolink [MagiC]) < 4.01 (Kernelversion >= 3) gilt:

Wegen Reentranzproblematiken ergeben sich einigen nderungen, wobei der
Kernel dem XFS Zugriffskontrollen abnimmt und weiterhin der Kernel den DD
freigibt, nicht das XFS: Der Kernel ”ffnet zun„chst mit xfs_path2DD den
Parent des zu l”schenden Verzeichnisses, dann testet er mit xfs_xattr, ob es
sich um einen Symlink handelt, und l”scht ihn ggf. per xfs_fdelete.

Handelt es sich um ein Verzeichnis, ”ffnet der Kernel dieses wieder per
(!nolink [xfs_path2DD]) (Modus 1) und gibt den Parent wieder per xfs_freeDD frei. Die
šberprfung von dd_refcnt wird vom Kernel durchgefhrt, der Z„hler kann und
mu daher vom XFS ignoriert werden. Das XFS mu nun sicherstellen, da das
zu l”schende Verzeichnis bzw. der DD nicht anderweitig ge”ffnet oder benutzt
werden k”nnen (wichtig fr reentrante XFSs). Das XFS l”scht dann das
Verzeichnis, gibt aber den DD nicht (!) frei, damit der Kernel im
Erfolgsfall (Rckgabe (!nolink [E_OK])) vorher seine Standardpfade freigeben kann. Der
Kernel ruft dann (!nolink [xfs_freeDD]) auf. Wie gehabt, mu das XFS prfen, ob das
Verzeichnis leer ist, bzw. Zugriffsberechtigungen existieren.

Nochmal im Zusammenhang:

!begin_itemize
!item Kernel ermittelt zu l”schenden DD, prft Referenzz„hler.
!item xfs_ddelete sperrt den DD. Wenn das nicht geht, wird EACCDN geliefert.
!item xfs_ddelete l”scht das Verzeichnis, wenn es leer ist. Der DD wirkt
      dabei als Sperre fr parallel laufende Versuche, das gerade gel”schte
      Verzeichnis zu benutzen.
!item xfs_ddelete l„t den jetzt ungltigen, aber noch als Sperre dienenden
      DD weiterhin gltig (im Gegensatz zum alten Konzept).
!item Der Kernel macht bei Erfolg seine Standardpfade ungltig.
!item Der Kernel gibt den DD frei.
!end_itemize

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Ddelete

(!ende_liste)
!end_node



!begin_node xfs_dfree

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_dfree® - Anzahl freier Bl”cke ermitteln.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
long[4]
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Fr Dfree. XFS_DOS ruft direkt den zust„ndigen DFS-Treiber auf.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Dfree

(!ende_liste)
!end_node



!begin_node xfs_DD2name

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_DD2name® - gibt den absoluten Pfadnamen zurck.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [d0 =]
int bufsize
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Fr Dgetpath und Dgetcwd. Nach <name> wird der Pfad kopiert der zum
bergebenen Verzeichnis geh”rt. Der Pfad mu ohne folgenden '\'
zurckgegeben werden, d.h. ein Leerstring fr das Wurzelverzeichnis.
<bufsize> versteht sich, wie berall, inklusive abschlieendes Nullbyte.
Wenn der Puffer zu klein ist (bufsize kleiner als der Pfad), mu wie in MiNT
(!nolink [ERANGE]) zurckgegeben werden.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_dopendir

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_dopendir® - ”ffnet ein Verzeichnis

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [d0 =]
int tosflag
!item [-> d0 =]
(!link [DHD][Der Directory-Handle-Deskriptor (DHD)]) *dhd  oder Fehlercode
!end_xlist

!item [Beschreibung:]
Fr Dopendir. Als <tosflag> sind z.Zt. nur 0 und 1 erlaubt. Ist <tosflag> ==
0, werden Dateinamen nicht abgeschnitten, und die ersten 4 Bytes, die von
D(x)readdir zurckgegeben werden, enthalten den Datei-Index.

Ist <tosflag> == 1, mu dreaddir die Dateinamen auf 8+3 und Groschrift
krzen und darf keine Dateikennung zurckgeben.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Dopendir ~  Dreaddir ~  Dxreaddir

(!ende_liste)
!end_node



!begin_node xfs_dpathconf

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_dpathconf® - ermittelt verschiedene Limits

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [d0 =]
int which
!item [-> d0 =]
long value
!end_xlist

!item [Beschreibung:]
Wie in MiNT. XFS_DOS ruft direkt den zust„ndigen DFS-Treiber auf. <which>
kann folgende Werte annehmen:

!begin_xlist !short [DP_XATTRFIELDS (-1)]
!item [DP_MAXREQ   (-1)]
ermittle max. gltigen Wert fr <which>
!item [DP_IOPEN    (0)]
internes Limit fr Anzahl offener Dateien
!item [DP_MAXLINKS (1)]
maximale Anzahl Links fr eine Datei
!item [DP_PATHMAX  (2)]
maximale L„nge fr vollen Pfadnamen
!item [DP_NAMEMAX  (3)]
maximale L„nge fr Dateinamen
!item [DP_ATOMIC   (4)]
Blockgr”e
!item [DP_TRUNC    (5)]
Dateinamen-Verkrzung liefert:
!begin_xlist !short [DP_AUTOTRUNC (1)]
!item [DP_NOTRUNC   (0)]
nie krzen, ggf. ERANGE
!item [DP_AUTOTRUNC (1)]
auf max. L„nge gekrzt
!item [DP_DOSTRUNC  (2)]
Verkrzung auf 8+3
!end_xlist
!item [DP_CASE     (6)]
Gro-/Kleinschreibung liefert:
!begin_xlist !short [DP_CASEINSENS (2)]
!item [DP_CASESENS   (0)]
unterschieden
!item [DP_CASECONV   (1)]
in Groschrift gewandelt
!item [DP_CASEINSENS (2)]
nicht unterschieden und nicht gewandelt
!end_xlist
!end_xlist

Ab der MagiC Version vom 21.5.95 wird weiterhin untersttzt:

!begin_xlist !short [DP_XATTRFIELDS (-1)]
!item [DP_MODEATTR    (7)]
(vgl. Dpathconf)
!item [DP_XATTRFIELDS (8)]
(vgl. Dpathconf)
!end_xlist

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])  ~ Dpathconf

(!ende_liste)
!end_node



!begin_node xfs_dreaddir

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_dreaddir® - liest n„chsten Verzeichniseintrag

!item [Parameter:]
!begin_xlist !short [->a0 =]
!item [a0 =]
(!link [DHD][Der Directory-Handle-Deskriptor (DHD)]) *dhd
!item [d0 =]
int  size
!item [a1 =]
char *buf
!item [d1 =]
XATTR *xattr oder NULL
!item [d2 =]
long *xr (wenn xattr != NULL)
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Wie in MiNT. šbernimmt sowohl Dreaddir als auch Dxreaddir.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_drewinddir

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_drewinddir® - Directory Handle auf 1. Eintrag setzen.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DHD][Der Directory-Handle-Deskriptor (DHD)]) * dhd
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]Wie in MiNT.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])  ~ Drewinddir

(!ende_liste)
!end_node



!begin_node xfs_drv_close

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_drv_close® - erzwingt einen Diskwechsel.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DMD][Der Drive-Medium-Deskriptor (DMD)]) *
!item [d0 =]
int mode
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Auch diese Funktion erfllt, abh„ngig vom <mode>, zwei Aufgaben:

!begin_enumerate
!item (!B)mode = 0:(!b)
(!nl)
      Der Kernel bittet das XFS, das Laufwerk, wenn m”glich, zu schlieen.
      Wenn dies nicht erlaubt ist, mu EACCDN geliefert werden, sonst sind
      alle Strukturen freizugeben bzw. Caches zurckzuschreiben und (!nolink [E_OK]) als
      Rckgabewert zu liefern.

      Ge”ffnete Dateien werden bereits vom Kernel erkannt und das Schlieen
      verhindert. Dabei k”nnen aber nur solche Dateien erkannt werden, die
      ein Handle haben und dem Kernel bekannt sind. Der Kernel ruft
      sicherheitshalber vor Aufruf dieser Funktion xfs_sync auf, falls ein
      Write-Back-Cache verwendet wird. Diese Vorgehensweise wird auch dann
      durchgefhrt, wenn einmal ein Mechanismus eingebaut wird, der den
      Auswurfknopf von Wechselplattenlaufwerken oder CD-ROM abfragt und ggf.
      den Auswurf verweigert.
!item (!B)mode = 1:(!b)
(!nl)
      Der Kernel erzwingt das Schlieen, das XFS mu E_OK liefern. Es drfen
      keine Caches zurckgeschrieben werden, da das Laufwerk bereits
      ungltig ist (nachdem ein Diskwechsel bereits gemeldet wurde). DDs und
      FDs brauchen nicht freigegeben zu werden, soweit sie vom Kernel noch
      referenziert werden, d.h. der Kernel fhrt auch nach dem Diskwechsel
      noch xfs_freeDD bzw. dev_close aus.
!end_enumerate

Das interne DOS_XFS leitet den Aufruf an die gleichnamige Funktion des DFS
weiter, auerdem werden ggf. XFS-Strukturen freigegeben.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_drv_open

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_drv_open® - DMD (Mediach) testen/initialisieren.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DMD][Der Drive-Medium-Deskriptor (DMD)]) *
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
MagiC untersttzt genau 26 gleichzeitig aktive Dateisysteme denen die
Buchstaben 'A'..'Z' zugeordnet sind. Dieser Eintrag hat zwei Aufgaben:

!begin_enumerate
!item Beim ersten Zugriff auf ein Laufwerk (etwa D:) legt der Kernel einen
      DMD (drive media descriptor) an und "bietet" diesen den XFSs an. Der
      Eintrag d_xfs ist noch ein Nullzeiger, d_drive ist initialisiert
      (zwischen 0 und 25, entsprechend 'A'..'Z').

      Die XFS-Treiber versuchen nun, auf dem Laufwerk "ihr" Dateisystem zu
      erkennen. Falls dies gelingt, mssen (!nolink [d_xfs]) und d_root initialisiert
      werden, der Rckgabewert ist dann (!nolink [E_OK]). Andernfalls wird
      (!nolink [EDRIVE])
      gemeldet, und der Kernel probiert das n„chste XFS.

      (!B)Achtung:(!b) Die root darf w„hrend der Lebensdauer eines
      gemounteten Dateisystems nicht freigegeben werden. Der Referenzz„hler
      der root sollte mit 1 vorbesetzt werden, um zu verhindern, da er per
      free_DD freigegeben wird. In den Versionen vor (!nolink [MagiC]) 4.01 war dies
      nicht notwendig, weil der Referenzz„hler (in unsauberer Weise) vor dem
      Aufruf von path2DD nicht inkrementiert und nachher dekrementier wurde.
!item Beim wiederholten Zugriff ist (!nolink [d_xfs]) bereits initialisiert, und das XFS
      hat die Gelegenheit, auf Mediumwechsel zu testen. Ist alles in
      Ordnung, mu (!nolink [E_OK]) zurckgegeben werden. Ansonsten mu die
      Diskwechselroutine des Kernels aufgerufen und (!nolink [E_CHNG]) zurckgegeben
      werden. Den Zeiger auf die Diskwechselroutine des Kernels erh„lt man
      bei der Installation des XFS.
!end_enumerate

Das interne DOS_XFS leitet den Aufruf an die gleichnamige Funktion des DFS
weiter, d.h. alle DFS-Treiber werden durchprobiert.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_fdelete

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_fdelete® - l”scht eine Datei.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name (ohne Pfad)
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Fr Fdelete. Beim L”schen eines Symlinks darf nur dieser gel”scht werden,
nicht etwa eine referenzierte Datei. D.h. der Rckgabewert ELINK ist hier
_UNZULSSIG_.

Zugriffsrecht-šberprfungen obliegen vollst„ndig dem XFS. Beim L”schen ist
darauf zu achten, da keine Datei durch den Kernel referenziert sein darf
(d.h. fd_refcnt != 0).

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_flags

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_flags® - Flags analog zu MiNT

!item [Parameter:]
---

!item [Beschreibung:]
Reserviert. Sollte eigentlich Flags enthalten. Wird jedoch vom MagiC Kernel
nicht verwendet. Also bitte nicht verwenden!

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_fopen

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_fopen® - ”ffnet oder erstellt eine Datei.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name (ohne Pfad)
!item [d0 =]
int omode (frs ™ffnen)
!item [d1 =]
int attrib (frs Erstellen)
!item [-> d0 =]
(!link [FD][Der Datei-Deskriptor (FD)]) *  oder Fehlercode
!item [-> a0 =]
SYMLINK *
!end_xlist

!item [Beschreibung:]
Wird fr die Funktionen Fopen und Fcreate verwendet. Der Open-Modus ist im
niederwertigen Byte anders als in MiNT, weil die MiNT-Modi fr die
Implementierung der Abfragen ungnstig sind. Beim Aufrufen von (!nolink [Fopen]) ber
Trap #1 werden die MiNT-Modi vom Kernel in die internen Modi konvertiert.
Hier die internen Modi, die vom XFS-Treiber bearbeitet werden mssen
(NOINHERIT wird (!I)nicht(!i) untersttzt, weil nach TOS-Konvention nur die
Handles 0..5 vererbt werden). Ansonsten entspricht das HiByte den
MiNT-Konventionen:

!begin_verbatim
OM_RPERM   EQU  1   // Datei ist zum Lesen ge”ffnet
OM_WPERM   EQU  2   // Datei ist zum Schreiben ge”ffnet
OM_EXEC    EQU  4   // Datei ist zum Ausfhren ge”ffnet
OM_APPEND  EQU  8   // Schreibzugriffe ans Ende (Kernel!)
OM_RDENY   EQU  16  // andere drfen nicht gleichz. lesen
OM_WDENY   EQU  32  // "" "" nicht gleichz. schreiben
OM_NOCHECK EQU  64  // KEINE šberprfung durch den Kernel
!end_verbatim

Das Bit OM_APPEND wird vom Kernel bei Aufruf von Fwrite() automatisch
beachtet, der Kernel fhrt vor jedem Schreibzugriff ein Fseek() aus.

OM_NOCHECK wird vom Kernel gesetzt, wenn eine Datei als Device, d.h. als
Handle -1,-2,-3 oder -4 ge”ffnet bzw. auf ein solches Handle umgelenkt
(Fforce) wird. Ist dieses Bit gesetzt, sollte das XFS keine Prfung auf
mehrfaches ™ffnen der Datei machen (siehe auch unten bei fd_mode), sondern
dies dem Ger„tetreiber berlassen.

Hier die Bits, die wie im MiNT verwendet werden:

!begin_verbatim
O_CREAT EQU  $200 // Datei erstellen, falls nicht existiert
O_TRUNC EQU  $400 // Datei leeren, falls existiert
O_EXCL  EQU  $800 // nicht ”ffnen, falls existiert
!end_verbatim

Der Kernel fhrt (!nolink [Fcreate]) aus als (!nolink [Fopen])
(O_CREAT +O_RDWR + O_TRUNC). O_COMPAT
(d.h. nur der TOS-Modus 0,1 oder 2 angegeben, ist in MagiC immer
gleichbedeutend mit O_WDENY.

Die šberprfung der Zugriffsrechte obliegt vollst„ndig dem XFS, der Kernel
tut nichts. Das w„re auch wenig sinnvoll, da jedes Dateisystem seine eigenen
Mechanismen und Rechte hat. Zurckgegeben wird dem Kernel ein Zeiger auf
einen ge”ffneten (!link [FD][Der Datei-Deskriptor (FD)]), d.h. das ™ffnen des Dateitreibers mu vom XFS
durchgefhrt werden. Der Referenzz„hler des zurckgegebenen FDs ist vom XFS
zu erh”hen bzw. beim ersten ™ffnen auf 1 zu initialisieren. Fr symbolische
Links und Diskwechsel gilt dasselbe wie bei xfs_sfirst.

(!B)(!nolink [Fopen]) wird unter MiNT folgendermaen zurckgefhrt:(!b)

!begin_enumerate !short
!item per <lookup> Konvertierung pathname->fcookie
!item per <getxattr> Ermittlung der Zugriffsrechte
!item Test der Zugriffsrechte durch den Kernel
!item per <getdev> Ermittlung des Dateitreibers
!item per <getdev->open> ™ffnen der Datei
!end_enumerate

Dieses Verfahren ist sehr langwierig. DOS gibt beim Suchen der Datei bereits
einen Zeiger auf den 32-Byte-Verzeichniseintrag zurck, der direkt zum
šberprfen des Attributs und damit der Zugriffsrechte und auch zum ™ffnen
der Datei dient. (!nolink [MagiC]) erwartet daher direkt die Implementation des
Fopen-Befehls mit allen šberprfungen der Zugriffsrechte. Zurckgeliefert
wird eine FD-Struktur, in die der Dateitreiber eingetragen und ge”ffnet
wurde.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_freeDD

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_freeDD® - gibt einen DD frei.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [->]
void
!end_xlist

!item [Beschreibung:]
Der Kernel hat den Referenzz„hler eines DD auf 0 dekrementiert, der DD wird
also vom Kernel nicht mehr referenziert. Die Funktion wird z.B. aufgerufen,
wenn der Kernel nach dem Fopen() den Pfad, in dem die ge”ffnete Datei liegt
und der an xfs_fopen bergeben worden war, nicht mehr ben”tigt. XFSs, die
keine garbage collection machen, k”nnen ber diese Funktion ihre DDs
freigeben.

Es muss sichergestellt werden, da die root nie freigegeben wird. Entweder
baut man hier eine spezielle Abfrage ein, oder (eleganter) setzt den
Referenzz„hler der root bei drv_open bereits auf 1.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_garbcoll

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_garbcoll® - Garbage Collection.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DMD][Der Drive-Medium-Deskriptor (DMD)]) *d
!item [-> d0 =]
1L oder 0L
!end_xlist

!item [Beschreibung:]
Der Kernel ben”tigt dringend internen GEMDOS-Speicher und macht eine
Mllsammlung (garbage collection). Ein XFS, das die interne
Speicherverwaltung des Kernels nicht verwendet, kann hier einen Nullpointer
als Funktion eintragen.

(!B)Achtung:(!b) Es sollten m”glichst soviele Bl”cke wie m”glich freigegeben
werden, Rckgabe ist 1, wenn (mindestens) ein Block freigegeben werden
konnte. Bei einer garbage collection durchl„uft der Kernel die gesamte Liste
aller angemeldeten logischen Laufwerke. Das XFS wird also so oft um eine
garbage collect ersucht, wie es zu diesem Zeitpunkt Laufwerke verwaltet.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_init

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_init® - Initialisierung.

!item [Parameter:]
---

!item [Beschreibung:]
Reserviert. Enth„lt im Fall MagiC interner XFSs deren Initialisierung. Wird
bei nachgeladenen XFSs nicht verwendet.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_link

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_link® - fr (!nolink [Frename]) und (!nolink [Flink]) notwendig.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *olddir
!item [a1 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *newdir
!item [d0 =]
char *oldname
!item [d1 =]
char *newname
!item [d2 =]
int flag_link
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Wird sowohl fr (!nolink [Frename]) (d2 = 0) als auch fr (!nolink [Flink])
(d2 = 1) verwendet. Im
Fall Frename ist ein neuer Verzeichniseintrag zu erstellen und der alte
Eintrag (Verweis auf die Datei) zu l”schen oder zu berschreiben.

Im Fall Flink wird ein weiterer Verweis auf dieselbe Datei angelegt und der
alte Eintrag nicht gel”scht. Beide DDs liegen immer auf demselben
Dateisystem, haben also denselben DMD. Wie bei Fdelete ist im Fall eines
symbolischen Links dieser umzubenennen bzw. ein weiterer Link zu erstellen.
D.h. der Rckgabewert ELINK ist hier (wie bei xfs_fdelete) _UNZULSSIG_.

(!nolink [Flink]) wird vom DOS_XFS (!I)nicht(!i) untersttzt.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_name

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_name® - Name des Dateisystems

!item [Parameter:]
---

!item [Beschreibung:]
Der Name ist bisher nur Kommentar; er soll irgendwann auch einmal die
M”glichkeit bieten, festzustellen, welche Treiber installiert sind und wie
z.B. der fr Laufwerk A: zust„ndige Treiber heit (d.h. was fr ein
Dateisystem die Diskette enth„lt).

Der Name des integrierten XFS lautet "DOS_XFS " (auf 8 Zeichen per
Leerstellen erweitert).

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_next

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_next® - n„chster Treiber.

!item [Parameter:]
---

!item [Beschreibung:]
Ist einfach ein Verkettungszeiger auf den n„chsten Treiber. Ein neuer
Treiber wird vorn eingebunden, hat also immer h”chste Priorit„t. Damit ist
es z.B. m”glich, den integrierten DOS-Treiber zu berladen.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_path2DD

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_path2DD® - gibt einen DD zum Pfadnamen zurck.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [mode =]
0: name ist Datei
!item [=]
1: name ist selbst Verzeichnis
!item [d0 =]
int mode
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *reldir akt. Verzeichnis
!item [a1 =]
char *pathname
!item [-> d0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [d1 =]
char *restpfad
!item [oder]
~
!item  [-> d0 =]
ELINK
!item [d1 =]
Restpfad ohne beginnenden '\'
!item  [a0 =]
(!link [FD][Der Datei-Deskriptor (FD)]) des Pfades, in dem der symbolische Link
liegt. Dies ist wichtig bei relativen Pfadangaben im Link.
!item [a1 =]
NULL, Der Pfad stellt den Parent des Wurzelverzeichnisses dar.
!item [oder]
~
!item [a1 =]
Pfad des symbolischen Links
!end_xlist

!item [Beschreibung:]
Der Kernel unterscheidet zwischen zwei Typen von Deskriptoren,
Dateideskriptoren FD, file descriptor) und Verzeichnisdeskriptoren (DD,
directory descriptor), die aber im Aufbau identisch sein k”nnen. Diese
Funktion liefert zu einem Pfad einen Deskriptor zurck. Der Referenzz„hler
des DD mu jedesmal, wenn er als Funktionswert zurckgeliefert wird, um 1
erh”ht werden, weil er vom Kernel referenziert wird. Die Funktion path2DD
entspricht einem "™ffnen" des Pfades, es wird eine Art "Dateihandle" dem
Kernel zurckgegeben, das der Kernel wieder schlieen mu. Das Parsen des
Pfades mu immer vom XFS erledigt werden.

(!B)Eingabeparameter:(!b)

!begin_xlist !short [<pathname>]
!item [<mode>]
Legt fest, ob das letzte Pfadelement selbst ein Verzeichnis ist (mode == 1),
oder ob der Pfad ermittelt werden soll, in dem diese Datei liegt.
!item [<reldir>]
Verzeichnis, von dem aus gesucht werden soll.
!item [<pathname>]
Der Pfadname, ohne Laufwerkbuchstaben und ohne fhrendes '\'.
!end_xlist

(!B)Ausgabeparameter:(!b)

1. Fall: Es ist ein Fehler aufgetreten

<d0> enth„lt den Fehlercode

2. Fall: Ein Verzeichnisdeskriptor (DD) konnte ermittelt werden.

!begin_xlist !short [<a0]
!item [<d0>]
Zeiger auf den (!link [DD][Der Verzeichnis-Deskriptor (DD)]). Der Referenzz„hler des
DD wurde vom XFS um 1 erh”ht.
!item [<d1>]
Zeiger auf den restlichen Dateinamen ohne beginnenden '\' bzw. '/'. Wenn das
Ende des Pfades erreicht wurde, zeigt dieser Zeiger auf das abschliessende
Nullbyte.
!end_xlist

3. Fall: Das XFS ist bei der Pfadauswertung auf einen symbolischen Link
gestoen

!begin_xlist !short [<a0>
!item [<d0>]
enth„lt den internen MagiC Fehlercode ELINK
!item [<d1>]
Zeiger auf den restlichen Pfad ohne beginnenden '\' bzw. '/'
!item [<a0>]
enth„lt den DD des Pfades, in dem der symbolische Link liegt. Der
Referenzz„hler des DD wurde vom XFS um 1 erh”ht.
!item [<a1>]
ist der Zeiger auf den Link selbst. Ein Link beginnt mit einem Wort (16 Bit)
fr die L„nge des Pfads, gefolgt vom Pfad selbst.
!end_xlist

(!B)Achtung:(!b) Die L„nge mu INKLUSIVE abschlieendes Nullbyte und
auerdem gerade sein. Der Link mu auf einer geraden Speicheradresse liegen.

Der Puffer fr den Link kann statisch oder auch flchtig sein, da der Kernel
die Daten sofort umkopiert, ohne da zwischendurch ein Kontextwechsel
stattfinden kann.

Wird a1 == NULL bergeben, wird dem Kernel signalisiert, da der Parent des
Wurzelverzeichnisses angew„hlt wurde. Befindet sich der Pfad etwa auf U:\A,
kann der Kernel auf U:\ zurckgehen. Der Wert des Rckgaberegisters a0 wird
vom Kernel ignoriert, es darf daher kein Referenzz„hler erh”ht werden.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_pterm

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_pterm® - teilt ein Programmende mit.

!item [Parameter:]
!begin_xlist !short [a0 =]
!item [a0 =]
PD *
!item [->]
void
!end_xlist

!item [Beschreibung:]
Diese Funktion wird bei jedem Programmende aufgerufen und gibt dem XFS
Gelegenheit, internen Strukturen freizugeben oder Locks zu entfernen. Die
fr den Kernel sichtbaren Dateien (d.h. die, denen ein Handle zugeordnet
ist), werden vorher vom Kernel geschlossen. Die Referenzz„hler fr
Standardverzeichnisse werden ebenfalls vorher durch den Kernel
dekrementiert. šbergeben wird in a0 ein Zeiger auf einen Proze-Deskriptor.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_readlink

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_readlink® - liest einen symbolischen Link.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [d0 =]
char *buf
!item [d1 =]
int  size
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Fr Freadlink. Wird vom DOS_XFS untersttzt.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_rlabel

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_rlabel® - liest den Disknamen.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [d0 =]
char *buf
!item [d1 =]
int len
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Zum Lesen des Medien-Namens. Wird vom Kernel dann aufgerufen, wenn Fsfirst
mit (Attribut == 8) durchgefhrt wird. <name> ist i.a. "*.*" und kann
ignoriert werden. <len> ist die L„nge des Puffers <buf>, bei šberschreitung
mu ERANGE geliefert werden. Wird auch fr Dreadlabel() aufgerufen. In
diesem Fall ist name == NULL.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_sfirst

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_sfirst® - sucht die erste passende Datei.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) * srchdir
!item [a1 =]
char *name (ohne Pfad)
!item [d0 =]
DTA *
!item [d1 =]
int  attrib
!item [-> d0 =]
long errcode
!item [-> a0 =]
SYMLINK * (ggf. Symlink)
!end_xlist

!item [Beschreibung:]
Wird fr Fsfirst ben”tigt. MiNT verwendet statt dieser Funktion eine
Kombination von Dreaddir und Fxattr, wozu aber sehr viele Aufrufe des
XFS-Treibers notwendig sind. Der reservierte Bereich der (!nolink [DTA]) kann vom XFS
frei verwendet werden, falls dieser zu klein ist, mu mit „hnlichen
heuristischen Methoden wie in MiNT vorgegangen werden, d.h. Zeiger in die
(!nolink [DTA]) eingetragen werden, die auf fest angelegte Deskriptoren zeigen.

Diese Deskriptoren k”nnen aber nur nach heuristischen Methoden freigegeben
werden, weil man nie wei, ob noch ein Fsnext kommt oder nicht. Der Kernel
ermittelt ber path2DD bereits den vollst„ndigen Pfad, so da nur noch der
reine Dateiname in a1 bergeben wird. Wie bei allen DOS-Aufrufen, die einen
Pfad verarbeiten, mu das XFS darauf achten, da der DD fr die Dauer der
Bearbeitung geschtzt wird. Das ist besonders dann kritisch, wenn das
Dateisystem reentrant ist.

Ist eine gesuchte Datei ein symbolischer Link, mu als Fehlercode in d0
ELINK und in a0 der Zeiger auf den Link bergeben werden. Der Kernel ruft
dann einfach (!nolink [Fxattr]) auf, um die (!nolink [DTA]) zu fllen.
Trat ein Diskwechsel auf, ist
E_CHNG zurckzugeben, der Kernel wiederholt dann automatisch die Funktion.
Das gilt auch fr alle anderen Funktionen.

In jedem Fall mu dta_drive korrekt initialisiert werden, z.B. per:
dta.dta_drive = srchdir->dd_dmd->d_drive. Wird (!nolink [E_OK]) oder ELINK
zurckgegeben, ohne da dta_drive initialisiert wurde, ist das Resultat
unvorhersehbar!

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node


!begin_node xfs_snext

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_snext® - sucht die n„chste passende Datei.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
DTA *
!item [a1 =]
(!link [DMD][Der Drive-Medium-Deskriptor (DMD)]) *
!item [-> d0 =]
long errcode,
!item [-> a0 =]
SYMLINK * (Symlink)
!end_xlist

!item [Beschreibung:]
Wird fr Fsnext ben”tigt. Der Kernel hat aus der (!nolink [DTA]) bereits das zugeh”rige
Dateisystem ermittelt, dessen DMD in a1 bergeben wird. Auch hier kann ein
symbolischer Link auftreten.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_symlink

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_symlink® - erstellt einen symbolischen Link.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) * dir
!item [a1 =]
char *name
!item [d0 =]
char *to
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Fr Fsymlink. Es mu unter dem neuen Namen <name> eine Datei im Verzeichnis
<dir> erstellt werden, die auf die Datei <to> zeigt. Wird vom DOS_XFS
untersttzt.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_sync

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_sync® - synchronisiert das Dateisystem.

!item [Parameter:]
!begin_xlist !short [a0 =]
!item [a0 =]
(!link [DMD][Der Drive-Medium-Deskriptor (DMD)]) *d
!item [->]
long errcode
!end_xlist

!item [Beschreibung:]
Der Kernel teilt dem XFS mit, da auf Laufwerk <d> alle Puffer
zurckzuschreiben sind. šbergeben wird in Register a0 ein Zeiger auf einen
DMD (drive media descriptor). Dieser wird vom Kernel angelegt.

Zurckgeliefert wird ein Fehlercode. Wenn das XFS keine Pufferverwaltung hat
(z.B. eine RAMDisk), mu eine 0 geliefert werden. Das interne DOS_XFS ruft
einfach die gleichlautende DFS- Funktion auf.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_wlabel

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_wlabel® - schreibt den Disknamen.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Zum (Um-)Benennen von Medien. Wird vom Kernel dann aufgerufen, wenn Fcreate
mit Attribut 8 durchgefhrt werden. Wird der Diskname, wie beim
DOS-Dateisystem, als spezielle Datei abgelegt, mssen alle anderen
pfadbasierten XFS-Funktionen den Disknamen ignorieren.

Ein leerer Name oder ein aus "\xe5" bestehender (Kompatibilit„t zu TOS) mu
den Disknamen l”schen (falls Medien ohne Namen zul„ssig sind). Wird auch fr
Dwritelabel() aufgerufen.

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node



!begin_node xfs_xattr

(!begin_liste) [Beschreibung]

!item [Name:]
¯xfs_xattr® - fr Fxattr notwendig.

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) *
!item [a1 =]
char *name
!item [d0 =]
XATTR *
!item [d1 =]
int mode
!item [-> d0 =]
long errcode
!item [-> a0 =]
SYMLINK *
!end_xlist

!item [Beschreibung:]
Wird fr Fxattr verwendet. Im Fall mode == 0 (d.h. folge symbolischen Links)
kann in d0 ELINK und in a0 ein Link zurckgegeben werden, andernfalls ist
ELINK unzul„ssig.

!begin_xlist !short [mode == 0:]
!item [mode == 0:]
folge symbolischen Links (gib ggf. ELINK zurck)
!item [== 1:]
folge nicht (d.h. erstelle (!nolink [XATTR]) fr den Link)
!end_xlist

!item [Gruppe:]
(!link [Aufbau eines XFS][Der Aufbau eines XFS])

!item [Querverweis:]
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])

(!ende_liste)
!end_node
!end_node



!begin_node Datenstrukturen fr ein XFS
!label XFS, Datenstrukturen fr ein

Bei der Arbeit mit einem XFS sind die folgenden Datenstrukturen wichtig:

!begin_xlist [MX_DEV ] !short
!item [(!link [DD] [Der Verzeichnis-Deskriptor (DD)])]        (Verzeichnis-Deskriptor)
!item [(!link [DHD] [Der Directory-Handle-Deskriptor (DHD)])] (Directory-Handle-Deskriptor)
!item [(!link [DMD] [Der Drive-Medium-Deskriptor (DMD)])]     (Medium-Deskriptor)
!item [(!link [DTA] [Die Disk-Transfer-Area DTA])]            (Disk-Transfer-Area)
!item [(!link [FD] [Der Datei-Deskriptor (FD)])]              (Datei-Deskriptor)
!item [(!link [MX_DEV] [Der Ger„tetreiber (MX_DEV)])]         (Ger„tetreiber)
!end_xlist

Querverweis:
(!link [DFS-Strukturen][Datenstrukturen fr ein DFS]) ~
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])



!begin_node Der Verzeichnis-Deskriptor (DD)
!label Verzeichnis-Deskriptor
!label Directory-Deskriptor
!label Deskriptor, Verzeichnis-

Die Verzeichnisdeskriptoren mssen vom XFS angelegt und verwaltet werden.
Alle Deskriptoren, die dem Kernel bekannt sind (d.h. diejenigen, die fr
einen Proze als Standardpfad verwendet werden) haben Referenzz„hler
ungleich Null. Eine Ausnahme bildet nur der DD fr das Wurzelverzeichnis
eines Laufwerks; hier ist der Referenzz„hler immer 0, egal ob ein Proze das
Wurzelverzeichnis als Standardverzeichnis hat oder nicht.

Fr den Kernel sieht ein DD folgendermaen aus, diese Eintr„ge mssen vom
XFS angelegt werden:

!begin_verbatim
dd_dmd:      DS.L      1    /* 0x00: Zeiger auf DMD               */
dd_refcnt:   DS.W      1    /* 0x04: Ref.z„hler fr Standardpfade */
!end_verbatim

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])



!begin_node dd_dmd

Hier steht das zugeh”rige Dateisystem.
!end_node



!begin_node dd_refcnt

Der Referenzz„hler. Dieser Eintrag wird nur vom Kernel verwendet, mu vom
XFS beim Erstellen eines (!nolink [DD]) auf 0 initialiert (bei der root am
besten auf 1, s.o. bei xfs_drv_open) und bei jeder šbergabe an den Kernel
(-> xfs_path2DD) um 1 inkrementiert werden.

D.h. da xfs_path2DD beim Zurckgeben eines neuen
(!link [DD][Der Verzeichnis-Deskriptor (DD)]) (der also vom Kernel
sonst nicht referenziert wird) den Referenzz„hler auf 1 setzen mu.

Wenn der Referenzz„hler ungleich 0 ist, hat der Kernel Zeiger auf diesen DD,
und er darf keinesfalls vom XFS freigegeben werden. Der Kernel z„hlt den
Referenzz„hler jedesmal um 1 herunter, wenn er einen DD nicht mehr ben”tigt.
Erreicht der Z„hler dabei Null, wird xfs_freeDD aufgerufen. Das XFS kann
dann den DD freigeben oder ansonsten erst beim Aufruf von (!nolink [xfs_garbcoll]) (der
"garbage collection") oder bei xfs_drv_close.

(!B)Achtung:(!b) Die root darf w„hrend der Lebensdauer eines gemounteten
Dateisystems nicht freigegeben werden. Der Referenzz„hler der root sollte
mit 1 vorbesetzt werden, um zu verhindern, da er per free_DD freigegeben
wird.

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  Datenstrukturen fr ein XFS
!end_node
!end_node



!begin_node Der Directory-Handle-Deskriptor (DHD)
!label Directory-Handle-Deskriptor
!label Deskriptor, Directory-Handle

Die Directory-Handles werden fr Dopendir/Dclosedir/Drewinddir ben”tigt. Im
Gegensatz zu den Dateideskriptoren (FD) h„lt der Kernel keine Liste der
ge”ffneten DHs. Wenn ein Proze terminiert, wird das XFS ber die Funktion
xfs_pterm aufgerufen und mu alle fr den Proze angelegten DHs freigeben.

Den Eigner eines DH kann das XFS ber den Kernel-Zeiger <act_pd> ermitteln.
Fr den Kernel sieht ein DH folgendermaen aus, diese Eintr„ge mssen vom
XFS angelegt werden:

!begin_verbatim
dhd_dmd:  DS.L   1   /* 0x00: Zeiger auf DMD  */
!end_verbatim

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~
(!link [DMD][Der Drive-Medium-Deskriptor (DMD)])


!begin_node dhd_dmd

Hier steht das zugeh”rige Dateisystem.
!end_node
!end_node



!begin_node Der Drive-Medium-Deskriptor (DMD)
!label Drive-Medium-Deskriptor
!label Deskriptor, Drive-Medium

Der DMD wird vom Kernel (!) fr jedes ge”ffnete Laufwerk angelegt und auch
ggf. wieder freigegeben. Hier legt der XFS alle Daten an, die er sich fr
das Laufwerk merken mu. Die folgenden Felder sind diejenigen, die der
Kernel ben”tigt (Das Ur- Objekt, von dem der XFS seinen XFS-DMD ableitet):

!begin_verbatim
d_xfs:      DS.L   1    /* 0x00: Der Dateisystemtreiber           */
d_drive:    DS.W   1    /* 0x04: Laufwerknummer 0..25             */
d_root:     DS.L   1    /* 0x06: Zeiger auf DD der Root           */
d_biosdev:  DS.W   1    /* 0x0a: BIOS-Laufwerk oder -1            */
d_driver:   DS.L   1    /* 0x0c: def. zus. mit devcode das Medium */
d_devcode:  DS.L   1    /* 0x10: z.B. SCSI Target & Laufwerk      */
d_dfs:      DS.L   1    /* 0x14: DOS-spez. Dateisystem-Treiber    */
!end_verbatim

Andere XFSs oder DFSs tragen weitere Daten in den DMD ein. Man kann sich
den DMD als eine Objektklasse vorstellen. Ein fr das DOS_XFS abgeleiteter
DMD hat nur den zus„tzlichen Eintrag d_dfs. Der FAT-DFS tr„gt zus„tzlich
Daten wie die Clustergr”e und die Anzahl der Sektoren ein.

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~
(!link [DD][Der Verzeichnis-Deskriptor (DD)])


!begin_node d_xfs

Hier steht der zugeh”rige Dateisystemtreiber (XFS). Er wird von
(!B)xfs_drv_open(!b) eingetragen.
!end_node



!begin_node d_drive

Hier steht, welchem logischen Laufwerk ('A' .. 'Z') das Dateisystem
zugeordnet ist. Das braucht nicht immer einem (!B)BIOS-Laufwerk(!b) zu
entsprechen. Dieser Wert wird (!I)immer (!)(!i) vom Kernel eingetragen, wenn
ein Laufwerk ge”ffnet wird, bevor ein XFS eingetragen wird.
!end_node



!begin_node d_root

Hier steht ein Zeiger auf den DD des Wurzelverzeichnisses.
!end_node



!begin_node d_biosdev

Wenn es sich um eine Partition handelt, die mit (!nolink [BIOS]) (!B)Rwabs(!b)
behandelt wird, steht hier die BIOS-Ger„tenummer. Ansonsten mu -1
eingetragen werden (z.B. bei Laufwerk U: oder einer
(!I)Macintosh(!i)-Partition).
!end_node



!begin_node d_driver

Bestimmt zusammen mit d_devcode das Medium. D.h. wenn d_driver und
(!nolink [d_devcode]) identisch sind, liegen beide Laufwerke auf demselben Medium. D.h.
wenn das Medium ausgeworfen werden soll, mssen beide Dateisysteme gesperrt
werden. Bei einer Harddisk-Partion ist d_biosdev das (!B)BIOS-Laufwerk(!b),
(!B)d_driver(!b) ist beliebig (z.B. Zeiger auf die XHDI-Struktur), (!nolink [d_devcode])
ist der XHDI-Code eines Mediums, d.h. SCSI-Target und Ger„tenummer (jew. ein
WORD).
!end_node



!begin_node d_devcode

Bestimmt zusammen mit d_driver das Medium. D.h. wenn d_driver und
d_devcode identisch sind, liegen beide Laufwerke auf demselben Medium. D.h.
wenn das Medium ausgeworfen werden soll, mssen beide Dateisysteme gesperrt
werden. Bei einer Harddisk-Partion ist d_biosdev das (!B)BIOS-Laufwerk(!b),
(!nolink [d_driver]) ist beliebig (z.B. Zeiger auf die XHDI-Struktur), d_devcode
ist der XHDI-Code eines Mediums, d.h. SCSI-Target und Ger„tenummer (jew. ein
WORD).
!end_node



!begin_node d_dfs

Dieser Eintrag existiert (!I)zwingend nur fr(!i) (!B)DOS-Dateisysteme(!b)
(also bereits fr ein abgeleitetes Objekt) und enth„lt einen Zeiger auf den
DFS-Untertreiber.
!end_node
!end_node



!begin_node Die Disk-Transfer-Area DTA

Die DTA wird von den alten DOS-Funktionen Fsfirst und Fsnext verwendet,
deren ungeschickte Konzeption durch die MSDOS-Sch”pfer immer noch wie ein
Fluch auf dem System lastet. Fr den Kernel sieht die Struktur
folgendermaen aus:

!begin_verbatim
dta_res1:        DS.B    20    /* 0x00: vom Kernel nicht benutzt */
dta_drive:       DS.B     1    /* 0x14: logisches Laufwerk       */
dta_attribute:   DS.B     1    /* 0x15: gefundenes Attribut      */
dta_time:        DS.W     1    /* 0x16: gefundene Zeit           */
dta_date:        DS.W     1    /* 0x18: gefundenes Datum         */
dta_len:         DS.L     1    /* 0x1a: gefundene L„nge          */
dta_name:        DS.B    14    /* 0x1e: gefundener Dateiname     */
!end_verbatim

(!B)Hinweis:(!b) Die Komponenten (!I)dta_attribute(!i) bis (!I)dta_name(!i)
stellen den dokumentierten User-Bereich dar; dieser muss nach
GEMDOS-Spezifikation behandelt werden.

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])



!begin_node xfs_dta_res1

Wird vom Kernel nicht verwendet. Hier darf sich das XFS tummeln.
!end_node



!begin_node xfs_dta_drive

Hier steht das zugeh”rige (!B)logische(!b) Laufwerk (0 entspricht Laufwerk-A
etc). Hierdurch kann der Kernel beim Fsnext entscheiden, welches XFS die
Anforderung ausfhren muss.
!end_node
!end_node



!begin_node Der Datei-Deskriptor (FD)
!label Datei-Deskriptor
!label File-Deskriptor
!label Deskriptor, Datei-

Die Dateideskriptoren mssen vom XFS angelegt und verwaltet werden. Alle
Deskriptoren, die dem Kernel bekannt sind, haben Referenzz„hler ungleich
Null. Fr den Kernel sieht ein FD genauso aus wie ein
(!link [DD][Der Verzeichnis-Deskriptor (DD)]), weshalb im DOS_XFS
die gleiche Datenstruktur verwendet wird.

Fr den Kernel sieht ein FD folgendermaen aus, diese Eintr„ge mssen vom
XFS angelegt werden:

!begin_verbatim
fd_dmd:      DS.L    1   /* 0x00: Zeiger auf DMD                       */
fd_refcnt:   DS.W    1   /* 0x04: Ref.z„hler frs Schlieen oder -1    */
fd_mode:     DS.W    1   /* 0x06: Open- Modus und flags                */
fd_dev:      DS.L    1   /* 0x08: Zeiger auf MX_DEV                    */
!end_verbatim

Die vom DOS_XFS abgeleitete Klasse (ein "DOS-FD") hat darber hinaus noch
die zus„tzlichen Felder:

!begin_verbatim
fd_ddev:     DS.L    1    /* 0x0c: Zeiger auf MX_DDEV                  */
fd_name:     DS.B   11    /* 0x10: DD_FD: Name im internen Format      */
fd_attr:     DS.B    1    /* 0x1b: Attribut                            */
fd_owner:    DS.L    1    /* 0x1c: DD_FD: Eigner eines FD oder NULL    */
fd_parent:   DS.L    1    /* 0x20: Zeiger auf den Parent-DD_FD         */
fd_children: DS.L    1    /* 0x24: DD_FD: Liste aller Kinder           */
fd_next:     DS.L    1    /* 0x28: Zeiger auf FDs im selben Verzeichn. */
fd_multi:    DS.L    1    /* 0x2c: Zeiger auf FD derselben Datei       */
fd_multi1:   DS.L    1    /* 0x30: Zeiger auf erstes Listenelement     */
fd_fpos:     DS.L    1    /* 0x34: Position des Dateizeigers           */
fd_dirch:    DS.B    1    /* 0x38: Bit0: "dirty"                       */
fd_unused:   DS.B    1    /* 0x39:                                     */
fd_time:     DS.W    1    /* 0x3a: Zeit  (8086)                        */
fd_date:     DS.W    1    /* 0x3c: Datum (8086)                        */
fd_stcl:     DS.W    1    /* 0x3e: Start- Cluster                      */
fd_len:      DS.L    1    /* 0x40: Dateil„nge in Bytes                 */
fd_dirpos:   DS.L    1    /* 0x44: Pos. des zug. Eintrags im Directory */
fd_user1:    DS.L    1    /* 0x48: zur freien Verfgung                */
fd_user2:    DS.L    1    /* 0x4c: zur freien Verfgung                */
!end_verbatim

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~
(!link [DMD][Der Drive-Medium-Deskriptor (DMD)]) ~
(!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)]) ~
(!link [MX_DEV][Der Ger„tetreiber (MX_DEV)])


!begin_node fd_dmd

Hier steht das zugeh”rige Dateisystem.
!end_node



!begin_node fd_refcnt

Der Referenzz„hler. Dieser Eintrag wird (!I)nur vom Kernel(!i) verwendet,
mu beim Aufruf von (!B)dev_close(!b) dekrementiert und durch
(!B)xfs_fopen(!b) initialisiert werden (mit 1).

Ein Referenzz„hler von -1 signalisiert, da der FD nie freigegeben werden
darf. Dies ist z.B. fr die Ger„tedateien U:\DEV\CON, U:\DEV\AUX usw.
notwendig, die immer zur Verfgung stehen.
!end_node



!begin_node fd_mode

Hier steht der Modus, wie bei (!B)xfs_fopen(!b) beschrieben. Zeigen zwei FDs
auf dieselbe Datei, mssen die Modi kompatibel sein. Durch die einfache
MagiC interne Modusdarstellung ist ein einfaches Rotieren und verUNDen der
Bits ausreichend, z.B:

!begin_verbatim
  move.w   fd_mode(a0),d1
  btst     #BOM_NOCHECK,d1  ; kein Check durch das XFS?
  bne.b    _opf_nxt         ; ja, ddev_open prft
  ror.b    #4,d1
  and.b    d0,d1
  bne      opd_eaccdn       ; Konflikt: return(EACCDN)
!end_verbatim
!end_node



!begin_node fd_dev

Dies ist der Zeiger auf den Ger„tetreiber.
!end_node



## die folgenden Komponenten sind eigentlich nur im
## DOS-XFS vorhanden.



!begin_node fd_ddev

Hier mu das DFS beim Aufruf von (!B)dir2FD(!b) den MX_DDEV eintragen, also
den Ger„tetreiber.
!end_node



!begin_node fd_name

Hier wird der Name (8+3) im internen Format abgelegt. Der Name ist nur
gltig, wenn es sich um ein (!B)Unterverzeichnis(!b) handelt. Der Name ist
(!I)nur im Prototyp-FD(!i), d.h. in fd->multi1 gltig. Der Name der Root ist
eine leere Zeichenkette.
!end_node



!begin_node fd_attr

Hier wird das Datei-Attribut abgelegt. Dieses ist (!I)nur im
Prototyp-FD(!i), d.h. in fd->multi1 gltig. Am Attribut kann man erkennen,
ob der FD ein Verzeichnis repr„sentiert.
!end_node



!begin_node fd_owner

Hier wird ein Zeiger auf den Eigner eines FD abgelegt (d.h. ein Zeiger auf
die (!B)Basepage(!b)). Ein Wert von NULL bedeutet, da der FD z.Zt. nicht
belegt ist.
!end_node


!begin_node fd_parent

Verkettungszeiger auf den (!B)Parent(!b), d.h. auf das Verzeichnis, in dem
die Datei liegt bzw. das Elterverzeichnis eines Unterverzeichnisses.
fd_parent ist nur fr den (!I)Prototyp-FD(!i) gltig.
!end_node



!begin_node fd_children

Liste aller ge”ffneten Dateien und ge”ffneten Unterverzeichnisse.
fd_children ist (!I)nur fr den Prototyp-FD(!i) gltig.
!end_node



!begin_node fd_next

Zeiger auf den n„chsten FD im selben Verzeichnis, d.h. auf das n„chste
Geschwist, dieses kann eine ge”ffnete Datei oder ein Unterverzeichnis sein,
prinzipiell werden keine Unterschiede gemacht. fd_next ist (!I)nur fr den
Prototyp-FD(!i) gltig.
!end_node



!begin_node fd_multi

Wenn eine Datei mehrmals ge”ffnet wird, wird ein (!B)'Clone'(!b) des
Prototyp-FD angelegt. Fr diesen Clone sind die meisten Felder des FD
ungltig, im wesentlichen sind nur Treiber, Modus und Dateiposition gltig.
fd_multi ist eine verkettete Liste, die mit NULL abgeschlossen ist.
!end_node



!begin_node fd_multi1

Der zugeh”rige Prototyp-FD, der die gltigen Dateiangaben enth„lt. Wenn eine
Datei nur einmal ge”ffnet ist, gilt: fd->fd_multi == fd
!end_node



!begin_node fd_fpos

Die Position des Dateizeigers, ist 0L bei einem Ger„t.
!end_node



!begin_node fd_dirch

Bit 0 zeigt an, ob eine Datei ver„ndert wurde und daher beim Schlieen der
Datei das Verzeichnis ((!B)fd_parent(!b)) aktualisiert werden mu (passiert
nicht, wenn es sich um einen Ordner handelt). Die anderen Bits sind
(!I)reserviert(!i) und werden teilweise vom DOS_XFS verwendet.
!end_node



!begin_node fd_unused

Unbenutzt und reserviert.
!end_node



!begin_node fd_time

Uhrzeit aus dem Verzeichniseintrag im (!B)Intel-Format(!b).
!end_node



!begin_node fd_date

Datum aus dem Verzeichniseintrag im (!B)Intel-Format(!b).
!end_node



!begin_node fd_stcl

Start-Cluster im (!B)Motorola-Format(!b).
!end_node



!begin_node fd_len

Dateil„nge in Bytes im (!B)Motorola-Format(!b).
!end_node



!begin_node fd_dirpos

Position des zugeh”rigen Eintrags im Parent. Ist (!I)nur fr den
Prototyp-FD(!i) gltig.
!end_node



!begin_node fd_user1

Zusammen mit (!B)fd_user2(!b) 2 Langworte zur freien Verfgung. Das FAT_DFS
speichert hier zus„tzliche Informationen zu (!B)fd_fpos(!b) ab, und zwar den
aktuellen Cluster. Andere DFSs k”nnen andere Daten ablegen. Diese Felder
sind zun„chst auch nur fr den Prototyp-FD gltig, es sei denn, beim ™ffnen
((!B)ddev_open(!b)) werden die Daten explizit aus dem Prototyp-FD in den
Clone kopiert.
!end_node



!begin_node fd_user2

Zusammen mit (!B)fd_user1(!b) 2 Langworte zur freien Verfgung. Das FAT_DFS
speichert hier zus„tzliche Informationen zu (!B)fd_fpos(!b) ab, und zwar den
aktuellen Cluster. Andere DFSs k”nnen andere Daten ablegen. Diese Felder
sind zun„chst auch nur fr den Prototyp-FD gltig, es sei denn, beim ™ffnen
((!B)ddev_open(!b)) werden die Daten explizit aus dem Prototyp-FD in den
Clone kopiert.
!end_node
!end_node



!begin_node Der Ger„tetreiber (MX_DEV)
!label Ger„tetreiber, MX_DEV

Der Ger„tetreiber wird beim ™ffnen einer Datei vom XFS in den
Dateideskriptor eingesetzt und vom Kernel direkt aufgerufen. Der
Ger„tetreiber mu die folgenden Funktionen bereitstellen:

!begin_verbatim
typedef struct _mx_dev
{
  LONG  (*dev_close)();
  LONG  (*dev_read)();
  LONG  (*dev_write)();
  LONG  (*dev_stat)();
  LONG  (*dev_seek)();
  LONG  (*dev_datime)();
  LONG  (*dev_ioctl)();
  LONG  (*dev_getc)();
  LONG  (*dev_getline)();
  LONG  (*dev_putc)();
} MX_DEV;
!end_verbatim

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])




!begin_node dev_close

(!begin_liste) [Beschreibung]

!item [Name:]
¯dev_close®

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [FD][Der Datei-Deskriptor (FD)]) *file
!item [-> d0 =]
long errcode
!end_xlist

!item [Beschreibung:]
Wenn fd_refcnt nicht schon 0 ist, mu fd_refcnt dekrementiert werden (dies
mu vom (!link [MX_DEV][Der Ger„tetreiber (MX_DEV)]) erledigt werden). Bei dieser
Gelegenheit sollten auch
m”glicherweise vorhandene Puffer zurckgeschrieben bzw. Verzeichniseintr„ge
aktualisiert werden. Wenn (!nolink [fd_refcnt]) 0 ist, kann der FD freigegeben werden.
Beim Diskwechsel ist (!nolink [fd_refcnt]) bereits beim Aufruf von dev_close 0, d.h. der
FD mu einfach nur freigegeben werden.

Der vom DOS_XFS installierte Dateitreiber schreibt die Verzeichnisdaten
zurck und ruft dann den (!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber auf.

!item [Gruppe:]
(!link [Ger„tetreiber][Der Ger„tetreiber (MX_DEV)])

!item [Querverweis:]
---

(!ende_liste)
!end_node



!begin_node dev_datime

(!B)Fr Fdatime.(!b) Der vom DOS_XFS installierte Dateitreiber leitet den
Aufruf an den (!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter, wenn die Funktion im
MX_DDEV-Treiber untersttzt wird (Zeiger != NULL), ansonsten wird die
Funktion (!I)automatisch(!i) mit Hilfe der Daten des FD ausgefhrt.

(!B)Parameter-šbergabe:(!b)
!begin_table [r l l]
a0 !! = !! (!link [FD][Der Datei-Deskriptor (FD)]) *file
a1 !! = !! int d[2]
d0 !! = !! int setflag
-> d0 !! = !! long errcode
!end_table
!end_node



!begin_node dev_getc

(!begin_liste) [Beschreibung]

!item [Name:]
¯dev_getc®

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [FD][Der Datei-Deskriptor (FD)]) *file
!item [d0 =]
int mode
!item [-> d0 =]
unsigned long c
!end_xlist

!item [Beschreibung:]
Wird vom Kernel fr (!nolink [Fgetchar])() und die zeichenorientierten Funktionen
(Cconin, Cconout, Cauxin usw.) verwendet. Im Fall eines Ger„ts kann der
Rckgabewert ein Langwort sein (so bei CON im Hiword der Scancode der
Taste), ansonsten ein Byte (immer als "unsigned" erweitert). Bei EOF mu
0x0000FF1A geliefert werden.

(!B)<mode> bedeutet:(!b)

!begin_xlist !short [CMODE_COOKED (1)]
!item [CMODE_COOKED (1)]
Bit 0 gesetzt: Steuerzeichen ^C, ^S, ^Q werden verarbeitet.
!item [CMODE_RAW (0)]
Bit 0 nicht gesetzt: "raw" Modus
!item [CMODE_ECHO (2)]
Bit 1 gesetzt: Eingabe wird ge-echo-t
!end_xlist

Der vom DOS_XFS installierte Dateitreiber leitet den Aufruf an den
(!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter, wenn die Funktion im MX_DDEV-Treiber
untersttzt wird (Zeiger != NULL), ansonsten wird die Funktion automatisch
auf dev_fread zurckgefhrt.

!item [Gruppe:]
(!link [Ger„tetreiber][Der Ger„tetreiber (MX_DEV)])

!item [Querverweis:]
---

(!ende_liste)
!end_node



!begin_node dev_getline

(!B)Fr zeilenorientierte Eingabe(!b). <mode> wie in dev_getc. Zurckgegeben
wird die Anzahl der eingegebenen Zeichen ohne Endezeichen o.„. Der vom
DOS_XFS installierte Dateitreiber leitet den Aufruf an den
(!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter, wenn die Funktion im MX_DDEV-Treiber
untersttzt wird (Zeiger != NULL), ansonsten wird die Funktion automatisch
auf dev_fread zurckgefhrt, die Zeile wird dann mit CR und LF beendet,
Steuerzeichen (BS oder Del) nicht ausgewertet.

(!B)Parameter-šbergabe:(!b)
!begin_table [r l l]
a0 !! = !! (!link [FD][Der Datei-Deskriptor (FD)]) *file
a1 !! = !! char *buf
d1 !! = !! long size
d0 !! = !! int mode
-> d0 !! = !! long amount
!end_table
!end_node



!begin_node dev_ioctl

(!B)Fr Fcntl.(!b) Der vom DOS_XFS installierte Dateitreiber leitet den
Aufruf direkt an den (!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter. Bearbeitet werden jedoch
vorher folgende Funktionen: FSTAT und FUTIME. Diese sollten auch von anderen
XFSs ausgefhrt werden. Jeder Dateitreiber sollte (!B)FIONREAD(!b) und
(!B)FIONWRITE(!b) untersttzen.

(!B)Parameter-šbergabe:(!b)
!begin_table [r l l]
a0 !! = !! (!link [FD][Der Datei-Deskriptor (FD)]) *file
d0 !! = !! int cmd
a1 !! = !! void *buf
-> d0 !! = !! long errcode
!end_table
!end_node



!begin_node dev_putc

(!begin_liste) [Beschreibung]

!item [Name:]
¯dev_putc®

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [FD][Der Datei-Deskriptor (FD)]) *file
!item [d0 =]
int mode
!item [d1 =]
long value
!item [-> d0 =]
unsigned long count
!end_xlist

!item [Beschreibung:]
Wird vom Kernel fr (!nolink [Fgetchar])() und die zeichenorientierten Funktionen
(Cconout, Cauxout usw.) verwendet. Im Fall eines Terminals mu der
Rckgabewert 4L sein (d.h. 4 Bytes geschrieben, ansonsten 1L, falls
erfolgreich geschrieben wurde.

(!B)<mode> bedeutet:(!b)

!begin_xlist !short [CMODE_COOKED (1)]
!item [CMODE_COOKED (1)]
Bit 0 gesetzt: Steuerzeichen ^C, ^S, ^Q werden verarbeitet.
!item [CMODE_RAW (0)]
Bit 0 nicht gesetzt: "raw" Modus
!end_xlist

Der vom DOS_XFS installierte Dateitreiber leitet den Aufruf an den
(!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter, wenn die Funktion im MX_DDEV-Treiber
untersttzt wird (Zeiger != NULL), ansonsten wird die Funktion automatisch
auf dev_fwrite zurckgefhrt.

!item [Gruppe:]
(!link [Ger„tetreiber][Der Ger„tetreiber (MX_DEV)])

!item [Querverweis:]
---

(!ende_liste)
!end_node



!begin_node dev_read

Von Datei <file> werden <count> Bytes in den Puffer <buffer> gelesen. Die
Anzahl der tats„chlich gelesenen Zeichen wird zurckgegeben. Der vom DOS_XFS
installierte Dateitreiber leitet den Aufruf direkt an den
(!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter.

(!B)Parameter-šbergabe:(!b)
!begin_table [r l l]
a0 !! = !! (!link [FD][Der Datei-Deskriptor (FD)]) *file
d0 !! = !! long count
a1 !! = !! char *buffer
-> d0 !! = !! long amount
!end_table
!end_node



!begin_node dev_seek

(!B)Fr Fseek.(!b) <mode> ist, wie im TOS, 0, 1 oder 2. Zurckgegeben wird
die aktuelle Position des Schreib-/Lesezeigers, Ger„tetreiber mssen hier
immer eine 0L zurckgeben. Der vom DOS_XFS installierte Dateitreiber leitet
den Aufruf direkt an den (!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter.

(!B)Parameter-bergabe:(!b)
!begin_table [r l l]
a0 !! = !! (!link [FD][Der Datei-Deskriptor (FD)]) *file
d0 !! = !! long where
d1 !! = !! int mode
-> d0 !! = !! long position
!end_table
!end_node



!begin_node dev_stat

(!begin_liste) [Beschreibung]

!item [Name:]
¯dev_stat®

!item [Parameter:]
!begin_xlist !short [-> a0 =]
!item [a0 =]
(!link [FD][Der Datei-Deskriptor (FD)]) *file
!item [a1 =]
MAGX_UNSEL *unselect oder NULL
!item [d0 =]
int rwflag
!item [d1 =]
long apcode
!item [-> d0 =]
long status
!end_xlist

!item [Beschreibung:]
Gibt den Lese-/Schreibstatus der Datei an. Wird z.B. bei Fselect()
aufgerufen (oder bei Cconos()/Cconis() usw.). Im Gegensatz zu MiNT wird hier
dem Treiber berlassen, ob er interruptf„hig ist oder nicht, d.h. ob er in
der Lage ist, eine wartende Applikation im Interrupt wieder aufzurufen oder
nicht. rwflag gibt an, ob Schreib- oder Lesestatus abgefragt wird.

<unselect> ist entweder NULL oder ein Zeiger auf folgende Struktur:

!begin_verbatim
typedef struct
{
   union
   {
      void (*unsel) (MAGX_UNSEL *un);
      long status;
   }
   long param;
} MAGX_UNSEL;
!end_verbatim

(!B)Vorgehensweise:(!b)

Allgemein gilt: Wenn <unselect> ungleich Null ist, mu der Rckgabewert
nicht nur als Funktionsergebnis (in d0.l), sondern auch in unselect->status
zurckgegeben werden. Das gilt fr alle Arten von Rckgabewerten. In
unsel->param kann optional ein Parameter abgelegt werden.

(!B)Wenn <apcode> == NULL ist, wird gepollt, d.h. die Applikation wird nicht
schlafengelegt. Also Rckgabe:(!b)

0 = nicht bereit, 1 = bereit, <0 = Fehler.

(!B)Wenn <apcode> != NULL ist (dann ist auch <unselect> != NULL) wird
zurckgegeben:(!b)

!begin_xlist !short [<0]
!item [<0]
Fehler
!item [0]
nicht bereit, Ger„t kann nur polling
!item [1]
bereit
!item [>0]
etwa Zeiger auf eine Funktion, die den Aufweckinterrupt wieder deinstalliert
(entspricht in etwa dem unselect in MiNT).
!end_xlist

(!B)Falls das Ger„t nicht bereit ist und interruptf„hig ist, geht man
folgendermaen vor:(!b)

!begin_enumerate !short
!item  unselect mit der Adresse der Aufr„umroutine und einem optionalen
       Parameter initialisieren, Prototyp etwa:
!begin_verbatim
void unselect( a0 = MAGX_UNSEL *un,a1 = void *ap_code );
!end_verbatim
!item Interrupt zum Aufwecken installieren, diesem unselect (und damit auch
      den optionalen Parameter) und appl mitteilen.
!item Zeiger auf Aufr„umroutine in d0 zurckgeben.
!end_enumerate

(!B)Die Interruptroutine macht folgendes:(!b)

!begin_enumerate !short
!item Der Interrupt trifft ein.
!item unselect->status wird mit 1 (ok) oder < 0 (nicht ok) beschrieben und
      der Interrupt deaktiviert! Die Applikation wird aufgeweckt mit
!begin_verbatim
kernel->appl_IOcomplete( a0 = APPL *ap );
!end_verbatim
!end_enumerate

(!B)Die Aufr„umroutine macht folgendes:(!b)

!begin_enumerate !short
!item Der Interrupt wird deaktiviert.
!item in unsel->status wird, falls noch nicht geschehen, eine 1
      (eingetroffen) oder 0 (nicht eingetroffen) oder < 0 (Fehler)
      eingetragen. Es mu sichergestellt werden, da kein IOcomplete und
      kein Schreibzugriff auf unsel anschlieend noch erfolgen kann. Ein
      Wert ungleich 1, aber gr”er als Null wird immer als Adresse der
      Aufr„umroutine interpretiert, diese mu noch aufgerufen werden, wenn
      der Interrupt nicht eingetroffen ist. Falls der Interrupt z.B. einen
      Wert von 2L eintrge, ginge der Kernel davon aus, da der Interrupt
      nicht eingetreten ist und immer noch die Adresse der Aufr„umroutine in
      der MAGX_UNSEL-Struktur steht. Ein Sprung nach Adresse 2 ist dann aber
      schnell ziemlich t”dlich.
!end_enumerate

Die DOS-Funktionen Finstat() und Foutstat() versuchen zun„chst, den Aufruf
auf (!nolink [Fcntl]) ((!nolink [FIONREAD]) bzw. (!nolink [FIONWRITE]))
zurckzufhren. Wenn diese Subfunktion
von dev_ioctl nicht existiert (der Dateitreiber mu EINVFN liefern!), wird
dev_stat aufgerufen. In diesem Fall kann die Aussage getroffen werden
"Zeichen liegt an" (Wert == 1) bzw. "kein Zeichen liegt an" (Wert == 0).

Der vom DOS_XFS installierte Dateitreiber leitet den Aufruf direkt an den
(!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter.

!item [Gruppe:]
(!link [Ger„tetreiber][Der Ger„tetreiber (MX_DEV)])

!item [Querverweis:]
---

(!ende_liste)
!end_node



!begin_node dev_write

Auf Datei <file> werden <count> Bytes aus dem Puffer <buffer> geschrieben.
Die Anzahl der tats„chlich geschriebenen Zeichen wird zurckgegeben. Der vom
DOS_XFS installierte Dateitreiber aktualisiert Zeit und Datum der Datei und
leitet dann den Aufruf an den (!link [MX_DDEV][Der Ger„tetreiber (MX_DDEV)])-Untertreiber weiter.

(!B)Parameter-šbergabe:(!b)
!begin_table [r l l]
a0 !! = !! (!link [FD][Der Datei-Deskriptor (FD)]) *file
d0 !! = !! long count
a1 !! = !! char *buffer
-> d0 !! = !! long amount
!end_table
!end_node
!end_node
!end_node



!begin_node Installation eines XFS
!ignore_index
!label XFS, Installation eines
Ein XFS ist einfach ein Programm, das den Treiber installiert und sich
resident beendet. Die Installation erfolgt per kernel = (!B)Dcntl
(KER_INSTXFS, NULL, &myxfs)(!b).

Man erh„lt einen Zeiger auf wichtige Kernelfunktionen oder einen Fehlercode
zurck. Die Kernelfunktionen kann man auch unabh„ngig von der Installation
eines XFS erfragen, und zwar per kernel = (!B)Dcntl(KER_GETINFO, NULL,
 NULL)(!b).

Die Deinstallation eines XFS ist (!I)nicht(!i) vorgesehen.
!end_node



!begin_node Kernelfunktionen fr ein XFS
!label XFS, Kernelfunktionen fr ein

(!nolink [MagiC]) stellt den installierten XFSs, DFSs oder Ger„tetreibern einige
Kernelinformationen sowie -funktionen zur Verfgung. Bei den
Kernelfunktionen gilt dieselbe Registerkonvention wie fr die
XFS-Funktionen, d.h. d0-d2 und a0-a2 k”nnen zerst”rt werden. Einen Zeiger
auf die Struktur, die die Kernelfunktionen enth„lt, bekommt man ber

!begin_verbatim
     kernel = Dcntl (KER_INSTXFS, NULL, &myxfs);   oder
     kernel = Dcntl (KER_GETINFO, NULL, NULL);
!end_verbatim

Im ersten Fall wird ein XFS installiert, im zweiten Fall bekommt man nur
die Kernelstruktur (etwa fr ein DFS oder einen Ger„tetreiber). Der Aufbau
der Kernelstruktur im einzelnen:

!label MX_KERNEL
!begin_verbatim
typedef struct
{
  WORD   mxk_version;
  VOID (*mxk_fast_clrmem)      ( void *von, void *bis );
  BYTE (*mxk_toupper)          ( char c );
  VOID (*mxk__sprintf)         ( char *dest, char *source, LONG *p );
  VOID  *mxk_mxk_act_pd;
  APPL  *mxk_act_appl;
  APPL  *mxk_keyb_app;
  WORD  *mxk_pe_slice;
  WORD  *mxk_pe_timer;
  VOID (*mxk_appl_yield)       ( void );
  VOID (*mxk_appl_suspend)     ( void );
  VOID (*mxk_appl_begcritic)   ( void );
  VOID (*mxk_appl_endcritic)   ( void );
  LONG (*mxk_evnt_IO)          ( LONG ticks_50hz, void *unsel );
  VOID (*mxk_evnt_mIO)         ( LONG ticks_50hz, void *unsel, WORD cnt );
  VOID (*mxk_evnt_emIO)        ( APPL *ap );
  VOID (*mxk_appl_IOcomplete)  ( APPL *ap );
  LONG (*mxk_evnt_sem)         ( WORD mode, void *sem, LONG timeout );
  VOID (*mxk_Pfree)            ( void *pd );
  WORD   mxk_int_msize;
  VOID  *mxk_int_malloc        ( void );
  VOID   mxk_int_mfree         ( void *memblk );
  VOID   mxk_resv_intmem       ( void *mem, LONG bytes );
  LONG   mxk_diskchange        ( WORD drv );
  LONG   mxk_DMD_rdevinit      ( DMD *dmd );
  LONG   mxk_proc_info         ( WORD code, PD *pd );
  LONG   mxk_mxalloc           ( d0 = LONG amount, d1 = WORD mode, a0 = PD *pd );
  LONG   mxk_mfree             ( a0 = void *block );
  LONG   mxk_mshrink           ( d0 = LONG newlen, a0 = void *block );
} MX_KERNEL;
!end_verbatim

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])



!begin_node mxk_version

Das ist die Versionsnummer, die z.Zt. einfach 3 ist. Bei jeder nderung der
Kernelstruktur wird die Versionsnummer hochgesetzt, so da sich Programme
entsprechend anpassen k”nnen.
!end_node



!begin_node mxk_fast_clrmem

Eine schnelle Speicherl”schroutine, die den Speicher von <von> bis <bis>
(ausschlielich) auf 0 setzt.

(!B)Dabei gilt:(!b)
!begin_table [r l l]
a0 !! = !! void *von
a1 !! = !! void *bis
!end_table
!end_node



!begin_node mxk_toupper

Wandelt das Zeichen <c> unter Bercksichtigung der nationalen Sonderzeichen
in Groschrift um.

(!B)Dabei gilt:(!b)
!begin_table [r l l]
d0 !! = !! char c
!end_table
!end_node



!begin_node mxk__sprintf

Eine Funktion, die ihre Argumente auf dem Stack erwartet. šbergeben wird die
Ziel-Zeichenkette <dest>, die Schablone <source> und die einzutragenden
Werte p[]. Die Langworte werden je nach Formatieranweisung als "unsigned
int" (%W), "signed long" (%L) oder Zeichenkette (%S) interpretiert.

Bei %W wird das weiter unten im Speicher liegende Wort verwendet, die Folge
%% fgt ein Prozentzeichen ein.
!end_node



!begin_node mxk_act_pd
Der Zeiger auf die aktuelle (!B)Basepage(!b), die Adresse l„t sich auch
ber den Systemheader oder die DOS-Variablen ermitteln.
!end_node



!begin_node mxk_act_appl

Der Zeiger auf die (!B)aktuelle Applikation(!b) (d.h. die laufende Task).
Der Aufbau der Struktur ist (!I)nicht(!i) dokumentiert, der Zeiger wird
wegen des schnelleren Zugriffs anstelle der ap_id als Deskriptor verwendet.
!end_node



!begin_node mxk_keyb_app

Die Applikation, die z.Zt. die Tastatur besitzt. Der Zeiger kann z.B. von
Ger„tetreibern verwendet werden, die die tastaturbesitzende Applikation
anders behandeln mssen.
!end_node



!begin_node mxk_pe_slice

Fr das pr„emptive Multitasking. Wenn <*pe_slice> == -1 ist, ist das
pr„emptive Multitasking abgeschaltet, und Diskzugriffe werden (!I)nicht(!i)
unterbrochen.
!end_node



!begin_node mxk_pe_timer

Fr das pr„emptive Multitasking. Wenn <*pe_slice> == -1 ist, ist das
pr„emptive Multitasking abgeschaltet, und Diskzugriffe werden nicht
unterbrochen.
!end_node



!begin_node mxk_appl_yield

Gibt Rechenzeit ans System. Wichtig fr Treiber, die nicht auf einen
Interrupt warten k”nnen und verhindern mssen, da ihr "busy waiting" das
System lahmlegt.
!end_node



!begin_node mxk_appl_suspend

Arbeitet wie (!B)appl_yield()(!b), gibt jedoch der Applikation eine
geringere Priorit„t, etwa als Hintergrundproze.
!end_node



!begin_node mxk_appl_begcritic

Die aktuelle Applikation tritt in eine kritische Phase und darf nicht
terminiert werden.
!end_node



!begin_node mxk_appl_endcritic

Ende der kritischen Phase. Falls zwischenzeitlich der Befehl zur
Terminierung eingegangen ist, wird das Programm terminiert.
!end_node



!begin_node mxk_evnt_IO

(!begin_liste) [Beschreibung]

!item [Name:]
¯evnt_IO®

!item [Parameter:]
!begin_xlist !short [a0 =]
!item [d0 =]
long ticks_50hz
!item [a0 =]
void *unsel
!end_xlist

!item [Beschreibung:]
evnt_IO erm”glicht es, auf EIN externes Ereignis zu warten. Als externes
Ereignis kommt entweder ein Interrupt oder eine andere Applikation (die etwa
zum Aufwecken in eine Pipe schreibt) in Frage. Die Funktion wird zum
Erstellen von Ger„tetreibern verwendet:

(!B)Vorgehensweise (siehe DEV_LPT1 als Beispiel):(!b)

!begin_enumerate !short
!item Interrupts sperren
!item Abfrage, ob das Ereignis (im Fall DEV_LPT1 lautet das Ereignis:
      "centronics busy off" eingetroffen ist.
!item Wenn ja, Interrupts freigeben und Aktion durchfhren (im Fall
      DEV_LPT1: Zeichen drucken)
!item Wenn nein, Interruptroutine aufsetzen (im Fall DEV_LPT1: MFP-I0, d.h.
      Centronics Busy Interrupt aktivieren) und diesem die aktuelle
      Applikation (act_appl) sowie eine Langwortadresse zug„nglich machen,
      in die die Interruptroutine Rckmeldungen schreiben kann. Diese
      Adresse ist mit der Adresse einer Routine zu beschreiben, die den
      Interrupt wieder abmeldet, dahinter k”nnen nach eigenen Anforderungen
      z.B. noch weitere Daten folgen. Die Unselect-Routine bekommt sp„ter
      einen Zeiger auf alle diese Daten und kann z.B. die optionalen
      Parameter auswerten. Der ganze Mechanismus ist notwendig, um ein
      korrektes Deinitialisieren des Interrupts in jedem Fall zu
      garantieren.
!item Interrupts freigeben
!item evnt_IO aufrufen. In d0.w die Anzahl der 50Hz- Ticks fr den Timeout
      angeben, 0 heit "kein Timeout". In a0 die Adresse des Langworts
      angeben, in dem die Adresse der Aufr„umroutine steht, die den
      Interrupt wieder abmeldet (dahinter folgen optional weitere Parameter,
      falls die Unselect-Routine diese versteht). Im Fall des Einbindens
      von Ger„tetreibern fr Fselect() ist nur ein optionales Langwort
      m”glich.

      Die Interruptroutine schreibt bei Eintreffen des Interrupts einen
      Status < 0L (Fehler) oder 1L (OK) statt der Deinitialisierungsroutine
      in das Statuslangwort (in dem vorher ihre eigene Startadresse stand).
      Anschlieend deinstalliert sich die Routine selbst bzw. stellt sicher
      da bei folgenden Interrupts keine Aktionen ausgefhrt werden.
      Schlielich weckt die Interruptroutine die dem Interrupt zugeordnete
      Applikation auf, und zwar ber den Aufruf appl_IOcomplete() mit der
      Applikation als Parameter.
!item evnt_IO() liefert als Rckgabewert 0L (Timeout, der Interrupt ist
      nicht eingetroffen) oder < 0 (der Interrupt hat Fehlermcode ins
      Statuslangwort geschrieben) oder 1L (der Interrupt hat eine 1L ins
      Statuslangwort geschrieben). Eine Deinstallierung des Interrupts ist
      nicht mehr notwendig, dies hat der Kernel erledigt, falls die
      Interruptroutine dies nicht selbst beim Eintreffen des Interrupts
      getan hat.
!end_enumerate

!item [Gruppe:]
(!link [Kernelfunktionen][Kernelfunktionen fr ein XFS])

!item [Querverweis:]
---

(!ende_liste)
!end_node



!begin_node mxk_evnt_mIO

(!begin_liste) [Beschreibung]

!item [Name:]
¯evnt_mIO®

!item [Parameter:]
!begin_xlist !short [a0 =]
!item [d0 =]
long ticks_50hz
!item [a0 =]
void *unsel
!item [d1 =]
int cnt
!end_xlist
bzw.
!begin_xlist !short [a0 =]
!item [a0 =]
APPL *ap
!end_xlist

!item [Beschreibung:]
evnt_mIO() erm”glicht es, auf MEHRERE externe Ereignisse zu warten, z.B.
wird diese Funktion von Fselect verwendet (mehrere Dateien!).

(!B)Vorgehensweise:(!b)

!begin_enumerate !short
!item Fr n Ereignisse eine Langwort-Tabelle der L„nge 2*n anlegen.
!item Fr jedes Ereignis die Aufr„umroutine (unselect-Routine) eintragen,
      (dahinter folgt ein optionaler Langwortparameter) und den Interrupt
      aufsetzen. Die Reihenfolge ist wichtig, es mu verhindert werden, da
      die unselect-Adresse den Rckgabewert des bereits eingetroffenen
      Interrupts berschreibt, ggf. Interrupts sperren.
!item evnt_mIO aufrufen. Die Parameter sind wie bei evnt_IO, in d1.w wird
      aber die Anzahl der Ereignisse bergeben, a0 ist der Tabellenanfang.
!item evnt_mIO() liefert keinen Rckgabewert. Die Tabelle mu durchsucht und
      die Interrupts deinstalliert werden (z.B. die unselect-Routinen
      aufrufen), dabei kann berprft werden, welche Interrupts bereits
      eingetroffen sind.
!item evnt_emIO mit der aktuellen Applikation aufrufen. Dieser Aufruf stellt
      sicher, da nach Deinstallieren aller Interrupts deren jetzt nutzlose
      (!nolink [Nachrichten]) an die Applikation gel”scht werden.
!end_enumerate

Auf die Ereignisse evnt_(m)IO wartende Applikationen erscheinen im
Programm-Manager als wartend auf "io" (Input/Output) oder "io ti"
(Input/Output mit Timeout).

!item [Gruppe:]
(!link [Kernelfunktionen][Kernelfunktionen fr ein XFS])

!item [Querverweis:]
---

(!ende_liste)
!end_node



!begin_node mxk_appl_IOcomplete

Weckt eine Applikation auf, die auf evnt_(m)IO wartet.

(!B)Dabei gilt:(!b)
!begin_table [r l l]
a0 !! = !! APPL *ap
!end_table
!end_node



!begin_node mxk_evnt_sem

(!begin_liste) [Beschreibung]

!item [Name:]
¯evnt_sem®

!item [Parameter:]
!begin_xlist !short [a0 =]
!item [d0 =]
int mode
!item [a0 =]
void *sem
!item [d1 =]
long timeout
!end_xlist

!item [Beschreibung:]
Fr mode sind folgende Unterfunktionen m”glich:

!begin_xlist !short [5 SEMCREATE]
!item [0 SEM_FREE]
Semaphore freigeben (ohne Taskwechsel!)
!item [1 SEM_SET]
Semaphore setzen, ggf. warten
!item [2 SEM_TEST]
Eigner der Semaphore ermitteln (ggf. NULL)
!item [3 SEM_CSET]
Semaphore setzen, falls nicht schon gesetzt
!item [4 SEM_GET]
Semaphore ermitteln, falls Name bekannt ist.
!item [5 SEM_CREATE]
Semaphore erstellen, d.h. neue einrichten
!item [6 SEM_DEL]
Semaphore entfernen
!end_xlist

SEM_SET und SEM_CSET sind die einzigen Unterfunktionen, die einen
Taskwechsel ausl”sen k”nnen.

Im Gegensatz zu wind_update() kann mit diesen Aufrufen das Setzen und
Freigeben von Semaphoren nicht geschachtelt werden. Versucht man, eine
bereits reservierte Semaphore nochmal zu reservieren, gibt es einen
Fehlercode.

Beim Freigeben der Semaphore wird kein Taskwechsel durchgefhrt, d.h. die
Semaphore kann zwar ggf. jetzt einer anderen Applikation geh”ren, die den
Status "ready" hat, aber sie hat noch keine Rechenzeit bekommen. Wenn die
Situation unkritisch ist, sollte in jedem Fall anschlieend ein appl_yield()
durchgefhrt werden.

Die Bildschirmsemaphore hat den Namen _SCR und darf mit evnt_sem() nur mit
der Unterfunktion SEM_TEST behandelt werden.

SEM_CREATE setzt den Erzeuger nicht automatisch als Eigner. Dies ist nicht
notwendig, weil kein Taskwechsel stattgefunden hat. Also kann bedenkenlos
ein SEM_SET anschlieend durchgefhrt werden.

SEM_DEL verlangt, da der L”scher auch der Eigner ist. Beim L”schen werden
alle wartenden Applikationen freigegeben, sie erhalten, wenn sie per
evnt_sem(SEM_SET, ..) warten, eine -2 als Rckgabewert. Wer
System-Semaphoren (solche, deren Namen mit '_' beginnen) l”scht, ist selbst
schuld.

!item [Gruppe:]
(!link [Kernelfunktionen][Kernelfunktionen fr ein XFS])

!item [Querverweis:]
---

(!ende_liste)
!end_node



!begin_node SEM_FREE

(!B)Parameter:(!b)
!begin_xlist !short [a0 =]
!item [a0 =]
Zeiger auf Semaphore
!begin_xlist !short [-> -1]
!item [-> 0]
OK
!item [-> -1]
Semaphore unbenutzt oder von anderer APP benutzt.
!end_xlist
!end_xlist
!end_node



!begin_node SEM_SET

(!B)Parameter:(!b)
!begin_xlist !short [a0 =]
!item [a0 =]
Zeiger auf Semaphore
!item [d1 =]
Timeout in 50Hz- Ticks
!begin_xlist !short [-> -1]
!item [-> 0]
OK
!item [-> 1]
Timeout
!item [-> -1]
Semaphore war schon von mir gesetzt.
!item [-> -2]
Semaphore wurde inzwischen entfernt.
!end_xlist
!end_xlist
!end_node



!begin_node SEM_TEST

(!B)Parameter:(!b)
!begin_xlist !short [ao =]
!item [a0 =]
Zeiger auf Semaphore
!begin_xlist !short [-> >0]
!item [-> >0]
Eigner
!item [->  0]
nicht benutzt
!end_xlist
!end_xlist
!end_node


!begin_node SEM_CSET

(!B)Parameter:(!b)
!begin_xlist !short [a0 =]
!item [a0 =]
Zeiger auf Semaphore
!item [d1 =]
Timeout in 50Hz- Ticks
!begin_xlist !short [-> -1]
!item [->  0]
OK
!item [->  1]
Semaphore von anderer APPL gesetzt.
!item [->  -1]
Semaphore war schon von mir gesetzt.
!end_xlist
!end_xlist
!end_node



!begin_node SEM_GET

(!B)Parameter:(!b)
!begin_xlist !short [a0 =]
!item [d1 =]
Name der Semaphore
!begin_xlist !short [-> -1]
!item [-> >0]
Zeiger auf Semaphore.
!item [-> -1]
Semaphore nicht gefunden.
!end_xlist
!end_xlist
!end_node



!begin_node SEM_CREATE

(!B)Parameter:(!b)
!begin_xlist !short [a0 =]
!item [a0 =]
Zeiger auf Semaphore (32 Bytes auf gerader Adresse)
!item [d1 =]
Name void
!end_xlist
!end_node



!begin_node SEM_DEL

(!B)Parameter:(!b)
!begin_xlist !short [a0 =]
!item [a0 =]
Zeiger auf Semaphore
!begin_xlist !short [-> -1]
!item [->  0]
OK
!item [-> -1]
Semaphore ungltig
!end_xlist
!end_xlist
!end_node



!begin_node mxk_Pfree

Gibt den Speicher fr einen Proze frei, der mit (!B)Ptermres(!b) beendet~
wurde. Dies ist notwendig, um einen Ger„tetreiber korrekt zu entfernen.

(!B)Dabei gilt:(!b)
!begin_table [r l l]
a0 !! = !! void *pd
!end_table
!end_node



!begin_node mxk_int_msize

Die L„nge eines Speicherblocks der internen (Kernel-) (!nolink [Speicherverwaltung]).
!end_node



!begin_node mxk_int_malloc

Alloziert einen internen Speicherblock. Ist kein Speicher mehr frei, wird
zun„chst eine globale (!B)"garbage collection"(!b) durchgefhrt (siehe
Beschreibung des XFS), dann bei Mierfolg das System angehalten. Interne
Speicherbl”cke drfen nur in kleinen Mengen angefordert werden, sonst erh„lt
man sehr bald ein "Out of internal memory", und das System steht.
!end_node



!begin_node mxk_int_mfree

Gibt einen Block wieder frei.

(!B)Dabei gilt:(!b)
!begin_table [r l l]
a0 !! = !! void *memblk
!end_table
!end_node



!begin_node mxk_resv_intmem

Erweitert den Kernelspeicher. Es ist (!I)keine(!i) M”glichkeit vorgesehen,
den Speicher zurckzufordern. Da der Kernel nur zur Bootzeit ausreichend
internen Speicher fr die FAT-Laufwerke anfordert, kann es fr ein XFS
notwendig sein, beim Start mit dieser Funktion weiteren Kernelspeicher
zu reservieren.

(!B)Dabei gilt:(!b)
!begin_table [r l l]
a0 !! = !! void *mem
d0 !! = !! long bytes
!end_table
!end_node



!begin_node mxk_diskchange

Muss aufgerufen werden, wenn ein XFS- oder DFS-Treiber einen
(!B)Diskwechsel(!b) erkannt hat. Der XFS-Treiber gibt seine Dateien und
Strukturen frei, anschlieend der Kernel.

Rckgabe:

!begin_xlist !short [EDRIVE]
!item [EDRIVE]
Laufwerk ungltig
!item [E_CHNG]
Laufwerk mit neuer Disk gltig
!end_xlist

(!B)Dabei gilt:(!b)
!begin_table [r l l]
d0 !! = !! int drv
!end_table
!end_node



!begin_node mxk_DMD_rdevinit
Ab Kernelversion 1

Initialisiert die Felder (!I)d_driver(!i) und (!I)d_devcode(!i) des DMD und
benutzt dazu das Feld (!I)d_biosdev(!i). Wird fr Diskwechselmechanismen
ben”tigt.

(!B)Dabei gilt:(!b)
!begin_table [r l l]
a0 !! = !! DMD *dmd
!end_table
!end_node



!begin_node mxk_proc_info
Ab Kernelversion 2

Ermittelt Daten fr den aktuellen Proze.

!begin_xlist !short [a0 = 0:]
!item [d0 = 0:]
0: h”chste verfgbare Unterfunktionsnummer,
!item [~]
1: Domain
!item [~]
2: Process-ID.
!end_xlist

(!B)Dabei gilt:(!b)
!begin_table [r l l]
d0 !! = !! WORD code
a0 !! = !! PD *pd
!end_table
!end_node

!begin_node mxk_mxalloc
Ab Kernelversion 4

Erm”glicht eine schnelle Speicherallozierung, z.B. fr ein RAMDisk-XFS,
ohne ber den Trap gehen zu mssen.

<pd> gibt den Proze an, der als Eigner des neuen Blocks eingetragen
wird, daher sollte normalerweise die Basepage des XFS-Treibers bergeben
werden.

!end_node

!begin_node mxk_mfree
Ab Kernelversion 4

Gibt Speicher wieder frei.

!end_node

!begin_node mshrink
Ab Kernelversion 4

ndert die Gr”e eines Speicherblocks.

!end_node

!end_node



!begin_node Symbolische Links und das XFS-Konzept

Symbolische Links (in der Benutzerdokumentation in šbereinstimmung mit der
Macintosh Nomenklatur auch als (!I)Aliase(!i) bezeichnet) sind Dateien, die
in irgendeiner Form besonders gekennzeichnet sind und statt Daten einen Pfad
enthalten, der wiederum auf eine andere Datei zeigt. Ein derartiger Pfad
kann auch auf eine nicht (mehr) bzw. noch nicht existierende Datei zeigen.
Pfade k”nnen (!I)absolut(!i) oder (!I)relativ(!i) sein, wobei letztere das
Verzeichnis als Bezug haben, in dem der Link liegt.

(!B)Im Speicher werden derartige Links als Strukturen verwaltet:(!b)

!begin_verbatim
{
   WORD n;         /* auf gerade Anzahl aufgerundet, inkl. EOS */
   char path[n];   /* Pfad mit EOS am Ende */
}
!end_verbatim

(!B)Hinweis:(!b) Einige XFS-Funktionen mssen, wenn sie auf einen Symlink
stoen, diesen dereferenzieren, d.h. sie liefern dem Kernel in d0 den
Fehlercode ELINK und in a0 einen Zeiger auf eine Struktur der obigen Form.
Der Kernel sorgt dann fr die Dereferenzierung und die Begrenzung der
maximalen Verschachtelung (falls der Symlink wieder auf einen solchen
zeigt). Die XFS-Funktionen, die ELINK liefern drfen, sind:

xfs_path2DD, xfs_sfirst, xfs_snext, xfs_fopen, xfs_xattr, xfs_attrib.

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])
!end_node



!begin_node MX_DOSLIMITS

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    UWORD version;        /* Versionsnummer               */
    UWORD num_drives;     /* max. Anzahl Laufwerke        */
    ULONG max_secsizb;    /* max. Sektorgr”e in Bytes    */
    UWORD min_nfats;      /* min. Anzahl FATs             */
    UWORD max_nfats;      /* max. Anzahl FATs             */
    ULONG min_nclsiz;     /* min. Anzahl Sektoren/Cluster */
    ULONG max_nclsiz;     /* max. Anzahl Sektoren/Cluster */
    ULONG max_ncl;        /* max. Anzahl Cluster          */
    ULONG max_nsec;       /* max. Anzahl Sektoren         */
} MX_DOSLIMITS;
!end_verbatim

Querverweis:
Dcntl ~  KER_DOSLIMITS ~  (!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])
!end_node


!begin_node XFS-Strukturen

!subsubtoc [all]

!begin_node dev_descr

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct dev_descr
{
    DEVDRV  *driver;
    SHORT   dinfo;
    SHORT   flags;
    struct tty *tty;
    LONG    devdrvsiz;
    LONG    reserved[4];
};
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)devdrvsiz(!i) beschreibt dabei die Gr”e
der DEVDRV-Struktur.

Querverweis: Dcntl ~ (!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])
!end_node


!begin_node DEVDRV

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct devdrv
{
    LONG (*open)      (FILEPTR *f);
    LONG (*write)     (FILEPTR *f, BYTE *buf, LONG bytes);
    LONG (*read)      (FILEPTR *f, BYTE *buf, LONG bytes);
    LONG (*lseek)     (FILEPTR *f, LONG where, WORD whence);
    LONG (*ioctl)     (FILEPTR *f, WORD mode, VOID *buf);
    LONG (*datime)    (FILEPTR *f, WORD *timeptr, WORD rwflag);
    LONG (*close)     (FILEPTR *f, WORD pid);
    LONG (*select)    (FILEPTR *f, LONG proc, WORD mode);
    VOID (*unselect)  (FILEPTR *f, LONG proc, WORD mode);
    LONG reserved[3];
} DEVDRV;
!end_verbatim

Querverweis: Dcntl ~ dev_descr ~ FILESYS ~
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])
!end_node

!begin_node FILESYS

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct filesys
{
    struct  filesys *next;
    LONG    fsflags;
    LONG    (*root)       (WORD drv, fcookie *fc);
    LONG    (*lookup)     (fcookie *dir, BYTE *name, fcookie *fc);
    LONG    (*creat)      (fcookie *dir, BYTE *name, UWORD mode,
                           WORD attrib, fcookie *fc);
    DEVDRV *(*getdev)     (fcookie *fc, LONG *devspecial);
    LONG    (*getxattr)   (fcookie *fc, XATTR *xattr);
    LONG    (*chattr)     (fcookie *fc, WORD attr);
    LONG    (*chown)      (fcookie *fc, WORD uid, WORD gid);
    LONG    (*chmode)     (fcookie *fc, UWORD mode);
    LONG    (*mkdir)      (fcookie *dir, BYTE *name, UWORD mode);
    LONG    (*rmdir)      (fcookie *dir, BYTE *name);
    LONG    (*remove)     (fcookie *dir, BYTE *name);
    LONG    (*getname)    (fcookie *relto, fcookie *dir, BYTE *pathname,
                           WORD size);
    LONG    (*rename)     (fcookie *olddir, BYTE *oldname,
                           fcookie *newdir, BYTE *newname);
    LONG    (*opendir)    (DIR *dirh, WORD tosflag);
    LONG    (*readdir)    (DIR *dirh, BYTE *nm, WORD nmlen, fcookie *fc);
    LONG    (*rewinddir)  (DIR *dirh);
    LONG    (*closedir)   (DIR *dirh);
    LONG    (*pathconf)   (fcookie *dir, WORD which);
    LONG    (*dfree)      (fcookie *dir, LONG *buf);
    LONG    (*writelabel) (fcookie *dir, BYTE *name);
    LONG    (*readlabel)  (fcookie *dir, BYTE *name, WORD namelen);
    LONG    (*symlink)    (fcookie *dir, BYTE *name, BYTE *to);
    LONG    (*readlink)   (fcookie *dir, BYTE *buf, WORD len);
    LONG    (*hardlink)   (fcookie *fromdir, BYTE *fromname,
                           fcookie *todir, BYTE *toname);
    LONG    (*fscntl)     (fcookie *dir, BYTE *name, WORD cmd, LONG arg);
    LONG    (*dskchng)    (WORD drv);
    LONG    (*release)    (fcookie *fc);
    LONG    (*dupcookie)  (fcookie *dest, fcookie *src);
} FILESYS;
!end_verbatim

Querverweis: Dcntl ~ fs_descr ~
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])
!end_node

!begin_node fs_descr

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct fs_descr
{
    FILESYS *file_system;
    SHORT   dev_no;
    LONG    flags;
    LONG    reserved[4];
};
!end_verbatim

Querverweis: Dcntl ~ (!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC])
!end_node

!end_node

!end_node
