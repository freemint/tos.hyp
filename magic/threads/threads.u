!iflang [english]

!begin_node Threads in MagiC

Das Konzept der Threads erm”glicht Quasi-Parallelit„t (!I)innerhalb(!i)
einer Anwendung, und ist unter Betriebssystemen wie OS/2, MacOS oder UNIX
schon l„nger bekannt. Im Gegensatz zum normalen Multitasking k”nnen dabei
(!I)mehrere(!i) Threads zu einem Programm (bzw. Prozess) geh”ren. In MagiC
werden Threads ab der Version 4.50 (01.04.96) untersttzt, und sind als
Applikation implementiert, d.h. ein Thread besitzt unter (!nolink [MagiC]) eine eigene
Applikations-ID. Das Konzept lehnt sich dabei an das von Sun Solaris 2.x an.

Dieser Abschnitt beschreibt die folgenden Punkte:

!begin_itemize !short
!item (!link [Erstellen eines Threads][Threads, Erzeugen von])
!item (!link [Beenden eines Threads] [Threads, Beenden von])
!item (!link [Signale und Threads] [Threads und Signale])
!item Threads und AES-Aufrufe
!item Threads und VDI-Aufrufe
!item (!link [Verteilung der Resourcen] [Verteilung der Resourcen bei Threads])
!end_itemize

See Also: GEMDOS ~
Prozessfunktionen  ~
(!link [Example][Threads, Example for])


!begin_node Threads und Signale

If a process is paused with the signal SIGSTOP or similar then all 
threads are paused as well; with SIGCONT all threads are reawakened.
When terminating a program with SIGTERM, SIGKILL etc. all threads are 
terminated too.

The signal handling will be taken over entirely by the main thread, 
i.e. the one that was started with Pexec. This means that during the 
processing of a signal handler only the main thread will be paused, and 
at Psigreturn one will jump back to it.

If more than one thread is mucking about with the signal mask then 
oddities can occur if the old signal mask is not restored in the 
correct order. For instance:

!begin_verbatim
thread A rescues the old mask
thread A alters the mask
thread B rescues the old mask
thread A restores the old mask
thread B restores the old mask
!end_verbatim

alters the signal mask in an unwaned manner. A clean solution would be 
to give each thread its (!I)own(!i) signal mask and OR-combine all masks of all 
threads for the (!I)effective(!i) signal mask. If this becomes necessary I 
will alter the kernel appropriately.

See Also: Threads in MagiC ~   Signale ~  shel_write ~
Prozessfunktionen
!end_node



!begin_node Threads und AES-Aufrufe

Bei der Entwicklung von eigenen Programmen muss unbedingt darauf geachtet
werden, da eine Multithread-sichere Bibliothek verwendet wird. Die
Standardbibliotheken von (!I)Pure-C(!i) etwa sind in weiten Teilen
diesbezglich unbrauchbar. Es muss inbesondere darauf geachtet werden, da
jeder Thread sein eigenes global-Feld erh„lt. Betroffen sind daher die
folgenden Funktionen:

!begin_itemize !short
!item appl_init
!item rsrc_free
!item rsrc_gaddr
!item rsrc_load
!item rsrc_rcfix
!item rsrc_saddr
!end_itemize

(!B)Hinweis:(!b) Die original MagiC Dokumentation enth„lt Beispiele fr
Multithread f„hige AES-Funktionen, an deren Aufbau man sich orientieren
kann. Beachtet werden sollte noch, da der Name eines Threads auf (!nolink [AES-Ebene])
(!I)ungltig(!i) ist, d.h. er kann (!I)nicht(!i) per appl_find oder
appl_search gefunden werden.

See Also: (!nl)
Threads und VDI-Aufrufe ~  Prozessfunktionen ~
AES-Bindings       ~       Signale
!end_node


!include magic\threads\vdi.u


!begin_node Verteilung der Resourcen bei Threads

In MagiC laufen Threads auf demselben Prozess, besitzen jedoch eine eigene
Applikations-ID, und sind somit eine selbstst„ndige Task. Die folgende
Tabelle gibt eine šbersicht ber die Resourcen, die ein Thread selbst
besitzt, bzw. vom Hauptprogramm benutzt.

!begin_table [l l]
Threads besitzen !! vom Hauptprogramm wird benutzt
!hline
ù user stack               !! ù file handles
ù supervisor stack         !! ù basepage
ù Applikations-ID         !! ù memory blocks
ù Resource-Dateien        !! ù current directories, current drive
ù menu bar               !! ù process ID (PID)
ù desktop background     !! ù domain (MiNT/TOS)
ù window                 !! ù umask
ù message queue           !! ù current (!nolink [DTA])
ù mouse pointer              !! ù malloc-flags
ù possibly VT52 window (selectable) !! ù command line and environment
ù etv_term vector         !! ù signal handler and -mask
ù semaphores              !! ù possibly VT52 window (selectable)
!end_table

(!B)Hinweis:(!b) Wie man sieht erh„lt ein Thread damit z.B. eine
(!I)eigene(!i) AP_TERM Nachricht. Bei der Verwendung von Resource-Dateien
ist darauf zu achten, da ggfs. ein eigenes global-Feld benutzt wird.

Zu beachten ist ferner, da Speicher, den der Thread alloziert, dem Prozess
geh”rt, und bei Beendigung des Threads (!I)nicht(!i) automatisch freigegeben
wird; gleiches gilt fr ge”ffnete Dateien, die erst bei der
Programmbeendigung geschlossen werden. Dies muss deshalb ggfs. vom Thread
bernommen werden.

(!B)Achtung:(!b) Es ist unbedingt zu beachten, da

!begin_itemize
!item keine DTA verwendet wird, da die Funktionen Fsfirst, Fsnext, Fsetdta
      und Fgetdta (!I)nicht(!i) Multithread-sicher sind.
!item Zugriffe auf Dateihandles mit geeigneten Methoden synchronisiert
      werden. Es drfen nicht zwei Threads gleichzeitig auf dieselbe Datei
      zugreifen.
!end_itemize

Die Funktion Psemaphore ist bereits fr Threads ausgelegt, und kann sowohl
zur Synchronisation zwischen Prozessen als auch zwischen mehreren Threads
eines Prozesses verwendet werden. Beim Beenden eines Threads werden alle von
diesem blockierten Semaphoren automatisch freigegeben.

Nach M”glichkeit sollte z.Zt. nur der Haupt-Thread ein Pexec ausfhren,
nicht jedoch nebenl„ufige Threads. Theoretisch ist dies jedoch erlaubt, und
zwar dann, wenn kein anderer Thread oder der Haupt-Thread (!nolink [Pexec]) aufgerufen
hat, und der Haupt-Thread sich nicht beendet.

Das Problem liegt ganz einfach darin, da z.Zt. Rcksprungadressen bei (!nolink [Pexec])
nicht im laufenden Prozess sondern im Parent abgelegt werden, und der Parent
des vom Thread gestarteten Prozesses ungltig wird.

Falls ein Thread die Funktion Pterm ausfhrt, so wird z.Zt. nur dieser
Thread beendet. Angemerkt werden soll auch noch, da ein Thread andere
Programme per shel_write (parallel) starten, und auf deren Beendigung warten
kann.

See Also:
Threads und AES-Aufrufe  ~ Threads und VDI-Aufrufe ~
Prozessfunktionen        ~ GEMDOS
!end_node

!include magic\threads\example.ui

!end_node

!else

!begin_node Threads in MagiC

Das Konzept der Threads erm”glicht Quasi-Parallelit„t (!I)innerhalb(!i)
einer Anwendung, und ist unter Betriebssystemen wie OS/2, MacOS oder UNIX
schon l„nger bekannt. Im Gegensatz zum normalen Multitasking k”nnen dabei
(!I)mehrere(!i) Threads zu einem Programm (bzw. Prozess) geh”ren. In MagiC
werden Threads ab der Version 4.50 (01.04.96) untersttzt, und sind als
Applikation implementiert, d.h. ein Thread besitzt unter (!nolink [MagiC]) eine eigene
Applikations-ID. Das Konzept lehnt sich dabei an das von Sun Solaris 2.x an.

Dieser Abschnitt beschreibt die folgenden Punkte:

!begin_itemize !short
!item (!link [Erstellen eines Threads][Threads, Erzeugen von])
!item (!link [Beenden eines Threads] [Threads, Beenden von])
!item (!link [Signale und Threads] [Threads und Signale])
!item Threads und AES-Aufrufe
!item Threads und VDI-Aufrufe
!item (!link [Verteilung der Resourcen] [Verteilung der Resourcen bei Threads])
!end_itemize

Querverweis: GEMDOS ~
Prozessfunktionen  ~
(!link [Beispiel-Code][Threads, Beispiel-Code zu])


!begin_node Threads und Signale

Beim Zusammenspiel von (!nolink [Threads]) und Signalen ist folgendes zu beachten:
wird ein Prozess (z.B. per (!nolink [SIGSTOP])) angehalten, so werden auch alle
zugeh”rigen Threads angehalten; durch das (!nolink [SIGCONT])-Signal k”nnen alle Threads
wieder aufgeweckt werden. Falls ein Prozess per SIGTERM oder SIGKILL beendet
wird, werden auch alle betroffenen Threads automatisch terminiert.

Die Signalbehandlung wird immer nur vom Haupt-Thread bernommen; dies ist
derjenige, der mit Pexec gestartet worden ist. W„hrend der Abarbeitung eines
Signalhandlers wird deshalb auch nur der Haupt-Thread angehalten, und bei
einem Aufruf von Psigreturn in diesen zurckgesprungen.

(!B)Achtung:(!b) Falls mehr als ein Thread die Signalmaske manipuliert, kann
es zu Unstimmigkeiten kommen, falls die Maske nicht in der richtigen
Reihenfolge wieder zurckgesetzt wird. Beispiel:

!begin_verbatim
Thread-A rettet alte Maske
Thread-A „ndert Maske
Thread-B rettet alte Maske
Thread-A restauriert alte Maske
Thread-B restauriert alte Maske
!end_verbatim

In diesem Fall wird die Signalmaske ungewollt ver„ndert. Eine L”sung dieses
Problems besteht darin, jedem Thread eine (!I)eigene(!i) Signalmaske
zuzuteilen, und als (!I)effektive(!i) Signalmaske die Masken aller Threads
durch eine Oder-Verknpfung zu verbinden. M”glicherweise wird das in einer
sp„teren Version von MagiC tats„chlich der Fall sein.

Querverweis: Threads in MagiC ~   Signale ~  shel_write ~
Prozessfunktionen
!end_node



!begin_node Threads und AES-Aufrufe

Bei der Entwicklung von eigenen Programmen muss unbedingt darauf geachtet
werden, da eine Multithread-sichere Bibliothek verwendet wird. Die
Standardbibliotheken von (!I)Pure-C(!i) etwa sind in weiten Teilen
diesbezglich unbrauchbar. Es muss inbesondere darauf geachtet werden, da
jeder Thread sein eigenes global-Feld erh„lt. Betroffen sind daher die
folgenden Funktionen:

!begin_itemize !short
!item appl_init
!item rsrc_free
!item rsrc_gaddr
!item rsrc_load
!item rsrc_rcfix
!item rsrc_saddr
!end_itemize

(!B)Hinweis:(!b) Die original MagiC Dokumentation enth„lt Beispiele fr
Multithread f„hige AES-Funktionen, an deren Aufbau man sich orientieren
kann. Beachtet werden sollte noch, da der Name eines Threads auf (!nolink [AES-Ebene])
(!I)ungltig(!i) ist, d.h. er kann (!I)nicht(!i) per appl_find oder
appl_search gefunden werden.

Querverweis: (!nl)
Threads und VDI-Aufrufe ~  Prozessfunktionen ~
AES-Bindings       ~       Signale
!end_node


!include magic\threads\vdi.u


!begin_node Verteilung der Resourcen bei Threads

In MagiC laufen Threads auf demselben Prozess, besitzen jedoch eine eigene
Applikations-ID, und sind somit eine selbstst„ndige Task. Die folgende
Tabelle gibt eine šbersicht ber die Resourcen, die ein Thread selbst
besitzt, bzw. vom Hauptprogramm benutzt.

!begin_table [l l]
Threads besitzen !! vom Hauptprogramm wird benutzt
!hline
ù Userstack               !! ù Dateihandles
ù Supervisor-Stack         !! ù Basepage
ù Applikations-ID         !! ù Speicherbl”cke
ù Resource-Dateien        !! ù aktuelles Laufwerk/Verzeichnisse
ù Menzeile               !! ù Prozess-ID (PID)
ù Desktop-Hintergrund     !! ù Domain (MiNT bzw. TOS)
ù Fenster                 !! ù umask
ù Message Queue           !! ù aktuelle (!nolink [DTA])
ù Mauszeiger              !! ù Malloc-Flags
ù VT52-Fenster (optional) !! ù Kommandozeile und Environment
ù etv_term-Vektor         !! ù Signal-Handler und -maske
ù Semaphoren              !! ù VT52-Fenster (optional)
!end_table

(!B)Hinweis:(!b) Wie man sieht erh„lt ein Thread damit z.B. eine
(!I)eigene(!i) AP_TERM Nachricht. Bei der Verwendung von Resource-Dateien
ist darauf zu achten, da ggfs. ein eigenes global-Feld benutzt wird.

Zu beachten ist ferner, da Speicher, den der Thread alloziert, dem Prozess
geh”rt, und bei Beendigung des Threads (!I)nicht(!i) automatisch freigegeben
wird; gleiches gilt fr ge”ffnete Dateien, die erst bei der
Programmbeendigung geschlossen werden. Dies muss deshalb ggfs. vom Thread
bernommen werden.

(!B)Achtung:(!b) Es ist unbedingt zu beachten, da

!begin_itemize
!item keine DTA verwendet wird, da die Funktionen Fsfirst, Fsnext, Fsetdta
      und Fgetdta (!I)nicht(!i) Multithread-sicher sind.
!item Zugriffe auf Dateihandles mit geeigneten Methoden synchronisiert
      werden. Es drfen nicht zwei Threads gleichzeitig auf dieselbe Datei
      zugreifen.
!end_itemize

Die Funktion Psemaphore ist bereits fr Threads ausgelegt, und kann sowohl
zur Synchronisation zwischen Prozessen als auch zwischen mehreren Threads
eines Prozesses verwendet werden. Beim Beenden eines Threads werden alle von
diesem blockierten Semaphoren automatisch freigegeben.

Nach M”glichkeit sollte z.Zt. nur der Haupt-Thread ein Pexec ausfhren,
nicht jedoch nebenl„ufige Threads. Theoretisch ist dies jedoch erlaubt, und
zwar dann, wenn kein anderer Thread oder der Haupt-Thread (!nolink [Pexec]) aufgerufen
hat, und der Haupt-Thread sich nicht beendet.

Das Problem liegt ganz einfach darin, da z.Zt. Rcksprungadressen bei (!nolink [Pexec])
nicht im laufenden Prozess sondern im Parent abgelegt werden, und der Parent
des vom Thread gestarteten Prozesses ungltig wird.

Falls ein Thread die Funktion Pterm ausfhrt, so wird z.Zt. nur dieser
Thread beendet. Angemerkt werden soll auch noch, da ein Thread andere
Programme per shel_write (parallel) starten, und auf deren Beendigung warten
kann.

Querverweis:
Threads und AES-Aufrufe  ~ Threads und VDI-Aufrufe ~
Prozessfunktionen        ~ GEMDOS
!end_node

!include magic\threads\example.ui

!end_node

!endif
