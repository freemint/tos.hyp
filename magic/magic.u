!iflang [english]

!include magic/magic_en.u

!else

!begin_node MagiC
!ignore_subtoc

... ist ein weitgehend TOS-kompatibles Betriebssystem, welches mit
preemptiven Multitasking und einer Reihe von weiteren Features aufwarten
kann. Das wichtigste Argument (!I)fÅr(!i) MagiC ist zweifellos die Tatsache,
daû es das einzige (kompatible) Betriebssystem ist, welches z.Zt. noch
weiterentwickelt wird, und darÅber hinaus die Verwendung einer modernen
Hardware (dem Power-PC) ermîglicht. Letzteres wurde durch eine Portierung
von MagiC auf die Apple-Plattform realisiert (MagiC Mac). Dieser Abschnitt
beschreibt die folgenden Punkte:

!begin_itemize !short
!item Accessories in MagiC
!item (!link [AUTOEXEC.BAT-Datei] [Die AUTOEXEC.BAT-Datei in MagiC])
!item (!link [DFS-Konzept in MagiC][Das DFS-Konzept von MagiC])
!item (!link [Fehlermeldungen von MagiC] [Spezielle Fehlermeldungen von MagiC])
!item (!link [Iconify] [Das Iconify in MagiC])
!item (!link [MAGX.INF-Datei von MagiC] [Der Aufbau der MAGX.INF-Datei])
!item (!link [Shutdown] [Allgemeines zum Shutdown])
!item (!link [Smart-Redraw] [Der Smart-Redraw in MagiC])
!item Test auf MagiC
!item VFAT-XFS in MagiC
!item (!link [Zusatzprogramme fÅr MagiC][Die Zusatzprogramme fÅr MagiC])
!item Auszug aus dem BIOS von MagiC
!item (!link [Besonderheiten des 3D-Looks] [Anmerkungen zum 3D-Look von MagiC])
!item (!link [Eingabefelder] [Eingabefelder in MagiC])
!item (!link [Hintergrund-DMA] [Der Hintergrund-DMA von MagiC])
!item (!link [Laufwerk U:] [Das Laufwerk U: in MagiC])
!item Semaphoren in MagiC
!item Single-Modus
!item (!link [Task-Manager] [Der Task-Manager in MagiC])
!item (!link [Threads][Threads in MagiC])
!item (!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC])
!item Shared Libraries
!end_itemize

(!B)Hinweis:(!b) Verschwiegen werden soll an dieser Stelle nicht, daû MagiC
gegenÅber Atari's MultiTOS (!I)deutliche SchwÑchen(!i) besitzt: Die
FunktionalitÑt des AES Version 4.0 ist noch nicht erreicht, viele
GEMDOS-Funktionen sind nicht implementiert, und auch das Interface zur
Einbindung alternativer Filesysteme darf, verglichen mit der
MultiTOS-Lîsung, wohl als sehr unglÅcklich bezeichnet werden.

Querverweis: BIOS ~ XBIOS ~ GEM ~ VDI



!begin_node AESVARS, Zeiger auf AESVARS

!label DOMagixAESVars
!begin_verbatim
/* Der folgende Code ermittelt auf zuverlÑssige Art und Weise den
   Zeiger auf die AESVARS-Struktur von MagiC.

   Die Routine ist deshalb besonders wichtig, weil die entsprechende
   Komponente im MagX-Cookie zur Bootzeit noch keinen gÅltigen Wert
   besitzt. */


AESVARS* DOMagixAESVars (VOID)
{
    LOCAL WORD have_it = 0;
    LOCAL AESVARS *ap = 0;

    if (!have_it)
    {
        OSHEADER *O;

        have_it = 1;

        O = (OSHEADER *) Supexec (get_osheader);
        ap = (AESVARS *) O->os_magic;

        if (!get_cookie ('MagX', NULL) ||
            ap->magic != 0x87654321L || ap->magic2 != 'MAGX')
              ap = 0;
    }

    return (ap);

} /* DOMagixAESVars */
!end_verbatim

Querverweis: Test auf MagiC ~ (!link [get_cookie][Beispiel-Code])
!end_node


!begin_node MAGX_COOKIE, status_bits

Ein Bitvektor, der wie folgt definiert ist:

!begin_table [l l l]
Bit-00 !! = !! MagiC Task-Manager z.Zt. aktiv?
Bit-01 !! = !! reserviert
.. !! ~
Bit-31 !! = !! reserviert
!end_table

(!B)Achtung:(!b) Die angegebenen Bits in diesem LONG-Wert sind Read-Only,
d.h. sie dÅrfen (!I)nicht(!i) verÑndert werden.
!end_node



!begin_node Auszug aus dem BIOS von MagiC

!begin_verbatim
*******************************
******* ACSI ******************
*******************************


* Interruptsteuerung:
*
* Alles geht Åber den Eingang I5 des ST-MFP, hat den Interrupt #7
* (aktiviert mit Bit 7 von ierb)
* Polling Åber Bit 5 von gpip
* 1. aer fÅr Bit 5 muû 0 sein, d.h. Interrupt wird ausgelîst beim
*    öbergang von 1 auf 0
* 2. Interrupt _mfpint (7) aktivieren und Vektor setzen (Adr. $11c)
*

**********************************************************************
*
* Sperre den FDC/ACSI-DMA
* und gib ihn wieder frei.
* Kein Register (auûer d0 bei dma_end) wird verÑndert
*
* FÅr die Zeit, in der AES noch nicht initialisiert ist, kann evnt_sem
* nicht sperren, weil act_appl immer NULL ist.
*

dma_begin:
 movem.l  d1-d2/a0-a2,-(sp)
 lea      dma_sem,a0
 moveq    #0,d1               ; kein Timeout
 moveq    #SEM_SET,d0
 jsr      evnt_sem
 st       flock
 movem.l  (sp)+,d1-d2/a0-a2
 rts

dma_end:
 movem.l  d0-d2/a0-a2,-(sp)
 lea      dma_sem,a0
 moveq    #SEM_FREE,d0
 jsr      evnt_sem
 clr.w    flock
 movem.l  (sp)+,d0-d2/a0-a2
 rts


**********************************************************************
*
* long wait_ACSI( d0 = long ticks_200hz )
*
* Röckgabe:    0    OK
*             -1    TimeOut
*             -2    Busfehler
*

wait_ACSI:
 movem.l  d1-d2/a0-a2,-(sp)
 tst.w    pe_slice            ; prÑemptiv ?
 bmi.b    wdma_no_yield       ; nein, busy waiting
 move.l   act_appl,d2
 ble.b    wdma_no_yield       ; aktuelle Applikation ungÅltig

* neue Routine Åber evnt_IO und MFP- Interrupt

 lsr.l    #2,d0               ; AES: 50Hz statt 200Hz
wdma_neu:
 move     sr,d1
 ori      #$700,sr
 btst     #5,gpip             ; schon fertig ?
 beq.b    wdma_ok2            ; ja, enable interrupt
; Interrupt aufsetzen
 pea      int_mfp7_unsel(pc)
 move.l   d2,imfp7_appl       ; act_appl
 move.l   sp,imfp7_unsel
; Interrupt freigeben
 move.w   d1,sr
; Auf Interrupt warten
 move.l   sp,a0
;move.w   d0,d0               ; TimeOut in 50Hz- Ticks
 jsr      evnt_IO
 addq.l   #4,sp
wdma_ende:
 movem.l  (sp)+,d1-d2/a0-a2
 rts

* alte Routine mit busy waiting Åber _hz_200

wdma_no_yield:
 add.l    _hz_200,d0
wdma_loop:
 btst     #5,gpip
 beq.b    wdma_ok
 cmp.l    _hz_200,d0
 bcc.b    wdma_loop
wdma_timeout:
 moveq    #-1,d0              ; Timeout
 bra.b    wdma_ende
wdma_ok2:
 move.w   d1,sr
wdma_ok:
 moveq    #0,d0               ; OK
 bra.b    wdma_ende


**********************************************************************
*
* Interruptroutine fÅr MFP, Interruptkanal #7 = I/O-Port 5
* (DMA/FDC busy)
*
* RÅckgabewert 0 (OK)
*

int_mfp7:
 tst.l    imfp7_unsel                   ; Interrupt aktiviert ?
 beq.b    imfp7_ende                    ; nein, weiter
 movem.l  d0-d2/a0-a2,-(sp)

 move.l   imfp7_unsel,a0
 clr.l    imfp7_unsel                   ; Interrupt deaktivieren
 clr.l    (a0)                          ; als eingetroffen markieren

 move.l   imfp7_appl,a0
 jsr      appl_IOcomplete               ; wartende APP aufwecken
 movem.l  (sp)+,d0-d2/a0-a2
imfp7_ende:
 move.b   #$7f,isrb                     ; service- Bit lîschen
 rte


**********************************************************************
*
* void int_mfp7_unsel( a0 = long *unselect, a1 = APPL *ap );
*
* Deaktiviert den Interrupt wieder, wenn er nicht eingetroffen ist
* RÅckgabewert -1 (Timeout)
*

int_mfp7_unsel:
 clr.l    imfp7_unsel                   ; Interrupt deaktivieren
 moveq    #-1,d0
 move.l   d0,(a0)                       ; nicht eingetroffen
 rts



*******************************
******* SCSI ******************
*******************************


* Interruptsteuerung:
*
* SCSI-DMA-Busfehler: Eingang I5 des TT-MFP
* 1. aer fÅr Bit 5 muû 0 sein, d.h. Interrupt wird ausgelîst beim
*    öbergang von 1 auf 0
* Polling Åber Bit 5 von gpip
* Interrupt #7 des TT-MFP (Adresse $15c)

* SCSI: Eingang I7 des TT-MFP
* 1. aer fÅr Bit 7 muû 1 sein, d.h. Interrupt wird ausgelîst beim
*    öbergang von 0 auf 1
* Polling Åber Bit 7 von gpip
* Interrupt #15 des TT-MFP (Adresse $17c)

* WÑhrend der öbertragung muû offenbar im Betriebsartenregister
* $fff785 des ncr 5380 das Bit 3 (enable process interrupt)
* gesetzt sein.

**********************************************************************
*
* Interruptroutine fÅr TT-MFP, Interruptkanal #7 = I/O-Port 5
* (SCSI-DMA Busfehler)
*
* RÅckgabewert -2
*

int_scsidma:
 tst.l    ncrdma_unsel                  ; Interrupt aktiviert ?
 beq.b    incrdma_ende                  ; nein, weiter
 movem.l  d0-d2/a0-a2,-(sp)

 moveq    #-2,d0                        ; eingetroffen (Fehler)
 move.l   ncrdma_unsel,a0
 clr.l    ncrdma_unsel                  ; Interrupt deaktivieren
 move.l   d0,(a0)                       ; als eingetroffen markieren

 move.l   ncrdma_appl,a0
 jsr      appl_IOcomplete               ; wartende APP aufwecken
 movem.l  (sp)+,d0-d2/a0-a2
incrdma_ende:
 move.b   #$7f,isrb+$80                 ; service- Bit lîschen (TT-MFP)
 rte


**********************************************************************
*
* Interruptroutine fÅr TT-MFP, Interruptkanal #15 = I/O-Port 7
* (SCSI)
*
* RÅckgabewert 0
*

int_ncr:
 tst.l    ncrdma_unsel                  ; Interrupt aktiviert ?
 beq.b    incr_ende                     ; nein, weiter
 movem.l  d0-d2/a0-a2,-(sp)

 move.l   ncrdma_unsel,a0
 clr.l    ncrdma_unsel                  ; Interrupt deaktivieren
 clr.l    (a0)                          ; als eingetroffen markieren

 move.l   ncrdma_appl,a0
 jsr      appl_IOcomplete               ; wartende APP aufwecken
 movem.l  (sp)+,d0-d2/a0-a2
incr_ende:
 move.b   #$7f,isra+$80                 ; service- Bit lîschen (TT-MFP)
 rte


**********************************************************************
*
* void incrdma_unsel( a0 = long *unselect, a1 = APPL *ap );
*
* Deaktiviert den Interrupt wieder, wenn er nicht eingetroffen ist.
* (RÅckgabewert -1)
*

incrdma_unsel:
 clr.l    ncrdma_unsel                  ; Interrupt deaktivieren
 moveq    #-1,d0                        ; Timeout
 move.l   d0,(a0)                       ; nicht eingetroffen
 rts


**********************************************************************
*
* long wait_NCR( d0 = long ticks_200hz )
*
* Röckgabe:    0    OK
*             -2    Busfehler
*             -1    TimeOut
*
* kein Register auûer d0 wird verÑndert
*

wait_NCR:
 movem.l  d1-d2/a0-a2,-(sp)
 tst.w    pe_slice            ; prÑemptiv ?
 bmi.b    wncr_no_yield       ; nein, busy waiting
 move.l   act_appl,d2
 ble.b    wncr_no_yield       ; aktuelle Applikation ungÅltig

* neue Routine Åber evnt_IO und MFP- Interrupt

 lsr.l    #2,d0               ; AES: 50Hz statt 200Hz
wncr_neu:
 move     sr,d1
 ori      #$700,sr
 btst     #5,gpip+$80         ; DMA- Busfehler ?
 beq.b    wncr_err2           ; ja, return(-2)
 btst     #7,gpip+$80         ; schon fertig ?
 bne.b    wncr_ok2            ; ja, enable interrupt, return(0)
; Interrupt aufsetzen
 pea      incrdma_unsel(pc)
 move.l   d2,ncrdma_appl      ; act_appl
 move.l   sp,ncrdma_unsel
; Interrupt freigeben
 move.w   d1,sr
; Auf Interrupt warten
 move.l   sp,a0
;move.w   d0,d0               ; TimeOut in 50Hz- Ticks
 jsr      evnt_IO
 addq.l   #4,sp
wncr_ende:
 movem.l  (sp)+,d1-d2/a0-a2
 rts

* alte Routine mit busy waiting Åber _hz_200

wncr_no_yield:
 add.l    _hz_200,d0
wncr_loop:
 btst     #5,gpip+$80
 beq.b    wncr_err
 btst     #7,gpip+$80
 bne.b    wncr_ok
 cmp.l    _hz_200,d0
 bcc.b    wncr_loop
 moveq    #-1,d0                   ; Timeout
 bra.b    wncr_ende
wncr_ok2:
 move.w   d1,sr
wncr_ok:
 moveq    #0,d0
 bra.b    wncr_ende
wncr_err2:
 move.w   d1,sr
wncr_err:
 moveq    #-2,d0
 bra.b    wncr_ende


**********************************************************************
*
* Sperre den NCR-SCSI
*
* kein Register auûer d0 wird verÑndert
*
* und gib ihn wieder frei.
*
* Kein Register wird verÑndert
*
* FÅr die Zeit, in der AES noch nicht initialisiert ist, kann evnt_sem
* nicht sperren, weil act_appl immer NULL ist.
*

ncr_begin:
 movem.l  d1-d2/a0-a2,-(sp)
 lea      ncr_sem,a0
 moveq    #0,d1               ; kein Timeout
 moveq    #SEM_SET,d0
 jsr      evnt_sem
 movem.l  (sp)+,d1-d2/a0-a2
 rts

ncr_end:
 movem.l  d0-d2/a0-a2,-(sp)
 lea      ncr_sem,a0
 moveq    #SEM_FREE,d0
 jsr      evnt_sem
 movem.l  (sp)+,d0-d2/a0-a2
 rts
!end_verbatim

(!B)Achtung:(!b) Die hier angegebenen Routinen, kînnen sich natÅrlich
jederzeit wieder Ñndern!

Querverweis: MagiC ~ GEMDOS ~ BIOS ~
(!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC])
!end_node



!begin_node Die AUTOEXEC.BAT-Datei in MagiC
!label AUTOEXEC.BAT in MagiC

Aufgrund des vorwÑrts- bzw. rÅckwÑrtssortierten Auto-Ordners auf dem Apple
Macintosh (Stichwort: MagiC Mac) gibt es jetzt auch fÅr Atari-Maschinen eine
Alternative:

Wird beim Booten im Auto-Ordner eine Datei mit Namen AUTOEXEC.BAT gefunden,
so werden alle Programme ausgefÅhrt, die darin zeilenweise aufgelistet
sind. Leerzeilen sind erlaubt, Programmnamen werden bis zum ersten
Leerzeichen Åbernommen. Daher kînnen Kommentare (durch Leerzeichen von den
Programmen getrennt) eingegeben werden. Programmnamen dÅrfen
(!I)absolute(!i) Pfade enthalten; tun sie dies nicht, so wird im Auto-Ordner
gesucht.

Als aktuelles Verzeichnis gilt dabei, wie gehabt, das Wurzelverzeichnis.
Durch dieses Feature gibt es also eine MagiC-spezifische
Auto-Ordner-Kollektion, da die AUTOEXEC.BAT von anderen Systemen ignoriert
wird.

Querverweis: _autopath ~ (!link [Systemvariablen][Die Systemvariablen])
!end_node



!begin_node Anmerkungen zum 3D-Look von MagiC

Ab MagiC 3 steht fÅr Objekte ein 3D-Look zur VerfÅgung, der sich jedoch in
einigen Details von der Atari-Variante unterscheidet. Die wichtigsten
Punkte in KÅrze:

!begin_itemize
!item der 3D-Look steht nur in Auflîsungen mit (!I)mindestens 16 Farben(!i)
      zur VerfÅgung.
!item wÑhrend man in TOS 4.0 per objc_sysvar das Verhalten der Indikatoren
      und Aktivatoren, sowie die Farben beeinflussen kann, erlaubt (!nolink [MagiC])
      nur die Abfrage der Daten. Als Farben werden in (!nolink [MagiC]) immer die
      Farbnummern 8 und 9 (hell- bzw. dunkelgrau) verwendet.
!item Aktivatoren werden bei SELECTED immer eingedrÅckt, Indikatoren oder
      Background-Objekte werden verfÑrbt.
!item Indikatoren und Background-Objekte werden gleich behandelt.
!item fÅr alle Objekttypen kînnen 3D-Effekte angefordert werden, dies gilt
      auch fÅr Texteingabefelder, öberschriften, Gruppenrahmen etc.
!item 3D-Objekte bekommen keinen zusÑtzlichen Rahmen und Ñndern sich daher
      nicht in der Grîûe. Je nach Rahmenbreite stehen sie weiter heraus und
      haben ggf. auch noch einen zusÑtzlichen Rand und Schatten.
      öberschriften sollten statt bisher 1+2 die Hîhe 1+3 haben, damit es
      ordentlich aussieht.
!item der Objektstatus DRAW3D wird ignoriert.
!item SchmuckrÑnder fÅr (!nolink [Dialogboxen]) werden genau dann erzeugt, wenn ein
      innerer Rahmen von 2 Pixeln und OUTLINED angewÑhlt wurde.
!end_itemize

Querverweis: AES ~ GEM ~ Style-Guidelines
!end_node


!begin_node Eingabefelder in MagiC
!label Eingabefelder in MagiC
!label Editfelder in MagiC

Die Eingabefelder bieten in MagiC von Haus aus bereits viele Funktionen, die
sonst mÅhsam zu Fuû programmiert werden mÅssen. U.a. sind dies:

!begin_itemize !short
!item exakte Cursorpositionierung per Maus
!item TastaturkÅrzel, um den Cursor zum vorherigen/nÑchsten Wort oder zum
      Zeilenanfang/Zeilenende zu bewegen.
!item EinfÅge/öberschreibmodus
!item Lîschen bis Zeilenende
!item Cut, Copy, Paste
!item Eingabefelder mit kleiner Schrift funktionieren
!end_itemize

Die Funktionen fÅr Help, Undo, Shift-hoch, Shift-runter und Ctrl-Q sind in
form_keybd enthalten (sie werden allerdings ignoriert, falls das
entsprechende Objekt (!nolink [DISABLED]) ist) die Cursorpositionierung per Maus in
form_do bzw. form_xdo und objc_edit und die restlichen Funktionen in
objc_edit.

Wer in den Genuû der entsprechenden Funktionen kommen mîchte, muû die dazu
gehîrigen (!nolink [AES])-Aufrufe benutzen.

Querverweis: AES ~ GEM ~ Style-Guidelines ~ (!link [scrollende Eingabefelder][scrollende Eingabefelder])
!end_node



!begin_node scrollende Eingabefelder

!begin_verbatim
/*******************************************************************
*
* Dieses Beispielprogramm demonstriert den Gebrauch scrollender
* Eingabefelder in MagiC 3.
*
*******************************************************************/

#include <aes.h>
#include <tos.h>
#include <string.h>
#include <magx.h>
#include "magxlib.h"
#include "edscroll.h"

#define TLEN  30

int  do_dialog    (OBJECT *dialog);

void main()
{
  OBJECT *adr_dialog;
  ULONG crdate;
  int is_scroll;

  XTED xted;
  char tmplt[TLEN+1],txt[TLEN+1];


  /* Feststellen, ob das System Scrolledit kann */
  /* ------------------------------------------ */

  is_scroll = ((0 < get_MagiC_ver(&crdate)) &&
    (crdate >= 0x19950829L));

     /* Applikation beim AES anmelden */
     /* ----------------------------- */

     if   (appl_init() < 0)
          Pterm(1);

     /* Resourcedatei laden */
     /* ------------------- */
     if   (!rsrc_load("edscroll.rsc"))
     {
          form_alert(1, "[3][Kann \"EDSCROLL.RSC\"|nicht finden][Abbruch]");
          goto err;
     }

     rsrc_gaddr(0, EDIT, &adr_dialog);

  /* Scroll-TEDINFO initialisieren */
  /* ----------------------------- */

  init_scrlted(adr_dialog+EDITTXT, is_scroll, &xted,
        txt, tmplt, TLEN);

  strcpy(txt, "Beispiel");

  /* Dialog */
  /* ------ */

     wind_update(BEG_MCTRL);
     graf_mouse(ARROW, 0L);
     do_dialog(adr_dialog);
     wind_update(END_MCTRL);
     rsrc_free();

  err:
     appl_exit();
     Pterm0();
}


/****************************************************************
*
* do_dialog
*
****************************************************************/

int do_dialog(OBJECT *dialog)
{
     int cx, cy, cw, ch;
     int exitbutton;

     form_center(dialog, &cx, &cy, &cw, &ch);
     form_dial(FMD_START, 0,0,0,0, cx, cy, cw, ch);
     objc_draw(dialog, ROOT, MAX_DEPTH, cx, cy, cw, ch);
     exitbutton = 0x7f & form_do(dialog, 0);
     form_dial(FMD_FINISH, 0,0,0,0,cx, cy, cw, ch);
     return(exitbutton);
}


/*******************************************************************
*
* MagiC-Version ermitteln.
* ========================
*
* Falls <crdate> != NULL ist, wird das Erstelldatum in der
* Form jjjjmmdd geliefert. Durch "<" und ">" kann dann
* direkt ermittelt werden, ob eine bestimmte Funktion
* bei der vorliegenden MagiC- Version verfÅgbar ist.
*
* RÅckgabe:  0     kein MagiC installiert
*           -1    bin noch im AUTO-Ordner
*       0x0a0b    Version a.b
*
*******************************************************************/

WORD get_MagiC_ver(ULONG *crdate)
{
  ULONG *cookie;
  AESVARS *av;

  cookie = get_cookie('MagX');
  if  (!cookie)
    return(0);
  else
  {
    av = ((MAGX_COOKIE *) (*cookie))->aesvars;
    if  (!av)
      return(-1);
    else if (crdate)
    {
      *crdate = av->date << 16L;        /* jjjj0000 */
      *crdate |= av->date >> 24L;       /* jjjj00tt */
      *crdate |= (av->date >> 8L) & 0xff00L;    /* jjjjmmtt */
      return(av->version);
    }
  }
}


/****************************************************************
*
* Macht ein F(BOX)TEXT-Objekt scrollbar, wenn MagiC lÑuft.
*
* Wenn <is_scroll> FALSE ist, wird nur das Textfeld auf eine
* Benutzerzeichenkette umgesetzt.
*
* Im RCS sollte das Textfeld leer gelassen werden, die Schablone
* und die Valid-Zeichenkette mÅssen jedoch eingegeben werden,
* weil sonst das RCS streikt.
* FÅr scrollende Felder muû eine neue Schablone angelegt werden,
* die in der .RSC-Datei angemeldete kann nicht verwendet werden,
* weil sie zu kurz ist. Die hier angelegte Schablone besteht
* nur aus '_'-Zeichen, weil dies 99.9% aller AnwendungsfÑlle
* fÅr scrollende !{"Objekte" ignore} abdeckt. Die LÑnge der
* Valid-Zeichenkette ist egal, d.h. muû mindestens 1 sein, weil
* das AES das letzte Zeichen der Valid-Zeichenkette
* automatisch vervielfacht, bis die LÑnge des Textfeld erreicht
* ist.
*
* Die maximale LÑnge fÅr die Eingabezeichenkette ist in jedem
* Fall (TEDINFO.te_txtlen - 1).
*
****************************************************************/

void init_scrlted(OBJECT *o, WORD is_scroll, XTED *xted,
        char *txt, char *tmplt, WORD len)
{
  TEDINFO *t;

  t = o->ob_spec.tedinfo;
  t->te_just = TE_LEFT;   /* wichtig! */
  t->te_ptext = txt;
  if  (is_scroll)
  {
    memset(tmplt, '_', len);  /* neue Schablone */
    tmplt[len] = '\0';
    xted->xte_ptmplt = tmplt;
    xted->xte_pvalid = t->te_pvalid;
    xted->xte_vislen = t->te_tmplen - 1;
    xted->xte_scroll = 0;

    t->te_tmplen = len+1;
    t->te_ptmplt = NULL;
    t->te_pvalid = (void *) xted;
  }
  t->te_txtlen = t->te_tmplen;
}
!end_verbatim

Querverweis: AES ~ Eingabefelder in MagiC ~ GEM ~ TEDINFO
!end_node



!include magic/magicerr.u


!begin_node Der Hintergrund-DMA von MagiC
!label Hintergrund-DMA in MagiC

Ab MagiC 3 ist das gesamte DOS einschlieûlich der Zugriffe auf DOS
Dateisysteme reentrant und lÑuft im Hintergrund ab. So ist es mîglich, auf
Laufwerk A Dateien zu bearbeiten, ohne den Rechner bei den
Diskettenzugriffen merklich zu bremsen. Voraussetzung hierfÅr sind jedoch
Disketten- und Festplattenroutinen, die im Hintergrund arbeiten.

Damit der Plattentreiber diese Funktionen nicht zur VerfÅgung zu stellen
braucht, enthÑlt das BIOS von (!nolink [MagiC]) alle notwendigen Funktionen. öber den
MagX-Cookie (Komponente (!I)hddrv_functions(!i)) erhÑlt man Zugriff auf die
folgende Struktur, die Zeiger auf wichtige Routinen des Hintergrund-DMAs
enthÑlt:

!begin_verbatim
typedef struct
{
    LONG dma_begin ( VOID);
    LONG dma_end   ( VOID );
    LONG dma_wait  ( d0 = LONG ticks_200hz );
    LONG ncr_begin ( VOID );
    LONG ncr_end   ( VOID );
    LONG ncr_wait  ( d0 = LONG ticks_200hz );
} HDFUNCS;
!end_verbatim

(!B)Hinweis:(!b) Direkt vor der Struktur (2 Bytes vorher) liegt ein WORD,
das die TabellenlÑnge in LONGs angibt (in diesem Fall 6). Alle 6 Zeiger
liegen im Systemvariablenbereich und dÅrfen notfalls verÑndert werden. Die
internen Funktionen fÅr die Floppy springen ebenfalls Åber die 6 Zeiger.
(!B)Wichtig:(!b) Der Zeiger (!I)hddrv_functions(!i) im MagX-Cookie darf
nicht verÑndert werden.

Zur Bootzeit ist das prÑemptive Multitasking abgeschaltet (eigentlich ist
auch das Multitasking abgeschaltet), aber die Routinen funktionieren auch
vor Installation des AES, wobei die Warteroutinen dann ein 'busy waiting'
machen (wie auch beim Abschalten des prÑemptiven Multitasking), und die
Semaphorenroutinen machen (bis auf das Setzen und Lîschen von flock) einfach
nichts.

Dieser Hypertext enthÑlt (!nolink [AuszÅge aus dem BIOS]) von (!nolink [MagiC]),
die demonstieren
sollen, wie das ganze funktioniert; dazu einige Worte:

!begin_itemize
!item die Routinen acsi_xxx sind gleichzeitig fÅr ACSI und FDC, d.h.
      dma_begin setzt (!nolink [flock]), dma_end lîscht es wieder.
!item die Routinen ncr_xxx sind fÅr TT-SCSI.
!item die Funktionen xxx_begin reservieren die jeweilige Semaphore. FÅr die
      RÅckgabwerte gilt:
!begin_table [l|l]
Wert !! Bedeutung
!hline
-1 !! Semaphore ist bereits im Besitz
~0 !! Ok
!end_table
      Die Routinen verÑndern mit Ausnahme von d0 keine Register.
!item die Funktionen xxx_end geben die Semaphore wieder frei; auch hier wird
      kein Register verÑndert.
!item dma_wait wartet auf einen Interrupt des ACSI-DMA (bzw. FDC)
      Controllers; ncr_wait ist fÅr den SCSI-Bus des Atari-TT. FÅr die
      RÅckgabewerte gilt:
!begin_table [l|l]
Wert !! Bedeutung
!hline
-2 !! Busfehler (Interrupt vom TT-SCSI)
-1 !! Timeout
~0 !! Ok
!end_table
!end_itemize

Querverweis: BIOS ~ GEMDOS ~
(!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC])
!end_node



!begin_node Das Iconify in MagiC
!label Iconify in MagiC

(!nolink [MagiC]) beherrscht (ab Version 3.0) wie MultiTOS das Ikonifizieren von
Fenstern. Folgendes ist dabei zu beachten:

!label Iconify, Algorithmus beim
Der Algorithmus zum Festlegen der Position des ikonifizierten Fensters
funktioniert anders als bei MultiTOS; MagiC durchsucht die aktuellen
Positionen der bereits ikonifizierten Fenster und setzt das neue Fenster
auf einen freien Platz. (!I)Ein Platz ist nur dann frei(!i), wenn der
Schnitt mit der neuen Position leer ist.

!label Iconify, Elemente nach dem
!label Iconify, Grîûe nach dem
Das AES schickt beim Un-/Ikonifizieren explizit eine Redraw-Nachricht, auch
wenn sich die Grîûe (!I)nicht(!i) geÑndert hat. Ikonifizierte Fenster haben
als Elemente nur Mover und (!nolink [Titel]). Ihre Grîûe betrÑgt (wie unter MultiTOS)
72x72 Pixel brutto. Diese Grîûe ist jedoch keinesfalls als fest anzusehen;
sie kînnte sich in spÑteren Versionen durchaus Ñndern. Aus diesem Grund
sollte die Grîûe eines ikonifizierten Fensters der (!nolink [WM_ICONIFY]) Nachricht
entnommen, oder per (!nolink [wind_get])((!nolink [WF_ICONIFY])) ermittelt werden.

Querverweis: wind_get  ~   wind_set  ~  WM_ICONIFY ~  WM_ALLICONIFY  ~
WM_UNICONIFY ~ (!link [Shortcuts][Iconify, Shortcuts fÅr])
!end_node



!begin_node Das Laufwerk U: in MagiC

Unter MagiC wird Laufwerk U: bei der Initialisierung des DOS angelegt. Damit
es von gÑngigen Programmen als existent erkannt wird, wird das entsprechende
Bit in _drvbits gesetzt; es existiert jedoch kein entsprechendes
(!nolink [BIOS])-Laufwerk.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image drv_u
!else
!image (!picture_path)\drv_u
!endif
!else
!image (!picture_path)\drv_u
!endif

Innerhalb des Laufwerks gibt es einige Spezialverzeichnisse, und zwar:

!begin_itemize !short
!item (!link [U:\DEV][Das Verzeichnis U:\DEV])    ~(Devices)
!item (!link [U:\PIPE][Das Verzeichnis U:\PIPE])  ~((!nolink [Pipes]))
!item (!link [U:\PROC][Das Verzeichnis U:\PROC])  (Prozesse)
!item (!link [U:\SHM][Das Verzeichnis U:\SHM])    ~((!nolink [Shared Memory]))
!end_itemize

Im Gegensatz zu MiNT sind dies jedoch keine eigenen Dateisysteme, sondern
einfach nur Unterverzeichnisse des DFS fÅr Laufwerk U:. Je nach
Unterverzeichnis legt das U-DFS verschiedene Dateitypen und -treiber an. Da
die Verzeichniskontrolle dem DOS_XFS obliegt, werden z.B. Schreibzugriffe
auf ein Device im Verzeichnis per Dateidatum protokolliert. Das geht sogar
soweit, daû ein Schreibzugriff auf das Wurzelverzeichnis von Laufwerk A:
automatisch das Dateidatum von U:\A verÑndert.

Alle Verzeichnisse sind z.Zt. auf maximal 32 EintrÑge beschrÑnkt, und
Aufrufe von Dfree liefern nur den Wert Null zurÅck. Auf dem
Wurzelverzeichnis kînnen auûer den bestehenden Dateien nur symbolische Links
(per Fsymlink) erstellt werden.

Vor jedem Zugriff auf Laufwerk U: werden neu hinzugekommene Laufwerke per
symbolischem Link hinzugefÅgt bzw. nicht mehr existierende entfernt; dies
wird Åber _drvbits erkannt. Ein symbolischer Link fÅr Laufwerk X: wird
standardmÑûig unter dem Namen U:\X angemeldet, und zeigt auf das Verzeichnis
X:\. Symbolische Links kînnen umbenannt oder gelîscht werden (auch ein
umbenannter Link wird automatisch gelîscht, wenn das entsprechende Bit in
der Systemvariablen _drvbits gelîscht wird).

(!B)Achtung:(!b) MiNT bindet die Laufwerke nicht als symbolische Links ein,
daher kann man folgende Befehlsfolge absetzen:

!begin_xlist !short [Dgetpath ]
!item [(!nolink [Dsetdrv])]  U:
!item [(!nolink [Dsetpath])] U:\A
!item [(!nolink [Dgetpath])] ==> U:\A
!item [(!nolink [Dsetpath])] ..
!item [(!nolink [Dgetpath])] ==> U:\
!end_xlist

Bei einem symbolischen Link wechselt man hingegen tatsÑchlich den Pfad, d.h.
in der dritten Zeile erscheint A:\ als aktueller Pfad. Um dieses Problem zu
umgehen, gibt es eine Sonderbehandlung im Kernel, der die obige Befehlsfolge
auch in MagiC ermîglicht. Dabei gibt es allerdings ein Problem: Der
symbolische Link darf nicht umbenannt werden, da sonst folgendes passiert:

!begin_xlist !short [Dgetpath ]
!item [(!nolink [Frename])]  U:\A U:\FLOPPY
!item [(!nolink [Dsetdrv])]  U:
!item [(!nolink [Dsetpath])] U:\FLOPPY
!item [(!nolink [Dgetpath])] ==> U:\A
!item [(!nolink [Dsetpath])] ..
!item [(!nolink [Dgetpath])] ==> U:\
!end_xlist

Weil alle Dateifunktionen auf U: genauso funktionieren wie auf einer
Diskette ist es auch mîglich, Verzeichnisse wie U:\DEV umzubenennen.
(!B)Achtung:(!b) Dies sollte tunlichst vermieden werden, da sonst
Anwenderprogramme ihre GerÑtetreiber nicht mehr finden kînnen.

Querverweis: BIOS ~ GEMDOS ~
(!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC]) ~
(!link [Test auf Pipes][Pipes, Test auf])



!begin_node Das Verzeichnis U:\DEV

In diesem Verzeichnis werden GerÑtetreiber (Devices) eingetragen. Es handelt
sich dabei um Pseudodateien, die nur dem DOS, nicht jedoch dem (!nolink [BIOS]) bekannt
sind.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image drv_udev
!else
!image (!picture_path)\drv_udev
!endif
!else
!image (!picture_path)\drv_udev
!endif

Auch die altbekannten GerÑtenamen finden sich in diesem Verzeichnis wieder,
denn es gilt:

!begin_itemize !short
!item CON: (Handle -1) ==> U:\DEV\CON
!item AUX: (Handle -2) ==> U:\DEV\AUX
!item PRN: (Handle -3) ==> U:\DEV\PRN
!item NUL: (Handle -4) ==> U:\DEV\NULL
!end_itemize

Da auf die hier installierten GerÑte mit den normalen Dateifunktionen des
(!nolink [GEMDOS]) zugegriffen werden kann, ist es z.B. mîglich ein Textdokument durch
einfaches Speichern per Fwrite auf dem Drucker auszugeben. Dateinamen wie
CON: werden dabei vom Kernel automatisch in die richtige Form umgewandelt
(in diesem Fall also: U:\DEV\CON).

AbhÑngig vom Rechnermodell stehen per Default die folgenden Devices zur
VerfÅgung:

!begin_xlist !short [SERIAL1]
!item [GerÑt]
Beschreibung
!item [~]
~
!item [AUX]
(!nolink [BIOS])-GerÑt 2
!item [CON]
Console
!item [LAN]
(!nolink [BIOS])-GerÑt 7, i.a. SCC, Kanal A
!item [MIDI]
(!nolink [BIOS])-GerÑt 3, beim Ausgabestatus hingegen das GerÑt mit der Nummer 4.
!item [MODEM1]
(!nolink [BIOS])-GerÑt 6, i.a. die mit dem ST-MFP realisierte serielle Schnittstelle,
auf dem Falcon der SCC mit Kanal-B.
!item [MODEM2]
(!nolink [BIOS])-GerÑt 7, i.a. SCC, Kanal B
!item [NULL]
leere Pseudodatei, liefert beim Schreiben immer den Status Ok und beim Lesen
den Wert EOF (kein Zeichen verfÅgbar).
!item [PRN]
(!nolink [BIOS])-GerÑt 0, bei der Ausgabe wird bei einem Timeout abgebrochen.
!item [SERIAL1]
(!nolink [BIOS])-GerÑt 8, i.a. der TT-MFP
!item [SERIAL2]
(!nolink [BIOS])-GerÑt 9, i.a. SCC, Kanal A
!end_xlist

Von CON: einmal abgesehen, arbeiten alle GerÑte im "Raw-Modus", d.h.
Steuersequenzen wie Control-C werden nicht berÅcksichtigt.

Weitere GerÑte kînnen jederzeit per Dcntl erstellt und eingetragen werden;
aufgrund des inkompatiblen Treiberformates muû jedoch der Opcode
DEV_M_INSTALL und nicht wie sonst Åblich DEV_INSTALL benutzt werden. Die
vorhandenen GerÑte kînnen mit den Åblichen Methoden umbenannt und gelîscht
werden; im Gegensatz zu MiNT wird das Lîschen eines GerÑtes Åber den
GerÑtetreiber selbst abgewickelt, der sich so aus den entsprechenden
Systemvektoren zurÅckziehen und den Speicher freigeben bzw. sich beenden
kann. Ein weiterer Unterschied zu MiNT besteht darin, daû MagiC die volle
FunktionalitÑt des DOS-Dateisystems zur VerfÅgung stellt, d.h.:

!begin_itemize !short
!item es dÅrfen keine GerÑte gleichen Namens existieren.
!item Schreibzugriffe werden mit énderung des Dateidatums Åberwacht.
!item schreibgeschÅtzte GerÑte dÅrfen nicht beschrieben, gelîscht oder
      umbenannt werden.
!end_itemize

(!B)Hinweis:(!b) öber (!nolink [Fcreate]) kînnen hier keine Dateien erzeugt werden; es
ist allerdings mîglich per Fsymlink symbolische Links anzulegen.

Querverweis: BIOS ~ GEMDOS ~ (!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC])
!end_node



!begin_node Das Verzeichnis U:\PIPE
!label Pipes

In diesem Verzeichnis werden Pipes abgelegt; es handelt sich dabei um
temporÑre Dateien, die insbesondere fÅr den Datenaustausch zwischen
Prozessen benutzt werden.

Man unterscheidet (!I)unidirektionale(!i) und (!I)bidirektionale(!i) Pipes:
erstere erlauben einen Datenfluû nur in einer Richtung, letztere kînnen in
beide Richtungen Åbertragen, jedoch nicht gleichzeitig. Bidirektionale Pipes
finden z.B. beim Drag&Drop-Protokoll Verwendung. Pipes liefern beim Lesen
per (!nolink [Fread]) grundsÑtzlich EOF (End-of-File) wenn sie leer sind, oder kein
schreibender Prozeû vorhanden ist. Analog wird beim Schreiben per Fwrite der
Wert EOF geliefert, falls kein lesender Prozess vorhanden ist.

Der Zugriff erfolgt dabei rein asynchron, d.h. Applikationen warten auf das
Lesen bzw. Schreiben und wecken ggf. eine andere Applikation wieder auf.
Pipes werden automatisch gelîscht, wenn das letzte Programm, daû sie
benutzt, die sie reprÑsentierende Datei geschlossen hat.

(!B)Hinweis:(!b) (!nolink [MagiC]) unterstÅtzt maximal 32 Pipes gleichzeitig. Ein Fseek
auf Pipes fÅhrt grundsÑtztlich zur RÅckgabe von 0L, d.h. der Dateizeiger
kann nicht beeinfluût werden. Im Verzeichnisfenster erscheinen Pipes mit
einer LÑnge von 2 bzw. 4k und dem Datum ihrer Erstellung. Falls beim ôffnen
einer Pipe eine Kennung > 31 geliefert wird, kann die Systemfunktion Fselect
nicht benutzt werden.

(!B)DarÅber hinaus ist ab (!nolink [MagiC]) 3 folgendes zu beachten:(!b)

!begin_itemize
!item Pipes mit Modus 4 (Pseudo-TTYs) werden nicht unterstÅtzt. MagiC kennt
      nur uni- und bidirektionale Pipes und erstellt bei Modus 4 eine
      bidirektionale Pipe. Der Hauptgrund fÅr Pipes sind zur Zeit das
      (!nolink [Drag&Drop-Protokoll]).
!item Pipes liefern bei Finstat/Foutstat die Anzahl der vorhandenen bzw.
      noch freien Bytes im Block.
!item Wird eine Pipe geschlossen, so werden alle wartenden Programme
      aufgeweckt, um evtl. mîgliche (!I)Deadlocks(!i) zu vermeiden.
!end_itemize

Querverweis: (!nl)
Fcreate ~  Fread ~  Fwrite ~  Fclose ~ Fpipe ~  (!link [Test auf Pipes][Pipes, Test auf])
!end_node



!begin_node Das Verzeichnis U:\PROC
!label Name eines Prozesses
!label Prozesses, Name eines
!label _PNAM

Dieses Verzeichnis gibt einen öberblick Åber die z.Zt. aktiven Prozesse im
System. Jeder Eintrag besteht aus den folgenden Komponenten:

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image drvuproc
!else
!image (!picture_path)\drvuproc
!endif
!else
!image (!picture_path)\drvuproc
!endif

!begin_itemize !short
!item dem Prozessnamen
!item der Prozess-ID (PID)
!item dem aktuellen Speicherplatzverbrauch
!item Datum und Uhrzeit der Prozesserstellung
!end_itemize

In der Abbildung oben beispielsweise, besitzt der Prozess (!I)XCONTROL(!i)
die PID 4 und belegt z.Zt. 93460 Bytes Speicherplatz.

Prozess IDs werden beim Programmstart vergeben und beim Terminieren
freigegeben. Das Lîschen einer Datei in diesem Verzeichnis hat zur Folge,
daû der entsprechende Prozess (Åber den Programmanager des AES) zerstîrt
wird.

(!B)Hinweis:(!b) Die MiNT-konformen Prozess-Attribute (spezielle
Dateiattribute) werden von MagiC z.Zt. nicht unterstÅtzt. Der Name eines
Prozesses kann auch Åber die Environment-Variable (!I)_PNAM(!i) ermittelt
werden; die Prozess-ID findet sich auch in der (!nolink [Basepage]).

Querverweis: GEM ~ Style-Guidelines ~ (!link [Task-Manager][Der Task-Manager in MagiC])
!end_node



!begin_node Das Verzeichnis U:\SHM
!label Shared memory

Dieses Verzeichnis dient als 'Ablage' fÅr Shared Memory; hier kînnen also
Dateien angelegt werden die Speicherblîcke reprÑsentieren, und auf die
andere Prozesse zugreifen dÅrfen.

öber Shared Memory (gemeinsamen Speicher) lÑût sich sehr leicht eine
(!I)Interprozess-Kommunikation(!i) (IPC) realisieren.

Querverweis: Fcntl ~ SHMGETBLK ~ SHMSETBLK
!end_node
!end_node



!include magic\magicinf.u


!begin_node Semaphoren in MagiC

Unter MagiC werden Semaphoren bei der Programmterminierung (genauer: bei der
Applikations-Terminierung) freigegeben. Im Gegensatz zu MiNT gilt dies auch
fÅr die per Psemaphore belegten Semaphoren.

(!nolink [MagiC]) unterstÅtzt bei (!nolink [Psemaphore]) z.Zt. nur die Modi 2
und 3, und kennt die folgenden System-Semaphoren:

!begin_xlist !short [Semaphore]
!item [Semaphore]
Bedeutung
!item [~]
~

!label Semaphore, _DMA
!item [_DMA]
(!B)ACSI und FDC(!b)
(!nl)
Beim Erhalt dieser Semaphore darf nicht vergessen werden, die Systemvariable
flock zu setzen, und diese nach dem Freigeben der Semaphore ebenfalls wieder
freizugeben.

!label Semaphore, _NCR
!item [_NCR]
(!B)SCSI des Atari-TT(!b)

!label Semaphore, _SCR
!item [_SCR]
(!B)(!nolink [AES])-Bildschirm(!b) (von wind_update benutzt)
!end_xlist

Querverweis:
GEMDOS ~ Prozessfunktionen ~  Signale
!end_node


!include magic\shutdown\shutdown.u




!begin_node Der Smart-Redraw in MagiC
!label Smart-Redraw

(!nolink [MagiC]) verfolgt die Philosophie, daû Geschwindigkeit nicht mit brutalen
Mitteln wie Grafikprozessoren usw. erreicht werden soll, sondern mit ein
wenig Nachdenken. Dazu gehîrt vor allem, immer nur soviel zu tun, wie nîtig
ist. WÑhrend TOS beim Wechsel des aktuellen Fensters, beim Schlieûen oder
beim Verschieben mit Vorliebe das (!I)gesamte(!i) Fenster oder gar noch
vîllig unschuldige, unbeteiligte andere Fenster neu zeichnet, wird dies
unter MagiC wirkungsvoll vermieden. Obwohl diese unschîne Eigenschaft des
TOS nirgendwo dokumentiert ist, existieren leider Programme und Bibliotheken
(etwa die aus dem Buch '(!I)Vom AnfÑnger zum (!nolink [GEM])-Profi(!i)'), welche die
Eigenschaft nutzen, daû TOS beim Vergrîûern eines Fensters dieses immer neu
zeichnet.

(!B)Dazu ein Beispiel:(!b) Nehmen wir an, in ein Fenster passen fÅnf Spalten
ne!-beneinander, die auch angezeigt werden. Wenn der Benutzer nun das Fenster
so weit verkleinert, daû nur noch vier Spalten hineinpassen, sortiert das
Programm seine Daten um und veranlaût anschlieûend selbstÑndig ein
Neuzeichnen des Fensters (TOS zeichnet bei Verkleinerung das Fenster
(!I)nicht(!i) von sich aus neu). Vergrîûert der Benutzer dagegen das Fenster
auf eine Breite von 7 Spalten, sortiert das Anwenderprogramm die Daten
ebenfalls um, veranlaût jedoch hier (!I)kein(!i) Neuzeichnen des Fensters.
Aufgrund des eher als Fehlverhalten des TOS zu bezeichnenden Verhaltens, das
Fenster fÅr diesen Fall (!I)immer ganz(!i) neu zu zeichnen, findet dann die
Ausgabe statt.

MagiC zeichnet nun immer nur den minimal nîtigen Teil des Fensters neu;
das wÑren im Fall des Aufziehens eines Fensters hîchstens rechts und unten
zwei Rechtecke. FÅr die Programme, die den oben beschriebenen Fehler des
TOS ausnutzen, gibt sich so eine (!I)Diskrepanz zwischen logischem und
physikalischem Bildschirminhalt(!i).

Viel einfacher wÑre es gewesen, einfach auf die Fallunterscheidung 'Fenster
grîûer oder kleiner als vorher' zu verzichten und immer im Fall des
Umsortierens einen Redraw zu veranlassen. Da das Betriebssystem auch im
TOS die Redraws zusammenfaût, hat ein eventuell ÅberflÅssiger Redraw
(!I)niemals(!i) irgendwelche Auswirkungen.

Den gleichen Effekt wie beschrieben hat man Åbrigens auch beim Vergrîûern
des Fensters, wenn bereits die unterste Zeile bzw. die rechteste Zeile
dargestellt wird.

(!B)Auch hier ein Beispiel:(!b) Ein Text habe 100 Zeilen, das Fenster habe
eine Hîhe von 20 Zeilen. Da der Scrollbalken ganz unten ist, werden also die
Zeilen 80 bis 100 im Fenster dargestellt. Wird nun das Fenster nach unten
vergrîûert, so daû etwa 30 Zeilen Platz finden, kînnte man eigentlich nur
einen weiûen Bereich aufziehen, da unterhalb von Zeile 100 ja keine Daten
mehr sind. Um dies zu verhindern scrollen die meisten Programme in dieser
Situation ihre Daten, in unserem Beispiel um 10 Zeilen nach oben. Folglich
zeigt das Programm jetzt die Zeilen 70 bis 100 an; da es aber auf einem
TOS- Fehler aufbaut, wird (!I)kein(!i) Neuzeichnen veranlaût, was unter
MagiC natÅrlich prompt zur Konfusion fÅhrt.

Auch hier wÑre ein generelles Neuzeichnen des Fensters beim Umsortieren auch
unter TOS nicht nur sauber, sondern auch ohne Nebenwirkung, da TOS auch hier
unnîtige Redraws vermeidet. Beim direkten Vergleich zwischen 'Smart Redraw'
und 'TOS Redraw', was hier durchaus im wîrtlichen Sinn als Gegenteil zu
verstehen ist, zeigt sich in ersterem Fall ein wesentlich schnellerer,
ruhigerer und saubererer Bildschirmaufbau, der durchaus mit dem
(!I)Macintosh(!i)-System konkurrieren kann und unter TOS selbst mit Blitter
und 68040 Prozessor in dieser Form nicht mîglich wÑre. Daher wird dringend
empfohlen, diese elegante Lîsung nicht durch Ausnutzen undokumentierter
Eigenschaften des TOS zunichte zu machen.

(!B)Sollten sie Programme benutzen, die das oben beschriebene Fehlverhalten
aufweisen, so sollten sie wie folgt verfahren:(!b)

!begin_itemize !short
!item im MagxConf ACC/CPX den Schalter 'Smart Redraw' deaktivieren
!item beim Autor des betreffenden Programmes anregen, daû dieser Fehler
      umgehend behoben wird.
!end_itemize

Querverweis:
Smart-Redraw ausschalten ~  GEM ~  Style-Guidelines
!end_node



!begin_node Der Task-Manager in MagiC

öber den Task-Manager von MagiC kînnen verschiedene Aufgaben wie z.B. das
Einfrieren, Auftauen oder Beenden von Prozessen ausgefÅhrt werden.
Aufgerufen wird der Manager durch die Tastenkombination Ctrl-Alt-Esc. Nach
dem Aufruf erscheint eine Liste aller im Speicher befindlichen Programme,
die wie folgt aufgebaut ist:

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image taskman
!else
!image (!picture_path)\taskman
!endif
!else
!image (!picture_path)\taskman
!endif

(!B)Hinweis:(!b) Unterhalb dieser Liste befindet sich ein MenÅ, welches eine
Reihe von Kommandos zur Steuerung des Systems zur VerfÅgung stellt. Im
einzelnen:

!begin_xlist !short [prev, next]
!item [Kommando]
Bedeutung
!item [~]
~
!item [Control]
(!nolink [MagiC]) versucht, der gewÑhlten Applikation die Kontrolle Åber Bildschirm und
Maus zu geben - dies kann u.U. bei Deadlocks helfen.
!item [freeze]
Die gewÑhlte Applikation wird eingefroren, sie ist dann fÅr alle anderen
Programme unsichtbar und bekommt keine Rechenzeit.
!item [OK]
zurÅck zum Normalbetrieb, der Taskmanager wird ohne Aktion verlassen.
!item [prev, next]
eine Zeile der obigen Liste ist immer invertiert dargestellt, welche das
ist, kann mittels Cursor hoch/runter eingestellt werden; die folgenden
Kommandos beziehen sich jeweils auf die so festgelegte Applikation.
Applikationen mit einstelligen IDs kînnen auch direkt durch Eingabe der
entsprechenden Ziffer ausgewÑhlt werden.
!item [Switch]
Die Menueleiste der gewÑhlten Applikation wird aktiviert.
!item [Terminate]
Die gewÑhlte Applikation wird unsanft aus dem Speicher geworfen, wobei in
der Regel alle ihre Daten verloren gehen; zuweilen kann das sogar zu
AbstÅrzen fÅhren, diese Funktion sollte also mit besonderer Vorsicht
genossen werden.
!item [unfreeze]
Hiermit werden eingefrorene Applikationen wieder aufgetaut, sie fahren dann
an der Stelle mit ihrer Arbeit fort, an der sie eingefroren wurden.
!end_xlist

Querverweis:
Prozessfunktionen ~
(!link [U:\PROC][Das Verzeichnis U:\PROC])
!end_node



!begin_node Test auf MagiC

!begin_verbatim
/*  Der folgende Code testet ob MagiC installiert ist, und liefert
    einen der folgenden Werte zurÅck:

    -1 = kein MagiC vorhanden
    -2 = MagiC installiert, aber MagiC-AES inaktiv, d.h. MagiC
         wird nur als schnelles Dateisystem benutzt.

    >0 = MagiC vorhanden und MagiC-AES aktiv. Der RÅckgabewert
         enthÑlt die BCD-codierte Versionsnummer. */

GLOBAL WORD InqMagX (VOID)
{
    MAGX_COOKIE *cv;

    if (get_cookie ("MagX", (LONG) &cv))
    {
        if (cv->aesvars)
            return (cv->aesvars->version);
        else
           return (-2);
    }
    else
       return (-1);
} /* InqMagX */
!end_verbatim

(!B)Hinweis:(!b) Programme die im AUTO-Ordner gestartet werden, kînnen mit
Hilfe dieser Routine (!I)nicht(!i) die Versionsnummer von MagiC ermitteln,
da das (!nolink [AES]) zur Bootzeit noch nicht initialisiert ist. In diesem Fall sollte
auf die Funktion DOMagixAESVars zurÅckgegriffen werden.

Querverweis:
Cookie-Jar ~  Cookie- und XBRA-Liste
!end_node



!include magic\threads\threads.u



!begin_node Die Zusatzprogramme fÅr MagiC

Auf der MagiC-Diskette befinden sich eine Reihe von Programmen fÅr
unterschiedliche Zwecke; im einzelnen:

!begin_xlist [Programm]
!item [Programm]
Bedeutung
!item [~]
~

!label ADDMEM
!label Speicher erweitern, internen
!item [ADDMEM]
entspricht dem fÅr TOS notwendigen foldr100 und stellt dem System
zusÑtzlichen Speicher fÅr die interne Verwaltung der Daten zur VerfÅgung.
Die Installation dieses Programmes ist (!I)nicht(!i) zwingend erforderlich,
sollte aber erfolgen, wenn die Meldung 'Kein interner Speicher mehr'
erscheint.

!label APPLICAT
!item [APPLICAT]
Dieses Programm ist gewissermaûen eine ausgelagerte Funktion des MagXDesk,
sollte also nur von letzterem aufgerufen werden, und ist insbesondere nicht
geeignet zum direkten Start per (!nolink [Doppelklick]) auf das Programm-Icon. Es
ermîglicht die Zuordnung von Icons an Dateien sowie das Anmelden von
Applikationen fÅr bestimmte Dateitypen.

!label FLP_PAR
!label Floppy-Parallelbetrieb
!label Parallelbetrieb der Floppy
!item [FLP_PAR]
Mit diesem Programm-Paar kann der Floppy-Parallelbetrieb konfiguriert
werden; es gilt:
!begin_xlist !short
!item [FLP_PAR0 =]
Parallelbetrieb ausschalten
!item [FLP_PAR1 =]
Parallelbetrieb einschalten
!end_xlist

!label HARDCOPY
!label Hardcopy-Routinen installieren
!item [HARDCOPY]
Die interne Hardcopyroutine fÅr 9-Nadel-Epsondrucker ist aus dem BIOS
rausgeflogen. Statt der ALT-Help-Routine, Scrdmp und Prtblk sind nur noch
Dummy-Routinen vorhanden.

Das beiliegende Programm HARDCOPY.PRG installiert die bisher im BIOS
integrierten Hardcopy-Funktionen. Das Programm lÑût sich nur unter (!nolink [MagiC])
starten. (!B)Achtung:(!b) Es hat keine Abfrage auf die MagiC-Version und
darf unter (!nolink [MagiC]) Version 2.0 oder Ñlteren 3.0-Versionen (!I)nicht(!i)
gestartet werden.

!label MAGXBOOT
!label MagiC, Bootprogramme fÅr
!item [MAGXBOOT]
Das Programm liegt in zwei Versionen vor (magxboot.prg und magxboot32.prg).
Die fÅr ihr System geeignete Version dieses Programmes wird in den
Autoordner kopiert und startet bzw. installiert (!nolink [MagiC]) beim Booten; daher
sollte es mîglichst weit vorne im Autoordner stehen, damit alle anderen
Programme auch mitbekommen, daû MagiC lÑuft. Auûerdem geht das Booten dann
schneller, weil Magxboot nach einem Kaltstart zusÑtzlich noch einen
Warmstart auslîst. Der Unterschied zwischen den beiden Startprogrammen ist
der, daû magxboot32 die Datei 'magic.ram' so in den Speicher lÑdt, daû es
per Outside (einer virtuellen Speicherverwaltung), Magx2rom etc. vor dem
öberschreiben durch amoklaufende Programme geschÅtzt werden kann. Dies
funktioniert jedoch nur auf Rechnern ab 68030-Prozessor und PMMU, also
beispielsweise auf Computern der TT- und Falcon-Serie.

!label MAGXCONF
!item [MAGXCONF]
Das CPX-Modul bzw. Accessorie erlaubt die Konfiguration von MagiC in einigen
Punkten. Es bedeuten:
!begin_blist !short []

!label Fastload
!item [Fastload]
(!nl)
Hiermit wird das schnelle Lesen von Disketten eingeschaltet; da es das
Schreiben nicht beeinfluût, kann es eigentlich immer eingeschaltet werden.

!label TOS-KompatibilitÑt
!item [TOS-KompatibilitÑt]
(!nl)
Aufgrund der Tatsache, daû (!nolink [MagiC]) mehrere Programme gleichzeitig laufen
lassen kann, mÅssen strengere Sicherheitsvorkehrungen getroffen werden.
Leider gibt es immer noch Programme, die fehlerhafte Systemaufrufe machen,
was unter UmstÑnden zu Problemen im Multitasking fÅhren kann. Andererseits
verlassen sich einige Programme auf Fehler im TOS und laufen daher nicht
mehr korrekt, wenn sie unter (!nolink [MagiC]) gestartet werden. Daher kînnen ein paar
der Sicherheitsvorkehrungen abgeschaltet werden, um solche Programme zur
Mitarbeit zu Åberreden - da dann natÅrlich die Betriebssicherheit
beeintrÑchtig wird, sollten solche Programme schnellstmîglich gegen neuere
Versionen oder Alternativen ausgetauscht werden.
!label Smart-Redraw ausschalten
!item [Smart Redraw]
(!nl)
(De-)Aktiviert den schnelleren Bildschirmaufbau unter (!nolink [MagiC]). Manche (meist
Ñltere) Programme verlassen sich auf bestimmte Eigenschaften des TOS beim
Fenster-Redraw, die (weil unnîtig oder fehlerhaft) unter (!nolink [MagiC]) nicht mehr
existieren. Um solche Programme zur Mitarbeit zu Åberreden, kann der
elegantere Smart-Redraw Mechanismus von MagiC abgeschaltet werden.
!label Growboxen ausschalten
!label Shrinkboxen ausschalten
!item [Grow- und Shrinkboxen]
(!nl)
Hiermit werden die wachsenden und schrumpfenden Rechtecke ein/ausgeschaltet,
die in manchen Programmen vor dem ôffnen/Schlieûen von Fenstern/Dialogen
erscheinen. Das Abschalten bringt auf manchen Rechnern einen kleinen
Geschwindigkeitsvorteil, hat aber sonst keine Auswirkungen.
!label Hintergrund-DMA ausschalten
!item [Hintergrund-DMA]
(!nl)
öber diesen Schalter kann der Hintergrundbetrieb der Floppy ein- bzw.
ausgeschaltet werden.
!label Pull-Down-MenÅs einschalten
!label Drop-Down-MenÅs ausschalten
!item [Pull-Down-Menues]
(!nl)
Ist dieser Schalter aktiviert, so fallen die Menues erst bei einem Mausklick
herunter, îffnen sich also nicht mehr unerwÅnschterweise, z.B. beim
Verschieben eines Fensters. Dieses Verhalten ist z.B. vom Apple Macintosh
bekannt.
!end_blist

!label MGCOPY
!item [MGCOPY]
Dieses Programm ist gewissermaûen eine ausgelagerte Funktion des MagXDesk,
sollte also nur von letzterem aufgerufen werden, und ist insbesondere nicht
geeignet zum direkten Start per (!nolink [Doppelklick]) auf das Programm-Icon. Das
Programm Åbernimmt das Kopieren und Verschieben von Dateien und Ordnern; der
Aufbau der Kommandozeile bzw. das Format der verschickten Nachrichten ist
nicht dokumentiert und kann sich daher jederzeit Ñndern.

!label MGFORMAT
!label Formatieren im Hintergrund
!item [MGFORMAT]
Mit diesem Programm kînnen Disketten formatiert werden, und zwar
(!I)ohne(!i) das dabei der Rechner blockiert wird. Zum Erstellen des
Bootsektors wird Åbrigens nicht mehr Protobt benutzt; bei 720k-Disketten
wird jetzt ein MSDOS-Format mit 730.112 freien Bytes erzeugt.

!label MGSEARCH
!item [MGSEARCH]
Dieses Programm ist gewissermaûen eine ausgelagerte Funktion des MagXDesk,
sollte also nur von letzterem aufgerufen werden, und ist insbesondere nicht
geeignet zum direkten Start per (!nolink [Doppelklick]) auf das Programm-Icon. Das Tool
stellt einen Dateisucher dar, wie er etwa im TOS 2.06 Desktop eingebaut ist.
Auch dieses Modul ist nicht oder nur bedingt geeignet zum direkten Start per
(!nolink [Doppelklick]) auf das Programmicon, denn die zu durchsuchenden Laufwerke
werden im Desktop eingestellt und beim Direktstart wird nur das aktuelle
Laufwerk durchsucht.

!label SHUTDOWN
!item [SHUTDOWN]
Dies ist dasjenige Programm, welches normalerweise vom Desktop bei der
Auswahl von (!I)Ausschalten(!i) (oder BetÑtigen der Tastenkomination
Alternate-Control-Delete) aufgerufen wird, und dafÅr sorgt, daû alle noch
!label SHUTDOWN.INF
laufenden Applikationen ihre Daten sichern und terminieren. Die Datei
(!I)SHUTDOWN.INF(!i) dient als Konfigurationsdatei fÅr dieses Programm, und
kann neben Kommentaren (eingeleitet durch das Zeichen '#') die folgenden
Kommandos enthalten:
!begin_itemize !short
!item (!B)ignore <prg>:(!b) fÅr unkritische alte Programme. Diese werden
      (!I)nicht(!i) von SHUTDOWN angemahnt, so daû ein Herunterfahren des
      Systems trotzdem mîglich ist. (!B)Vorsicht:(!b) Solche Programme
      sichern ihre Daten nicht, so daû es im Einzelfall sinnvoll sein kann,
      sie von Hand zu beenden (bevor das System heruntergefahren wird).
!item (!B)terminate <prg>:(!b) Sonderfall fÅr XCONTROL. Auf diese Art
      aufgefÅhrte Programme werden 'zwangsterminiert'; fÅr die
      Datensicherheit gilt das unter (!I)ignore(!i) gesagte.
!item (!B)timeout <zeit>:(!b) maximale Reaktionszeit fÅr moderne Programme.
      Ein Wert von 0 steht fÅr 'beliebig lange warten'.
!end_itemize

!label TSLICE
!label Zeitscheiben fÅr Multitasking
!label Multitasking, Zeitscheiben fÅr
!item [TSLICE]
Mit diesem CPX-Modul kann zum einen das preemptive Multitasking abgeschaltet
werden, wonach das System im kooperativen Multitasking lÑuft. Zum anderen
kann hier die ZeitscheibenlÑnge sowie die HintergrundprioritÑt eingestellt
werden. Preemptives Multitasking kann man sich so vorstellen, daû es eine
Uhr gibt, deren Ziffernblatt in lauter gleichgroûe TortenstÅcke unterteilt
wird, die dann an die laufenden Programme verteilt werden.

Der (!B)Parameter Zeitscheibendauer(!b) bestimmt dann die Grîûe der
TortenstÅcke, wÑhlt man sie klein, so finden mehr Wechsel statt, die
natÅrlich auch Zeit kosten, dafÅr wird die Rechenzeit gleichmÑûiger
verteilt; wÑhlt man sie groû, so wird der rechnende Prozeû seltener
unterbrochen, die einzelnen Programme mÅssen aber auch lÑnger warten, bis
sie wieder ein TortenstÅck bekommen, was sich im Extremfall z.B. in
ruckelndem Scrolling zeigen kann.

Der (!B)Parameter HintergrundprioritÑt(!b) legt fest, wieviel mehr
TortenstÅcke das Programm mit dem obersten Fenster erhÑlt, denn dieses wird
offenbar aktuell benutzt und soll daher schneller reagieren, als die im
Hintergrund laufenden Programme.

In der Praxis hat sich eine Zeitscheibendauer von 5-10ms (Millisekunden) und
eine HintergrundprioritÑt von 1:20 bis 1:32 bewÑhrt. Diese Werte kînnen
Åbrigens per _TSL auch direkt in der MAGX.INF-Datei eingestellt werden.

!label VFATCONF
!label VFAT, Konfigurieren bei
!item [VFATCONF]
Mit diesem Programm kann festgelegt werden, auf welchen
Festplattenpartitionen lange Dateinamen im VFAT-Format von Windows95
unterstÅtzt werden sollen. Das Programm lÑuft ab der MagiC-Version 4.02 vom
16.02.96. Weitere Einzelheiten zu VFATCONF kînnen der Originaldokumentation
von (!nolink [MagiC]) entnommen werden.

!label WBDAEMON
!label Writeback-Daemon
!item [WBDAEMON]
Der Writeback-Daemon ist ein Programm, daû die Schreibzugriffe aller
laufenden Applikationen verzîgert und damit das System spÅrbar beschleunigt.

Der Betrieb mit dem Writeback-Daemon ist jetzt prinzipiell sicher, weil er
nicht mehr eingefroren werden kann. Bisher fÅhrte der Start einer
Single-Tasking-Applikation immer dazu, daû der WBDAEMON eingefroren wurde
und bis zum Wiederauftauen der Cache nicht zurÅckgeschrieben wurde. Im
Gegensatz zum Atari, wo dieses Programm nur optional ist, empfiehlt sich der
Einsatz auf einem (!B)Macintosh(!b) ausdrÅcklich: auf dieser Plattform
steigert es nÑmlich Geschwindigkeit (!I)und(!i) Datensicherheit des
Dateisystems.

!label WDIALOG
!item [WDIALOG]
Bei diesem Programm handelt es sich um eine Systemerweiterung, die (!nolink [MagiC])
kompatible AES-Erweiterungen (z.B. Fenster- und Druckdialoge, Listboxen,
Zeichensatzauswahl) auch unter Ñlteren Betriebssystemen zur VerfÅgung
stellt. Die Installation erfolgt durch Kopieren des Programms in den
AUTO-Ordner, und anschlieûenden Neustart des Systems. Nach gÑngigen
Erfahrungen empfiehlt sich eine Reihenfolge im AUTO-Ordner, bei der WDIALOG
(!I)vor(!i) NVDI liegt.

!label XMEN_MGR
!label MenÅfunktionen, erweiterte
!item [XMEN_MGR]
Das Programm ist fÅr die KompatibilitÑt zu den erweiterten MenÅ-Funktionen
von MultiTOS entstanden und muû darum nur bei Bedarf eingesetzt werden. Es
installiert die folgenden Funktionen:
!begin_itemize !short
!item menu_attach
!item menu_istart
!item menu_popup
!item menu_settings
!end_itemize
Die Funktion appl_getinfo liefert bei den entsprechenden Unterfunktionen den
Wert TRUE, wenn dieses Programm installiert ist.
!end_xlist

Querverweis:
MagiC ~  GEM ~  Style-Guidelines
!end_node



!include magic\DFS\dfs.u
!include magic\XFS\xfs.u




!begin_node VFAT-XFS in MagiC

(!nolink [MagiC]) unterstÅtzt ab Version 5.0 ein VFAT-XFS, mit dessen Hilfe sich lange
Dateinamen im Windows95-Format auf dem Atari nutzen lassen.

(!B)Vorteile dieses Konzepts:(!b)

!begin_itemize
!item bestehende Partitionen mÅssen nicht neu formatiert werden; die langen
      Dateinamen stehen also direkt zur VerfÅgung.
!item auf diese Weise erzeugte Dateien kînnen direkt zwischen MagiC und
      Windows95 ausgetauscht werden, und das Bearbeiten der erzeugten
      Dateien ist auch ohne installiertes VFAT-XFS mîglich (wichtig, falls
      z.B. einmal ohne (!nolink [MagiC]) gebootet wird).
!item da VFAT auf dem FAT-Konzept beruht, war eine einfache Implementierung
      ohne nennenswerten Speicherbedarf mîglich.
!end_itemize

(!B)Nachteile dieses Konzepts:(!b)

!begin_itemize
!item VFAT hat alle Probleme von FAT geerbt. So gibt es den bekannten
      Clusterverschnitt z.B. auch unter VFAT.
!item es gibt modernere Konzepte, die sowohl schneller als auch sicherer
      sind.
!item auf dem Atari fehlen derzeit noch Programme, die Volumes mit langen
      Dateinamen reparieren kînnen. Diese mÅssten allen DateinamenseintrÑge
      die unvollstÑndig sind, oder von einem falschen Haupteintrag
      gefolgt werden, lîschen.
!end_itemize

(!B)Technische Beschreibung des VFAT-Systems:(!b)

!begin_verbatim
typedef struct
{
    BYTE   head;       /* Bit 0..4: Nummer, Bit 6: Endofname */
    UBYTE  name1[10];  /* 5 Unicode- Zeichen                 */
    BYTE   attr;       /* Attribut (0x0f)                    */
    BYTE   unused;     /* z.Zt. unbenutzt                    */
    BYTE   chksum;     /* Checksumme des kurzen Namens       */
    UBYTE  name2[12];  /* 6 Unicode- Zeichen                 */
    WORD   stcl;       /* erster Cluster (0)                 */
    UBYTE  name3[4];   /* 2 Unicode-Zeichen                  */
} LDIR;
!end_verbatim

(!B)Hinweis:(!b) Dabei ist (!I)head(!i) beim ersten Eintrag z.B. 0x01, beim
zweiten 0x02 und beim dritten 0x43, wenn der Name drei EintrÑge braucht.

Pro Eintrag kînnen 13 Zeichen abgelegt werden. Die EintrÑge mit dem langen
Dateinamen liegen immer unmittelbar vor dem Haupteintrag. Die Unicode
Zeichen liegen im Intel-Format vor. Im letzten Eintrag werden nach dem
Nullbyte die nicht verwendeten Zeichen mit 0xff,0xff belegt. Die Reihenfolge
der EintrÑge ist umgekehrt, d.h. die letzten 13 Zeichen des langen Namens
liegen physikalisch an erster Stelle. Der letzte Verzeichniseintrag, der mit
gesetztem Bit 6 im Feld (!I)head(!i) gekennzeichnet ist, liegt physikalisch
an erster Stelle.

Die Komponente (!I)stcl(!i) ist immer Null; (!I)chksum(!i) berechnet sich
aus dem kurzen Namen (im internen Format) durch abwechselndes Rechtsrotieren
des bisherigen Ergebnisses und Aufaddieren der 11 Zeichen. Linux verwendet
das Feld (!I)unused(!i), um Flags fÅr Groû-/Kleinschrift abzuspeichern. Die
aktuelle Windows95-Version schreibt jedoch immer Nullen in dieses Feld, und
so verhÑlt sich auch MagiC. Weitere Hinweise:

!begin_itemize
!item das Umbenennen von Dateien bei bis auf Klein-/Groûschrift identischem
      Namen ist mîglich. Beispiel: Durch das Umbenennen von 'test.txt' in
      'TEST.TXT' fÑllt der lange Name automatisch weg.
!item die Umsetzung Unicode <-> ASCII ist entsprechend dem NVDI-Mapping
      implementiert.
!item beim Erzeugen des Kurznamens werden Leerstellen durch Unterstriche
      ersetzt. Beispiel: 'Wassili Kandinsky.app" -> "WASSILI_.APP"
!item das VFAT-XFS kann (egal ob lange Namen zugelassen sind oder nicht)
      auch Ordner innerhalb der Verzeichnisstruktur verschieben.
!end_itemize

Querverweis:
(!link [XFS-Konzept in MagiC] [Das XFS-Konzept von MagiC]) ~  VFATCONF
!end_node

!include magic/sharelib.u

!end_node

!endif
