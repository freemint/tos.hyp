!iflang [english]


!begin_node Shared libraries
!html_name magic_sharelib

(!U)Shared Libraries in (!nolink [MagiC]) from V6.00 onwards(!u)


!begin_itemize !compressed
!item What are shared libraries?
!item Why shared libraries?
!item How do I use a library?
!item How do I write a library?
!end_itemize


(!B)Note:(!b) Shared libraries were introduced already with (!nolink [MagiC]) Version
5.20. Due to a design error, they had to change the format of the
library as of Version 6.00. As different "magic" IDs are used this
can not cause crashes; it's just that the libraries for 6.00 will not
be recognized by the old version 5.20, and vice versa. Due to several
inadequacies in version 5.20 one should in any case only create
libraries for 6.00.


!begin_node What are shared libraries?
!ignore_index

Usually libraries with frequently used procedures are collected in
their own object module and then linked with several programs during
compilation. In that case each program receives a copy of the library,
which is integrated firmly into the PRG file. On the other hand,
shared libraries exist as separate files only once on the hard disk
and can be used by several programs, even simultaneously.

!end_node

!begin_node Why shared libraries?
!ignore_index

Compared to hard-linked libraries, using shared libraries results in
a series of advantages:

!begin_itemize !compressed
!item Saving of storage space on the hard disk. The more programs that
     use the same libraries, the greater the saving.
!item Saving of storage space in main memory (RAM). This only comes
     into play when several programs that use the same library are
     loaded simultaneously.
!item Systematic maintenance by the programmer: For an update it may
     suffice at times just to distribute a new library. All programs
     that use the library will then profit from the update.
     Additionally there will be fewer source texts to maintain. When
     a library has been altered there is no need to newly translate
     all of the programs using it.
!end_itemize

Naturally there are also disadvantages:

!begin_itemize !compressed
!item Program loading takes somewhat longer; however this is so only
     if the library has not been loaded yet.
!item There may be interaction between updates of various programs.
     When exchanging a library, several programs may be affected
     (positively or negatively).
!item During installation of a program the files have to be copied to
     the XTENSION folder (normally in GEMSYS\MAGIC\ of the boot drive)
     or to the first folder specified in the searchlist SLBPATH (from
     (!nolink [MagiC]) 6), so it is no longer possible to establish easily which
     shared library belongs to which program.
     Remedies, for instance:
!begin_itemize !compressed
  !item Only place aliases in the XTENSION folder or the first
        folder specified by the environmental variable SLBPATH (see below)
  !item Leave the shared libraries in a subdirectory of the program
        and merely extend the environmental variable SLBPATH in MAGX.INF by this
        directory (possible from (!nolink [MagiC]) 6 onwards). If no SLBPATH
        variable exists as yet then one has to enter the XTENSION path in it
        first.
!end_itemize
!end_itemize

!end_node

!begin_node How do I use a library?
!ignore_index

To start with, one needs the object module SLB_BIND for calling the
two new DOS functions, for which one has to link the file SLB.H.

For each library used one declares a descriptor of the type SHARED_LIB
and a function pointer of the type SLB_EXEC.

Each library is opened with Slbopen (opening and closing should only
take place in user-mode), during which the following parameters are
passed:
!begin_xlist [char *name ] !compressed
!item [char *name]   The name of the library, in capitals, including the
                     extension (".SLB"). The library name is also the filename.
!item [char *path]   If this parameter is not NULL, then first of
                     all a search will be made for the library
                     (the path must end with '\' in (!nolink [MagiC]) 5.20;
                     this is no longer necessary in (!nolink [MagiC]) 6).
                     The path should be an absolute one, so that
                     the shared library knows where it lies.
                     If the parameter is NULL or the library was
                     not found in the specified path, then a
                     search is made in the XTENSION folder.  (!nl)
                     From (!nolink [MagiC]) 6 onwards the environmental variable
                     SLBPATH will be evaluated. Like PATH it contains
                     a list of search-paths, each separated by ';'.
                     If the variable is defined no additional search
                     will be made in the XTENSION folder.
!item [LONG min_ver]    Minimum required version number of the library. (!nl)
                        If a program needs, say, version 3 but the
                        library present is only version 2, then
                        ERANGE will be returned. The return value will
                        be the actual version number of the library.
!item [SHARED_LIB *sl]  Pointer to the descriptor. When the library
                        is opened the descriptor will be entered here.
!item [SLB_EXEC *fn]    Pointer to the function pointer. When the
                        library is opened the function pointer will
                        be entered here.
!end_xlist
Return values can be:
!begin_preformatted !inside
  >= 0        All OK, version number of the library
  ERANGE      Version number too low
  EACCDN      Library already opened by this process
  EFILNF      Library not found
  ENSMEM      Insufficient memory free
  ...         Other error-codes.
!end_preformatted
The library can now be used and finally closed again with Slbclose.
This is not absolutely necessary as all open libraries are closed
automatically at program termination, but it is good programming
practice. On no account may a library be closed more than once, since
the kernel can not recognize such errors.

Some libraries such as EDITOBJC.SLB, for instance, install new system
calls, in this case the (!nolink [AES]) calls 210..217. For these libraries the
function pointer is not needed. Otherwise all functions of the library
are called via the function pointer. The library call function is
declared in the following way:

!begin_verbatim
 typedef LONG cdecl (*SLB_EXEC)( SHARED_LIB sl, LONG fn,
        WORD nargs, ... );
!end_verbatim

As regretably Pure-C has an error here, I was forced to declare this
functions as 'typedef LONG (*SLB_EXEC)( void , ... );'.
Unfortunately this inhibits all type checking. So take care!

The call expects the following (!B)parameters:(!b)
!begin_preformatted !inside
     The descriptor of the library
     A longword (!) for the function number
     A WORD, that specifies the number of arguments in WORDs
             (i.e. all "..." arguments)
     Further arguments, depending on the function.
!end_preformatted

The best way is to make the call via a macro, which should be defined
in a header file for the library, e.g.:

JPEG.H:

 #define SLBJPEG_WANDELN (a,b) (*slbjpeg_exec)(slbjpeg, 7L, 4, a, b)

With this (!I)slbjpeg_exec(!i) and (!I)slbjpeg(!i) will be ascertained at Slbopen,
7L is the function number for the call WANDELN (convert), 4 describes
the length of the following arguments (<a> and <b> are two pointers
=> 2*4 bytes => 4 WORDs), and (!I)a(!i) and (!I)b(!i) are the arguments of the
function WANDELN.

If the function is not present (the library contains a NULL-pointer
for this function, or the function number is higher than the number of
functions actually present), one will receive EINVFN as the function
result (in fact this only works correctly from (!nolink [MagiC]) 6 onwards).

!end_node


!begin_node How do I write a library?
!ignore_index

For this too there is a sample library SLB_DEMO, which contains all
the required elements and descriptions. The best thing is to copy
SLB_DEMO.C, LIBHEAD.S and SLB_DEMO.PRJ and then modify the files to
suit your requirements. It is most important to ensure that bit 3 of
the flag in the program header of a library is set; one can use
PH_BIT3.TTP for this.

LIBHEAD is the header for a shared library. The pointer to the
function names can be omitted, otherwise it points to a table of
pointers with the names of the library functions. The number of
functions must be stated correctly, as must the table of functions
and the library name, which is identical to the filename. When adding
a function one has to ensure that the function number is adapted
accordingly, and perhaps that the version number is increased.

For publicly available shared libraries one has to ensure that
documented function calls are never altered! They can either be
supplemented with new parameters (the called function can inquire
the number of parameters actually passed), or a new function number
should be used.

NULL-pointers are also permissible for the function pointers; they
return a EINVFN when the function is called.

The following functions for (de-)initialization are obligatory:

(!U)slb_init/slb_exit(!u)

These are called during loading and removal of the library
respectively, and at that in supervisor-mode and in the context
(process) of the library. Typically, slb_init loads a configuration
file, allocates global memory for the library and opens a virtual (!nolink [VDI])
workstation. slb_exit writes back the configuration file, releases
the memory again and closes the (!nolink [VDI]) workstation.

If slb_init opens a file, then the handle can only be accessed again
at slb_exit, as all other calls of the library run in the context of
the calling application.

From (!nolink [MagiC]) 6 onwards the library is passed a normal 'C' character
string in the command line structure which contains the complete path
of the shared library. If the shared library has to load configuration
or RSC files, the path can be extracted and the filename of the
configuration file assembled correspondingly.

If slb_init terminates by reason of a bus error, for instance, then
the caller will get EXCPT as the result of the Slbopen call. In
order to intercept an unplanned termination of the library, the
kernel installs an etv_term handler for the library before calling
slb_init/exit.

(!U)slb_open/slb_close(!u)

These are called at the opening or closing of the library
respectively. Once the library has been opened, the order is:
!begin_verbatim
  slb_init()
  slb_open()
  slb_close()
  slb_exit()
!end_verbatim

Unlike slb_init/slb_exit, slb_open/slb_close run in the context of
the caller and in user-mode, with the user-stack of the caller, even
if the Slbopen call was performed in supervisor-mode.

The library can also allocate memory at slb_open, though this belongs
to the caller and should be released again at slb_close. In order to
permit allocation of this reserved memory to the caller, the library
is also passed the current process descriptor at slb_open, slb_close
and at every function call.

(!B)Warning:(!b) Due to a bug in 5.20, the passing of the (!nolink [PD]) to slb_open and
slb_close only works from (!nolink [MagiC]) 6 onwards.

The kernel ensures that the open/close calls are nested correctly,
i.e. a process can not open a library more than once.

The kernel ensures that the open/close calls are nested correctly,
i.e. a process cannot open a library more than once.

(!U)Functions(!u)

Functions are not obligatory, so a library can hook in system calls
also via the (!nolink [AES]) or DOS that are removed again at termination, yet
generally functions are made available.

A function is called with the following parameters on the stack:
!begin_xlist [WORD nargs ] !compressed
!item [PD *pd]    Process descriptor of the caller, corresponds
                  to the associated slb_open()/close()
!item [LONG fn]   Function number. Practical when several
                  functions are amalgamated (identical
                  function pointers in LIBHEAD)
!item [WORD nargs]  Number of the following arguments, in WORDs. If a
              function has a variable number of parameters, one can
              ascertain the actual number. Very useful for extensions,
              without having to incorporate new functions. (!B)Example:(!b)
              If a function always expects a pointer, but optionally
              also a WORD, it will receive either 2 or 3 as (!I)nargs.(!i)
!item [...]         The remaining parameters
!end_xlist
The functions are executed in the context of the caller and with its
stack. As this call is generally made in user-mode, multitasking will
not be interrupted even for longer operations. Depending on the
function, the function result can be a LONG, a WORD, void etc.

A function may alter registers d0-d2 and a0-a1, all other registers
have to be saved if appropriate. In particular, register a2 must not
be altered, so that Pure-C routines may be called.

!end_node

!begin_node SLB_DEMO.C
!ignore_index
!begin_preformatted !inside
/*
*
* Body of a "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <portab.h>
#include <tos.h>
#include <tosdefs.h>
#pragma warn -par

typedef void *PD;

char *mem;               /* Here global memory */

/*****************************************************************
*
* The init-function is called once during loading the library.
* For this it runs as a process of the library, i.e. files can
* be opened and memory can be reserved that belong to the library
* in each case.
* Warning: The files opened in this way may _NOT_ be accessed
*          by the library functions, because these run in the
*          context of the caller.
*
* Warning: The init-function runs in supervisor mode, as a
*          library generally does not have a user stack.
*          Hence it must not use too much stack space (max. 1kB)
*          and may not run too long (because multitasking is
*          blocked in supervisor mode).
*          But if necessary a user stack can be allocated and one
*          can then switch to user mode.
*
*****************************************************************/

extern LONG cdecl slb_init( void )
{
     mem = Malloc(4096L);
     if     (mem)
          return(E_OK);
     else     return(ENSMEM);
}

/*****************************************************************
*
* The exit-function is called once during releasing the library.
* For this it runs as a process of the library, i.e. files can
* be opened and memory can be reserved that belong to the library
* in each case.
*
* Warning: The exit-function runs in supervisor mode, as a
*          library generally does not have a user stack.
*          Hence it must not use too much stack space (max. 1kB)
*          and may not run too long (because multitasking is
*          blocked in supervisor mode).
*          But if necessary a user stack can be allocated and one
*          can then switch to user mode.
*
*****************************************************************/

extern void cdecl slb_exit( void )
{
     Mfree(mem);
}


/*****************************************************************
*
* The open-function is called once during opening of the library
* by an application process. For this it runs as a process of the
* caller, i.e. files can be opened and memory can be reserved that
* belong to the caller in each case.
*
* The kernel ensures that each process does not open the library
* several times, and that the library is always closed properly.
*
* Warning: The open-function runs in user mode, and actually with
*          the user stack of the caller. This means that the caller,
*          even when running in supervisor mode, always has to make
*          a sufficiently large usp available.
*
*****************************************************************/

extern LONG cdecl slb_open( PD *pd )
{
     return(E_OK);
}


/*****************************************************************
*
* The close-function is called once during closing of the library
* by an application process. For this it runs as a process of the
* caller, i.e. files can be opened and memory can be reserved and
* released, that belongs to the caller in each case.
*
* Warning: The close-function runs in user mode, and actually with
*          the user stack of the caller. This means that the caller,
*          even when running in supervisor mode, always has to make
*          a sufficiently large usp available.
*
*****************************************************************/

extern void cdecl slb_close( PD *pd )
{
}


/*****************************************************************
*
* An example library function.
* It is executed in the context of the caller, and actually with
* the stack of the caller (depending on status usp or ssp).
*
* It is strongly recommended to call the functions of an SLB only in
* user mode, so as to ensure compatibility to later implementations.
*
*****************************************************************/

extern LONG cdecl slb_fn0( PD *pd, LONG fn, WORD nargs, char *s )
{
     Cconws(s);
     Cconws("\r\n Key: ");
     Cconin();
     return(E_OK);
}
!end_preformatted
!end_node

!begin_node LIBHEAD.S
!ignore_index
!begin_preformatted !inside
/*
*
* Header for a "shared library"
* This is used in place of the start-code of PureC
*
* It is _imperative_ to ensure that bit 3 of the flags
* in the program header is set, so that the library
* does not reserve the whole of the available memory.
*
* Warning: The SLB-concept of MagiC 5.20 still had an error,
* which I have fixed in 6.00. For this the makeup had to be
* modified slightly. SLBs for MagiC 6 therefore do not run
* with those for MagiC 5.20 and vice versa.
*
* Andreas Kromke
* 10.2.98
*
*/

     XREF slb_init
     XREF slb_exit
     XREF slb_open
     XREF slb_close
     XREF slb_fn0

     TEXT

DC.L          $70004afc              ; Magical value (5.20: $42674e41)
DC.L          name                   ; Pointer to name of library
DC.L          1                      ; Version number
DC.L          0                      ; Flags, at present 0L
DC.L          slb_init               ; Is called after loading
DC.L          slb_exit               ; Is called before removing
DC.L          slb_open               ; Is called at opening
DC.L          slb_close              ; Is called at closing
DC.L          0                      ; Pointer to procedure name (optional)
DC.L          0,0,0,0,0,0,0,0        ; Unused, always NULL
DC.L          1                      ; Number of functions (5.20: .W)
DC.L          slb_fn0                ; Function #0

name:          DC.B     'DEMO.SLB',0

     END
!end_preformatted
!end_node

!begin_node SLB_DEMO.PRJ
!ignore_index
!begin_preformatted !inside
slb_demo.slb
.L[-S=256]     ; Minimum stack

=

libhead.s      ; Startup code for SLBs
slb_demo.c (slb.h)

pctoslib.lib
pcstdlib.lib
!end_preformatted
!end_node

!begin_node PH_BIT3.TTP
!ignore_index
!begin_preformatted !inside
/*
*
* Program for the manipulation of bit 3 in the program header.
* MagiC needs this bit, which is generally 0, to assign to
* the program only the minimum amount of memory that is needed,
* i.e. only basepage+text+data+symbol+BSS.
* Is needed in particular for all SharedLibraries.
*
* Andreas Kromke
* 25.10.97
*
*/

#include <portab.h>
#include <tos.h>
#include <tosdefs.h>
#include <stdio.h>

/* ProgramHeader, Program header for executable files                   */
/************************************************************************/

typedef struct {
 WORD ph_branch;         /* 0x00: Must be 0x601a */
 LONG ph_tlen;           /* 0x02: Length of TEXT segment */
 LONG ph_dlen;           /* 0x06: Length of DATA segment */
 LONG ph_blen;           /* 0x0a: Length of BSS  segment */
 LONG ph_slen;           /* 0x0e: Length of the symbol table */
 LONG ph_res1;           /* 0x12: Required by PureC */
 LONG ph_prgflags;       /* 0x16:    Bit 0: Don't clear heap */
                         /*          Bit 1: Load into FastRAM */
                         /*          Bit 2: Malloc from FastRAM */
                         /*          Bit 3: Only t+d+b+s (MagiC 5.20) */
                         /*          Bit 4,5,6,7: Memory protection */
                         /*          Bit 8: Unused */
                         /*          Bit 9: Unused */
                         /*          Bit 10: Unused */
                         /*          Bit 11: SharedText (MiNT) */
                         /*          Bit 12: Unused */
                         /*          Bit 13: Unused */
                         /*          Bit 14: Unused */
                         /*          Bit 15: Unused */
                         /*          Bits 31..28: TPA size */
                         /*          (times 128k + 128k: Min. heap size) */
 WORD ph_absflag;        /* 0x1a: Non-zero => do not relocate */
} PH;



WORD main( WORD argc, char *argv[] )
{
     PH ph;
     WORD ret = 0;
     LONG err;
     WORD f;

     for     (argc(--),argv++; argc; argc(--),argv++)
          {
          Cconws("File: ");
          Cconws(*argv);
          err = Fopen(*argv, RMODE_RW);    /* Open for reading + writing */
          f = (WORD) err;                  /* File handle                */
          err = Fread(f, sizeof(PH), &ph);
          if     ((err != sizeof(PH)) || (ph.ph_branch != 0x601a))
               {
               err = EPLFMT;
               goto nextone;
               }
          Fseek(0L, f, 0);                 /* File pointer to the start  */
          ph.ph_prgflags |= 8;             /* Set bit 3                  */
          err = Fwrite(f, sizeof(PH), &ph);

      nextone:
          if     (f > 0)
               Fclose(f);
          if     (err < 0)
               {
               printf(" => Error %ld", err);
               ret = (WORD) err;
               }
          Cconws("\r\n");
          }
     return(ret);
}
!end_preformatted
!end_node

!begin_node SLB_BIND
!ignore_index
(!B)Warning:(!b) The function Slbopen contains an additionnal parameter (!I)param.(!i)
This no longer appears in the SLB.H. Best to just simply inore it.
!begin_preformatted !inside
/*
*
* Binding for the use of a "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <mgx_dos.h>

/*****************************************************************
*
* Opens a "shared lib".
*
* Input:
*     name             Name of the library, including extension
*     path             Search path with '\', optional
*     min_ver          Minimum required version number
* Returns:
*     sl               Library descriptor
*     fn               Function for calling a library function
*     <ret>            Actual version number, or error code
*
*****************************************************************/

LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn,
        LONG param )
{
  return(gemdos(0x16, name, path, min_ver, sl, fn, param));
}


/*****************************************************************
*
* Closes a "shared lib".
*
* Returns:
*     <ret>          EACCDN, if library not opened
*
*****************************************************************/

extern LONG Slbclose( SHARED_LIB sl )

{
  return(gemdos(0x17, sl));
}

!end_preformatted

!end_node

!begin_node SLB.H
!ignore_index

!begin_preformatted !inside
/*
*
* Binding for the use of "shared libraries"
*
* Andreas Kromke
* 22.10.97
* Last change 19.2.99  - SLB_EXEC with cdecl corrected
*
* 19.2.99
* - SLB_EXEC mit cdecl korrigiert
* 20.8.99
* - Slbclose korrigiert
*/

#ifndef LONG
#include <portab.h>
#endif

typedef void *SHARED_LIB;

/* old Version: typedef LONG (*SLB_EXEC)( void , ... );	*/
typedef LONG cdecl (*SLB_EXEC)( SHARED_LIB sl, LONG fn, WORD nargs, ... );

extern LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn );
extern LONG Slbclose( SHARED_LIB sl );
!end_preformatted
!end_node

!end_node

!else

!begin_node Shared Libraries
!html_name magic_sharelib

(!U)Gemeinsame Bibliotheken (Shared Libraries) in (!nolink [MagiC]) ab V6.00(!u)


!begin_itemize !compressed
!item Was sind Shared Libraries?
!item Wozu Shared Libraries?
!item Wie verwende ich eine Shared Libraries?
!item Wie schreibe ich eine Shared Libraries?
!end_itemize


(!B)Hinweis:(!b)
Shared Libraries wurden bereits mit (!nolink [MagiC]) Version 5.20 eingef(!uumlaut)hrt.
Aufgrund eines Designfehlers mu(!sharps)te das Format der Bibliothek ab
Version 6.00 (!aumlaut)ndern. Da unterschiedliche "magische" Kennungen verwendet
werden, kann es aber nicht zu Abst(!uumlaut)rzen kommen, sondern die Bibliotheken
f(!uumlaut)r 6.00 werden lediglich von der alten Version 5.20 nicht erkannt und
umgekehrt. Aufgrund mehrerer Unzul(!aumlaut)nglichkeiten in der Version 5.20
sollten ohnehin nur Bibliotheken f(!uumlaut)r 6.00 erstellt werden.

!begin_node Was sind Shared Libraries?
!ignore_index

Meist werden Bibliotheken mit h(!aumlaut)ufig genutzten Prozeduren in einem
eigenen Objektmodul zusammengefa(!sharps)t und mit mehreren Programmen
zusammengelinkt. Dabei erh(!aumlaut)lt jedes Programm eine Kopie der
Bibliothek, die fest in die PRG-Datei integriert wird.
(!nolink [Shared Libraries]) dagegen existieren als eigene Dateien nur ein
einziges Mal auf der Festplatte und werden von mehreren Programmen,
auch gleichzeitig, verwendet.

!end_node

!begin_node Wozu Shared Libraries?
!ignore_index

Gegen(!uumlaut)ber fest eingelinkten Bibliotheken ergeben sich eine Reihe von
Vorteilen:

!begin_itemize !compressed
!item Speicherplatzersparnis auf der Festplatte. Je mehr Programme
  dieselben Bibliotheken verwenden, desto gr(!oumlaut)(!sharps)er ist die Ersparnis.
!item Speicherplatzersparnis im Hauptspeicher. Dies kommt erst dann zum
  Tragen, wenn mehrere Programme gleichzeitig geladen sind, die
  dieselbe Bibliothek verwenden.
!item Systematische Wartung f(!uumlaut)r den Programmierer: Beim Update gen(!uumlaut)gt es
  mitunter, nur eine neue Bibliothek nachzureichen. Von diesem Update
  profitieren dann alle Programme, die die Bibliothek verwenden.
  Au(!sharps)erdem sind weniger Quelltexte zu warten. Wenn eine Bibliothek
  ver(!aumlaut)ndert wurde, m(!uumlaut)ssen nicht alle Programme, die sie verwenden,
  neu (!uumlaut)bersetzt werden.
!end_itemize

Nat(!uumlaut)rlich gibt es auch Nachteile:

!begin_itemize !compressed
!item Das Programmladen dauert etwas l(!aumlaut)nger. Jedoch nur, wenn die
  Bibliothek noch nicht geladen ist.
!item Es k(!oumlaut)nnen sich Wechselwirkungen von Updates verschiedener Programme
  ergeben. Beim Austausch einer Bibliothek k(!oumlaut)nnen mehrere Programme
  betroffen sein (positiv oder negativ).
!item Bei der Installation eines Programms m(!uumlaut)ssen Dateien in den XTENSION-
  bzw. den ersten in der Suchliste SLBPATH angegebenen Ordner (ab
  (!nolink [MagiC]) 6) kopiert werden, es ist also nicht mehr ohne weiteres
  nachvollziehbar, zu welchem Programm welche Shared Library geh(!oumlaut)rt.
  Abhilfe z.B.:

!begin_itemize !compressed
  !item Nur Aliase in den XTENSION-Ordner bzw. den ersten durch die
    Environment-Variable SLBPATH (s.u.) angegebenen Ordner legen.
  !item (!nolink [Shared Libraries]) in einem Unterverzeichnis des Programms belassen
    und lediglich die Environment-Variable SLBPATH in MAGX.INF
    um dieses Verzeichnis erweitern (ab (!nolink [MagiC]) 6 m(!oumlaut)glich). Falls
    noch keine Variable SLBPATH existiert, mu(!sharps) der XTENSION-Pfad dort
    zun(!aumlaut)chst eingetragen werden.
!end_itemize
!end_itemize

!end_node

!begin_node Wie verwende ich eine Shared Libraries?
!ignore_index

Zun(!aumlaut)chst ben(!oumlaut)tigt man zum Aufruf der beiden neuen DOS-Funktionen das
Objektmodul SLB_BIND, dazu mu(!sharps) man die Datei SLB.H einbinden.

F(!uumlaut)r jede benutzte Bibliothek deklariert man einen Deskriptor vom Typ
SHARED_LIB und einen Funktionszeiger vom Typ SLB_EXEC.

Jede Bibliothek wird mit Slbopen() ge(!oumlaut)ffnet (das (!Oumlaut)ffnen und Schlie(!sharps)en
sollte nur im User-Modus erfolgen), dabei werden folgende Parameter
(!uumlaut)bergeben:
!begin_xlist [char *name ] !compressed
!item [char *name]    Der Name der Bibliothek, in Gro(!sharps)schrift,
          inkl. Extension (".SLB"). Der
          Bibliotheksname ist gleichzeitig Dateiname.
!item [char *path]    Wenn dieser Parameter nicht NULL ist, wird
          hier zuerst nach der Bibliothek gesucht (der
          Pfad mu(!sharps) in (!nolink [MagiC]) 5.20 mit '\' abgeschlossen
          sein; dies ist in (!nolink [MagiC]) 6 nicht mehr n(!oumlaut)tig).
          Der Pfad sollte absolut sein, damit die
          Shared Library wei(!sharps), wo sie liegt.
          Wenn der Parameter NULL ist oder die
          Bibliothek im angegebenen Pfad nicht
          gefunden wurde, wird im XTENSION-Ordner
          gesucht. (!nl)
          Ab (!nolink [MagiC]) 6 wird die Environment-Variable
          SLBPATH ausgewertet. Sie enth(!aumlaut)lt wie PATH eine
          Liste der Suchpfade, jeweils durch ';' getrennt.
          Ist die Variable definiert, wird nicht mehr
          extra im XTENSION-Ordner gesucht.
!item [LONG min_ver]    Minimal notwendige Versionsnummer der
          Bibliothek. (!nl)
          Wenn ein Programm etwa die Version 3
          ben(!oumlaut)tigt, die Bibliothek aber erst Version 2
          ist, wird ERANGE zur(!uumlaut)ckgegeben. Die
          tats(!aumlaut)chliche Versionsnummer der Bibliothek
          wird als R(!uumlaut)ckgabewert geliefert.
!item [SHARED_LIB *sl]    Zeiger auf den Deskriptor. Wenn die
          Bibliothek ge(!oumlaut)ffnet wurde, wird hier der
          Deskriptor eingetragen.
!item [SLB_EXEC *fn]    Zeiger auf den Funktionszeiger. Wenn die
          Bibliothek ge(!oumlaut)ffnet wurde, wird hier der
          Funktionszeiger eingetragen.
!end_xlist
R(!uumlaut)ckgabewert kann sein:
!begin_preformatted !inside
  >= 0        Alles OK, Versionsnummer der Bibliothek.
  ERANGE      Versionsnummer zu niedrig
  EACCDN      Bibliothek schon von diesem Proze(!sharps) ge(!oumlaut)ffnet
  EFILNF      Bibliothek nicht gefunden
  ENSMEM      zuwenig Speicher
  ...         andere Fehlercodes.
!end_preformatted
Die Bibliothek kann nun verwendet und schlie(!sharps)lich mit Slbclose()
wieder geschlossen werden. Dies ist nicht unbedingt notwendig, da
alle ge(!oumlaut)ffneten Bibliotheken bei Programmende automatisch geschlossen
werden, aber es ist guter Programmierstil. Auf keinen Fall darf eine
Bibliothek mehrmals geschlossen werden, der Kernel kann solche Fehler
nicht erkennen.

Einige Bibliotheken, wie z.B. EDITOBJC.SLB, installieren neue
Systemaufrufe, in diesem Fall die AES-Aufrufe 210..217. F(!uumlaut)r diese
Bibliotheken wird der Funktionszeiger nicht ben(!oumlaut)tigt. Ansonsten
werden alle Funktionen der Bibliothek (!uumlaut)ber den Funktionszeiger
aufgerufen. Die Bibliotheks-Aufruf-Funktion ist folgenderma(!sharps)en
deklariert:

!begin_verbatim
 typedef LONG cdecl (*SLB_EXEC)( SHARED_LIB sl, LONG fn,
        WORD nargs, ... );
!end_verbatim

Da leider PureC hier einen Fehler hat, mu(!sharps)te ich die Funktion
notgedrungen deklarieren als "typedef LONG (*SLB_EXEC)( void , ... );"
Damit sind leider alle Typ(!uumlaut)berpr(!uumlaut)fungen verbaut. Also Vorsicht!

Der Aufruf erwartet folgende Parameter:
!begin_preformatted !inside
     Den Deskriptor der Bibliothek
     Ein Langwort (!) f(!uumlaut)r die Funktionsnummer
     Ein WORD, das die Anzahl der Argumente in WORDs
               (d.h. alle "..."-Argumente) angibt
     weitere Argumente je nach Funktion
!end_preformatted

Am besten geschieht der Aufruf (!uumlaut)ber ein Makro, das in einer Headerdatei
f(!uumlaut)r die Bibliothek definiert werden sollte, z.B.:

JPEG.H:

 #define SLBJPEG_WANDELN (a,b) (*slbjpeg_exec)(slbjpeg, 7L, 4, a, b)

Hierbei werden <slbjpeg_exec> und <slbjpeg> bei Slbopen() ermittelt,
7L ist die Funktionsnummer f(!uumlaut)r den Aufruf WANDELN, 4 bezeichnet die
L(!aumlaut)nge der folgenden Argumente (a und b sind zwei Zeiger => 2*4 Bytes
=> 4 WORDs), a und b sind die Argumente der Funktion WANDELN.

Wenn die Funktion nicht vorhanden ist (die Bibliothek enth(!aumlaut)lt f(!uumlaut)r
diese Funktion einen Nullzeiger, oder die Funktionsnummer ist h(!oumlaut)her
als die Anzahl der tats(!aumlaut)chlich vorhandenen Funktionen), erh(!aumlaut)lt man
EINVFN als Funktionsergebnis (tats(!aumlaut)chlich klappt das erst ab (!nolink [MagiC]) 6
korrekt).

!end_node

!begin_node Wie schreibe ich eine Shared Libraries?
!ignore_index

Auch dazu gibt es eine Beispielbibliothek SLB_DEMO, die alle
notwendigen Elemente und Beschreibungen enth(!aumlaut)lt.
Am besten, man kopiert SLB_DEMO.C, LIBHEAD.S und SLB_DEMO.PRJ und
modifiziert die Dateien entsprechend. Es mu(!sharps) dringend darauf geachtet
werden, da(!sharps) Bit 3 der Flags im Programmheader einer Bibliothek
gesetzt ist, dazu kann man PH_BIT3.TTP verwenden.

LIBHEAD ist der Header f(!uumlaut)r eine Shared Library. Der Zeiger auf die
Funktionsnamen kann entfallen, ansonsten zeigt er auf eine Tabelle
von Zeigern mit den Namen der Bibliotheksfunktionen.
Die Anzahl der Funktionen mu(!sharps) korrekt festgelegt werden, ebenso die
Tabelle der Funktionen und der Bibliotheksname, welcher mit dem
Dateinamen identisch ist.
Beim Hinzuf(!uumlaut)gen von Funktionen mu(!sharps) darauf geachtet werden, die
Funktionsanzahl entsprechend anzupassen und ggf. die Versionsnummer
zu erh(!oumlaut)hen.

Bei (!oumlaut)ffentlich zug(!aumlaut)nglichen Shared Libraries ist sicherzustellen, da(!sharps)
dokumentierte Funktionsaufrufe nie ge(!aumlaut)ndert werden! Entweder sind neue
Parameter zu erg(!aumlaut)nzen (die aufgerufene Funktion kann die Anzahl der
tats(!aumlaut)chlich (!uumlaut)bergebenen Parameter abfragen), oder es ist eine neue
Funktionsnummer zu verwenden.

F(!uumlaut)r die Funktionszeiger sind auch Nullzeiger zul(!aumlaut)ssig, sie geben beim
Aufruf der Funktion ein EINVFN.

Folgende Funktionen zur (De-) Initialisierung sind obligatorisch:

(!U)slb_init()/slb_exit()(!u)

Werden beim Laden bzw. Entfernen der Bibliothek aufgerufen, und zwar
im Supervisor-Modus und im Kontext (Proze(!sharps)) der Bibliothek.
Typischerweise l(!aumlaut)dt slb_init() eine Konfigurationsdatei, alloziert
globalen Speicher f(!uumlaut)r die Bibliothek und (!oumlaut)ffnet eine virtuelle VDI-
Workstation. slb_exit() schreibt die Konfigurationsdatei zur(!uumlaut)ck, gibt
den Speicher wieder frei und schlie(!sharps)t die (!nolink [VDI])-Workstation.

Falls slb_init() eine Datei (!oumlaut)ffnet, darf auf das Handle erst wieder
bei slb_exit() zugegriffen werden, da alle anderen Aufrufe der
Bibliothek im Kontext des Aufrufers ablaufen.

Ab (!nolink [MagiC]) 6 erh(!aumlaut)lt die Bibliothek in der Kommandozeilen-Struktur der
Basepage eine normale 'C'-Zeichenkette (!uumlaut)bergeben, welche den
vollst(!aumlaut)ndigen Pfad der SharedLibrary enth(!aumlaut)lt. Falls die SharedLibrary
Konfigurations- oder RSC-Dateien laden mu(!sharps), kann der Pfad extrahiert
und der Dateiname der Konfigurationsdatei entsprechend
zusammengebastelt werden.

Falls slb_init() z.B. aufgrund eines Busfehlers beendet wird, erh(!aumlaut)lt
der Aufrufer EXCPT als Ergebnis des Slbopen()-Aufrufs. Um die
unplanm(!aumlaut)(!sharps)ige Terminierung der Bibliothek abzufangen, installiert der
Kernel vor Aufruf von slb_init()/exit() einen etv_term-Handler f(!uumlaut)r
die Bibliothek.

(!U)slb_open()/slb_close()(!u)

Werden beim (!Oumlaut)ffnen bzw. Schlie(!sharps)en der Bibliothek aufgerufen. Wenn die
Bibliothek nur einmal ge(!oumlaut)ffnet wird, ist die Reihenfolge:
!begin_verbatim
  slb_init()
  slb_open()
  slb_close()
  slb_exit()
!end_verbatim

Im Gegensatz zu slb_init()/slb_exit() laufen slb_open()/slb_close()
im Kontext des Aufrufers und im Usermodus mit dem Userstack des
Aufrufers ab, auch dann, wenn der Slbopen()-Aufruf im Supervisor-Modus
erfolgt ist.

Die Bibliothek kann auch bei slb_open Speicher allozieren, dieser
geh(!oumlaut)rt jedoch dem Aufrufer und sollte bei slb_close() wieder
freigegeben werden. Um die Zuordnung von alloziertem Speicher zum
Aufrufer zu erm(!oumlaut)glichen, wird der Bibliothek bei slb_open(),
slb_close() und bei jedem Funktionsaufruf der aktuelle Proze(!sharps)-
Deskriptor mit (!uumlaut)bergeben.

(!B)Achtung:(!b) Die (!Uumlaut)bergabe des (!nolink [PD]) an slb_open() und slb_close() geht
      aufgrund eines Bugs in 5.20 erst ab (!nolink [MagiC]) 6.

Der Kernel stellt sicher, da(!sharps) die open/close Aufrufe korrekt
geschachtelt sind, d.h. ein Proze(!sharps) kann eine Bibliothek nicht
mehrmals (!oumlaut)ffnen.

(!U)Funktionen(!u)

Funktionen sind nicht obligatorisch, so kann eine Bibliothek auch
Systemaufrufe (!uumlaut)ber AES oder DOS einh(!aumlaut)ngen, die nach Beendigung wieder
entfernt werden, i.a. werden jedoch Funktionen zur Verf(!uumlaut)gung gestellt.

Eine Funktion wird mit folgenden Parametern auf dem Stack aufgerufen:
!begin_xlist [WORD nargs ] !compressed
!item [PD *pd]    Proze(!sharps)-Deskriptor des Aufrufers, korrespondiert
        mit dem zugeh(!oumlaut)rigen slb_open()/close()
!item [LONG fn]   Funktionsnummer. Praktisch, wenn mehrere
        Funktionen zusammengelegt sind (identische
        Funktionszeiger in LIBHEAD)
!item [WORD nargs]  Anzahl der folgenden Argumente, in WORDs. Hat
        eine Funktion eine variable Anzahl von
        Parametern, kann die tats(!aumlaut)chliche Anzahl
        ermittelt werden. Sehr praktisch bei
        Erweiterungen, ohne neue Funktionen einzubauen.
        Beispiel: Erwartet eine Funktion immer einen
        Zeiger, optional aber noch ein WORD, erh(!aumlaut)lt sie
        entweder 2 oder 3 als <nargs>.
!item [...]     die (!uumlaut)brigen Parameter
!end_xlist
Die Funktionen werden im Kontext des Aufrufers und mit dessen Stack
ausgef(!uumlaut)hrt. Da dieser Aufruf i.a. im User-Modus erfolgt, wird das
Multitasking auch bei l(!aumlaut)ngeren Aktionen nicht unterbrochen. Das
Funktions-Ergebnis kann je nach Funktion LONG, WORD, void usw. sein.

Eine Funktion darf die Register d0-d2 und a0-a1 (!aumlaut)ndern, alle anderen
Register m(!uumlaut)ssen ggf. gerettet werden. Insbesondere darf Register a2
nicht ver(!aumlaut)ndert werden, damit Routinen von PureC aus aufgerufen werden
k(!oumlaut)nnen.

!end_node

!begin_node SLB_DEMO.C
!ignore_index
!begin_preformatted !inside
/*
*
* Rumpf einer "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <portab.h>
#include <tos.h>
#include <tosdefs.h>
#pragma warn -par

typedef void *PD;

char *mem;      /* hier globalen Speicher */

/*****************************************************************
*
* Die init-Funktion wird einmal beim Laden der Bibliothek
* aufgerufen. Dabei l(!aumlaut)uft sie im Proze(!sharps) der Bibliothek,
* d.h. es k(!oumlaut)nnen Dateien ge(!oumlaut)ffnet und Speicher angefordert
* werden, die jeweils der Bibliothek geh(!oumlaut)ren.
* Achtung: Auf die dabei ge(!oumlaut)ffneten Dateien darf durch die
*          Bibliotheksfunktionen _NICHT_ zugegriffen werden,
*          weil diese im Kontext des Aufrufers laufen.
*
* Achtung: Die init-Funktion l(!aumlaut)uft im Supervisormode, da eine
*          Bibliothek i.a. keinen Userstack hat.
*          Daher darf sie nicht zuviel Stack benutzen (max. 1kB)
*          und nicht zu lange laufen (weil das Multitasking
*          im Supervisormode blockiert ist).
*          Ggf. kann aber ein Userstack alloziert und in den
*          Usermode gewechselt werden.
*
*****************************************************************/

extern LONG cdecl slb_init( void )
{
  mem = Malloc(4096L);
  if  (mem)
    return(E_OK);
  else  return(ENSMEM);
}

/*****************************************************************
*
* Die exit-Funktion wird einmal beim Freigeben der Bibliothek
* aufgerufen. Dabei l(!aumlaut)uft sie im Proze(!sharps) der Bibliothek,
* d.h. es k(!oumlaut)nnen Dateien ge(!oumlaut)ffnet und Speicher angefordert
* werden, die jeweils der Bibliothek geh(!oumlaut)ren.
*
* Achtung: Die exit-Funktion l(!aumlaut)uft im Supervisormode, da eine
*          Bibliothek i.a. keinen Userstack hat.
*          Daher darf sie nicht zuviel Stack benutzen (max. 1kB)
*          und nicht zu lange laufen (weil das Multitasking
*          im Supervisormode blockiert ist).
*          Ggf. kann aber ein Userstack alloziert und in den
*          Usermode gewechselt werden.
*
*****************************************************************/

extern void cdecl slb_exit( void )
{
  Mfree(mem);
}


/*****************************************************************
*
* Die open-Funktion wird einmal beim (!Oumlaut)ffnen der Bibliothek
* durch einen Anwenderproze(!sharps) aufgerufen. Dabei l(!aumlaut)uft sie im
* Proze(!sharps) des Aufrufers, d.h. es k(!oumlaut)nnen Dateien ge(!oumlaut)ffnet und
* Speicher angefordert werden, die jeweils dem Aufrufer geh(!oumlaut)ren.
*
* Durch den Kernel ist sichergestellt, da(!sharps) jeder Proze(!sharps) die
* Bibliothek nicht mehrmals (!oumlaut)ffnet und da(!sharps) die Bibliothek immer
* ordnungsgem(!aumlaut)(!sharps) geschlossen wird.
*
* Achtung: Die open-Funktion l(!aumlaut)uft im Usermode, und zwar mit dem
*          Userstack des Aufrufers. Das hei(!sharps)t, da(!sharps) der Aufrufer,
*          auch wenn er im Supervisormode l(!aumlaut)uft, immer einen
*          ausreichend gro(!sharps)en usp zur Verf(!uumlaut)gung stellen mu(!sharps).
*
*****************************************************************/

extern LONG cdecl slb_open( PD *pd )
{
  return(E_OK);
}


/*****************************************************************
*
* Die close-Funktion wird einmal beim Schlie(!sharps)en der Bibliothek
* durch einen Anwenderproze(!sharps) aufgerufen. Dabei l(!aumlaut)uft sie im
* Proze(!sharps) des Aufrufers, d.h. es k(!oumlaut)nnen Dateien ge(!oumlaut)ffnet bzw.
* geschlossen und Speicher angefordert und freigegeben  werden,
* die jeweils dem Aufrufer geh(!oumlaut)ren.
*
* Achtung: Die close-Funktion l(!aumlaut)uft im Usermode, und zwar mit dem
*          Userstack des Aufrufers. Das hei(!sharps)t, da(!sharps) der Aufrufer,
*          auch wenn er im Supervisormode l(!aumlaut)uft, immer einen
*          ausreichend gro(!sharps)en usp zur Verf(!uumlaut)gung stellen mu(!sharps).
*
*****************************************************************/

extern void cdecl slb_close( PD *pd )
{
}


/*****************************************************************
*
* Eine Beispiel-Bibliotheksfunktion.
* Sie wird im Kontext des Aufrufers ausgef(!uumlaut)hrt, und zwar mit dem
* Stack des Aufrufers (je nach Status usp oder ssp).
*
* Es wird dringend empfohlen, die Funktionen einer SLB nur im
* Usermode aufzurufen, um die Kompatibilit(!aumlaut)t zu sp(!aumlaut)teren
* Implementationen zu wahren.
*
*****************************************************************/

extern LONG cdecl slb_fn0( PD *pd, LONG fn, WORD nargs, char *s )
{
  Cconws(s);
  Cconws("\r\nTaste: ");
  Cconin();
  return(E_OK);
}
!end_preformatted
!end_node

!begin_node LIBHEAD.S
!ignore_index
!begin_preformatted !inside
/*
*
* Header f(!uumlaut)r eine "shared library"
* Wird statt des Start-Codes von PureC verwendet
*
* Andreas Kromke
* 10.2.98
*
*/

  XREF slb_init
  XREF slb_exit
  XREF slb_open
  XREF slb_close
  XREF slb_fn0

  TEXT

DC.L    $70004afc         ; magischer Wert (5.20: $42674e41)
DC.L    name              ; Zeiger auf Namen der Bibliothek
DC.L    1                 ; Versionsnummer
DC.L    0                 ; Flags, z.Zt. 0L
DC.L    slb_init          ; wird nach dem Laden aufgerufen
DC.L    slb_exit          ; wird vor dem Entfernen aufgerufen
DC.L    slb_open          ; wird beim (!Oumlaut)ffnen aufgerufen
DC.L    slb_close         ; wird beim Schlie(!sharps)en aufgerufen
DC.L    0                 ; Zeiger auf Prozedurnamen (optional)
DC.L    0,0,0,0,0,0,0,0   ; unbenutzt, immer NULL
DC.L    1                 ; Anzahl der Funktionen (5.20: .W)
DC.L    slb_fn0           ; Funktion #0

name:   DC.B  'DEMO.SLB',0

END
!end_preformatted
!end_node

!begin_node SLB_DEMO.PRJ
!ignore_index
!begin_preformatted !inside
slb_demo.slb
.L[-S=256]     ; minimaler Stack

=

libhead.s      ; startup code for SLBs
slb_demo.c (slb.h)

pctoslib.lib
pcstdlib.lib
!end_preformatted
!end_node

!begin_node PH_BIT3.TTP
!ignore_index
!begin_preformatted !inside
/*
*
* Programm zur Manipulation des Bit 3 im Programmheader.
* MagiC ben(!oumlaut)tigt dieses Bit, das i.a. Null ist, daf(!uumlaut)r, um
* dem Programm nur den minimal notwendigen Speicher zuzuweisen,
* d.h. nur Basepage+Text+Daten+Symbol+Bss.
* Wird insbesondere f(!uumlaut)r alle SharedLibraries ben(!oumlaut)tigt.
*
* Andreas Kromke
* 25.10.97
*
*/

#include <portab.h>
#include <tos.h>
#include <tosdefs.h>
#include <stdio.h>

/* ProgramHeader, Programmkopf f(!uumlaut)r ausf(!uumlaut)hrbare Dateien                  */
/************************************************************************/

typedef struct {
 WORD ph_branch;         /* 0x00: mu(!sharps) 0x601a sein            */
 LONG ph_tlen;           /* 0x02: L(!aumlaut)nge  des TEXT - Segments */
 LONG ph_dlen;           /* 0x06: L(!aumlaut)nge  des DATA - Segments */
 LONG ph_blen;           /* 0x0a: L(!aumlaut)nge  des BSS  - Segments */
 LONG ph_slen;           /* 0x0e: L(!aumlaut)nge  der Symboltabelle   */
 LONG ph_res1;           /* 0x12: von PureC ben(!oumlaut)tigt         */
 LONG ph_prgflags;       /* 0x16:  Bit 0: Heap nicht l(!oumlaut)schen */
                         /*        Bit 1: Laden ins FastRAM  */
                         /*        Bit 2: Malloc aus FastRAM */
                         /*        Bit 3: nur t+d+b+s (MagiC 5.20) */
                         /*        Bit 4,5,6,7: Speicherschutz (MiNT) */
                         /*        Bit 8: unbenutzt          */
                         /*        Bit 9: unbenutzt          */
                         /*        Bit 10: unbenutzt         */
                         /*        Bit 11: SharedText (MiNT) */
                         /*        Bit 12: unbenutzt         */
                         /*        Bit 13: unbenutzt         */
                         /*        Bit 14: unbenutzt         */
                         /*        Bit 15: unbenutzt         */
                         /*        Bits 31..28: TPA-Size     */
                         /*         (mal 128k + 128k: Mindestgr. Heap */
 WORD ph_absflag;        /* 0x1a: ungleich Null => nicht relozieren */
} PH;



WORD main( WORD argc, char *argv[] )
{
     PH ph;
     WORD ret = 0;
     LONG err;
     WORD f;

     for  (argc(--),argv++; argc; argc(--),argv++)
          {
          Cconws("Datei: ");
          Cconws(*argv);
          err = Fopen(*argv, RMODE_RW); /* zum Lesen+Schreiben (!oumlaut)ffnen */
          f = (WORD) err;     /* Datei-Handle */
          err = Fread(f, sizeof(PH), &ph);
          if   ((err != sizeof(PH)) || (ph.ph_branch != 0x601a))
               {
               err = EPLFMT;
               goto nextone;
               }
          Fseek(0L, f, 0);         /* Dateizeiger an den Anfang */
          ph.ph_prgflags |= 8;     /* Bit 3 setzen */
          err = Fwrite(f, sizeof(PH), &ph);

      nextone:
          if   (f > 0)
               Fclose(f);
          if   (err < 0)
               {
               printf(" => Fehler %ld", err);
               ret = (WORD) err;
               }
          Cconws("\r\n");
          }
     return(ret);
}
!end_preformatted
!end_node

!begin_node SLB_BIND
!ignore_index
(!B)Achtung:(!b) Die Funktion Slbopen enth(!aumlaut)lt einen zus(!aumlaut)tzliche
       Parameter (!I)param(!i). Dieser taucht in der SLB.H nicht mehr auf.
       Am besten einfach ignorieren.
!begin_preformatted !inside
/*
*
* Binding f(!uumlaut)r die Benutzung einer "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <mgx_dos.h>

/*****************************************************************
*
* (!Oumlaut)ffnet eine "shared lib".
*
* Eingabe:
* name      Name der Bibliothek inkl. Extension.
* path      Suchpfad mit '\', optional
* min_ver   Minimale ben(!oumlaut)tigte Versionsnummer
* R(!uumlaut)ckgabe:
* sl        Bibliotheks-Deskriptor
* fn        Funktion zum Aufruf einer Bibliotheksfunktion
* <ret>     tats(!aumlaut)chliche Versionsnummer oder Fehlercode
*
*****************************************************************/

LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn,
        LONG param )
{
  return(gemdos(0x16, name, path, min_ver, sl, fn, param));
}


/*****************************************************************
*
* Schlie(!sharps)t eine "shared lib".
*
* R(!uumlaut)ckgabe:
* <ret>   EACCDN, falls Lib nicht ge(!oumlaut)ffnet
*
*****************************************************************/

extern LONG Slbclose( SHARED_LIB sl )

{
  return(gemdos(0x17, sl));
}

!end_preformatted

!end_node

!begin_node SLB.H
!ignore_index

!begin_preformatted !inside
/*
*
* Binding f(!uumlaut)r Verwendung von "shared libraries"
*
* Andreas Kromke
* 22.10.97
*
* 19.2.99
* - SLB_EXEC mit cdecl korrigiert
* 20.8.99
* - Slbclose korrigiert
*/

#ifndef LONG
#include <portab.h>
#endif

typedef void *SHARED_LIB;

/* alte Version: typedef LONG (*SLB_EXEC)( void , ... );	*/
typedef LONG cdecl (*SLB_EXEC)( SHARED_LIB sl, LONG fn, WORD nargs, ... );

extern LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn );
extern LONG Slbclose( SHARED_LIB sl );
!end_preformatted
!end_node

!end_node


!endif
