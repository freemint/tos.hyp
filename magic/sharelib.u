## Hypertext zum TOS-Betriebssystem
## entwickelt fÅr den ST-Guide
##
## Last Edit: 01.05.2002
##
## Kapitel x: Shared Libraries in MagiC ab V6.00

!iflang [english]


!begin_node Shared Libraries

(!U)Shared Libraries in (!nolink [MagiC]) from V6.00 onwards(!u)


!begin_itemize !short
!item What are shared libraries?
!item Why shared libraries?
!item How do I use a library?
!item How do I write a library?
!end_itemize


(!B)Note:(!b)
Shared libraries were introduced already with (!nolink [MagiC]) version 5.20. Due to
a design error had to change the format of the library from version
6.00 onwards. As different "magic" IDs are used this can not cause 
crashes; it's just that the libraries for 6.00 will not be recognised by the
old version 5.20, and vice versa. Due to several inadequacies in version 5.20
one should in any case only create libraries for 6.00.


!begin_node What are shared libraries?

Usually libraries with frequently used procedures are collected in 
their own object module and then linked with several programs during
compilation. In that case each program receives a copy of the library, 
which is integrated firmly into the PRG file.
Shared libraries, on the other hand, exist as separate files only once 
on the hard disk and can be used by several programs, even simultaneously.

!end_node

!begin_node Why shared libraries?

Compared to hard-linked libraries this results in a series of advantages:

!begin_itemize !short
!item Saving of storage space on the hard disk. The more programs that 
  use the same libraries, the greater the saving.
!item Saving of storage space in main memory (RAM). This only comes into 
  play when several programs that use the same library are loaded 
  simultaneously.
!item Systematic maintenance by the programmer: For an update it may suffice 
  at times just to distribute a new library. All programs that use the 
  library will then profit from the update.   
  Additionally there will be fewer source texts to maintain. When a 
  library has been altered there is no need to newly translate all 
  programs that use it.
!end_itemize

Naturally there are also disadvantages:

!begin_itemize !short
!item Program loading takes somewhat longer; however this is so only if 
  the library has not been loaded yet.
!item There may be interaction between updates of various programs. When 
  exchanging a library, several programs may be affected (positively 
  or negatively).
!item During installation of a program the files have to be copied to the 
  XTENSION folder or to the first folder specified in the searchlist 
  SLBPATH (from (!nolink [MagiC]) 6), so it is no longer possible to establish 
  easily which shared library belongs to which program. 
	Remedies, for instance:
!begin_itemize !short
  !item Only place aliases in the XTENSION folder or the first folder 
       specified by the environmental variable SLBPATH (see below).
  !item Leave the shared libraries in a subdirectory of the program and
       merely extend the environmental variable SLBPATH in MAGX.INF by 
       this directory (possible from (!nolink [MagiC]) 6 onwards). If no SLBPATH 
       variable exists as yet then one has to enter the XTENSION path 
       in it first.
!end_itemize
!end_itemize

!end_node

!begin_node How do I use a library?

To start with, one needs the object module SLB_BIND for calling the 
two new DOS functions, for which one has to link the file SLB.H.

For each library used one declares a descriptor of the type SHARED_LIB 
and a function pointer of the type SLB_EXEC.

Each library is opened with Slbopen() (opening and closing should only  
take place in user-mode), during which the following parameters are 
passed:
!begin_xlist [char *name ] !short
!item [char *name]   The name of the library, in capitals, including the
										 extension (".SLB"). The library name is also the filename.
!item [char *path]   If this parameter is not NULL, then first of 
                     all a search will be made for the library 
                     (the path must end with '\' in (!nolink [MagiC]) 5.20; 
                     this is no longer necessary in (!nolink [MagiC]) 6).
                     The path should be an absolute one, so that 
                     the shared library knows where it lies.
                     If the parameter is NULL or the library was 
                     not found in the specified path, then a 
                     search is made in the XTENSION folder.  (!nl)
                     From (!nolink [MagiC]) 6 onwards the environmental variable
                     SLBPATH will be evaluated. Like PATH it contains
                     a list of search-paths, each separated by ';'.
                     If the variable is defined no additional search 
                     will be made in the XTENSION folder.
!item [LONG min_ver]    Minimum required version number of the library. (!nl)
                        If a program needs, say, version 3 but the 
                        library present is only version 2, then 
                        ERANGE will be returned. The return value will
                        be the actual version number of the library. 
!item [SHARED_LIB *sl]  Pointer to the descriptor. When the library 
                        is opened the descriptor will be entered here.
!item [SLB_EXEC *fn]    Pointer to the function pointer. When the 
                        library is opened the function pointer will 
                        be entered here.
!end_xlist
Return values can be:
!begin_verbatim
  >= 0        All OK, version number of the library
  ERANGE      Version number too low
  EACCDN      Library already opened by this process
  EFILNF      Library not found
  ENSMEM      Insufficient memory free
  ...         Other error-codes.
!end_verbatim
The library can now be used and finally closed again with Slbclose(). 
This is not absolutely necessary as all open libraries are closed 
automatically at program termination, but it is good programming practice.
On no account may a library be closed more than once, since the kernel 
can not recognise such errors.

Some libraries such as EDITOBJC.SLB, for instance, install new system 
calls, in this case the AES calls 210..217. For these libraries the 
function pointer is not needed. Otherwise all functions of the library 
are called via the function pointer.
The library call function is declared in the following way:

!begin_verbatim
 typedef LONG (cdecl *SLB_EXEC)( SHARED_LIB *sl, LONG fn,
        WORD nargs, ... );
!end_verbatim

As unfortunately PureC has an error here, I was forced to declare 
this functions as "typedef LONG (*SLB_EXEC)( void , ... );" 
This unfortunately inhibits all type checking. So take care!

The call expects the following parameters:
!begin_verbatim
     The descriptor of the library
     A longword (!) for the function number
     A WORD, that specifies the number of arguments in WORDs
             (i.e. all "..." arguments)
     Further arguments, depending on the function.
!end_verbatim

The best way is to make the call via a macro, which should be defined 
in a header file for the library, e.g.:

JPEG.H:

#define SLBJPEG_WANDELN (a,b) (*slbjpeg_exec)(slbjpeg, 7L, 4, a, b)

With this <slbjpeg_exec> and <slbjpeg> will be ascertained at Slbopen(), 
7L is the function number for the call WANDELN (convert), 4 describes the 
length of the following arguments (a and b are two pointers => 2*4 bytes 
=> 4 WORDs), and a and b are the arguments of the function WANDELN.

If the function is not present (the library contains a null-pointer for 
this function, or the function number is higher than the number of 
functions actually present), one will receive EINVFN as the function 
result (in fact this only works correctly from (!nolink [MagiC]) 6 onwards).

!end_node


!begin_node How do I write a library?

For this too there is a sample library SLB_DEMO, which contains all the 
required elements and descriptions.
The best thing is to copy SLB_DEMO.C, LIBHEAD.S and SLB_DEMO.PRJ and 
then modify the files to suit your requirements. It is most important 
to ensure that bit 3 of the flag in the program header of a library is  
set; one can use PH_BIT3.TTP for this.

LIBHEAD is the header for a shared library. The pointer to the function 
names can be omitted, otherwise it points to a table of pointers with 
the names of the library functions.
The number of functions must be stated correctly, as must the table of 
functions and the library name, which is identical to the filename.
When adding a functions one has to ensure that the function number is 
adapted accordingly, and perhaps that the version number is increased.

For publicly available shared libraries one has to ensure that documented 
function calls are never altered! They can either be supplemented with 
new parameters (the called function can inquire the number of parameters 
actually passed), or a new function number should be used.

Null-pointers are also permissible for the function pointers; they return 
a EINVFN when the function is called.

The following functions for (de-)initialisation are obligatory:

(!U)slb_init()/slb_exit()(!u)

These are called during loading and removal of the library respectively, 
and at that in supervisor mode and in the context (process) of the library.
Typically, slb_init() loads a configuration file, allocates global 
memory for the library and opens a virtual VDI workstation. slb_exit() 
writes back the configuration file, releases the memory again and closes 
the (!nolink [VDI]) workstation.

If slb_init() opens a file, then the handle can only be accessed again 
at slb_exit(), as all other calls of the library run in the context of 
the calling application.
                                                                  
From (!nolink [MagiC]) 6 onwards the library is passed a normal 'C' character string
in the command line structure which contains the complete path of the 
shared library. If the shared library has to load configuration or RSC 
files, the path can be extracted and the filename of the configuration 
file assembled correspondingly.

If slb_init() terminates by reason of a bus error, for instance, then 
the caller will get EXCPT as the result of the Slbopen() call. In order 
to intercept an unplanned termination of the library, the kernel installs 
an etv_term handler for the library before calling slb_init()/exit().


(!U)slb_open()/slb_close()(!u)

These are called at the opening or closing of the library respectively.
Once the library has been opened, the order is:
!begin_verbatim
  slb_init()
  slb_open()
  slb_close()
  slb_exit()
!end_verbatim

Unlike slb_init()/slb_exit(), slb_open()/slb_close() run in the context 
of the caller and in user-mode, with the user-stack of the caller, even 
if the Slbopen() call was performed in supervisor mode.

The library can also allocate memory at slb_open, though this belongs 
to the caller and should be released again at slb_close(). In order to 
permit allocation of this reserved memory to the caller, the library is 
also passed the current process descriptor at slb_open(), slb_close() 
and at every function call.

(!B)Warning:(!b)  Due to a bug in 5.20, the passing of the (!nolink [PD]) to slb_open()
						and slb_close() only works from (!nolink [MagiC]) 6 onwards.


The kernel ensures that the open/close calls are nested correctly, 
i.e. a process can not open a library more than once. 

(!U)Functions(!u)

Functions are not obligatory, so a library can hook in system calls 
also via the AES or DOS that are removed again at termination, yet 
generally functions are made available.

A function is called with the following parameters on the stack:
!begin_xlist [WORD nargs ] !short
!item [PD *pd]    Process descriptor of the caller, corresponds 
                  to the associated slb_open()/close()
!item [LONG fn]   Function number. Practical when several  
                  functions are amalgamated (identical 
                  function pointers in LIBHEAD)
!item [WORD nargs]  Number of the following arguments, in WORDs. 
                    If a function has a variable number of 
                    parameters, one can ascertain the actual 
                    number. Very useful for extensions,     
                    without having to incorporate new functions.
                    Example: If a function always expects a pointer,
                    but optionally also a WORD, it will receive 
                    either 2 or 3 as <nargs>.
!item [...]         The remaining parameters
!end_xlist
The functions are executed in the context of the caller and with 
its stack. As this call is generally made in user-mode, multitasking 
will not be interrupted even for longer operations. Depending on the 
function, the function result can be a LONG, a WORD, void etc.

A function may alter registers d0-d2 and a0-a1, all other registers 
have to be saved if appropriate. In particular, register a2 must not 
be altered, so that PureC routines may be called.

!end_node

!begin_node SLB_BIND
(!B)Achtung:(!b) Die Funktion Slbopen enthÑlt einen zusÑtzliche
       Paramter (!I)param(!i). Dieser taucht in der SLB.H nicht mehr auf.
       Am besten einfach ignorieren.
!begin_verbatim
/*
*
* Binding for the use of a "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <mgx_dos.h>

/*****************************************************************
*
* Opens a "shared lib".
*
* Input:
*     name             Name of the library, including extension
*     path             Search path with '\', optional
*     min_ver          Minimum required version number
* Returns:
*     sl               Library descriptor
*     fn               Function for calling a library function
*     <ret>            Actual version number, or error code
*
*****************************************************************/

LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn,
        LONG param )
{
  return(gemdos(0x16, name, path, min_ver, sl, fn, param));
}


/*****************************************************************
*
* Closes a "shared lib".
*
* Returns:
*     <ret>          EACCDN, if library not opened
*
*****************************************************************/

extern LONG Slbclose( SHARED_LIB *sl )

{
  return(gemdos(0x17, sl));
}

!end_verbatim

!end_node 

!begin_node SLB.H

!begin_verbatim
/*
*
* Binding for the use of "shared libraries"
*
* Andreas Kromke
* 22.10.97
* Last change 19.2.99  - SLB_EXEC with cdecl corrected
*
*/

#ifndef LONG
#include <portab.h>
#endif

typedef void *SHARED_LIB;
typedef LONG (*SLB_EXEC)( void , ... );
/*
  das geht leider in PureC nicht, weil PureC hier einen
  Fehler (!!!) hat: cdecl wird ignoriert, wenn die Funktion
  eine variable Anzahl von Parametern hat.

typedef LONG (cdecl *SLB_EXEC)( SHARED_LIB *sl, LONG fn, WORD nargs, ... );
*/

extern LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn );
extern LONG Slbclose( SHARED_LIB *sl );
!end_verbatim
!end_node

!end_node

!else

!begin_node Shared Libraries

(!U)Gemeinsame Bibliotheken (Shared Libraries) in (!nolink [MagiC]) in MagiC ab V6.00(!u)


!begin_itemize !short
!item Was sind Shared Libraries?
!item Wozu Shared Libraries?
!item Wie verwende ich eine Shared Libraries?
!item Wie schreibe ich eine Shared Libraries?
!end_itemize


(!B)Hinweis:(!b)
Shared Libraries wurden bereits mit (!nolink [MagiC]) Version 5.20 eingefÅhrt.
Aufgrund eines Designfehlers muûte das Format der Bibliothek ab
Version 6.00 Ñndern. Da unterschiedliche "magische" Kennungen verwendet
werden, kann es aber nicht zu AbstÅrzen kommen, sondern die Bibliotheken
fÅr 6.00 werden lediglich von der alten Version 5.20 nicht erkannt und
umgekehrt. Aufgrund mehrerer UnzulÑnglichkeiten in der Version 5.20
sollten ohnehin nur Bibliotheken fÅr 6.00 erstellt werden.

!begin_node Was sind Shared Libraries?

Meist werden Bibliotheken mit hÑufig genutzten Prozeduren in einem 
eigenen Objektmodul zusammengefaût und mit mehreren Programmen 
zusammengelinkt. Dabei erhÑlt jedes Programm eine Kopie der 
Bibliothek, die fest in die PRG-Datei integriert wird.
(!nolink [Shared Libraries]) dagegen existieren als eigene Dateien nur ein 
einziges Mal auf der Festplatte und werden von mehreren Programmen, 
auch gleichzeitig, verwendet.

!end_node

!begin_node Wozu Shared Libraries?

GegenÅber fest eingelinkten Bibliotheken ergeben sich eine Reihe von 
Vorteilen:

!begin_itemize !short
!item Speicherplatzersparnis auf der Festplatte. Je mehr Programme 
  dieselben Bibliotheken verwenden, desto grîûer ist die Ersparnis.
!item Speicherplatzersparnis im Hauptspeicher. Dies kommt erst dann zum 
  Tragen, wenn mehrere Programme gleichzeitig geladen sind, die 
  dieselbe Bibliothek verwenden.
!item Systematische Wartung fÅr den Programmierer: Beim Update genÅgt es  
  mitunter, nur eine neue Bibliothek nachzureichen. Von diesem Update 
  profitieren dann alle Programme, die die Bibliothek verwenden.   
  Auûerdem sind weniger Quelltexte zu warten. Wenn eine Bibliothek   
  verÑndert wurde, mÅssen nicht alle Programme, die sie verwenden, 
  neu Åbersetzt werden.
!end_itemize

NatÅrlich gibt es auch Nachteile:

!begin_itemize !short
!item Das Programmladen dauert etwas lÑnger. Jedoch nur, wenn die 
  Bibliothek noch nicht geladen ist.
!item Es kînnen sich Wechselwirkungen von Updates verschiedener Programme 
  ergeben. Beim Austausch einer Bibliothek kînnen mehrere Programme 
  betroffen sein (positiv oder negativ).
!item Bei der Installation eines Programms mÅssen Dateien in den XTENSION-
  bzw. den ersten in der Suchliste SLBPATH angegebenen Ordner (ab 
  (!nolink [MagiC]) 6) kopiert werden, es ist also nicht mehr ohne weiteres 
  nachvollziehbar, zu welchem Programm welche Shared Library gehîrt.
  Abhilfe z.B.:

!begin_itemize !short
  !item Nur Aliase in den XTENSION-Ordner bzw. den ersten durch die
    Environment-Variable SLBPATH (s.u.) angegebenen Ordner legen.
  !item (!nolink [Shared Libraries]) in einem Unterverzeichnis des Programms belassen
    und lediglich die Environment-Variable SLBPATH in MAGX.INF
    um dieses Verzeichnis erweitern (ab (!nolink [MagiC]) 6 mîglich). Falls
    noch keine Variable SLBPATH existiert, muû der XTENSION-Pfad dort
    zunÑchst eingetragen werden.
!end_itemize
!end_itemize

!end_node

!begin_node Wie verwende ich eine Shared Libraries?

ZunÑchst benîtigt man zum Aufruf der beiden neuen DOS-Funktionen das 
Objektmodul SLB_BIND, dazu muû man die Datei SLB.H einbinden.

FÅr jede benutzte Bibliothek deklariert man einen Deskriptor vom Typ 
SHARED_LIB und einen Funktionszeiger vom Typ SLB_EXEC.

Jede Bibliothek wird mit Slbopen() geîffnet (das ôffnen und Schlieûen 
sollte nur im User-Modus erfolgen), dabei werden folgende Parameter 
Åbergeben:
!begin_xlist [char *name ] !short
!item [char *name]    Der Name der Bibliothek, in Groûschrift, 
          inkl. Extension (".SLB"). Der   
          Bibliotheksname ist gleichzeitig Dateiname.
!item [char *path]    Wenn dieser Parameter nicht NULL ist, wird 
          hier zuerst nach der Bibliothek gesucht (der 
          Pfad muû in (!nolink [MagiC]) 5.20 mit '\' abgeschlossen 
          sein; dies ist in (!nolink [MagiC]) 6 nicht mehr nîtig).
          Der Pfad sollte absolut sein, damit die
          Shared Library weiû, wo sie liegt.
          Wenn der Parameter NULL ist oder die 
          Bibliothek im angegebenen Pfad nicht 
          gefunden wurde, wird im XTENSION-Ordner 
          gesucht. (!nl)
          Ab (!nolink [MagiC]) 6 wird die Environment-Variable
          SLBPATH ausgewertet. Sie enthÑlt wie PATH eine
          Liste der Suchpfade, jeweils durch ';' getrennt.
          Ist die Variable definiert, wird nicht mehr
          extra im XTENSION-Ordner gesucht.
!item [LONG min_ver]    Minimal notwendige Versionsnummer der 
          Bibliothek. (!nl)
          Wenn ein Programm etwa die Version 3 
          benîtigt, die Bibliothek aber erst Version 2 
          ist, wird ERANGE zurÅckgegeben. Die     
          tatsÑchliche Versionsnummer der Bibliothek 
          wird als RÅckgabewert geliefert.
!item [SHARED_LIB *sl]    Zeiger auf den Deskriptor. Wenn die 
          Bibliothek geîffnet wurde, wird hier der 
          Deskriptor eingetragen.
!item [SLB_EXEC *fn]    Zeiger auf den Funktionszeiger. Wenn die 
          Bibliothek geîffnet wurde, wird hier der 
          Funktionszeiger eingetragen.
!end_xlist
RÅckgabewert kann sein:
!begin_verbatim
  >= 0        Alles OK, Versionsnummer der Bibliothek.
  ERANGE      Versionsnummer zu niedrig
  EACCDN      Bibliothek schon von diesem Prozeû geîffnet
  EFILNF      Bibliothek nicht gefunden
  ENSMEM      zuwenig Speicher
  ...         andere Fehlercodes.
!end_verbatim
Die Bibliothek kann nun verwendet und schlieûlich mit Slbclose() 
wieder geschlossen werden. Dies ist nicht unbedingt notwendig, da 
alle geîffneten Bibliotheken bei Programmende automatisch geschlossen 
werden, aber es ist guter Programmierstil. Auf keinen Fall darf eine 
Bibliothek mehrmals geschlossen werden, der Kernel kann solche Fehler 
nicht erkennen.

Einige Bibliotheken, wie z.B. EDITOBJC.SLB, installieren neue 
Systemaufrufe, in diesem Fall die AES-Aufrufe 210..217. FÅr diese 
Bibliotheken wird der Funktionszeiger nicht benîtigt. Ansonsten 
werden alle Funktionen der Bibliothek Åber den Funktionszeiger 
aufgerufen. Die Bibliotheks-Aufruf-Funktion ist folgendermaûen 
deklariert:

!begin_verbatim
 typedef LONG (cdecl *SLB_EXEC)( SHARED_LIB *sl, LONG fn,
        WORD nargs, ... );
!end_verbatim

Da leider PureC hier einen Fehler hat, muûte ich die Funktion 
notgedrungen deklarieren als "typedef LONG (*SLB_EXEC)( void , ... );"
Damit sind leider alle TypÅberprÅfungen verbaut. Also Vorsicht!

Der Aufruf erwartet folgende Parameter:
!begin_verbatim
     Den Deskriptor der Bibliothek
     Ein Langwort (!) fÅr die Funktionsnummer
     Ein WORD, das die Anzahl der Argumente in WORDs
               (d.h. alle "..."-Argumente) angibt
     weitere Argumente je nach Funktion
!end_verbatim

Am besten geschieht der Aufruf Åber ein Makro, das in einer Headerdatei
fÅr die Bibliothek definiert werden sollte, z.B.:

JPEG.H:

 #define SLBJPEG_WANDELN (a,b) (*slbjpeg_exec)(slbjpeg, 7L, 4, a, b)

Hierbei werden <slbjpeg_exec> und <slbjpeg> bei Slbopen() ermittelt, 
7L ist die Funktionsnummer fÅr den Aufruf WANDELN, 4 bezeichnet die 
LÑnge der folgenden Argumente (a und b sind zwei Zeiger => 2*4 Bytes 
=> 4 WORDs), a und b sind die Argumente der Funktion WANDELN.

Wenn die Funktion nicht vorhanden ist (die Bibliothek enthÑlt fÅr 
diese Funktion einen Nullzeiger, oder die Funktionsnummer ist hîher 
als die Anzahl der tatsÑchlich vorhandenen Funktionen), erhÑlt man 
EINVFN als Funktionsergebnis (tatsÑchlich klappt das erst ab (!nolink [MagiC]) 6
korrekt).

!end_node

!begin_node Wie schreibe ich eine Shared Libraries?

Auch dazu gibt es eine Beispielbibliothek SLB_DEMO, die alle 
notwendigen Elemente und Beschreibungen enthÑlt.
Am besten, man kopiert SLB_DEMO.C, LIBHEAD.S und SLB_DEMO.PRJ und 
modifiziert die Dateien entsprechend. Es muû dringend darauf geachtet 
werden, daû Bit 3 der Flags im Programmheader einer Bibliothek 
gesetzt ist, dazu kann man PH_BIT3.TTP verwenden.

LIBHEAD ist der Header fÅr eine Shared Library. Der Zeiger auf die 
Funktionsnamen kann entfallen, ansonsten zeigt er auf eine Tabelle 
von Zeigern mit den Namen der Bibliotheksfunktionen.
Die Anzahl der Funktionen muû korrekt festgelegt werden, ebenso die 
Tabelle der Funktionen und der Bibliotheksname, welcher mit dem 
Dateinamen identisch ist.
Beim HinzufÅgen von Funktionen muû darauf geachtet werden, die 
Funktionsanzahl entsprechend anzupassen und ggf. die Versionsnummer 
zu erhîhen.

Bei îffentlich zugÑnglichen Shared Libraries ist sicherzustellen, daû
dokumentierte Funktionsaufrufe nie geÑndert werden! Entweder sind neue
Parameter zu ergÑnzen (die aufgerufene Funktion kann die Anzahl der
tatsÑchlich Åbergebenen Parameter abfragen), oder es ist eine neue
Funktionsnummer zu verwenden.

FÅr die Funktionszeiger sind auch Nullzeiger zulÑssig, sie geben beim 
Aufruf der Funktion ein EINVFN.

Folgende Funktionen zur (De-) Initialisierung sind obligatorisch:

(!U)slb_init()/slb_exit()(!u)

Werden beim Laden bzw. Entfernen der Bibliothek aufgerufen, und zwar 
im Supervisor-Modus und im Kontext (Prozeû) der Bibliothek.
Typischerweise lÑdt slb_init() eine Konfigurationsdatei, alloziert 
globalen Speicher fÅr die Bibliothek und îffnet eine virtuelle VDI-
Workstation. slb_exit() schreibt die Konfigurationsdatei zurÅck, gibt 
den Speicher wieder frei und schlieût die (!nolink [VDI])-Workstation.

Falls slb_init() eine Datei îffnet, darf auf das Handle erst wieder 
bei slb_exit() zugegriffen werden, da alle anderen Aufrufe der 
Bibliothek im Kontext des Aufrufers ablaufen.

Ab (!nolink [MagiC]) 6 erhÑlt die Bibliothek in der Kommandozeilen-Struktur der 
Basepage eine normale 'C'-Zeichenkette Åbergeben, welche den 
vollstÑndigen Pfad der SharedLibrary enthÑlt. Falls die SharedLibrary 
Konfigurations- oder RSC-Dateien laden muû, kann der Pfad extrahiert 
und der Dateiname der Konfigurationsdatei entsprechend 
zusammengebastelt werden.

Falls slb_init() z.B. aufgrund eines Busfehlers beendet wird, erhÑlt 
der Aufrufer EXCPT als Ergebnis des Slbopen()-Aufrufs. Um die 
unplanmÑûige Terminierung der Bibliothek abzufangen, installiert der 
Kernel vor Aufruf von slb_init()/exit() einen etv_term-Handler fÅr 
die Bibliothek.

(!U)slb_open()/slb_close()(!u)

Werden beim ôffnen bzw. Schlieûen der Bibliothek aufgerufen. Wenn die 
Bibliothek nur einmal geîffnet wird, ist die Reihenfolge:
!begin_verbatim
  slb_init()
  slb_open()
  slb_close()
  slb_exit()
!end_verbatim

Im Gegensatz zu slb_init()/slb_exit() laufen slb_open()/slb_close() 
im Kontext des Aufrufers und im Usermodus mit dem Userstack des 
Aufrufers ab, auch dann, wenn der Slbopen()-Aufruf im Supervisor-Modus 
erfolgt ist.

Die Bibliothek kann auch bei slb_open Speicher allozieren, dieser 
gehîrt jedoch dem Aufrufer und sollte bei slb_close() wieder 
freigegeben werden. Um die Zuordnung von alloziertem Speicher zum 
Aufrufer zu ermîglichen, wird der Bibliothek bei slb_open(), 
slb_close() und bei jedem Funktionsaufruf der aktuelle Prozeû-
Deskriptor mit Åbergeben.

(!B)Achtung:(!b) Die öbergabe des (!nolink [PD]) an slb_open() und slb_close() geht
      aufgrund eines Bugs in 5.20 erst ab (!nolink [MagiC]) 6.

Der Kernel stellt sicher, daû die open/close Aufrufe korrekt 
geschachtelt sind, d.h. ein Prozeû kann eine Bibliothek nicht 
mehrmals îffnen.

(!U)Funktionen(!u)

Funktionen sind nicht obligatorisch, so kann eine Bibliothek auch 
Systemaufrufe Åber AES oder DOS einhÑngen, die nach Beendigung wieder 
entfernt werden, i.a. werden jedoch Funktionen zur VerfÅgung gestellt.

Eine Funktion wird mit folgenden Parametern auf dem Stack aufgerufen:
!begin_xlist [WORD nargs ] !short
!item [PD *pd]    Prozeû-Deskriptor des Aufrufers, korrespondiert 
        mit dem zugehîrigen slb_open()/close()
!item [LONG fn]   Funktionsnummer. Praktisch, wenn mehrere 
        Funktionen zusammengelegt sind (identische 
        Funktionszeiger in LIBHEAD)
!item [WORD nargs]  Anzahl der folgenden Argumente, in WORDs. Hat 
        eine Funktion eine variable Anzahl von 
        Parametern, kann die tatsÑchliche Anzahl 
        ermittelt werden. Sehr praktisch bei  
        Erweiterungen, ohne neue Funktionen einzubauen.
        Beispiel: Erwartet eine Funktion immer einen 
        Zeiger, optional aber noch ein WORD, erhÑlt sie 
        entweder 2 oder 3 als <nargs>.
!item [...]     die Åbrigen Parameter
!end_xlist
Die Funktionen werden im Kontext des Aufrufers und mit dessen Stack 
ausgefÅhrt. Da dieser Aufruf i.a. im User-Modus erfolgt, wird das 
Multitasking auch bei lÑngeren Aktionen nicht unterbrochen. Das 
Funktions-Ergebnis kann je nach Funktion LONG, WORD, void usw. sein.

Eine Funktion darf die Register d0-d2 und a0-a1 Ñndern, alle anderen
Register mÅssen ggf. gerettet werden. Insbesondere darf Register a2
nicht verÑndert werden, damit Routinen von PureC aus aufgerufen werden
kînnen.

!end_node

!begin_node SLB_BIND
(!B)Achtung:(!b) Die Funktion Slbopen enthÑlt einen zusÑtzliche
       Paramter (!I)param(!i). Dieser taucht in der SLB.H nicht mehr auf.
       Am besten einfach ignorieren.
!begin_verbatim
/*
*
* Binding fÅr die Benutzung einer "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <mgx_dos.h>

/*****************************************************************
*
* ôffnet eine "shared lib".
*
* Eingabe:
* name      Name der Bibliothek inkl. Extension.
* path      Suchpfad mit '\', optional
* min_ver   Minimale benîtigte Versionsnummer
* RÅckgabe:
* sl        Bibliotheks-Deskriptor
* fn        Funktion zum Aufruf einer Bibliotheksfunktion
* <ret>     tatsÑchliche Versionsnummer oder Fehlercode
*
*****************************************************************/

LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn,
        LONG param )
{
  return(gemdos(0x16, name, path, min_ver, sl, fn, param));
}


/*****************************************************************
*
* Schlieût eine "shared lib".
*
* RÅckgabe:
* <ret>   EACCDN, falls Lib nicht geîffnet
*
*****************************************************************/

extern LONG Slbclose( SHARED_LIB *sl )

{
  return(gemdos(0x17, sl));
}

!end_verbatim

!end_node 

!begin_node SLB.H

!begin_verbatim
/*
*
* Binding fÅr Verwendung von "shared libraries"
*
* Andreas Kromke
* 22.10.97
*
*/

#ifndef LONG
#include <portab.h>
#endif

typedef void *SHARED_LIB;
typedef LONG (*SLB_EXEC)( void , ... );
/*
  das geht leider in PureC nicht, weil PureC hier einen
  Fehler (!!!) hat: cdecl wird ignoriert, wenn die Funktion
  eine variable Anzahl von Parametern hat.

typedef LONG (cdecl *SLB_EXEC)( SHARED_LIB *sl, LONG fn, WORD nargs, ... );
*/

extern LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn );
extern LONG Slbclose( SHARED_LIB *sl );
!end_verbatim
!end_node

!end_node


!endif
