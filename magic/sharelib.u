!iflang [english]


!begin_node Shared libraries

(!U)Shared Libraries in (!nolink [MagiC]) from V6.00 onwards(!u)


!begin_itemize !short
!item What are shared libraries?
!item Why shared libraries?
!item How do I use a library?
!item How do I write a library?
!end_itemize


(!B)Note:(!b) Shared libraries were introduced already with (!nolink [MagiC]) Version
5.20. Due to a design error, they had to change the format of the
library as of Version 6.00. As different "magic" IDs are used this
can not cause crashes; it's just that the libraries for 6.00 will not
be recognized by the old version 5.20, and vice versa. Due to several
inadequacies in version 5.20 one should in any case only create
libraries for 6.00.


!begin_node What are shared libraries?
!ignore_index

Usually libraries with frequently used procedures are collected in
their own object module and then linked with several programs during
compilation. In that case each program receives a copy of the library,
which is integrated firmly into the PRG file. On the other hand,
shared libraries exist as separate files only once on the hard disk
and can be used by several programs, even simultaneously.

!end_node

!begin_node Why shared libraries?
!ignore_index

Compared to hard-linked libraries, using shared libraries results in
a series of advantages:

!begin_itemize !short
!item Saving of storage space on the hard disk. The more programs that
     use the same libraries, the greater the saving.
!item Saving of storage space in main memory (RAM). This only comes
     into play when several programs that use the same library are
     loaded simultaneously.
!item Systematic maintenance by the programmer: For an update it may
     suffice at times just to distribute a new library. All programs
     that use the library will then profit from the update.
     Additionally there will be fewer source texts to maintain. When
     a library has been altered there is no need to newly translate
     all of the programs using it.
!end_itemize

Naturally there are also disadvantages:

!begin_itemize !short
!item Program loading takes somewhat longer; however this is so only
     if the library has not been loaded yet.
!item There may be interaction between updates of various programs.
     When exchanging a library, several programs may be affected
     (positively or negatively).
!item During installation of a program the files have to be copied to
     the XTENSION folder (normally in GEMSYS\MAGIC\ of the boot drive)
     or to the first folder specified in the searchlist SLBPATH (from
     (!nolink [MagiC]) 6), so it is no longer possible to establish easily which
     shared library belongs to which program.
     Remedies, for instance:
!begin_itemize !short
  !item Only place aliases in the XTENSION folder or the first
        folder specified by the environmental variable SLBPATH (see below)
  !item Leave the shared libraries in a subdirectory of the program
        and merely extend the environmental variable SLBPATH in MAGX.INF by this
        directory (possible from (!nolink [MagiC]) 6 onwards). If no SLBPATH
        variable exists as yet then one has to enter the XTENSION path in it
        first.
!end_itemize
!end_itemize

!end_node

!begin_node How do I use a library?
!ignore_index

To start with, one needs the object module SLB_BIND for calling the
two new DOS functions, for which one has to link the file SLB.H.

For each library used one declares a descriptor of the type SHARED_LIB
and a function pointer of the type SLB_EXEC.

Each library is opened with Slbopen (opening and closing should only
take place in user-mode), during which the following parameters are
passed:
!begin_xlist [char *name ] !short
!item [char *name]   The name of the library, in capitals, including the
                     extension (".SLB"). The library name is also the filename.
!item [char *path]   If this parameter is not NULL, then first of
                     all a search will be made for the library
                     (the path must end with '\' in (!nolink [MagiC]) 5.20;
                     this is no longer necessary in (!nolink [MagiC]) 6).
                     The path should be an absolute one, so that
                     the shared library knows where it lies.
                     If the parameter is NULL or the library was
                     not found in the specified path, then a
                     search is made in the XTENSION folder.  (!nl)
                     From (!nolink [MagiC]) 6 onwards the environmental variable
                     SLBPATH will be evaluated. Like PATH it contains
                     a list of search-paths, each separated by ';'.
                     If the variable is defined no additional search
                     will be made in the XTENSION folder.
!item [LONG min_ver]    Minimum required version number of the library. (!nl)
                        If a program needs, say, version 3 but the
                        library present is only version 2, then
                        ERANGE will be returned. The return value will
                        be the actual version number of the library.
!item [SHARED_LIB *sl]  Pointer to the descriptor. When the library
                        is opened the descriptor will be entered here.
!item [SLB_EXEC *fn]    Pointer to the function pointer. When the
                        library is opened the function pointer will
                        be entered here.
!end_xlist
Return values can be:
!begin_verbatim
  >= 0        All OK, version number of the library
  ERANGE      Version number too low
  EACCDN      Library already opened by this process
  EFILNF      Library not found
  ENSMEM      Insufficient memory free
  ...         Other error-codes.
!end_verbatim
The library can now be used and finally closed again with Slbclose.
This is not absolutely necessary as all open libraries are closed
automatically at program termination, but it is good programming
practice. On no account may a library be closed more than once, since
the kernel can not recognize such errors.

Some libraries such as EDITOBJC.SLB, for instance, install new system
calls, in this case the (!nolink [AES]) calls 210..217. For these libraries the
function pointer is not needed. Otherwise all functions of the library
are called via the function pointer. The library call function is
declared in the following way:

!begin_verbatim
 typedef LONG (cdecl *SLB_EXEC)( SHARED_LIB *sl, LONG fn,
        WORD nargs, ... );
!end_verbatim

As regretably Pure-C has an error here, I was forced to declare this
functions as 'typedef LONG (*SLB_EXEC)( void , ... );'.
Unfortunately this inhibits all type checking. So take care!

The call expects the following (!B)parameters:(!b)
!begin_verbatim
     The descriptor of the library
     A longword (!) for the function number
     A WORD, that specifies the number of arguments in WORDs
             (i.e. all "..." arguments)
     Further arguments, depending on the function.
!end_verbatim

The best way is to make the call via a macro, which should be defined
in a header file for the library, e.g.:

JPEG.H:

 #define SLBJPEG_WANDELN (a,b) (*slbjpeg_exec)(slbjpeg, 7L, 4, a, b)

With this (!I)slbjpeg_exec(!i) and (!I)slbjpeg(!i) will be ascertained at Slbopen,
7L is the function number for the call WANDELN (convert), 4 describes
the length of the following arguments (<a> and <b> are two pointers
=> 2*4 bytes => 4 WORDs), and (!I)a(!i) and (!I)b(!i) are the arguments of the
function WANDELN.

If the function is not present (the library contains a NULL-pointer
for this function, or the function number is higher than the number of
functions actually present), one will receive EINVFN as the function
result (in fact this only works correctly from (!nolink [MagiC]) 6 onwards).

!end_node


!begin_node How do I write a library?
!ignore_index

For this too there is a sample library SLB_DEMO, which contains all
the required elements and descriptions. The best thing is to copy
SLB_DEMO.C, LIBHEAD.S and SLB_DEMO.PRJ and then modify the files to
suit your requirements. It is most important to ensure that bit 3 of
the flag in the program header of a library is set; one can use
PH_BIT3.TTP for this.

LIBHEAD is the header for a shared library. The pointer to the
function names can be omitted, otherwise it points to a table of
pointers with the names of the library functions. The number of
functions must be stated correctly, as must the table of functions
and the library name, which is identical to the filename. When adding
a function one has to ensure that the function number is adapted
accordingly, and perhaps that the version number is increased.

For publicly available shared libraries one has to ensure that
documented function calls are never altered! They can either be
supplemented with new parameters (the called function can inquire
the number of parameters actually passed), or a new function number
should be used.

NULL-pointers are also permissible for the function pointers; they
return a EINVFN when the function is called.

The following functions for (de-)initialization are obligatory:

(!U)slb_init/slb_exit(!u)

These are called during loading and removal of the library
respectively, and at that in supervisor-mode and in the context
(process) of the library. Typically, slb_init loads a configuration
file, allocates global memory for the library and opens a virtual (!nolink [VDI])
workstation. slb_exit writes back the configuration file, releases
the memory again and closes the (!nolink [VDI]) workstation.

If slb_init opens a file, then the handle can only be accessed again
at slb_exit, as all other calls of the library run in the context of
the calling application.

From (!nolink [MagiC]) 6 onwards the library is passed a normal 'C' character
string in the command line structure which contains the complete path
of the shared library. If the shared library has to load configuration
or RSC files, the path can be extracted and the filename of the
configuration file assembled correspondingly.

If slb_init terminates by reason of a bus error, for instance, then
the caller will get EXCPT as the result of the Slbopen call. In
order to intercept an unplanned termination of the library, the
kernel installs an etv_term handler for the library before calling
slb_init/exit.

(!U)slb_open/slb_close(!u)

These are called at the opening or closing of the library
respectively. Once the library has been opened, the order is:
!begin_verbatim
  slb_init
  slb_open
  slb_close
  slb_exit
!end_verbatim

Unlike slb_init/slb_exit, slb_open/slb_close run in the context of
the caller and in user-mode, with the user-stack of the caller, even
if the Slbopen call was performed in supervisor-mode.

The library can also allocate memory at slb_open, though this belongs
to the caller and should be released again at slb_close. In order to
permit allocation of this reserved memory to the caller, the library
is also passed the current process descriptor at slb_open, slb_close
and at every function call.

(!B)Warning:(!b) Due to a bug in 5.20, the passing of the (!nolink [PD]) to slb_open and
slb_close only works from (!nolink [MagiC]) 6 onwards.

The kernel ensures that the open/close calls are nested correctly,
i.e. a process can not open a library more than once.

The kernel ensures that the open/close calls are nested correctly,
i.e. a process cannot open a library more than once.

(!U)Functions(!u)

Functions are not obligatory, so a library can hook in system calls
also via the (!nolink [AES]) or DOS that are removed again at termination, yet
generally functions are made available.

A function is called with the following parameters on the stack:
!begin_xlist [WORD nargs ] !short
!item [PD *pd]    Process descriptor of the caller, corresponds
                  to the associated slb_open()/close()
!item [LONG fn]   Function number. Practical when several
                  functions are amalgamated (identical
                  function pointers in LIBHEAD)
!item [WORD nargs]  Number of the following arguments, in WORDs. If a
              function has a variable number of parameters, one can
              ascertain the actual number. Very useful for extensions,
              without having to incorporate new functions. (!B)Example:(!b)
              If a function always expects a pointer, but optionally
              also a WORD, it will receive either 2 or 3 as (!I)nargs.(!i)
!item [...]         The remaining parameters
!end_xlist
The functions are executed in the context of the caller and with its
stack. As this call is generally made in user-mode, multitasking will
not be interrupted even for longer operations. Depending on the
function, the function result can be a LONG, a WORD, void etc.

A function may alter registers d0-d2 and a0-a1, all other registers
have to be saved if appropriate. In particular, register a2 must not
be altered, so that Pure-C routines may be called.

!end_node

!begin_node SLB_DEMO.C
!ignore_index
!begin_verbatim
/*
*
* Body of a "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <portab.h>
#include <tos.h>
#include <tosdefs.h>
#pragma warn -par

typedef void *PD;

char *mem;               /* Here global memory */

/*****************************************************************
*
* The init-function is called once during loading the library.
* For this it runs as a process of the library, i.e. files can
* be opened and memory can be reserved that belong to the library
* in each case.
* Warning: The files opened in this way may _NOT_ be accessed
*          by the library functions, because these run in the
*          context of the caller.
*
* Warning: The init-function runs in supervisor mode, as a
*          library generally does not have a user stack.
*          Hence it must not use too much stack space (max. 1kB)
*          and may not run too long (because multitasking is
*          blocked in supervisor mode).
*          But if necessary a user stack can be allocated and one
*          can then switch to user mode.
*
*****************************************************************/

extern LONG cdecl slb_init( void )
{
     mem = Malloc(4096L);
     if     (mem)
          return(E_OK);
     else     return(ENSMEM);
}

/*****************************************************************
*
* The exit-function is called once during releasing the library.
* For this it runs as a process of the library, i.e. files can
* be opened and memory can be reserved that belong to the library
* in each case.
*
* Warning: The exit-function runs in supervisor mode, as a
*          library generally does not have a user stack.
*          Hence it must not use too much stack space (max. 1kB)
*          and may not run too long (because multitasking is
*          blocked in supervisor mode).
*          But if necessary a user stack can be allocated and one
*          can then switch to user mode.
*
*****************************************************************/

extern void cdecl slb_exit( void )
{
     Mfree(mem);
}


/*****************************************************************
*
* The open-function is called once during opening of the library
* by an application process. For this it runs as a process of the
* caller, i.e. files can be opened and memory can be reserved that
* belong to the caller in each case.
*
* The kernel ensures that each process does not open the library
* several times, and that the library is always closed properly.
*
* Warning: The open-function runs in user mode, and actually with
*          the user stack of the caller. This means that the caller,
*          even when running in supervisor mode, always has to make
*          a sufficiently large usp available.
*
*****************************************************************/

extern LONG cdecl slb_open( PD *pd )
{
     return(E_OK);
}


/*****************************************************************
*
* The close-function is called once during closing of the library
* by an application process. For this it runs as a process of the
* caller, i.e. files can be opened and memory can be reserved and
* released, that belongs to the caller in each case.
*
* Warning: The close-function runs in user mode, and actually with
*          the user stack of the caller. This means that the caller,
*          even when running in supervisor mode, always has to make
*          a sufficiently large usp available.
*
*****************************************************************/

extern void cdecl slb_close( PD *pd )
{
}


/*****************************************************************
*
* An example library function.
* It is executed in the context of the caller, and actually with
* the stack of the caller (depending on status usp or ssp).
*
* It is strongly recommended to call the functions of an SLB only in
* user mode, so as to ensure compatibility to later implementations.
*
*****************************************************************/

extern LONG cdecl slb_fn0( PD *pd, LONG fn, WORD nargs, char *s )
{
     Cconws(s);
     Cconws("\r\n Key: ");
     Cconin();
     return(E_OK);
}
!end_verbatim
!end_node

!begin_node LIBHEAD.S
!ignore_index
!begin_verbatim
/*
*
* Header for a "shared library"
* This is used in place of the start-code of PureC
*
* It is _imperative_ to ensure that bit 3 of the flags
* in the program header is set, so that the library
* does not reserve the whole of the available memory.
*
* Warning: The SLB-concept of MagiC 5.20 still had an error,
* which I have fixed in 6.00. For this the makeup had to be
* modified slightly. SLBs for MagiC 6 therefore do not run
* with those for MagiC 5.20 and vice versa.
*
* Andreas Kromke
* 10.2.98
*
*/

     XREF slb_init
     XREF slb_exit
     XREF slb_open
     XREF slb_close
     XREF slb_fn0

     TEXT

DC.L          $70004afc              ; Magical value (5.20: $42674e41)
DC.L          name                   ; Pointer to name of library
DC.L          1                      ; Version number
DC.L          0                      ; Flags, at present 0L
DC.L          slb_init               ; Is called after loading
DC.L          slb_exit               ; Is called before removing
DC.L          slb_open               ; Is called at opening
DC.L          slb_close              ; Is called at closing
DC.L          0                      ; Pointer to procedure name (optional)
DC.L          0,0,0,0,0,0,0,0        ; Unused, always NULL
DC.L          1                      ; Number of functions (5.20: .W)
DC.L          slb_fn0                ; Function #0

name:          DC.B     'DEMO.SLB',0

     END
!end_verbatim
!end_node

!begin_node SLB_DEMO.PRJ
!ignore_index
!begin_verbatim
slb_demo.slb
.L[-S=256]     ; Minimum stack

=

libhead.s      ; Startup code for SLBs
slb_demo.c (slb.h)

pctoslib.lib
pcstdlib.lib
!end_verbatim
!end_node

!begin_node PH_BIT3.TTP
!ignore_index
!begin_verbatim
/*
*
* Program for the manipulation of bit 3 in the program header.
* MagiC needs this bit, which is generally 0, to assign to
* the program only the minimum amount of memory that is needed,
* i.e. only basepage+text+data+symbol+BSS.
* Is needed in particular for all SharedLibraries.
*
* Andreas Kromke
* 25.10.97
*
*/

#include <portab.h>
#include <tos.h>
#include <tosdefs.h>
#include <stdio.h>

/* ProgramHeader, Program header for executable files                   */
/************************************************************************/

typedef struct {
 WORD ph_branch;         /* 0x00: Must be 0x601a                          */
 LONG ph_tlen;           /* 0x02: Length of TEXT segment                  */
 LONG ph_dlen;           /* 0x06: Length of DATA segment                  */
 LONG ph_blen;           /* 0x0a: Length of BSS  segment                  */
 LONG ph_slen;           /* 0x0e: Length of the symbol table              */
 LONG ph_res1;           /* 0x12: Required by PureC                       */
 LONG ph_prgflags;       /* 0x16:    Bit 0: Don't clear heap              */
                         /*          Bit 1: Load into FastRAM             */
                         /*          Bit 2: Malloc from FastRAM           */
                         /*          Bit 3: Only t+d+b+s (MagiC 5.20)     */
                         /*          Bit 4,5,6,7: Memory protection (MiNT)*/
                         /*          Bit 8: Unused                        */
                         /*          Bit 9: Unused                        */
                         /*          Bit 10: Unused                       */
                         /*          Bit 11: SharedText (MiNT)            */
                         /*          Bit 12: Unused                       */
                         /*          Bit 13: Unused                       */
                         /*          Bit 14: Unused                       */
                         /*          Bit 15: Unused                       */
                         /*          Bits 31..28: TPA size                */
                         /*           (times 128k + 128k: Min. heap size) */
 WORD ph_absflag;        /* 0x1a: Non-zero => do not relocate             */
} PH;



WORD main( WORD argc, char *argv[] )
{
     PH ph;
     WORD ret = 0;
     LONG err;
     WORD f;

     for     (argc--,argv++; argc; argc--,argv++)
          {
          Cconws("File: ");
          Cconws(*argv);
          err = Fopen(*argv, RMODE_RW);     /* Open for reading + writing */
          f = (WORD) err;                   /* File handle                */
          err = Fread(f, sizeof(PH), &ph);
          if     ((err != sizeof(PH)) || (ph.ph_branch != 0x601a))
               {
               err = EPLFMT;
               goto nextone;
               }
          Fseek(0L, f, 0);                  /* File pointer to the start  */
          ph.ph_prgflags |= 8;              /* Set bit 3                  */
          err = Fwrite(f, sizeof(PH), &ph);

      nextone:
          if     (f > 0)
               Fclose(f);
          if     (err < 0)
               {
               printf(" => Error %ld", err);
               ret = (WORD) err;
               }
          Cconws("\r\n");
          }
     return(ret);
}
!end_verbatim
!end_node

!begin_node SLB_BIND
!ignore_index
(!B)Warning:(!b) The function Slbopen contains an additionnal parameter (!I)param.(!i)
This no longer appears in the SLB.H. Best to just simply inore it.
!begin_verbatim
/*
*
* Binding for the use of a "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <mgx_dos.h>

/*****************************************************************
*
* Opens a "shared lib".
*
* Input:
*     name             Name of the library, including extension
*     path             Search path with '\', optional
*     min_ver          Minimum required version number
* Returns:
*     sl               Library descriptor
*     fn               Function for calling a library function
*     <ret>            Actual version number, or error code
*
*****************************************************************/

LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn,
        LONG param )
{
  return(gemdos(0x16, name, path, min_ver, sl, fn, param));
}


/*****************************************************************
*
* Closes a "shared lib".
*
* Returns:
*     <ret>          EACCDN, if library not opened
*
*****************************************************************/

extern LONG Slbclose( SHARED_LIB *sl )

{
  return(gemdos(0x17, sl));
}

!end_verbatim

!end_node

!begin_node SLB.H
!ignore_index

!begin_verbatim
/*
*
* Binding for the use of "shared libraries"
*
* Andreas Kromke
* 22.10.97
* Last change 19.2.99  - SLB_EXEC with cdecl corrected
*
*/

#ifndef LONG
#include <portab.h>
#endif

typedef void *SHARED_LIB;
typedef LONG (*SLB_EXEC)( void , ... );
/*
  Unfortunately this does not work in Pure-C, because Pure-C has an
  error (!!!) here: cdecl is ignored if the function has a variable
  number of parameters.

typedef LONG (cdecl *SLB_EXEC)( SHARED_LIB *sl, LONG fn, WORD nargs, ... );
*/

extern LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn );
extern LONG Slbclose( SHARED_LIB *sl );
!end_verbatim
!end_node

!end_node

!else

!begin_node Shared Libraries

(!U)Gemeinsame Bibliotheken (Shared Libraries) in (!nolink [MagiC]) ab V6.00(!u)


!begin_itemize !short
!item Was sind Shared Libraries?
!item Wozu Shared Libraries?
!item Wie verwende ich eine Shared Libraries?
!item Wie schreibe ich eine Shared Libraries?
!end_itemize


(!B)Hinweis:(!b)
Shared Libraries wurden bereits mit (!nolink [MagiC]) Version 5.20 eingefÅhrt.
Aufgrund eines Designfehlers muûte das Format der Bibliothek ab
Version 6.00 Ñndern. Da unterschiedliche "magische" Kennungen verwendet
werden, kann es aber nicht zu AbstÅrzen kommen, sondern die Bibliotheken
fÅr 6.00 werden lediglich von der alten Version 5.20 nicht erkannt und
umgekehrt. Aufgrund mehrerer UnzulÑnglichkeiten in der Version 5.20
sollten ohnehin nur Bibliotheken fÅr 6.00 erstellt werden.

!begin_node Was sind Shared Libraries?
!ignore_index

Meist werden Bibliotheken mit hÑufig genutzten Prozeduren in einem
eigenen Objektmodul zusammengefaût und mit mehreren Programmen
zusammengelinkt. Dabei erhÑlt jedes Programm eine Kopie der
Bibliothek, die fest in die PRG-Datei integriert wird.
(!nolink [Shared Libraries]) dagegen existieren als eigene Dateien nur ein
einziges Mal auf der Festplatte und werden von mehreren Programmen,
auch gleichzeitig, verwendet.

!end_node

!begin_node Wozu Shared Libraries?
!ignore_index

GegenÅber fest eingelinkten Bibliotheken ergeben sich eine Reihe von
Vorteilen:

!begin_itemize !short
!item Speicherplatzersparnis auf der Festplatte. Je mehr Programme
  dieselben Bibliotheken verwenden, desto grîûer ist die Ersparnis.
!item Speicherplatzersparnis im Hauptspeicher. Dies kommt erst dann zum
  Tragen, wenn mehrere Programme gleichzeitig geladen sind, die
  dieselbe Bibliothek verwenden.
!item Systematische Wartung fÅr den Programmierer: Beim Update genÅgt es
  mitunter, nur eine neue Bibliothek nachzureichen. Von diesem Update
  profitieren dann alle Programme, die die Bibliothek verwenden.
  Auûerdem sind weniger Quelltexte zu warten. Wenn eine Bibliothek
  verÑndert wurde, mÅssen nicht alle Programme, die sie verwenden,
  neu Åbersetzt werden.
!end_itemize

NatÅrlich gibt es auch Nachteile:

!begin_itemize !short
!item Das Programmladen dauert etwas lÑnger. Jedoch nur, wenn die
  Bibliothek noch nicht geladen ist.
!item Es kînnen sich Wechselwirkungen von Updates verschiedener Programme
  ergeben. Beim Austausch einer Bibliothek kînnen mehrere Programme
  betroffen sein (positiv oder negativ).
!item Bei der Installation eines Programms mÅssen Dateien in den XTENSION-
  bzw. den ersten in der Suchliste SLBPATH angegebenen Ordner (ab
  (!nolink [MagiC]) 6) kopiert werden, es ist also nicht mehr ohne weiteres
  nachvollziehbar, zu welchem Programm welche Shared Library gehîrt.
  Abhilfe z.B.:

!begin_itemize !short
  !item Nur Aliase in den XTENSION-Ordner bzw. den ersten durch die
    Environment-Variable SLBPATH (s.u.) angegebenen Ordner legen.
  !item (!nolink [Shared Libraries]) in einem Unterverzeichnis des Programms belassen
    und lediglich die Environment-Variable SLBPATH in MAGX.INF
    um dieses Verzeichnis erweitern (ab (!nolink [MagiC]) 6 mîglich). Falls
    noch keine Variable SLBPATH existiert, muû der XTENSION-Pfad dort
    zunÑchst eingetragen werden.
!end_itemize
!end_itemize

!end_node

!begin_node Wie verwende ich eine Shared Libraries?
!ignore_index

ZunÑchst benîtigt man zum Aufruf der beiden neuen DOS-Funktionen das
Objektmodul SLB_BIND, dazu muû man die Datei SLB.H einbinden.

FÅr jede benutzte Bibliothek deklariert man einen Deskriptor vom Typ
SHARED_LIB und einen Funktionszeiger vom Typ SLB_EXEC.

Jede Bibliothek wird mit Slbopen() geîffnet (das ôffnen und Schlieûen
sollte nur im User-Modus erfolgen), dabei werden folgende Parameter
Åbergeben:
!begin_xlist [char *name ] !short
!item [char *name]    Der Name der Bibliothek, in Groûschrift,
          inkl. Extension (".SLB"). Der
          Bibliotheksname ist gleichzeitig Dateiname.
!item [char *path]    Wenn dieser Parameter nicht NULL ist, wird
          hier zuerst nach der Bibliothek gesucht (der
          Pfad muû in (!nolink [MagiC]) 5.20 mit '\' abgeschlossen
          sein; dies ist in (!nolink [MagiC]) 6 nicht mehr nîtig).
          Der Pfad sollte absolut sein, damit die
          Shared Library weiû, wo sie liegt.
          Wenn der Parameter NULL ist oder die
          Bibliothek im angegebenen Pfad nicht
          gefunden wurde, wird im XTENSION-Ordner
          gesucht. (!nl)
          Ab (!nolink [MagiC]) 6 wird die Environment-Variable
          SLBPATH ausgewertet. Sie enthÑlt wie PATH eine
          Liste der Suchpfade, jeweils durch ';' getrennt.
          Ist die Variable definiert, wird nicht mehr
          extra im XTENSION-Ordner gesucht.
!item [LONG min_ver]    Minimal notwendige Versionsnummer der
          Bibliothek. (!nl)
          Wenn ein Programm etwa die Version 3
          benîtigt, die Bibliothek aber erst Version 2
          ist, wird ERANGE zurÅckgegeben. Die
          tatsÑchliche Versionsnummer der Bibliothek
          wird als RÅckgabewert geliefert.
!item [SHARED_LIB *sl]    Zeiger auf den Deskriptor. Wenn die
          Bibliothek geîffnet wurde, wird hier der
          Deskriptor eingetragen.
!item [SLB_EXEC *fn]    Zeiger auf den Funktionszeiger. Wenn die
          Bibliothek geîffnet wurde, wird hier der
          Funktionszeiger eingetragen.
!end_xlist
RÅckgabewert kann sein:
!begin_verbatim
  >= 0        Alles OK, Versionsnummer der Bibliothek.
  ERANGE      Versionsnummer zu niedrig
  EACCDN      Bibliothek schon von diesem Prozeû geîffnet
  EFILNF      Bibliothek nicht gefunden
  ENSMEM      zuwenig Speicher
  ...         andere Fehlercodes.
!end_verbatim
Die Bibliothek kann nun verwendet und schlieûlich mit Slbclose()
wieder geschlossen werden. Dies ist nicht unbedingt notwendig, da
alle geîffneten Bibliotheken bei Programmende automatisch geschlossen
werden, aber es ist guter Programmierstil. Auf keinen Fall darf eine
Bibliothek mehrmals geschlossen werden, der Kernel kann solche Fehler
nicht erkennen.

Einige Bibliotheken, wie z.B. EDITOBJC.SLB, installieren neue
Systemaufrufe, in diesem Fall die AES-Aufrufe 210..217. FÅr diese
Bibliotheken wird der Funktionszeiger nicht benîtigt. Ansonsten
werden alle Funktionen der Bibliothek Åber den Funktionszeiger
aufgerufen. Die Bibliotheks-Aufruf-Funktion ist folgendermaûen
deklariert:

!begin_verbatim
 typedef LONG (cdecl *SLB_EXEC)( SHARED_LIB *sl, LONG fn,
        WORD nargs, ... );
!end_verbatim

Da leider PureC hier einen Fehler hat, muûte ich die Funktion
notgedrungen deklarieren als "typedef LONG (*SLB_EXEC)( void , ... );"
Damit sind leider alle TypÅberprÅfungen verbaut. Also Vorsicht!

Der Aufruf erwartet folgende Parameter:
!begin_verbatim
     Den Deskriptor der Bibliothek
     Ein Langwort (!) fÅr die Funktionsnummer
     Ein WORD, das die Anzahl der Argumente in WORDs
               (d.h. alle "..."-Argumente) angibt
     weitere Argumente je nach Funktion
!end_verbatim

Am besten geschieht der Aufruf Åber ein Makro, das in einer Headerdatei
fÅr die Bibliothek definiert werden sollte, z.B.:

JPEG.H:

 #define SLBJPEG_WANDELN (a,b) (*slbjpeg_exec)(slbjpeg, 7L, 4, a, b)

Hierbei werden <slbjpeg_exec> und <slbjpeg> bei Slbopen() ermittelt,
7L ist die Funktionsnummer fÅr den Aufruf WANDELN, 4 bezeichnet die
LÑnge der folgenden Argumente (a und b sind zwei Zeiger => 2*4 Bytes
=> 4 WORDs), a und b sind die Argumente der Funktion WANDELN.

Wenn die Funktion nicht vorhanden ist (die Bibliothek enthÑlt fÅr
diese Funktion einen Nullzeiger, oder die Funktionsnummer ist hîher
als die Anzahl der tatsÑchlich vorhandenen Funktionen), erhÑlt man
EINVFN als Funktionsergebnis (tatsÑchlich klappt das erst ab (!nolink [MagiC]) 6
korrekt).

!end_node

!begin_node Wie schreibe ich eine Shared Libraries?
!ignore_index

Auch dazu gibt es eine Beispielbibliothek SLB_DEMO, die alle
notwendigen Elemente und Beschreibungen enthÑlt.
Am besten, man kopiert SLB_DEMO.C, LIBHEAD.S und SLB_DEMO.PRJ und
modifiziert die Dateien entsprechend. Es muû dringend darauf geachtet
werden, daû Bit 3 der Flags im Programmheader einer Bibliothek
gesetzt ist, dazu kann man PH_BIT3.TTP verwenden.

LIBHEAD ist der Header fÅr eine Shared Library. Der Zeiger auf die
Funktionsnamen kann entfallen, ansonsten zeigt er auf eine Tabelle
von Zeigern mit den Namen der Bibliotheksfunktionen.
Die Anzahl der Funktionen muû korrekt festgelegt werden, ebenso die
Tabelle der Funktionen und der Bibliotheksname, welcher mit dem
Dateinamen identisch ist.
Beim HinzufÅgen von Funktionen muû darauf geachtet werden, die
Funktionsanzahl entsprechend anzupassen und ggf. die Versionsnummer
zu erhîhen.

Bei îffentlich zugÑnglichen Shared Libraries ist sicherzustellen, daû
dokumentierte Funktionsaufrufe nie geÑndert werden! Entweder sind neue
Parameter zu ergÑnzen (die aufgerufene Funktion kann die Anzahl der
tatsÑchlich Åbergebenen Parameter abfragen), oder es ist eine neue
Funktionsnummer zu verwenden.

FÅr die Funktionszeiger sind auch Nullzeiger zulÑssig, sie geben beim
Aufruf der Funktion ein EINVFN.

Folgende Funktionen zur (De-) Initialisierung sind obligatorisch:

(!U)slb_init()/slb_exit()(!u)

Werden beim Laden bzw. Entfernen der Bibliothek aufgerufen, und zwar
im Supervisor-Modus und im Kontext (Prozeû) der Bibliothek.
Typischerweise lÑdt slb_init() eine Konfigurationsdatei, alloziert
globalen Speicher fÅr die Bibliothek und îffnet eine virtuelle VDI-
Workstation. slb_exit() schreibt die Konfigurationsdatei zurÅck, gibt
den Speicher wieder frei und schlieût die (!nolink [VDI])-Workstation.

Falls slb_init() eine Datei îffnet, darf auf das Handle erst wieder
bei slb_exit() zugegriffen werden, da alle anderen Aufrufe der
Bibliothek im Kontext des Aufrufers ablaufen.

Ab (!nolink [MagiC]) 6 erhÑlt die Bibliothek in der Kommandozeilen-Struktur der
Basepage eine normale 'C'-Zeichenkette Åbergeben, welche den
vollstÑndigen Pfad der SharedLibrary enthÑlt. Falls die SharedLibrary
Konfigurations- oder RSC-Dateien laden muû, kann der Pfad extrahiert
und der Dateiname der Konfigurationsdatei entsprechend
zusammengebastelt werden.

Falls slb_init() z.B. aufgrund eines Busfehlers beendet wird, erhÑlt
der Aufrufer EXCPT als Ergebnis des Slbopen()-Aufrufs. Um die
unplanmÑûige Terminierung der Bibliothek abzufangen, installiert der
Kernel vor Aufruf von slb_init()/exit() einen etv_term-Handler fÅr
die Bibliothek.

(!U)slb_open()/slb_close()(!u)

Werden beim ôffnen bzw. Schlieûen der Bibliothek aufgerufen. Wenn die
Bibliothek nur einmal geîffnet wird, ist die Reihenfolge:
!begin_verbatim
  slb_init()
  slb_open()
  slb_close()
  slb_exit()
!end_verbatim

Im Gegensatz zu slb_init()/slb_exit() laufen slb_open()/slb_close()
im Kontext des Aufrufers und im Usermodus mit dem Userstack des
Aufrufers ab, auch dann, wenn der Slbopen()-Aufruf im Supervisor-Modus
erfolgt ist.

Die Bibliothek kann auch bei slb_open Speicher allozieren, dieser
gehîrt jedoch dem Aufrufer und sollte bei slb_close() wieder
freigegeben werden. Um die Zuordnung von alloziertem Speicher zum
Aufrufer zu ermîglichen, wird der Bibliothek bei slb_open(),
slb_close() und bei jedem Funktionsaufruf der aktuelle Prozeû-
Deskriptor mit Åbergeben.

(!B)Achtung:(!b) Die öbergabe des (!nolink [PD]) an slb_open() und slb_close() geht
      aufgrund eines Bugs in 5.20 erst ab (!nolink [MagiC]) 6.

Der Kernel stellt sicher, daû die open/close Aufrufe korrekt
geschachtelt sind, d.h. ein Prozeû kann eine Bibliothek nicht
mehrmals îffnen.

(!U)Funktionen(!u)

Funktionen sind nicht obligatorisch, so kann eine Bibliothek auch
Systemaufrufe Åber AES oder DOS einhÑngen, die nach Beendigung wieder
entfernt werden, i.a. werden jedoch Funktionen zur VerfÅgung gestellt.

Eine Funktion wird mit folgenden Parametern auf dem Stack aufgerufen:
!begin_xlist [WORD nargs ] !short
!item [PD *pd]    Prozeû-Deskriptor des Aufrufers, korrespondiert
        mit dem zugehîrigen slb_open()/close()
!item [LONG fn]   Funktionsnummer. Praktisch, wenn mehrere
        Funktionen zusammengelegt sind (identische
        Funktionszeiger in LIBHEAD)
!item [WORD nargs]  Anzahl der folgenden Argumente, in WORDs. Hat
        eine Funktion eine variable Anzahl von
        Parametern, kann die tatsÑchliche Anzahl
        ermittelt werden. Sehr praktisch bei
        Erweiterungen, ohne neue Funktionen einzubauen.
        Beispiel: Erwartet eine Funktion immer einen
        Zeiger, optional aber noch ein WORD, erhÑlt sie
        entweder 2 oder 3 als <nargs>.
!item [...]     die Åbrigen Parameter
!end_xlist
Die Funktionen werden im Kontext des Aufrufers und mit dessen Stack
ausgefÅhrt. Da dieser Aufruf i.a. im User-Modus erfolgt, wird das
Multitasking auch bei lÑngeren Aktionen nicht unterbrochen. Das
Funktions-Ergebnis kann je nach Funktion LONG, WORD, void usw. sein.

Eine Funktion darf die Register d0-d2 und a0-a1 Ñndern, alle anderen
Register mÅssen ggf. gerettet werden. Insbesondere darf Register a2
nicht verÑndert werden, damit Routinen von PureC aus aufgerufen werden
kînnen.

!end_node

!begin_node SLB_DEMO.C
!ignore_index
!begin_verbatim
/*
*
* Rumpf einer "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <portab.h>
#include <tos.h>
#include <tosdefs.h>
#pragma warn -par

typedef void *PD;

char *mem;      /* hier globalen Speicher */

/*****************************************************************
*
* Die init-Funktion wird einmal beim Laden der Bibliothek
* aufgerufen. Dabei lÑuft sie im Prozeû der Bibliothek,
* d.h. es kînnen Dateien geîffnet und Speicher angefordert
* werden, die jeweils der Bibliothek gehîren.
* Achtung: Auf die dabei geîffneten Dateien darf durch die
*          Bibliotheksfunktionen _NICHT_ zugegriffen werden,
*          weil diese im Kontext des Aufrufers laufen.
*
* Achtung: Die init-Funktion lÑuft im Supervisormode, da eine
*          Bibliothek i.a. keinen Userstack hat.
*          Daher darf sie nicht zuviel Stack benutzen (max. 1kB)
*          und nicht zu lange laufen (weil das Multitasking
*          im Supervisormode blockiert ist).
*          Ggf. kann aber ein Userstack alloziert und in den
*          Usermode gewechselt werden.
*
*****************************************************************/

extern LONG cdecl slb_init( void )
{
  mem = Malloc(4096L);
  if  (mem)
    return(E_OK);
  else  return(ENSMEM);
}

/*****************************************************************
*
* Die exit-Funktion wird einmal beim Freigeben der Bibliothek
* aufgerufen. Dabei lÑuft sie im Prozeû der Bibliothek,
* d.h. es kînnen Dateien geîffnet und Speicher angefordert
* werden, die jeweils der Bibliothek gehîren.
*
* Achtung: Die exit-Funktion lÑuft im Supervisormode, da eine
*          Bibliothek i.a. keinen Userstack hat.
*          Daher darf sie nicht zuviel Stack benutzen (max. 1kB)
*          und nicht zu lange laufen (weil das Multitasking
*          im Supervisormode blockiert ist).
*          Ggf. kann aber ein Userstack alloziert und in den
*          Usermode gewechselt werden.
*
*****************************************************************/

extern void cdecl slb_exit( void )
{
  Mfree(mem);
}


/*****************************************************************
*
* Die open-Funktion wird einmal beim ôffnen der Bibliothek
* durch einen Anwenderprozeû aufgerufen. Dabei lÑuft sie im
* Prozeû des Aufrufers, d.h. es kînnen Dateien geîffnet und
* Speicher angefordert werden, die jeweils dem Aufrufer gehîren.
*
* Durch den Kernel ist sichergestellt, daû jeder Prozeû die
* Bibliothek nicht mehrmals îffnet und daû die Bibliothek immer
* ordnungsgemÑû geschlossen wird.
*
* Achtung: Die open-Funktion lÑuft im Usermode, und zwar mit dem
*          Userstack des Aufrufers. Das heiût, daû der Aufrufer,
*          auch wenn er im Supervisormode lÑuft, immer einen
*          ausreichend groûen usp zur VerfÅgung stellen muû.
*
*****************************************************************/

extern LONG cdecl slb_open( PD *pd )
{
  return(E_OK);
}


/*****************************************************************
*
* Die close-Funktion wird einmal beim Schlieûen der Bibliothek
* durch einen Anwenderprozeû aufgerufen. Dabei lÑuft sie im
* Prozeû des Aufrufers, d.h. es kînnen Dateien geîffnet bzw.
* geschlossen und Speicher angefordert und freigegeben  werden,
* die jeweils dem Aufrufer gehîren.
*
* Achtung: Die close-Funktion lÑuft im Usermode, und zwar mit dem
*          Userstack des Aufrufers. Das heiût, daû der Aufrufer,
*          auch wenn er im Supervisormode lÑuft, immer einen
*          ausreichend groûen usp zur VerfÅgung stellen muû.
*
*****************************************************************/

extern void cdecl slb_close( PD *pd )
{
}


/*****************************************************************
*
* Eine Beispiel-Bibliotheksfunktion.
* Sie wird im Kontext des Aufrufers ausgefÅhrt, und zwar mit dem
* Stack des Aufrufers (je nach Status usp oder ssp).
*
* Es wird dringend empfohlen, die Funktionen einer SLB nur im
* Usermode aufzurufen, um die KompatibilitÑt zu spÑteren
* Implementationen zu wahren.
*
*****************************************************************/

extern LONG cdecl slb_fn0( PD *pd, LONG fn, WORD nargs, char *s )
{
  Cconws(s);
  Cconws("\r\nTaste: ");
  Cconin();
  return(E_OK);
}
!end_verbatim
!end_node

!begin_node LIBHEAD.S
!ignore_index
!begin_verbatim
/*
*
* Header fÅr eine "shared library"
* Wird statt des Start-Codes von PureC verwendet
*
* Andreas Kromke
* 10.2.98
*
*/

  XREF slb_init
  XREF slb_exit
  XREF slb_open
  XREF slb_close
  XREF slb_fn0

  TEXT

DC.L    $70004afc         ; magischer Wert (5.20: $42674e41)
DC.L    name              ; Zeiger auf Namen der Bibliothek
DC.L    1                 ; Versionsnummer
DC.L    0                 ; Flags, z.Zt. 0L
DC.L    slb_init          ; wird nach dem Laden aufgerufen
DC.L    slb_exit          ; wird vor dem Entfernen aufgerufen
DC.L    slb_open          ; wird beim ôffnen aufgerufen
DC.L    slb_close         ; wird beim Schlieûen aufgerufen
DC.L    0                 ; Zeiger auf Prozedurnamen (optional)
DC.L    0,0,0,0,0,0,0,0   ; unbenutzt, immer NULL
DC.L    1                 ; Anzahl der Funktionen (5.20: .W)
DC.L    slb_fn0           ; Funktion #0

name:   DC.B  'DEMO.SLB',0

END
!end_verbatim
!end_node

!begin_node SLB_DEMO.PRJ
!ignore_index
!begin_verbatim
slb_demo.slb
.L[-S=256]     ; minimaler Stack

=

libhead.s      ; startup code for SLBs
slb_demo.c (slb.h)

pctoslib.lib
pcstdlib.lib
!end_verbatim
!end_node

!begin_node PH_BIT3.TTP
!ignore_index
!begin_verbatim
/*
*
* Programm zur Manipulation des Bit 3 im Programmheader.
* MagiC benîtigt dieses Bit, das i.a. Null ist, dafÅr, um
* dem Programm nur den minimal notwendigen Speicher zuzuweisen,
* d.h. nur Basepage+Text+Daten+Symbol+Bss.
* Wird insbesondere fÅr alle SharedLibraries benîtigt.
*
* Andreas Kromke
* 25.10.97
*
*/

#include <portab.h>
#include <tos.h>
#include <tosdefs.h>
#include <stdio.h>

/* ProgramHeader, Programmkopf fÅr ausfÅhrbare Dateien                  */
/************************************************************************/

typedef struct {
 WORD ph_branch;         /* 0x00: muû 0x601a sein            */
 LONG ph_tlen;           /* 0x02: LÑnge  des TEXT - Segments */
 LONG ph_dlen;           /* 0x06: LÑnge  des DATA - Segments */
 LONG ph_blen;           /* 0x0a: LÑnge  des BSS  - Segments */
 LONG ph_slen;           /* 0x0e: LÑnge  der Symboltabelle   */
 LONG ph_res1;           /* 0x12: von PureC benîtigt         */
 LONG ph_prgflags;       /* 0x16:  Bit 0: Heap nicht lîschen */
                         /*        Bit 1: Laden ins FastRAM  */
                         /*        Bit 2: Malloc aus FastRAM */
                         /*        Bit 3: nur t+d+b+s (MagiC 5.20) */
                         /*        Bit 4,5,6,7: Speicherschutz (MiNT) */
                         /*        Bit 8: unbenutzt          */
                         /*        Bit 9: unbenutzt          */
                         /*        Bit 10: unbenutzt         */
                         /*        Bit 11: SharedText (MiNT) */
                         /*        Bit 12: unbenutzt         */
                         /*        Bit 13: unbenutzt         */
                         /*        Bit 14: unbenutzt         */
                         /*        Bit 15: unbenutzt         */
                         /*        Bits 31..28: TPA-Size     */
                         /*         (mal 128k + 128k: Mindestgr. Heap */
 WORD ph_absflag;        /* 0x1a: ungleich Null => nicht relozieren */
} PH;



WORD main( WORD argc, char *argv[] )
{
     PH ph;
     WORD ret = 0;
     LONG err;
     WORD f;

     for  (argc--,argv++; argc; argc--,argv++)
          {
          Cconws("Datei: ");
          Cconws(*argv);
          err = Fopen(*argv, RMODE_RW); /* zum Lesen+Schreiben îffnen */
          f = (WORD) err;     /* Datei-Handle */
          err = Fread(f, sizeof(PH), &ph);
          if   ((err != sizeof(PH)) || (ph.ph_branch != 0x601a))
               {
               err = EPLFMT;
               goto nextone;
               }
          Fseek(0L, f, 0);         /* Dateizeiger an den Anfang */
          ph.ph_prgflags |= 8;     /* Bit 3 setzen */
          err = Fwrite(f, sizeof(PH), &ph);

      nextone:
          if   (f > 0)
               Fclose(f);
          if   (err < 0)
               {
               printf(" => Fehler %ld", err);
               ret = (WORD) err;
               }
          Cconws("\r\n");
          }
     return(ret);
}
!end_verbatim
!end_node

!begin_node SLB_BIND
!ignore_index
(!B)Achtung:(!b) Die Funktion Slbopen enthÑlt einen zusÑtzliche
       Parameter (!I)param(!i). Dieser taucht in der SLB.H nicht mehr auf.
       Am besten einfach ignorieren.
!begin_verbatim
/*
*
* Binding fÅr die Benutzung einer "shared library"
*
* Andreas Kromke
* 22.10.97
*
*/

#include <mgx_dos.h>

/*****************************************************************
*
* ôffnet eine "shared lib".
*
* Eingabe:
* name      Name der Bibliothek inkl. Extension.
* path      Suchpfad mit '\', optional
* min_ver   Minimale benîtigte Versionsnummer
* RÅckgabe:
* sl        Bibliotheks-Deskriptor
* fn        Funktion zum Aufruf einer Bibliotheksfunktion
* <ret>     tatsÑchliche Versionsnummer oder Fehlercode
*
*****************************************************************/

LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn,
        LONG param )
{
  return(gemdos(0x16, name, path, min_ver, sl, fn, param));
}


/*****************************************************************
*
* Schlieût eine "shared lib".
*
* RÅckgabe:
* <ret>   EACCDN, falls Lib nicht geîffnet
*
*****************************************************************/

extern LONG Slbclose( SHARED_LIB *sl )

{
  return(gemdos(0x17, sl));
}

!end_verbatim

!end_node

!begin_node SLB.H
!ignore_index

!begin_verbatim
/*
*
* Binding fÅr Verwendung von "shared libraries"
*
* Andreas Kromke
* 22.10.97
*
*/

#ifndef LONG
#include <portab.h>
#endif

typedef void *SHARED_LIB;
typedef LONG (*SLB_EXEC)( void , ... );
/*
  das geht leider in PureC nicht, weil PureC hier einen
  Fehler (!!!) hat: cdecl wird ignoriert, wenn die Funktion
  eine variable Anzahl von Parametern hat.

typedef LONG (cdecl *SLB_EXEC)( SHARED_LIB *sl, LONG fn, WORD nargs, ... );
*/

extern LONG Slbopen( char *name, char *path, LONG min_ver,
        SHARED_LIB *sl, SLB_EXEC *fn );
extern LONG Slbclose( SHARED_LIB *sl );
!end_verbatim
!end_node

!end_node


!endif
