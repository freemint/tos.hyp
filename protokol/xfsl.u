# ########################################################################
# @(#) Beschreibung der xFSL-Schnittstelle, Revision 4
# @(#)16.08.1998 by Dirk Haun, Johanniterstr. 3, 74177 Bad Friedrichshall
# ########################################################################

# ########################################################################

!begin_node xFSL-Schnittstelle
Sp„testens seit der Einfhrung von Vektorfonts erfreut sich das GDOS, das
jahrelang auf dem Atari ein Schattendasein fhrte, steigender
Be!-liebt!-heit. Immer mehr Programme bieten die M”glichkeit, fr die
Aus!-ga!-be (und teilweise auch fr die Eingabe) einen anderen Font als
den Systemfont zu verwenden.

Um nun einen Font ausw„hlen zu k”nnen, ben”tigt man einen Fontselektor.
Und damit nicht jeder Programmierer sein eigenes Sppchen kocht und im
Sinne einer einheitlichen Bedienung entstand der Wunsch nach einer
Systemerweiterung, die einen Fontselektor --- „hnlich wie einen
Fileselektor --- fr alle Programme zur Verfgung stellt.

Das erste derartige Programm war der UFSL von Michael Th„nitz. Er stellt
ber einen Cookie Routinen zum Aufruf eines Fontselektors zur Verfgung.
Diese Schnittstelle wird bereits von einer Reihe von Programmen verwendet
und es gibt auch bereits weitere Font!-selektoren, die ber diese
Schnittstelle aufgerufen werden k”nnen.

Zwar l„t sich nun ber die UFSL--Schnittstelle ein Fontselektor
auf!-rufen, doch hat diese Schnittstelle bereits eine Reihe von --- zum
Teil inkompatiblen --- nderungen und Erweiterungen hinter sich. Daher
gehen die meisten Programme heute davon aus, da sie nur die
ur!-sprng!-liche einfache (!nolink [UFSL-Schnittstelle]) zur Verfgung haben. Im
Endeffekt bleiben also die Erweiterungen ungenutzt und wenn in einem
Programm dann doch einmal ein etwas leistungsf„higerer Fontselektor
ben”tigt wird, dann geht man doch wieder dazu ber, extra fr das Programm
einen neuen Fontselektor zu schreiben. Etwas berspitzt formuliert wird
hier also die Idee eines externen Fontselektors ad absurdum gefhrt !..

Durch den ""Wildwuchs"" an der (!nolink [UFSL-Schnittstelle]) erschien es sinn!-voller,
einen klaren Trennstrich zu ziehen und eine komplett neue Schnittstelle
zu entwickeln, die dann auch ber einen neuen Cookie angeboten wird.

Dieser Text beschreibt diese neue Schnittstelle, ber die nicht nur
einfach ein Fontselektor aufgerufen, sondern auch in vielf„ltiger Weise
Einflu auf diesen genommen werden kann.

!subtoc [all]

# ########################################################################
!begin_node Die xFSL--Schnittstelle

šber die xFSL--Schnittstelle hat der Aufrufer (d.h. das Programm, das den
Fontselektor aufruft) wesentlich mehr Einflu auf den Fontselektor, sein
Verhalten und auf die zur Auswahl angebotenen Fonts.

Bei der Konzeption der neuen Schnittstelle wurde versucht, auf die
M”glichkeiten der verschiedenen Programmiersprachen Rcksicht zu neh!-men
(z.B. Vermeidung von Zeigern auf Funktionen) und gleichzeitig fr m”gliche
Erweiterungen der Schnittstelle gerstet zu sein.

Die Anpassung eines Programms an die xFSL--Schnittstelle sollte eine
Sache von wenigen Minuten sein, zumal Beispielaufrufe in
ver!-schie!-de!-nen Programmiersprachen mitgeliefert wer!-den. Die
Umsetzung spezieller Wnsche ist natrlich u.U. etwas aufwendiger, sollte
aber auch kein unl”sbares Problem darstellen.

Es folgt die Beschreibung des xFSL--Cookies sowie der verschiedenen
xFSL--Aufrufe und Parameter !..

!subtoc [all]

# ========================================================================
!begin_node Der xFSL--Cookie
!label xFSL-Cookie

Wenn ein Fontselektor installiert ist, der die xFSL--Schnittstelle
un!-ter!-sttzt, dann existiert ein Cookie ""(!V)xFSL(!v)"", dessen Wert
ein Zeiger auf die folgende Struktur ist:

!begin_quote
!begin_verbatim
typedef struct
{
 unsigned long xfsl;       /* Magic 'xFSL'              */
 unsigned int  revision;   /* Schnittstellen-Revision   */
 unsigned long product;    /* Kennung des Fontselektors */
 unsigned int  version;    /* Version des Fontselektors */
 xFSL_INPUT    xfsl_input; /* einfacher Aufruf          */
 xFSL_INIT     xfsl_init;  /* Init-Aufruf               */
 xFSL_EVENT    xfsl_event; /* Event-Aufruf              */
 xFSL_EXIT     xfsl_exit;  /* Exit-Aufruf               */
 xFSL_INFO     xfsl_info;  /* Info-Aufruf               */
} xFSL;
!end_verbatim
!end_quote

Die Komponenten der Struktur im einzelnen:
!begin_description
!item [(!V)xfsl(!v)]
 Hier steht, nur zur Sicherheit, nochmals die ASCII--Zeichenfolge ""xFSL""
 (entspricht hexadezimal $7846534C).

!item [(!V)revision(!v)]
 Dies ist die Revisionsnummer der xFSL--Schnittstelle, sie enth„lt z.Z.
 den Wert 4. Sollte die Schnittstelle erweitert wer!-den, so werden dort
 entsprechend h”here Werte zu finden sein.

!item [(!V)product(!v)]
 Hier findet sich eine Kennung fr den tats„chlich in!-stal!-lier!-ten
 Fontselektor. Diese Angabe ist jedoch nur als zu!-s„tz!-liche Information
 gedacht und sollte von An!-wen!-dungs!-pro!-grammen, die den Fontselektor
 aufrufen wollen, (!I)nicht(!i) ausgewertet werden!

Bisher verwendete Kennungen:
!begin_quote
!begin_verbatim
 Kennung Fontselektor
----------------------
 CLVN    Calvino
 FSEL    FontSel
 HUGO    HuGo!
!end_verbatim
!end_quote

 Die Kennung (wie auch die folgende Versionsnummer) wurde nur fr
 Programme eingefhrt, die eine Information ber den installierten
 Fontselektor ausgeben wollen (z.B. das Programm SysInfo).

!item [(!V)version(!v)]
 Die Versionsnummer des installierten Fontselektors als BCD--Zahl
 (z.B. hexadezimal $100 fr Version 1.00). Hier gelten sinn!-ge!-m„ die
 (!nolink [Anmerkungen]) zum Feld ''(!V)product(!v)''.

!item [(!V)xfsl_input(!v)]
 Dies ist der Einsprungpunkt fr einen vereinfachten Auf!-ruf des
 Fontselektors. Der Fontselektor erscheint dann immer als modaler
 Dialog und die meisten zus„tzlichen Features der xFSL--Schnittstelle
 k”nnen nicht angesprochen werden.

!item [(!V)xfsl_init(!v), (!V)xfsl_event(!v), (!V)xfsl_exit(!v)~]
 Diese drei Funktionen bilden zu!-sam!-men den erweiterten
 Fontselektor--Aufruf. Hierber k”nnen alle neuen Features angesprochen
 werden. Die Vorgehensweise entspricht dem Darstellen eines (!nolink [GEM])-Dialogs:
 !begin_enumerate
  !item Fontselektor darstellen ((!V)xfsl_init(!v))
  !item Eventbehandlung in einer Schleife, bis ""OK"" oder ""Abbruch""
        angew„hlt wurde ((!V)xfsl_event(!v))
  !item Fontselektor vom Bildschirm entfernen ((!V)xfsl_exit(!v))
 !end_enumerate

!item [(!V)xfsl_info(!v)]
 šber diese Aufruf k”nnen einige der Features des in!-stal!-lier!-ten
 Fontselektors abgefragt werden, z.B. Drag&Drop--Unter!-sttzung.
!end_description

!end_node


# ========================================================================
!begin_node Der vereinfachte Aufruf (xfsl_input)
!label xfsl_input
(!V)xfsl_input(!v) ist der Einsprungpunkt fr einen vereinfachten Aufruf.
Der Fontselektor kann darber nur als modaler Dialog aufgerufen werden.
Auerdem kann eine šberschrift angegeben und eingeschr„nkt werden,
welche Arten von Fonts der Selektor zur Auswahl stellen soll.

!begin_quote
!begin_verbatim
int xfsl_input (int           vdihandle,
                unsigned int  fontflags,
                const char   *headline,
                int          *id,
                int          *size
               );
!end_verbatim
!end_quote

Die Parameter im einzelnen:
!begin_xlist [vdihandle~]
!item [(!V)vdihandle(!v)]
 Hier bergeben Sie das Handle einer von Ihrem Programm be!-reits
 ge”ffneten virtuellen VDI--Workstation (wenn Sie in Ihrem Programm einen
 Font einstellen wollen, mssen Sie ja ohnehin eine solche (!nolink [VDI])-Workstation
 ”ffnen). Der Fontselektor bernimmt dann den auf dieser Workstation gerade
 ein!-ge!-stell!-ten Font als ak!-tu!-ellen Font (voraus!-ge!-setzt, 
 er wird durch die Fontflags ber!-haupt zur Auswahl gestellt).

 Statt eines gltigen Handles k”nnen Sie aber auch einfach eine Null
 bergeben, dann wird der Fontselektor den Font anzeigen, den Sie in
 den Parametern ''(!V)id(!v)'' und ''(!V)size(!v)'' ber!-ge!-ben.

 Wenn Sie ein (!nolink [VDI])--Workstation--Handle bergeben, wird der aus!-ge!-w„hlte
 Font auf dieser Workstation auch gleich ein!-ge!-stellt.

!item [(!V)fontflags(!v)]
 šber die Fontflags k”nnen Sie festlegen, welche Fonts ber!-haupt zur
 Auswahl gestellt werden.

!item [(!V)headline(!v)]
 Hier k”nnen Sie eine šberschrift angeben, die dann im Fontselektor
 erscheint. Fehlt die šberschrift (šbergabe von 0L), dann wird ein
 Defaulttext (""Fontauswahl"" o.„.) ein!-ge!-setzt.

!item [(!V)id(!v)]
 In dieser Variablen wird die ID des ausgew„hlten Zeichensatzes
 zurckgeliefert (natrlich nur, wenn auch wirklich ein Zeichensatz
 ausgew„hlt wurde). Dieser Zeichensatz kann nun direkt mit der
 VDI-Funktion (!V)vst_font()(!v) ein!-ge!-stellt wer!-den.

 Wenn Sie in ''(!V)vdihandle(!v)'' eine Null bergeben, wird der
 Fontselektor den in ''(!V)id(!v)'' an!-ge!-ge!-ben!-en Font anzeigen.

!item [(!V)size(!v)]
 In dieser Variablen wird die Gr”e des ausgew„hlten Fonts in Punkt
 zurckgegeben (auch nur, wenn wirklich ein neuer Zeichensatz ausgew„hlt
 wurde). Wenn es sich um einen Bitmapfont handelt, kann diese Gr”e
 mit der (!nolink [VDI])--Funktion (!V)vst_point()(!v) eingestellt werden. Fr
 Vektorfonts sollte die Funktion (!V)vst_arbpt()(!v) auf!-ge!-ru!-fen
 werden.

 Wenn Sie in ''(!V)vdihandle(!v)'' eine Null bergeben, wird der
 Fontselektor den in ''(!V)id(!v)'' angegebenen Font in der in
 ''(!V)size(!v)'' an!-ge!-ge!-ben!-en Gr”e anzeigen.
!end_xlist

!smallskip

(!U)Rckgaben(!u)

(!V)xfsl_input(!v) liefert eine negative Zahl zurck, wenn ein Fehler
auf!-ge!-tre!-ten ist. Eine 0 wird zurckgegeben, wenn ""Abbruch""
angew„hlt wur!-de. Wird eine 1 zurck geliefert, dann wur!-de ein neuer
Font ausgew„hlt.

Die Rckgabewerte sind fr alle xFSL--Funktionen gleich
und auf!-w„rts!-kom!-pa!-ti!-bel zu den Rckgabewerten des UFSL.
!end_node


# ========================================================================
!begin_node Der erweiterte Aufruf
Der erweiterte xFSL--Aufruf besteht aus drei einzelnen
Funktions!-auf!-rufen:
!begin_xlist [xfsl_event~]
!item [(!V)xfsl_init(!v)]
      Stellt den Fontselektor auf dem Bildschirm dar. Auerdem werden hier
      die Parameter bergeben.
!item [(!V)xfsl_event(!v)]
      Diese Funktion wird solange immer wieder aufgerufen, bis im
      Fontselektor ein Font ausgew„hlt, oder ""Abbruch"" an!-ge!-w„hlt
      wurde.
!item [(!V)xfsl_exit(!v)]
      Entfernt den Fontselektor wieder vom Bildschirm.
!end_xlist

!smallskip

In C kann das dann beispielsweise so ausssehen:
!begin_quote
!begin_verbatim
xhandle = xfsl->xfsl_init (vdihandle, &xpar);
if (xhandle >= 0)
{
  do
  {
    ret = xfsl->xfsl_event (xhandle, 0L);
    if (ret == xFS_HELP)
      ...;  /* Hilfefunktion aufrufen */
    else if (ret == xFS_POPUP)
      ...;  /* Popup behandeln        */
    else if (ret == xFS_EVENT)
      ...;  /* AES-Event bearbeiten   */
  } while ((ret != xFS_OK) && (ret != xFS_STOP));
  xfsl->xfsl_exit (xhandle);
}
!end_verbatim
!end_quote

Diese ""Dreiteilung"" hat u.a. den Vorteil, da zur Bearbeitung der
Ereignisse (Hilfe--Button, (!nolink [Popup]), (!nolink [AES])--Events) keine Zeiger auf
Funk!-tionen bergeben werden mssen (was in einigen Programmier!-sprachen
nur schwer zu realisieren ist). Auch l„t sich die Schnittstelle so
leicht um weitere Ereignisse erweitern, falls dies einmal n”tig sein
sollte.

!end_node
# Weil UDO zuwenige Unterkapitel kann.

# ------------------------------------------------------------------------
!begin_node xfsl_init

Dieser Aufruf bringt nicht nur den Fontselektor auf den Bildschirm,
er bestimmt auch, welche Fonts angezeigt werden sollen, ob ein
User--(!nolink [Popup]) verwendet wird und einiges mehr.

!begin_quote
!begin_verbatim
int xsfl_init (int       vdihandle,
               xFSL_PAR *xpar
              );
!end_verbatim
!end_quote

Die beiden Parameter bedeuten:
!begin_xlist [vdihandle~]
!item [(!V)vdihandle(!v)]
 Hier bergeben Sie, wie schon beim vereinfachten Aufruf, das Handle
 einer von Ihrem Programm bereits ge”ffneten virtuellen VDI--Workstation
 oder einfach eine Null.

 Wenn Sie ein gltiges Workstation--Handle bergeben, wird der
 Fontselektor den auf dieser Workstation aktuellen Font bernehmen und
 anzeigen --- sofern er duch die Font!-flags (in der
 (!V)xFSL_PAR(!v)--Struk!-tur) berhaupt zur Auswahl gestellt wird. Ist
 dies nicht der Fall, wird der Fontselektor einen Font aus den zur
 Verfgung stehenden aus!-w„hlen und an!-zei!-gen.

 šbergeben Sie als Workstation--Handle eine Null, dann wird der Font
 aus der (!V)PFONTINFO(!v)--Struktur (auf die ein Zeiger in der
 (!V)xFSL_PAR(!v)--Struktur zeigt) ber!-nommen und angezeigt.

 Wenn Sie ein VDI--Workstation--Handle bergeben, wird der aus!-ge!-w„hlte
 Font auf dieser Workstation auch gleich eingestellt.

!item [(!V)xpar(!v)]
 Dies ist ein Zeiger (d.h. die Adresse) auf eine
 (!V)xFSL_PAR(!v)--Struktur, die alle weiteren Angaben fr den
 Fontselektor enth„lt.

 Wegen der Vielzahl der M”glichkeiten wurde dieser Struk!-tur ein eigener
 Abschnitt gewidmet.
!end_xlist

Fr die Returncodes der Funktion gilt wieder: Ein negativer
Rck!-ga!-be!-wert deutet auf einen Fehler hin. Positive Werte haben hier
eine et!-was abweichende Bedeutung: Eine 0 heit, der Fontselektor wurde
(er!-folg!-reich) als modaler Dialog ge”ffnet. Andere positive Werte
ent!-sprechen dem Fensterhandle des ge”ffneten Fontselektors. Somit k”nnen
Sie das Fenster des Fontselektors beispielsweise bei einem AV--Server
anmelden.

Im Erfolgsfalle (Rckgabe gr”er oder gleich 0) sollten Sie sich das
Handle in einer Variablen merken, da es fr die folgenden Aufrufe
((!V)xfsl_event(!v) und (!V)xfsl_exit(!v)) noch ben”tigt wird.

(!B)Hinweis:(!b) Wenn der Fontselektor als Fenster dargestellt werden
sollte, (!V)xfsl_init(!v) aber den Fehler (!V)xFS_NO_WINDOW(!v) liefert
(kein Fenster mehr frei), dann sollte m”glichst versucht werden, den
Fontselektor we!-nig!-stens als Dialog darzustellen (Kontrollflag
(!V)CC_WINDOW(!v) l”schen und nochmals (!V)xfsl_init(!v) aufrufen).

(!B)Merke:(!b) Der Anwender will einen Fontselektor, keine Fehlermeldung.

!end_node


# ------------------------------------------------------------------------
!begin_node xfsl_event

Wenn der Fontselektor initialisiert und auf den Bildschirm gebracht
wurde, bernimmt (!V)xfsl_event(!v) die Hauptarbeit.

!begin_quote
!begin_verbatim
int xfsl_event (int    xhandle,
                EVENT *event
               );
!end_verbatim
!end_quote

Die beiden Parameter bedeuten:
!begin_xlist [xhandle~]
!item [(!V)xhandle(!v)]
 Das Handle des Fontselektors, wie es von (!V)xfsl_init(!v) ge!-lie!-fert
 wurde.

!item [(!V)event(!v)]
 Zeiger auf eine (!V)EVENT(!v)--Struktur, wie sie von Pure C ver!-wen!-det
 wird. In dieser Struktur liefert der Fontselektor (!nolink [AES])--Events zu!-rck,
 die er nicht selbst bearbeiten konnte. Auer!-dem k”n!-nen Sie ber die
 Eingabeparameter dem Fontselektor auch mit!-tei!-len, ber welche
 Ereignisse sie berhaupt un!-ter!-rich!-tet werden wollen.

 Der Zeiger kann aber auch einfach Null sein, wenn Sie keine (wei!-te!-ren)
 Events auswerten wollen. Soll der Fontselektor als Fenster!-dialog
 betrieben werden und der Aufrufer (d.h. Ihr Programm) hat noch weitere
 Fenster offen, dann mssen Sie aber zu!-min!-dest die Redraw--Meldungen
 auswerten!

 (!B)Beispiel:(!b) Wenn Sie in ''(!V)ev_mflags(!v)'' das Flag
 (!V)MU_MESAG(!v) setzen, wird der Fontselektor alle eintreffenden
 (!nolink [AES])--(!nolink [Nachrichten]), die er nicht selbst bearbeiten kann, an
 den Aufrufer zu!-rck!-lie!-fern.

 (!B)Hinweis:(!b) Es ist natrlich auch m”glich, Timer--Events zu
 be!-kommen. Diese sollten aber sparsam eingesetzt werden und nicht zu
 kurz sein, da der Fontselektor dazu jedesmal erst seine eigene
 Event--Schleife verlassen mu. 250 ms m”gen als --- unverbindliche ---
 un!-te!-re Grenze gelten.
!end_xlist

Die m”glichen Rckgabewerte von (!V)xfsl_event(!v):
!begin_xlist [xFS_POPUP~]
!item [(!V)xFS_STOP(!v)]
 Im Fontselektor wurde der Button ""Abbruch"" oder (so vor!-han!-den) der
 Closer des Fensterdialogs angew„hlt.

 Wenn das Kontrollflag (!V)CC_CLOSER(!v) gesetzt ist und der Closer
 an!-ge!-klickt wurde, enth„lt die (!V)PFONTINFO(!v)--Struktur, auf die der
 Zeiger in der (!V)xFSL_PAR(!v)--Struktur zeigt, aber trotzdem Angaben
 darber, welcher Font zuletzt im Fontselektor angew„hlt worden war.
 Anders w„re diese In!-for!-ma!-ti!-on sonst ja nicht zu erhalten.

!item [(!V)xFS_OK(!v)]
 Es wurde ein Font ausgew„hlt und ""OK"" angew„hlt.
 Welcher Font ausgew„hlt wurde, beschreibt die (!V)PFONTINFO(!v)--Struktur,
 auf die der Zeiger in der (!V)xFSL_PAR(!v)--Struktur zeigt. Wenn bei
 (!V)xfsl_init(!v) ein gltiges (!nolink [VDI])--Handle bergeben wurde, dann wird der
 ausgew„hlte Font auch gleich auf dieser VDI--Workstation eingestellt.

!item [(!V)xFS_HELP(!v)]
 Der Hilfe--Button wurde angew„hlt (kann natrlich nur auf!-tre!-ten, wenn
 Sie ihn haben einblenden lassen). Es liegt nun am Aufrufer, wie er darauf
 reagiert. Im Normalfall wird man wohl eine Hilfe geben, z.B. indem man
 eine Hilfs!-seite anzeigt oder anzeigen l„t.

!item [(!V)xFS_EVENT(!v)]
 Ein (!nolink [AES])--Event ist aufgetreten, den der Fontselektor nicht bearbeiten
 konnte (z.B. eine Redraw--Meldung fr ein an!-de!-res Fenster). Welcher
 Event es genau war, k”nnen Sie dem Feld ''(!V)ev_mwich(!v)'' der
 (!V)EVENT(!v)--Struktur entnehmen.

 Accessories sollten bei Eintreffen der Nachricht (!V)AC_CLOSE(!v) den
 Aufruf von (!V)xfsl_exit(!v) nicht vergessen! Gleiches gilt analog fr
 die Nachricht (!V)AP_TERM(!v).

!item [(!V)xFS_POPUP(!v)]
 Am User--(!nolink [Popup]) (sofern vorhanden) wurde ein Ver„nderung vor!-ge!-nommen.
 Bei dem (!nolink [Popup])--Eintrag, der ge„ndert wurde, ist im Element
 ''(!V)fontflags(!v)'' das Bit (!V)FF_CHANGED(!v) gesetzt. Der
 (!nolink [Popup])--Eintrag, der jetzt angew„hlt wurde und bei Rckkehr in den
 Fontselektor (beim n„chsten (!V)xfsl_event(!v)--Aufruf) der aktuelle des
 Popups sein wird, steht im Element ''(!V)sel_entry(!v)''.

 Sie haben jetzt noch die M”glichkeit, nderungen an den (!nolink [Popup])--Eintr„gen
 vorzunehmen, beispielsweise die Fontflags zu „ndern oder den ge„nderten
 Font in alle anderen (!nolink [Popup])-Eintr„ge zu ber!-nehmen (auf diese Weise ist
 es auch m”g!-lich, das (!nolink [Popup]) fr eine andere Information zu ver!-wen!-den,
 die mit den ausgew„hlten Fonts nichts zu tun hat).
 Die Texte und die Anzahl der (!nolink [Popup])-Eintr„ge drfen aber nicht ver„ndert
 werden!

!item [andere Werte:]
 Andere positive Werte sollten ignoriert werden. Es ist m”glich, da die
 Schnittstelle um weitere Rckgabewerte (Er!-eig!-nis!-se) erweitert wird.

 Negative Werte zeigen einen Fehler an, der Fontselektor soll!-te dann
 abgebrochen werden. Dazu mu aber unbedingt noch (!V)xfsl_exit(!v)
 aufgerufen werden!
!end_xlist

!end_node

# ------------------------------------------------------------------------
!begin_node xfsl_exit

Mit dem (!V)xfsl_exit(!v)--Aufruf wird der Fontselektor wieder vom
Bildschirm entfernt:

!begin_quote
!begin_verbatim
void xfsl_exit (int xhandle);
!end_verbatim
!end_quote

Dabei ist ''(!V)xhandle(!v)'' wieder das Handle des Fontselektors, wie es
von (!V)xfsl_init(!v) geliefert wurde.

(!V)xfsl_exit(!v) mu immer dann aufgerufen werden, wenn die Behandlung des
Fontselektors beendet werden soll. Sei es dadurch, da ein Font
aus!-ge!-w„hlt oder ""Abbruch"" angew„hlt wurde, oder da
(!V)xfsl_event(!v) einen Feh!-ler meldete. Wenn schon der
(!V)(!nolink [xfsl_init])(!v)--Aufruf fehlgeschlagen ist, darf (!V)xfsl_exit(!v) nicht
aufgerufen werden (logisch, da man ja auch kein gl!-tiges Handle hat).

Der Aufruf von (!V)xfsl_exit(!v) sollte auch bei Eintreffen der
(!nolink [Nachrichten]) (!V)AC_CLOSE(!v) und (!V)AP_TERM(!v) nicht vergessen werden!

!end_node

# ========================================================================
!begin_node Der Info--Aufruf (xfsl_info)
!label xfsl_info

šber diesen Aufruf k”nnen einige der Features des installierten
Fontselektors abgefragt werden:

!begin_quote
!begin_verbatim
long xfsl_info (void);
!end_verbatim
!end_quote

Wenn der Rckgabewert positiv ist, dann stehen die folgenden Flags fr
vorhandene Features (negative Rckgabewerte sind, wie blich,
Fehlermeldungen):

!raw [stg] @alabel "XF_SIZE" "XF_COLOR" "XF_ATTR" "XF_WIDTH" "XF_KERN" "XF_SKEW"
!raw [stg] @alabel "XF_ALIGN" "XF_ROTATION" "XF_FIX31" "XF_POPUP" "XF_DRAGDROP"
!raw [stg] @alabel "XF_MAPPING"
!begin_quote
!begin_verbatim
 Name         Wert     Bedeutung
--------------------------------------------------------
 XF_SIZE      0x0001   Gr”en„nderung m”glich
 XF_COLOR     0x0002   Farb„nderung m”glich
 XF_ATTR      0x0004   Attribut„nderung m”glich
 XF_WIDTH     0x0008   Breiten„nderung m”glich
 XF_KERN      0x0010   Kerning„nderung m”glich
 XF_SKEW      0x0020   Neigungs„nderung m”glich
 XF_ALIGN     0x0040   nderung der Ausrichtung m”glich
 XF_ROTATION  0x0080   Textrotation m”glich
 XF_FIX31     0x0100   fix31-Untersttzung
 XF_POPUP     0x0200   Popup-Untersttzung
 XF_DRAGDROP  0x0400   Drag&Drop-Untersttzung
 XF_MAPPING   0x0800   beherrscht Mapping
!end_verbatim
!end_quote

Weitere Features des Fontselektors lassen sich indirekt ber das Element
''(!V)(!nolink [control])(!v)'' der (!V)xFSL_PAR(!v)--Struktur abfragen: Bei einem
er!-folg!-reichen (!V)xfsl_init(!v)--Aufruf werden diejenigen
Kontrollflags ge!-l”scht, die der Fontselektor nicht kennt.

!end_node

# ========================================================================
!begin_node Die VDI--Workstation

Bei den Aufrufen (!V)xfsl_input(!v) und (!V)xfsl_init(!v) kann jeweils
das Handle einer vom Aufrufer bereits ge”ffneten virtuellen
VDI--Workstation bergeben werden. Davon, ob man tats„chlich ein Handle
einer Workstation oder einfach eine Null bergibt, h„ngt das weitere
Verhalten des Fontselektors ab:

šbergibt man ein gltiges Handle, so wird der Fontselektor versuchen, den
auf der entsprechenden Workstation gerade aktuellen Font zu er!-mitteln
und diesen dann --- sofern er zu den bergebenen Fontflags pat --- auch
einstellen und zur Auswahl anbieten. Pat der aktuelle Font nicht zu den
Fontflags (wenn z.B. nur Vektorfonts angeboten werden sollen, der aktuelle
Font aber ein Bitmapfont ist), so wird der Fontselektor einen Font aus
den tats„chlich angebotenen ausw„hlen und als aktuellen Font pr„sentieren.

W„hlt der Anwender nun einen Font aus und beendet den Fontselektor mit
""OK"", so wird dieser Font auch gleich auf der bergebenen Workstation
eingestellt, so da das aufrufende Programm dies nicht mehr bernehmen
mu.

Dabei gilt es zu beachten, da der Fontselektor ebenfalls eine eigene
(!nolink [VDI])--Workstation ”ffnet und diese intern und zur Auswahl der Fonts
verwendet. U.a. wird er fr diese Workstation auch (!V)vst_load_fonts()(!v)
aufrufen (sofern ein GDOS installiert ist). Dies kann zu unerwarteten
Resultaten fhren, wenn auf der bergebenen Workstation noch kein
(!V)(!nolink [vst_load_fonts])()(!v) aufgerufen wurde und der Anwender im Fontselektor
einen Font ausw„hlt, der erst nach einem (!V)(!nolink [vst_load_fonts])()(!v)--Aufruf
zur Verfgung steht!

!smallskip

Statt eines Workstation--Handles kann man aber auch einfach eine Null
bergeben. Der Fontselektor wird den aktuellen Font dann aus den
bergebenen Parametern (beim (!V)(!nolink [xfsl_input])(!v)--Aufruf) bzw. aus der
(!V)xFSL_PAR(!v)--Struktur (beim (!V)(!nolink [xfsl_init])(!v)--Aufruf) ermitteln.

Der ausgew„hlte Font wird dann (logischerweise) auch nur in den Parametern
bzw. der (!V)(!nolink [xFSL_PAR])(!v)--Struktur zurckgegeben und der Aufrufer mu ihn
dann selbst einstellen.

!end_node


# ========================================================================
!begin_node Die xFSL_PAR-Struktur
!label xFSL_PAR
šber diese Struktur haben Sie weitgehenden Einflu auf das Verhalten des
Fontselektors und die Art der dargestellten Fonts. Daher f„llt die
Beschreibung der M”glichkeiten auch etwas l„nger aus !..

!begin_quote
!begin_verbatim
typedef struct
{
 int            par_size;    /* Gr”e der xFSL_PAR-Struktur   */
 int            pfi_size;    /* Gr”e der PFONTINFO-Struktur  */
 unsigned long  control;     /* Kontrollflags                 */
 const char    *headline;    /* šberschrift oder 0L           */
 const char    *example;     /* Beispieltext oder 0L          */
 const char    *helptext;    /* Text des Hilfe-Buttons od. 0L */
 PFONTINFO     *font;        /* Zeiger auf Fontinfo-Struktur  */
 unsigned int   fontflags;   /* erlaubte Fontarten            */
 const char    *poptext;     /* Text vor dem Popup oder 0L    */
 int            num_entries; /* Anzahl der Eintr„ge (0..n)    */
 int            sel_entry;   /* Selektierter Eintrag (0..n-1) */
 xFSL_PENTRY   *popup;       /* Zeiger auf ein Popup oder 0L  */
 char          *helpinfo;    /* Zeiger auf Hilfedatei/-seite  */
} xFSL_PAR;
!end_verbatim
!end_quote

Trotz der Vielzahl der Eintr„ge ist eigentlich alles ganz einfach, zumal
Sie Felder, die Sie nicht ben”tigen oder deren Bedeutung Ihnen noch nicht
klar ist, einfach mit Null ausfllen k”nnen, worauf der Fontselektor dann
sinnvolle Defaultwerte annehmen wird.

Die Felder im einzelnen:
!begin_xlist [fontflags~]
!item [(!V)par_size(!v)]
 Dieses Feld darf nicht auf Null gesetzt werden, hier wird die Gr”e der
 (!V)xFSL_PAR(!v)--Struktur in Bytes eingetragen, weshalb man in C einfach
 schreiben kann
!begin_quote
!begin_verbatim
xpar.par_size=sizeof(xFSL_PAR);
!end_verbatim
!end_quote
 Die Gr”e der Struktur betr„gt z.Z. 42 Bytes. Sollte die Struktur
 erweitert werden, kann der Fontselektor an der Gr”enangabe er!-ken!-nen,
 ob er es mit einer neuen oder einer alten Struktur zu tun hat.

!item [(!V)pfi_size(!v)]
 Auch dieses Feld darf nicht Null sein, hier mu die Gr”e der
 (!V)(!nolink [PFONTINFO])(!v)--Struktur eingetragen werden, also
!begin_quote
!begin_verbatim
xpar.pfi_size=sizeof(PFONTINFO);
!end_verbatim
!end_quote
 Die aktuelle Gr”e der (!V)PFONTINFO(!v)--Struktur betr„gt 38 Bytes
 und k”nnte ebenfalls in Zukunft erweitert werden.

!item [(!V)(!nolink [control])(!v)]
 Dies sind die sogenannten Kontrollflags, ber die das Ver!-hal!-ten des
 Fontselektors beeinflut werden kann (z.B. ob er als Fenster oder als
 Dialog erscheinen soll).

 Diesen Flags wurde ein eigener Abschnitt gewidmet.

!item [(!V)headline(!v)]
 Dies ist, wie schon vom einfachen Aufruf her bekannt, ein Zeiger auf eine
 šberschrift fr den Fontselektor. Fehlt diese (d.h. ''(!V)headline(!v)''
 enth„lt Null), dann wird der Fontselektor eine Default--šberschrift
 einsetzen.

 Die L„nge der šberschrift sollte sich in dem noch vom UFSL
 vor!-ge!-ge!-be!-nen Rahmen (34 Zeichen) bewegen, der Fontselektor wird
 l„n!-gere šberschriften aber ggfs. krzen.

!item [(!V)example(!v)]
 Ein Zeiger auf einen Beispieltext. Der Fontselektor zeigt fr den jeweils
 eingestellten Font ein Schriftbeispiel an, dessen Text hiermit vorgegeben
 werden kann. Fehlt dieser Text (d.h. ''(!V)example(!v)'' enth„lt Null),
 wird der Fontselektor einen Defaulttext anzeigen (z.B. den Namen des
 jeweiligen Zeichensatzes).

!item [(!V)helptext(!v)]
 Dies ist der Text fr einen Button, der links unten im Fontselektor
 eingeblendet werden kann. Im Normalfall wird man dort einen Button mit
 der Aufschrift ""Hilfe"" oder ""Help"" einblenden wollen, um dem Anwender
 die Funktion des Fontselektors zu er!-kl„!-ren, und wofr der ausgew„hlte
 Font verwendet wird.

 Fehlt dieser Text (d.h. ''(!V)helptext(!v)'' enth„lt Null), wird auch
 kein Hilfe-Button eingeblendet. Dann wird (!V)xfsl_event(!v) auch nicht
 den Rckgabewert (!V)xFS_HELP(!v) liefern.

 Man sollte einen kurzen Text w„hlen (etwa 8 Zeichen), der Fontselektor
 wird l„ngere Texte aber ggfs. krzen.

!item [(!V)font(!v)]
 Dies ist ein Zeiger auf eine Struktur ((!V)PFONTINFO(!v)), die einen Font
 beschreibt. Die Struktur wird sowohl zur šber!-ga!-be von Werten an den
 Fontselektor als auch zur Rckgabe des ausgew„hlten Fonts verwendet.

 Auch dieser Struktur ist ein eigener Abschnitt gewidmet.

!item [(!V)fontflags(!v)]
 Dies sind wieder die vom einfachen Aufruf bekannten Font!-flags, mit
 denen Sie die zur Auswahl gestellten Fonts beeinfluen k”nnen.

!item [(!V)poptext(!v), (!V)num_entries(!v), (!V)sel_entry(!v), (!V)popup(!v):]
 Mit diesen vier Parametern k”nnen Sie ein zus„tzliches (!nolink [Popup]) in den
 Fontselektor einblenden lassen. Wegen der vielf„ltigen M”glichkeiten
 gibt's dafr auch wieder einen eigenen Abschnitt.

 Wollen Sie kein (!nolink [Popup]), so setzen Sie diese vier Werte einfach auf Null.

!item [(!V)helpinfo(!v)]
 Dies ist ein reiner Ausgabeparameter: Wenn der Hilfe--Button angew„hlt
 wurde (sofern vorhanden, siehe ''(!V)help!-text(!v)''), dann steht hier ein
 Zeiger auf einen Dateinamen einer Hilfedatei und den Namen einer Seite,
 die angezeigt werden kann. Der Dateiname wird ohne Pfad und Extension
 angegeben, der Seitenname folgt direkt dahinter, durch ein Komma getrennt.
 !begin_quote
  (!B)Der String darf nur gelesen, aber nicht ver!-„ndert werden!(!b)
 !end_quote
 Wenn Sie bei (!V)xFS_HELP(!v) nicht selbst eine Hilfe anzeigen wollen,
 dann k”nnen Sie mit diesen Informationen ein Hilfesystem (z.B. ST--Guide)
 aufrufen.

 (!B)Beispiel:(!b) (!V)xfsl_event(!v) gibt (!V)xFS_HELP(!v) zurck, in
 ''(!V)helpinfo(!v)'' findet sich ein Zeiger auf den String
!begin_quote
!begin_verbatim
toll,Der tollste Fontselektor aller Zeiten
!end_verbatim
!end_quote
 Daraus l„t sich dann folgender Aufruf fr ST-Guide erstellen:
!begin_quote
!begin_verbatim
*:\toll.hyp Der tollste Fontselektor aller Zeiten
!end_verbatim
!end_quote
 Man h„ngt also an den Dateinamen die Extension fr das jeweilige
 Hilfesystem an und bergibt den Teil nach dem ersten Komma als Seitenname.
!end_xlist

!smallskip

Um es nochmals zu betonen: Felder, die sie nicht ben”tigen oder noch nicht
verstehen, k”nnen Sie zun„chst einfach auf Null setzen. Aus!-nahmen sind
nur
!begin_itemize
 !item ''(!V)par_size(!v)'', die Gr”e der (!V)xFSL_PAR(!v)--Struktur selbst
 !item ''(!V)pfi_size(!v)'', die Gr”e der (!V)PFONTINFO(!v)--Struktur
 !item ''(!V)font(!v)'', der Zeiger auf die (!V)(!nolink [PFONTINFO])(!v)--Struktur
!end_itemize

!end_node

# ------------------------------------------------------------------------
!begin_node Die Kontrollflags

šber die Kontrollflags kann das Verhalten des Fontselektors be!-ein!-flut
werden.

!raw [stg] @alabel "CC_WINDOW" "CC_FIX31" "CC_NOSIZE" "CC_NOCOLOR" "CC_NOATTR"
!raw [stg] @alabel "CC_NOWIDTH" "CC_NOKERN" "CC_NOSKEW" "CC_NOALIGN" "CC_NOROTATION"
!raw [stg] @alabel "CC_DFLTSIZE" "CC_INVSTYLE"
!begin_quote
!begin_verbatim
 Name           Wert    Bedeutung
--------------------------------------------------------------
 CC_WINDOW      0x0001  Fontselektor als Fenster
 CC_APPMODAL    0x0002  Fontselektor ist applikationsmodal
 CC_FIX31       0x0004  alle Gr”enangaben in 1/65536 Punkt
 CC_FAKESTYLE   0x0008  Schnitte simulieren (nur Bitmapfonts)
 CC_CLOSER      0x0010  Fenster mit Closer, kein OK-Button
 CC_NOSIZE      0x0100  Gr”e nicht „ndern
 CC_NOCOLOR     0x0200  Farbe nicht „ndern
 CC_NOATTR      0x0400  Attribute nicht „ndern
 CC_NOWIDTH     0x0800  Breite nicht „ndern
 CC_NOKERN      0x1000  Kerning nicht „ndern
 CC_NOSKEW      0x2000  Skewing nicht „ndern
 CC_NOALIGN     0x4000  Ausrichtung nicht „ndern
 CC_NOROTATION  0x8000  Textrotation nicht „ndern
 CC_DFLTSIZE   0x10000  Schriftgr”e "Default"
 CC_INVSTYLE   0x20000  Attribut "Invers"
!end_verbatim
!end_quote
Die Funktion der einzelnen Flags sollte sich schon aus den Namen und den
Kurzbeschreibungen ergeben. Hier noch einige (!nolink [Anmerkungen]):
!begin_itemize
!raw [stg] @alabel "CC_APPMODAL"
!item (!V)CC_APPMODAL(!v) (!nl)
 ""Applikationsmodal"" heit, da das Programm in einen Modus ver!-setzt
 wird, in dem nur noch der Fontselektor bearbeitet wer!-den kann. Im
 wesentlichen bedeutet das, da der Fontselektor alle
 (!V)WM_TOPPED(!v)--Nachrichten fr andere Fenster des aufrufenden
 Programms abf„ngt und (!I)nicht(!i) weiterleitet, sondern sich
 statt!-dessen selbst zum obersten Fenster macht. Damit soll dem Anwender
 si!-gna!-lisiert wer!-den, da er zuerst den Fontselektor bearbeiten soll,
 bevor er eine andere Aktion im Programm aus!-l”sen kann.

 Der Aufrufer sollte in diesem Modus natrlich darauf verzichten, eigene
 Fenster selbst mit (!V)wind_set(WF_TOP)(!v) zum obersten Fenster zu
 machen.

!raw [stg] @alabel "CC_FAKESTYLE"
!item (!V)CC_FAKESTYLE(!v) (!nl)
 Dies ist eine Spezialit„t, die z.Z. nur Calvino anbietet: Bei denjenigen
 Bitmapfonts, bei denen keine leichten, kursiven bzw. fetten Schnitte
 vorliegen, werden die jeweils fehlenden Schnitte mit der VDI--Funktion
 (!V)vst_effects()(!v) simuliert.

!raw [stg] @alabel "CC_CLOSER"
!item (!V)CC_CLOSER(!v) (!nl)
 Wenn dieses Flag und (!V)CC_WINDOW(!v) gesetzt sind, wird der Fontselektor mit
 einem Closer versehen, w„hrend der OK-- und der Abbruch--Button versteckt
 werden. Gedacht ist dies fr die F„lle, in denen der Fontselektor als
 reiner Drag&Drop--Selektor eingesetzt werden soll.

!item (!V)CC_NO...(!v) (!nl)
 šber diese Flags kann bestimmt werden, welche Einstellungen nicht
 ver„ndert werden sollen. Beispielsweise k”nnte ein Programm verhindern
 wollen, da die Gr”e eines Zeichensatzes ge!-„n!-dert wird, w„hrend eine
 nderung des Fonts selbst erm”glicht werden soll. Dann mu der Aufrufer
 nur das Flag (!V)CC_NOSIZE(!v) setzen.

 Beachten Sie aber, da Sie trotz gesetztem (!V)CC_NO...(!v)--Flag immer
 einen gltigen Wert bergeben mssen. Die Bedeutung dieser Flags ist
 also, da die vorgegebenen Werte nicht ver„ndert werden k”nnen und nicht,
 da die Werte nicht von Interesse sind.
!end_itemize

(!B)Bitte beachten:(!b) Nicht alle Fontselektoren untersttzen auch alle
Kontrollflags! Wenn ein Fontselektor ein Flag nicht untersttzt, so wird
er es einfach ignorieren. Bei einem erfolgreichen(!)
(!V)xfsl_init(!v)-Aufruf wird der Fontselektor diejenigen Flags im Element
''(!V)(!nolink [control])(!v)'' der (!V)xFSL_PAR(!v)-Struktur l”schen, die er nicht
versteht.

!end_node

# ------------------------------------------------------------------------
!begin_node Die PFONTINFO-Struktur
!label PFONTINFO
Diese Struktur beschreibt einen Font. Sie enth„lt nach dem Aufruf des
Fontselektors den ausgew„hlten Font. Zudem werden diese Angaben vom
Fontselektor schon beim Aufruf ausgewertet (und der so beschriebene Font
angezeigt), wenn als (!nolink [VDI])--Handle eine Null bergeben wird.
!begin_quote
!begin_verbatim
typedef struct
{
 int          fontid;     /* ID des Fonts                  */
 int          fonttype;   /* Typ des Fonts                 */
 char        *fontname;   /* Name des Fonts                */
 union fsize  fontsize;   /* Fontgr”e in pt oder fix31    */
 union fsize  fontwidth;  /* Breite in pt oder fix31       */
 char         trackkern;  /* Track-Kerning                 */
 char         pairkern;   /* Paar-Kerning                  */
 int          fontattr;   /* Attribute                     */
 int          fontskew;   /* Neigung                       */
 int          fontcol;    /* Farbe                         */
 int          backcol;    /* Text-Hintergrundfarbe         */
 int          halign;     /* horizontale Textausrichtung   */
 int          valign;     /* vertikale Textausrichtung     */
 int          rotation;   /* Textrotation in 1/10 Grad     */
 int          validtype;  /* Typ (V_CHAR_...) oder Mapping */
 int         *validchars; /* ben”tigte Zeichen oder 0L     */
} PFONTINFO;
!end_verbatim
!end_quote

Die Elemente im einzelnen:
##!begin_description
!begin_xlist [fontwidth~]
!item [(!V)fontid(!v)]
 Die ID des Fonts, wie sie auch von der VDI--Funktion (!V)vqt_name()(!v)
 zurckgegegeben wird. Die Font--ID ist eine Zahl ungleich Null (kann also
 auch negativ sein).

!label BITMAP_FONT
!label SPEEDO_FONT
!label TT_FONT
!label PFB_FONT
!item [(!V)fonttype(!v)]
 Der Typ des Fonts, wie er ab Speedo 5 bzw. NVDI 3 ver!-wen!-det wird:
!label Fonttyp
!begin_quote
!begin_verbatim
 Name         Wert    Fontart
------------------------------------------
 BITMAP_FONT  0x0001  Pixel
 SPEEDO_FONT  0x0002  Speedo
 TT_FONT      0x0004  TrueType
 PFB_FONT     0x0008  Type 1 (Postscript)
!end_verbatim
!end_quote
 Diese Angaben sind z.Z. nur zur Information, aber ohne Bedeutung fr
 den Fontselektor. Allerdings wird es knf!-tig m”glich sein, einen Font
 nicht nur anhand seiner ID, sondern auch anhand seines Namens zu setzen,
 wobei dann noch zus„tzlich der Fonttyp ben”tigt wird.

 Der Fonttyp ist aber auch von Interesse, wenn man die Gr”e des Fonts
 „ndern will: Bei Bitmapfonts geschieht dies mit der (!nolink [VDI])--Funktion
 (!V)vst_point()(!v), bei allen anderen Typen (Vektorfonts) mit der
 Funktion (!V)vst_arbpt()(!v).
!item [(!V)fontname(!v)]
 Der Name des Fonts, wie er von (!V)vqt_name()(!v) geliefert wurde
 (m”glicherweise wurden mehrfache Leerzeichen entfernt).

 Der Aufrufer mu selbst gengend Platz fr den Fontnamen zur Ver!-fgung
 stellen, also fr 32 Zeichen und ein Null!-byte! Wenn Sie den Fontnamen
 nicht ben”tigen, k”nnen Sie den Zeiger auch einfach auf Null setzen.

!item [(!V)fontsize(!v)]
 Die Gr”e des Fonts in Punkt (pt) oder 1/65536 Punkt
 (Typ ""(!V)(!nolink [fix31])(!v)""):
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Fontgr”e in Punkt         */
 fix31 size31;  /* Fontgr”e in 1/65536 Punkt */
};
!end_verbatim
!end_quote
 Welche der beiden Angaben gltig ist, wird (!nolink [global]) ber das
 Kon!-troll!-flag (!V)CC_FIX31(!v) geregelt.

!item [(!V)fontwidth(!v)]
 Breite des Fonts in Punkt (pt) oder 1/65536 Punkt
 (Typ ""(!V)(!nolink [fix31])(!v)""):
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Fontgr”e in Punkt         */
 fix31 size31;  /* Fontgr”e in 1/65536 Punkt */
};
!end_verbatim
!end_quote
 Welche der beiden Angaben gltig ist, wird (!nolink [global]) ber das
 Kon!-troll!-flag (!V)CC_FIX31(!v) geregelt.

 Die Breite kann mit den VDI--Funktionen (!V)vst_width()(!v) in Punkt und
 mit (!V)vst_setsize()(!v) in (!V)fix31(!v) eingestellt werden.

!label Kerning
!item [trackkern]
 Dieser Parameter gibt die Art des Track--Kernings fr (!V)vst_kern()(!v)
 an. Gltige Werte sind:
 
!begin_table [c|l]
 Wert !! (!nolink [Kerning])
!hline
   0 !! kein Kerning
   1 !! normales (!nolink [Kerning])
   2 !! enges (!nolink [Kerning])
   3 !! sehr enges (!nolink [Kerning])
!end_table

!item [pairkern]
 Mit diesem Parameter kann das Pair--Kerning aus-- (0) oder eingeschaltet
 (1) werden, vgl. (!V)(!nolink [vst_kern])()(!v).

!item [(!V)fontattr(!v)]
 Dies sind die Fontattribute (Texteffekte), wie sie auch von der
 (!nolink [VDI])--Funktion (!V)vst_effects()(!v) verwendet werden.

 Calvino verwendet dieses Feld nur dann, wenn das Kontroll!-flag
 (!V)CC_FAKESTYLE(!v) gesetzt ist.

!item [(!V)fontskew(!v)]
 Die Neigung des Fonts in 1/10 Grad, vgl. (!V)vst_skew()(!v).

!item [(!V)fontcol(!v)]
 Die Farbe des Fonts. Es werden die VDI--Farben verwendet, d.h. 0 = Wei,
 1 = Schwarz, usw., vgl. (!V)vst_color()(!v).

!item [(!V)backcol(!v)]
 Die Hintergrundfarbe des Textes. Es werden die (!nolink [VDI])--Farben ver!-wen!-det,
 d.h. 0 = Wei, 1 = Schwarz, usw. Das Setzen einer Text--Hintergrundfarbe
 wird vom (!nolink [VDI]) nicht direkt untersttzt, es ob!-liegt daher dem Aufrufer,
 ob und wie dieser Parameter verwendet wird.

!label Textausrichtung
!label Ausrichtung

!item [(!V)halign(!v)]
 Hierber kann die horizontale Textausrichtung angegeben wer!-den: Der
 Text soll linksbndig, rechts!-bndig  oder zentriert aus!-ge!-ge!-ben
 werden.
!label THA_LEFT
!label THA_CENTER
!label THA_RIGHT
 !begin_verbatim
   Name        Wert Ausrichtung
  -------------------------------
   THA_LEFT     0   linksbndig
   THA_CENTER   1   zentriert
   THA_RIGHT    2   rechtsbndig
 !end_verbatim
 Diese Werte entsprechen dem Parameter fr die horizontale Aus!-rich!-tung
 beim (!nolink [VDI])--Aufruf (!V)vst_alignment()(!v).

!item [(!V)valign(!v)]
 Hierber kann die vertikale Textausrichtung angegeben werden: Der Text
 soll an der Oberkante oder der Un!-ter!-kan!-te ausgerichtet oder
 (vertikal) zentriert aus!-ge!-ge!-ben wer!-den.
!label TVA_BOTTOM
!label TVA_CENTER
!label TVA_TOP
 !begin_verbatim
   Name        Wert Ausrichtung
  -----------------------------------------
   TVA_BOTTOM   0   an der Text-Unterkante
   TVA_CENTER   1   vertikal zentriert
   TVA_TOP      2   an der Text-Oberkante
 !end_verbatim
 Diese Werte entsprechen absichtlich (!I)nicht(!i) dem Parameter zur
 ver!-ti!-kalen Ausrichtung bei (!V)(!nolink [vst_alignment])()(!v)! Die dort
 ver!-wen!-de!-ten Werte (""Zeichen!-unter!-kante"",
 ""Zeichen!-zellen!-unter!-kante"") sind fr den normalen Anwender wenig
 in!-tui!-tiv und sollten daher nicht Teil des User--Interfaces sein (was
 sie bei der Aus!-wahl im Fontselektor aber w„ren). Die Ausrichtung mu
 daher vom auf!-rufen!-den Programm in die ""richtigen"" Werte konvertiert
 werden.

!label Textrotation
!label Rotation
!item [(!V)rotation(!v)]
 Textrotation in 1/10 Grad, wie sie auch von der VDI--Funktion
 (!V)vst_rotation()(!v) verwendet wird.
!end_xlist

!smallskip

Fehlen noch die beiden Parameter ''(!V)validtype(!v)'' und
''(!V)validchars(!v)'':

 Manchmal ist es wichtig, sicherzustellen, da der Font be!-stimm!-te
 Zeichen enth„lt. Dafr gibt es zwei M”g!-lich!-kei!-ten:

 Wenn ''(!V)validchars(!v)'' Null ist, kann man mit ''(!V)validtype(!v)''
 eine der fol!-gen!-den vier Gruppen von Zeichen ausw„hlen:
!label V_CHAR_IND
!label V_CHAR_ASC
!label V_CHAR_PRT
!label V_CHAR_ALL
 !begin_verbatim
   Name       Wert Bereich  Kommentar
  --------------------------------------------------------
   V_CHAR_IND  -1    -      "egal"
   V_CHAR_ASC  -2  32-126   alle druckbaren ASCII-Zeichen
   V_CHAR_PRT  -3  32-255   alle druckbaren Zeichen
   V_CHAR_ALL  -4   0-255   wirklich alle Zeichen
 !end_verbatim
 Diese vier Gruppen drften die h„ufigsten Anwendungsf„lle ab!-decken.

 Wenn sowohl ''(!V)validtype(!v)'' als auch ''(!V)validchars(!v)'' Null
 sind, wird der Fontselektor dies wie (!V)V_CHAR_IND(!v) behandeln,
 ebenso bei anderen un!-gl!-ti!-gen Werten in ''(!V)validtype(!v)''.

 !smallskip

 Wenn die vier Gruppen einmal nicht ausreichen, so kann man statt!-dessen
 ber ''(!V)validtype(!v)'' und ''(!V)validchars(!v)'' auch genauer
 angeben, welche Zeichen be!-n”!-tigt werden:

##!begin_xlist [validchars~]
!begin_description
!label Mapping
  !item [validtype] enth„lt dann einen Wert fr das vom GDOS zu
        ver!-wen!-den!-de Mapping (vgl. (!V)vst_charmap()(!v)).

        Die freie Wahl des Mappings steht nur mit einem ent!-sprech!-en!-den
        GDOS (SpeedoGDOS oder NVDI ab Version 3) zur Verfgung. Z.Z.
        sind folgende Mappings definiert:
!label MAP_DIRECT
!label MAP_ASCII
!begin_verbatim
 Name       Wert Bedeutung
-----------------------------------------
 MAP_DIRECT  0   "direktes Mapping"
 MAP_ASCII   1   ASCII-Mapping (Default)
!end_verbatim
        Wenn das GDOS kein Mapping beherrscht, wird der Fontselektor
        nur (!V)MAP_ASCII(!v) akzeptieren, alle anderen Mappings werden
        dann igno!-riert und ein Test auf Vorhandensein bestimmter Zeichen
        wird (!I)nicht(!i) durchgefhrt.
  !item [validchars] ist ein Zeiger auf ein Array von Integers (Words),
        ber das angegeben werden kann, welche Zeichen der Font
        un!-be!-dingt enthalten soll.

        Das Array besteht aus einer Folge von Von--Bis--Paaren:
        !begin_itemize
         !item zwei aufeinanderfolgende Werte geben einen Bereich
               (von--bis) an
         !item einzelne Zeichen werden durch Verdopplung angegeben
         !item das Ende der Liste wird durch ein Von--Bis--Paar
               angegeben, bei dem ''bis'' kleiner ist als ''von''
        !end_itemize

        (!B)Beispiel:(!b) Es sollen nur Fonts angeboten werden, die alle
        druck!-baren ASCII--Zeichen sowie die deutschen Umlaute enthalten.
!begin_verbatim
xFSL_PAR xpar;
int chars[] = { ' ', '~',  /* ASCII 32..126 */
                '„','„', '”','”', '','',
                '','', '™','™', 'š','š', '','',
                1,0       /* Ende der Liste */
              };

xpar.font->validtype=MAP_ASCII;
xpar.font->validchars=chars;
!end_verbatim
##!end_xlist
!end_description
Zuknftige GDOSse werden wahrscheinlich weitere Mappings unter!-sttzen
(BICS, Unicode, !..). Durch die verwendete Codierung wird der
Fontselektor auch diese korrekt beherrschen: Das in ''(!V)valid!-type(!v)''
bergebene Mapping wird einfach eingestellt und dann das Vorhandensein
der Zeichen aus ''(!V)validchars(!v)'' abgetestet.

(!B)Anmerkung:(!b) Die diversen M”glichkeiten mit den Parametern
''(!V)validtype(!v)'' und ''(!V)validchars(!v)'' sollten sparsam und mit
Bedacht verwendet werden, da das notwendige Testen der Zeichen je nach
GDOS recht lange dauern kann.

!end_node

# ------------------------------------------------------------------------
!begin_node Das User-Popup
Fr das benutzerdefinierte (!nolink [Popup]) (kurz User-(!nolink [Popup])) existieren die
fol!-gen!-den Felder in der (!V)xFSL_PAR(!v)--Struktur:
!begin_xlist [num_entries~]
!item [(!V)poptext(!v)]
Zeiger auf einen Text, der vor dem (!nolink [Popup]) erscheinen soll oder 0L. Dem
Fontselektor steht es frei, diesen Text zu ignorieren.

!item [(!V)num_entries(!v)]
Anzahl Eintr„ge (d.h. Zeilen) im (!nolink [Popup]). Steht hier eine Null, so wird
kein (!nolink [Popup]) angezeigt. Es sollten nicht mehr als 16 Eintr„ge verwendet
werden, auch wenn ein!-zel!-ne Fontselektoren u.U. auch mehr Eintr„ge
un!-ter!-sttzen.

!item [(!V)sel_entry(!v)]
Der selektierte Eintrag im (!nolink [Popup]) (gez„hlt wird ab 0). Der Fontselektor
legt hier die Nummer des angew„hlten (!nolink [Popup])-Eintrags ab und liest den Wert
bei jedem Aufruf von (!V)xfsl_event(!v) wieder neu aus. Somit k”nnen Sie
den Fontselektor z.B. auch zwingen, statt dem angew„hlten Ein!-trag Nummer
3 den mit der Nummer 5 zu aktivieren (bei (!V)xFS_POPUP(!v) meldet der
Fontselektor nur, welcher Eintrag an!-ge!-w„hlt wurde, aktiviert wird
dieser erst beim Rck!-sprung in den Fontselektor).

!item [(!V)popup(!v)]
Dies ist ein Zeiger auf ein Array von (!V)xFSL_PENTRY(!v)-Elementen.
An der angegebenen Adresse mssen genau so viele Elemente stehen, wie in
''(!V)num_entries(!v)'' angegeben wurden.
!end_xlist

!label xFSL_PENTRY
Ein Eintrag im (!nolink [Popup]) ist wie folgt aufgebaut:
!begin_quote
!begin_verbatim
typedef struct
{
 char         *entry;      /* Text des Popup-Eintrags       */
 PFONTINFO    *fontinfo;   /* Zeiger auf Fontinfo-Struktur  */
 unsigned int  fontflags;  /* erlaubte Fontarten            */
 long          funcflags;  /* Funktionsflags, nur fr HuGo! */
} xFSL_PENTRY;
!end_verbatim
!end_quote
Die Bedeutung der Elemente dieser Struktur sollte nach den
vor!-an!-ge!-gan!-gen!-en Ausfhrungen klar sein. Die Funktionsflags
ent!-sprechen den Kontrollflags, bis auf die Flags, die das globale
Verhalten des Fontselektors beeinfluen ((!V)CC_WINDOW(!v) etc.). Diese
wer!-den hier ignoriert.

(!B)Wichtig:(!b) Der Zeiger auf die (!V)PFONTINFO(!v)--Struktur darf
nicht Null sein!

Wenn der Text eines Eintrags mit einem ''(!V)-(!v)'' beginnt, wird der
ent!-sprech!-en!-de Eintrag disabled (in heller Schrift und nicht
an!-w„hl!-bar) dargestellt. Dies ist in erster Linie fr Trennlinien
zwischen den Eintr„gen gedacht.

!smallskip

(!U)Verwendung(!u)

Im Prinzip kann man drei Einsatzgebiete fr das User-(!nolink [Popup]) sehen:
!begin_enumerate
!item Jeder (!nolink [Popup])-Eintrag stellt den Font fr einen bestimmten Programmteil
      ein. Beispielsweise k”nnte man in einem bestimmten Fenster eines
      Programms nur nicht--proportionale Fonts zulassen wol!-len, in einem
      anderen keine Vektorfonts, in einem dritten alle Fonts.
!item Jeder Eintrag stellt eine gewisse Gruppe von Fonts zur Ver!-f!-gung.
      Braucht man beispielsweise oft Vektorfonts, k”nnte ein (!nolink [Popup]) mit
      den Eintr„gen ""nur Vektorfonts"" und ""alle Fonts"" kon!-stru!-iert
      werden.
!item Das (!nolink [Popup]) kann aber auch fr etwas ganz anderes verwendet wer!-den.
      Man k”nnte hier noch eine Information unterbringen, die zwar nichts
      mit Fonts, aber mit dem Fenster zu tun hat, fr das man einen Font
      einstellen will. Beispielsweise k”nnte fr ein Consolen--Fenster
      die Art, wie inverse Zeichen darzustellen sind, in Form eines
      Popups mit den Eintr„gen ""invers"", ""fett"", ""unter!-strichen""
      zur Auswahl angeboten wer!-den.

      Will man das (!nolink [Popup]) so zweckentfremden, so mu man bei der 
      Mel!-dung (!V)xFS_POPUP(!v) den ge„nderten Font (der sich am 
      gesetzten (!V)FF_CHANGED(!v)--Flag erkennen l„t) in alle 
      anderen (!nolink [Popup])-Eintr„ge bertragen, da sich sonst der im 
      Fontselektor angezeigte Font „ndern wrde!
!end_enumerate

!end_node
# !end_node

# ========================================================================
!begin_node Die Fontflags

šber die Fontflags k”nnen die zur Auswahl gestellten Fonts
ein!-ge!-schr„nkt werden:

!raw [stg] @alabel "FF_SYSTEM" "FF_MONOSPACED" "FF_PROPORTIONAL"
!raw [stg] @alabel "FF_VECTOR" "FF_BITMAP" "FF_ALL" "FF_CHANGED"
!raw [stg] @alabel "FF_VEKTOR" "FF_MONO" "FF_PROP"
!raw [stg] @alabel "FF_SPD" "FF_TTF" "FF_PFB" "FF_CFN"
!begin_quote
!begin_verbatim
 Name             Wert    Bedeutung
-----------------------------------------------------------
 FF_SYSTEM        0x0001  Systemfont (zus„tzlich) anzeigen
 FF_MONOSPACED    0x0002  monospaced Fonts anzeigen
 FF_PROPORTIONAL  0x0004  proportionale Fonts anzeigen
 FF_BITMAP        0x0008  Bitmapfonts anzeigen
 FF_SPD           0x0010  Speedofonts anzeigen
 FF_TTF           0x0020  TrueType-Fonts anzeigen
 FF_PFB           0x0040  Type-1-Fonts anzeigen
 FF_CFN           0x0080  Calamusfonts anzeigen (n.i.)
 FF_VECTOR        0x00F0  alle Vektorfonts anzeigen
 FF_ALL           0x00FE  alle Fonts anzeigen
 FF_CHANGED       0x8000  nderung erfolgt (nur im Popup)
!end_verbatim
!end_quote

Die Werte sind so gew„hlt, da die einzelnen Flags miteinander ver!-odert
werden k”nnen. Setzt man fr die Fontflags also beispielsweise
(!V)FF_MONOSPACED|FF_VECTOR(!v) ein, so werden nur unproportionale
Vektorfonts zur Auswahl gestellt.

Zudem gilt:
!begin_itemize
!item (!V)FF_SYSTEM(!v) hat Vorrang, d.h. wenn dieses Flag gesetzt ist,
      wird der Systemfont auf jeden Fall mit zur Auswahl gestellt.
!item Wenn (!V)FF_SYSTEM(!v) nicht gesetzt ist, wird der Systemfont genau
      dann zur Auswahl gestellt, wenn seine Eigenschaften den gesetzten
      Flags entsprechen.
!item Wenn weder (!V)FF_MONOSPACED(!v) noch (!V)FF_PROPORTIONAL(!v)
      gesetzt sind, werden die Fontflags so behandelt, als seien beide
      Flags ge!-setzt.

      Dies gilt analog fr (!V)FF_VECTOR(!v) und (!V)FF_BITMAP(!v).
!item Wenn (!V)FF_VECTOR(!v) gesetzt wird, werden automatisch alle
      Vektorfont--Formate angeboten. Eine feinere Unterteilung ist aber
      auf Wunsch durch die Flags (!V)FF_SPD(!v), !.., (!V)FF_CFN(!v)
      m”glich.

      (!B)Bitte beachten:(!b) Calamus--Fonts (und somit das Flag
      (!V)FF_CFN(!v)) werden z.Z. noch von keinem GDOS untersttzt!
!item Das Flag (!V)FF_CHANGED(!v) wird nur dazu verwendet, um im
      User--(!nolink [Popup]) die Einstellungen zu markieren, die sich ge„ndert haben.
      Der Fontselektor setzt dieses Flag nur, wertet es aber selbst nicht
      aus.
!end_itemize

!end_node

# ========================================================================
!begin_node Returncodes

Alle xFSL--Aufrufe liefern einheitliche Returncodes (Rckgabewerte)
zurck. Dabei steht eine negative Zahl fr einen Fehler, eine po!-si!-tive
Zahl (oder Null) bedeutet Erfolg bzw. ein Ereignis.

!raw [stg] @alabel "xFS_LOADERROR" "xFS_RES_ERROR" "xFS_NO_HANDLE" "xFS_NO_WINDOW"
!raw [stg] @alabel "xFS_NO_FONTS" "xFS_NO_FONTSIZE" "xFS_ACTIVE" "xFS_ERROR"
!raw [stg] @alabel "xFS_STOP" "xFS_OK" "xFS_HELP" "xFS_EVENT" "xFS_POPUP"
!begin_quote
!begin_verbatim
 Name            Wert Bedeutung
----------------------------------------------------------------
 xFS_PARERROR     -9  Parameterfehler, z.B. Aufruf nach Rev. 3
 xFS_LOADERROR    -8  Fehler beim Nachladen des xFSL-Moduls
 xFS_RES_ERROR    -7  Aufl”sung zu klein (mind. 640x400 Punkte)
 xFS_NO_HANDLE    -6  Kein VDI-Handle frei
 xFS_NO_WINDOW    -5  Kein Fenster(handle) frei
 xFS_NO_FONTS     -4  Keine Fonts geladen
 xFS_NO_FONTSIZE  -3  Fontgr”e nicht identifizierbar
 xFS_ACTIVE       -2  Fontselektor ist bereits aktiv
 xFS_ERROR        -1  allgemeiner Fehler (Speichermangel o.„.)
 xFS_STOP          0  <Abbruch> gew„hlt
 xFS_OK            1  <Ok> gew„hlt
 xFS_HELP          2  Hilfe-Button angew„hlt
 xFS_EVENT         3  AES-Event aufgetreten
 xFS_POPUP         4  nderung am User-Popup
!end_verbatim
!end_quote

Diese Werte wurden aufw„rtskompatibel zum Fontselektor UFSL gew„hlt
(dieser kennt die Returncodes -4, -3, -2, -1, 0 und 1).

Darber hinaus k”nnen auch Gemdos-Fehlermeldungen (Werte kleiner oder
gleich -32) auftreten, insbesondere kann (!V)xfsl_init(!v) auch den
Wert (!V)EINVFN(!v) (-32) liefern, wenn der Fontselektor den erweiterten
Aufruf nicht untersttzt.

Beim Aufruf (!V)(!nolink [xfsl_init])(!v) entsprechen positive Rckgabewerte dem
Fenster!-handle des Fontselektors (0 bedeutet, da der Fontselektor als
mo!-daler Dialog ge”ffnet wurde).

Es ist m”glich, da die Liste der Returncodes in Zukunft um weitere Fehler
(Werte kleiner -9) oder Ereignisse (Werte gr”er 4) erweitert wird. Dies
sollte beim Programmentwurf bercksichtigt werden: Bei un!-be!-kann!-ten
Fehlern sollte abgebrochen, unbekannte Ereignisse sollten ignoriert
werden.

!end_node

# ========================================================================
!begin_node Die Pure-C-Event-Struktur
!label EVENT
Die (!nolink [GEM])--Bibliothek von Pure C verwendet eine spezielle Struktur, in der
die Parameter der (!nolink [AES])-Funktion (!V)evnt_multi()(!v) zusammengefat sind.
Diese Struktur wird auch von (!V)xfsl_event(!v) verwendet.
!begin_quote
!begin_verbatim
typedef struct /* Special type for EventMulti */
{
 /* Eingabeparameter */
 int ev_mflags,
     ev_mbclicks, ev_bmask, ev_mbstate,
     ev_mm1flags, ev_mm1x, ev_mm1y, ev_mm1width, ev_mm1height,
     ev_mm2flags, ev_mm2x, ev_mm2y, ev_mm2width, ev_mm2height,
     ev_mtlocount, ev_mthicount;

 /* Ausgabeparameter */
 int ev_mwich,
     ev_mmox, ev_mmoy, ev_mmobutton, ev_mmokstate,
     ev_mkreturn, ev_mbreturn;

 /* Message-Buffer */
 int ev_mmgpbuf[8];
} EVENT;
!end_verbatim
!end_quote
Die Elemente der Struktur entsprechen denen des (!V)(!nolink [evnt_multi])()(!v)--Aufrufs.
Auch die Reihenfolge der Parameter ist --- bis auf wenige Ausnahmen ---
identisch. Das Feld ''(!V)ev_mwich(!v)'' enth„lt die aufgetretenen Events
in der gleichen Kodierung wie ''(!V)ev_mflags(!v)''.

!end_node

!end_node

# ########################################################################
!begin_node Tips und Hinweise
In den folgenden Abschnitten soll versucht werden, noch einige Tips und
Hinweise zur xFSL--Schnittstelle zu geben.

!subtoc stg


# ========================================================================
!begin_node Ein einfacher Aufruf
Angesichts der Vielzahl der Parameter und Einstellm”glichkeiten
er!-scheint folgender Hinweis angebracht:
!begin_center
(!B)Keine Panik!(!b)
!end_center

Ein xFSL--Aufruf ist einfacher als es zun„chst scheint. Insbesondere kann
hier die Strategie der ""schrittweisen Verfeinerung"" angewendet wer!-den,
da man (fast) alle Parameter zun„chst einmal auf Null setzen kann.

Ein m”glichst einfacher xFSL--Aufruf kann z.B. so aussehen:
!begin_quote
!begin_verbatim
#include <stdio.h>
#include <aes.h>
#include <vdi.h>
#include <xfsl.h>

void call_xfsl (void)
{
  int xhandle, xret;
  xFSL_PAR xpar;
  PFONTINFO pfont;
  xFSL *xfsl;
 
  memset (&xpar, 0, sizeof (xFSL_PAR));
  memset (&pfont, 0, sizeof (PFONTINFO));
 
  xpar.par_size = sizeof (xFSL_PAR);
  xpar.pfi_size = sizeof (PFONTINFO);
  xpar.font = &pfont;
  xpar.font->fontcol = BLACK;
 
  if (get_cookie ('xFSL', &xfsl))
  {
    xhandle = xfsl->xfsl_init (0, &xpar);
    if (xhandle >= 0)
    {
     do
       xret = xfsl->xfsl_event (xhandle, 0L);
     while (xret > xFS_OK);
     xfsl->xfsl_exit (xhandle);
     if (xret == xFS_STOP)
       printf ("Abbruch\n");
     else if (xret == xFS_OK)
       printf ("Font mit ID %d ausgew„hlt\n", xpar.font->fontid);
     else if (xret < 0)
       printf ("Fehler %d\n", xret);
   }
   else
     printf ("Fehler %d\n", xhandle);
  }
  else
    printf ("Cookie nicht gefunden!\n");
}
!end_verbatim
!end_quote

Mit den beiden (!V)memset(!v)--Aufrufen werden alle Elemente der
Strukturen (!V)(!nolink [xFSL_PAR])(!v) und (!V)(!nolink [PFONTINFO])(!v) auf Null gesetzt.
Anschlieend werden einige un!-be!-dingt n”tige Werte eingetragen:
!begin_itemize
 !item die Gr”en der beiden Strukturen (!V)xFSL_PAR(!v) und
       (!V)(!nolink [PFONTINFO])(!v)
 !item die Adresse der (!V)(!nolink [PFONTINFO])(!v)--Struktur wird in der
       (!V)xFSL_PAR(!v)--Struktur eingetragen
 !item die Schriftfarbe wird auf schwarz gesetzt (dies k”nnte man auch
       weglassen, aber normalerweise wird man ja in schwarzer Schrift
       auf weiem Grund schreiben wollen)
!end_itemize

Mehr ist an Vorbereitungen nicht n”tig, es folgt nun der eigentliche
Aufruf. Zun„chst wird der xFSL--Cookie gesucht. Im Erfolgsfall wird
nun der Fontselektor initialisiert, indem die (!V)xFSL_PAR(!v)--Struktur
ber!-ge!-ben wird. War dieser Aufruf erfolgreich (''(!V)xhandle(!v)'' ist
gr”er oder gleich Null), so befindet sich der Fontselektor bereits auf
dem Bild!-schirm. In der Hauptschleife wird nun gewartet, bis der
Fontselektor entweder mit (!V)xFS_STOP(!v) oder (!V)xFS_OK(!v) vom
Anwender beendet wird oder bis ein Fehler auftritt (andere positive
Rckgabewerte werden hier ein!-fach ignoriert). Mit dem Aufruf von
(!V)xfsl_exit(!v) wird der Fontselektor wieder vom Bildschirm entfernt
und anschlieend der Rckgabewert aus!-ge!-wer!-tet.

Das war doch gar nicht so kompliziert, oder? Von hier aus k”nnen Sie nun
mit den diversen Parametern und Flags weiter experimentieren.

!end_node

# ========================================================================
!begin_node Fragen und Antworten
(!B)Wie kann ich feststellen, welche Features der Fontselektor
bietet?(!b)

Direkt kann dies fr einige Features ber die Funktion (!V)xfsl_info(!v)
geschehen. Indirekt k”nnen weitere Features ber das Feld
''(!V)(!nolink [control])(!v)'' in der (!V)xFSL_PAR(!v)--Struktur abgefragt werden:
Nach einem erfolgreichen (!V)xfsl_init(!v)--Aufruf wird der Fontselektor
diejenigen Kontrollflags l”!-schen, die er nicht versteht.

!smallskip

(!B)Wie soll sich mein Programm verhalten, wenn es feststellt, da der
Fontselektor das gewnschte Feature nicht untersttzt?(!b)

Wenn berhaupt ein Fontselektor installiert ist, sollte dieser auch auf
jeden Fall verwendet werden. Je nachdem, wie wichtig das vermite Feature
ist, k”nnte sich Ihr Programm nach Alternativen umsehen (z.B. ber das
Font-Protokoll) oder versuchen, das fehlende Feature zu kompensieren.

Auch hier gilt wieder: Der Anwender wollte einen Fontselektor, keine
Fehlermeldung. Wenn das fehlende Feature nur schwer zu kompensieren ist,
dann sollten Sie den Anwender einmalig(!) mit einem ent!-sprech!-en!-den
Hinweis informieren, aber trotzdem den Fontselektor aufrufen. Auch wenn
die Auswahl dann nicht mit dem gewnschten Kom!-fort ge!-sche!-hen kann,
ist dies fr den Anwender immer noch weniger fru!-strie!-rend, als
berhaupt keinen Font ausw„hlen zu k”nnen.

Einige Beispiele: Sollte ber das (!nolink [Popup]) der Font fr bestimmte Fenster
des Programms eingestellt werden, so sollte er bei fehlendem Popup fr das
oberste Fenster des Programms bernommen werden. Unter!-sttzt der
Fontselektor das Sperren der Gr”en„nderung nicht, so sollte die
zurckgelieferte Gr”e einfach ignoriert werden und --- wenn sie von der
gewnschten Gr”e abweicht --- der Anwender durch einen Hinweis davon in
Kenntnis gesetzt werden.

Man sollte sich brigens nicht darauf verlassen, da der Fontselektor beim
n„chsten Aufruf noch der gleiche ist bzw. die gleichen Features
untersttzt! Die Fontselektoren, die mit einem Overlay ((!V)XFSL.OVL(!v))
arbeiten k”nnen durch einfaches Umkopieren des Overlays jederzeit ohne
Reset ausgewechselt werden.

!smallskip

(!B)Was hat es mit diesem ""(!nolink [Mapping])"" auf sich?(!b)

Vektorfonts enthalten meist wesentlich mehr als die blichen 256 Zeichen,
noch dazu normalerweise nicht in der gewohnten ASCII--Codierung
(beispielsweise k”nnte das Leerzeichen auf Position 0 statt auf 32 liegen).
Daher werden die entsprechenden Zeichen aus dem Font auf die ""normalen""
256 Zeichen ""gemappt"" (d.h. abgebildet), so da sich das Leerzeichen
wie gewohnt an Position 32 befindet, unabh„ngig davon, welche Position es
innerhalb des Fonts hat. Dieses bezeichnet man als ASCII--(!nolink [Mapping]).

Per Default ist das ASCII--(!nolink [Mapping]) aktiv. Dadurch kann man aber die
Zeichen, die auerhalb des ASCII--Zeichensatzes liegen, nicht
an!-spre!-chen. Als zweites Mapping steht daher das ""direkte Mapping""
zur Ver!-f!-gung. Hier hat man nun Zugriff auf (!I)alle(!i) Zeichen eines
Fonts. Aller!-dings mu man dazu auch wissen, um welche Art von Font es
sich han!-delt und wieviele Zeichen der Font enth„lt: Speedofonts haben
meist 564 Zeichen, TrueType--Fonts k”nnen (theoretisch) bis zu 65536
Zeichen enthalten. Diese Information erh„lt man nach dem Umschalten auf
das direkte (!nolink [Mapping]) mit der (!nolink [VDI])--Funktion vqt_fontinfo():
!begin_verbatim
 int minADE, maxADE;

 vst_charmap(handle,0);
 vqt_fontinfo(handle,&minADE,&maxADE,dumarray,&dummy,dumarray);
!end_verbatim
In ''(!V)minADE(!v)'' erh„lt man den kleinsten, in ''(!V)maxADE(!v)'' den
gr”ten gl!-ti!-gen Zeichenindex.

Das direkte (!nolink [Mapping]) ist fr normale Anwendungen nur eingeschr„nkt
brauch!-bar. Im Gegensatz zum ASCII--(!nolink [Mapping]), das ein einheitliches
(!nolink [Mapping]) fr alle Arten von Fonts darstellt, mu man hier n„mlich ganz
genau wissen, um welche Art von Font es sich handelt. So haben z.B. die
Speedo--Symbolfonts eine andere Codierung als die ""normalen""
Speedo!-fonts. D.h. da man an Position 64 eines solchen Symbolfonts nicht
das gleiche Zeichen vorfinden wird wie bei einem ""normalen"" Speedo!-font.

Andere Mappings als ASCII sind daher z.Z. fr den Groteil der Programme
uninteressant. Knftige GDOSse werden aber m”glicherweise noch andere
einheitliche Mappings (z.B. Unicode oder BICS) anbieten, bei denen man
sich dann wieder darauf verlassen kann, da an einer be!-stimm!-ten
Position auch immer das gleiche Zeichen liegt („hnlich wie beim
ASCII--(!nolink [Mapping]), nur eben auch bei Positionen gr”er 255).

!smallskip

(to be continued !..)

!end_node

# ========================================================================
!begin_node Programmiertechnische Hinweise
Die Beschreibung der xFSL--Schnittstelle in diesem Text erfolgt in Pure C.
In den folgenden Abschnitten werden die (!nolink [Datentypen]) und
Be!-son!-der!-hei!-ten von Pure C n„her beschrieben, damit xFSL--Aufrufe
auch aus anderen Programmiersprachen und C--Dialekten gelingen.

!subsubtoc stg

!end_node

# ------------------------------------------------------------------------
!begin_node Datentypen

In diesem Text werden die folgenden Datentypen verwendet:
!begin_quote
!begin_verbatim
 Name            Gr”e
----------------------------------------
 int             16 Bit mit Vorzeichen
 unsigned int    16 Bit ohne Vorzeichen
 long            32 Bit mit Vorzeichen
 unsigned long   32 Bit ohne Vorzeichen
!end_verbatim
!end_quote

Der Datentyp (!V)char(!v) ist ein (ASCII--)Zeichen und wird hier nur als
Zei!-ger!-typ verwendet, d.h. als Zeiger auf einen C--String (eine Folge
von Zeichen, die mit einem Nullbyte abgeschloen sind).

!smallskip

!label union
(!U)Union(!u)

Eine Union entspricht einem varianten Record in Pascal. Es handelt sich
um eine Struktur, deren einzelne Elemente ""bereinander"" liegen, d.h.
denselben Speicherbereich belegen. Welches Element gerade gltig ist,
ergibt sich aus dem Kontext bzw. bleibt dem Programmierer ber!-lassen.

(!B)Beispiel:(!b) In der Struktur (!V)PFONTINFO(!v) wird fr die
Gr”enangabe eine Union ''(!V)fsize(!v)'' verwendet:
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Fontgr”e in Punkt         */
 fix31 size31;  /* Fontgr”e in 1/65536 Punkt */
};
!end_verbatim
!end_quote
Der Speicherbedarf dieser Union betr„gt vier Bytes, da der Typ fix31
vier Bytes gro ist. Man (!I)k”nnte(!i) nun dem Element ''(!V)size31(!v)''
eine Gr”en!-an!-ga!-be in 1/65536 Punkt zuweisen und dann den Wert in
ganzen Punkt aus dem Element ''(!V)size(!v)'' auslesen --- dies ist aber
nicht empfehlenswert, da bei der Umrechnung (!V)(!nolink [fix31])(!v) nach pt immer
gerundet werden sollte, s.u.

!smallskip

!label fix31
(!U)(!V)fix31(!v)(!u)

Der Datentyp (!V)(!nolink [fix31])(!v) ist eine Festkommazahl, bei dem die oberen
16 Bit den vorzeichenbehafteten Vorkomma-Anteil darstellen und die
unteren 16 Bit den vorzeichenlosen Nachkomma-Anteil. Er wird
ausschlielich fr Gr”enangaben von Fonts verwendet, die damit auf
1/65536 Punkt genau angegeben werden k”nnen.

Bei der Umrechnung von (!V)(!nolink [fix31])(!v) nach pt darf man das Runden nicht
ver!-gessen. Zitat aus dem NVDI--Guide:

(!B)Man darf nie, nie, niemals den Nachkommateil einfach abschneiden!(!b)

!end_node

# ------------------------------------------------------------------------
!begin_node Parameterbergabe
!raw [stg] @alias Parameterbergabe
Die šbergabe der Parameter bei allen xFSL--Aufrufen geschieht ber
den Stack nach C--Konvention. D.h. da der beim Aufruf am weitesten
rechts stehende Parameter zuerst auf den Stack gelegt wird und der am
wei!-testen links stehende Parameter zum Schlu, d.h. beim Einsprung in
den Fontselektor, obenauf liegt.

!end_node

# ------------------------------------------------------------------------
!begin_node Pure C und ''cdecl''
!raw [stg] @alias "cdecl"
Pure C bergibt die Parameter an Funktionen normalerweise in Re!-gi!-stern.
Fr eine šbergabe ber den Stack mu entweder das Schls!-sel!-wort
""(!V)cdecl(!v)"" verwendet werden (wie im Includefile (!V)XFSL.H(!v)
geschehen) oder der Compilerschalter ""(!V)-H(!v)"" gesetzt werden.

Das Schlsselwort ""(!V)cdecl(!v)"" ist eine Pure--C--spezifische
Erweiterung und wird daher bei gesetztem Compilerschalter ""(!V)-A(!v)""
(ANSI-Konformit„t) an!-ge!-mahnt.

!end_node
#!end_node
!end_node

# ########################################################################
!begin_node Revisions--History
!raw [stg] @alias History
(!B)Revision 4(!b)
!begin_itemize
 !item Aufgrund eines kleinen Designfehlers in den „lteren Revisionen,
       der die Erweiterbarkeit der Schnittstelle einschr„nkte, ist
       Revision 4 (!I)nicht(!i) kompatibel zu „lteren Revisionen. Dies
       sollte in der Praxis kein Problem darstellen, da der Fontselektor
       Auf!-rufe nach dem alten Schema mit einem Fehler quittieren wird.
       Die alte Revision 3 wird im Laufe der Zeit verschwinden.
 !item neue Parameter in der (!V)(!nolink [PFONTINFO])(!v)--Struktur:
       !begin_itemize
        !item Text--Hintergrundfarbe (''(!V)backcol(!v)'')
        !item (!nolink [Textausrichtung]) (''(!V)halign(!v)'' und ''(!V)valign(!v)'')
        !item (!nolink [Textrotation]) (''(!V)rotation(!v)'')
        !item Angabe von Zeichen, die der ausgew„hlte Font unbedingt
              ent!-hal!-ten soll (''(!V)validtype(!v)'' und
              ''(!V)validchars(!v)'')
       !end_itemize
 !item die (!V)(!nolink [PFONTINFO])(!v)--Struktur wird auch bei Rckgabe
       (!V)(!nolink [xFS_STOP])(!v) mit den Werten des zuletzt im Fontselektor
       ausgew„hlten Fonts gefllt
 !item Codierung der Fontflags ge„ndert (feinere Unterscheidung der
       Vektorformate)
!end_itemize

!smallskip

(!B)Revision 3(!b)
!begin_itemize
 !item die erste ”ffentlich verfgbare Schnittstellen--Revision
!end_itemize

!smallskip

(!B)„ltere Revisionen(!b)
!begin_itemize
 !item „ltere Revisionen k”nnen getrost ignoriert werden, da diese
       nie!-mals in einem fr eine gr”ere ™ffentlichkeit verfgbaren
       Programm in Erscheinung getreten sind
!end_itemize
!end_node


# ########################################################################
!begin_node Programmbersicht
Es folgt eine šbersicht ber alle z.Z. erh„ltlichen Fontselektoren, die
ber eine UFSL-- oder eine xFSL--Schnittstelle (oder beides) ver!-fgen.

Desweiteren folgt eine Liste von Programmen, die einen Fontselektor mit
einer der beiden Schnittstellen verwenden.

!subtoc stg

Erg„nzungen und Berichtigungen zu diesen Aufstellungen schicken Sie bitte
an Dirk Haun (Adresse siehe unter ""Kontaktadressen"").


# ========================================================================
!begin_node Fontselektor--šbersicht
!raw [stg] @index "Fontselektoren"

Eine kleine šbersicht ber die existierenden Fontselektoren:
!begin_description
!label UFSL
!item [UFSL] von Michael Th„nitz (!nl)
Dies ist der Prototyp aller externen Fontselektoren. Die letzte
ver”ffentliche Version ist 0.97, danach hat Michael leider die Entwicklung
eingestellt. Dankenswerterweise hat er aber die Quell!-texte
ver”ffentlicht.

!raw [stg] @index "FontSel"
!item [FontSel] von Holger Weets und Christoph Zwerschke (!nl)
Ein kleiner, aber auch etwas spartanischer Fontselektor von Holger Weets,
der seit der Version 1.02 von Christoph Zwerschke weiterentwickelt wird.
Ab der Version 1.02 wird auch die xFSL-Schnittstelle untersttzt.

!label xUFSL
!item [xUFSL] von Stefan Rogel (!nl)
Der xUFSL bietet gegenber den bisher genannten Fontselektoren viele
zus„tzliche Features. Da diese ber die existierende UFSL-Schnittstelle
nicht angesprochen werden konnten, hat Stefan die Schnittstelle erweitert.
Das Design der ersten Version war, vor!-sich!-tig ausgedrckt,
""umstritten"". Letzte ver”ffentlichte Ver!-si!-on: 1.05. Nachfolger des
xUFSL ist !..

!raw [stg] @index "HuGo!"
!item [HuGo] von Stefan Rogel (!nl)
HuGo! ist der an die xFSL--Schnittstelle angepate Nachfolger des xUFSL
(die UFSL-Schnittstelle wird ebenfalls noch untersttzt, nicht aber die
speziellen Erweiterungen des xUFSL an der UFSL--Schnittstelle).
Die Namens„nderung wurde vollzogen, um Ver!-wechs!-lungen zu vermeiden.

!raw [stg] @index "Calvino"
!item [Calvino] von Dirk Haun (!nl)
Zusammen mit HuGo! der erste Fontselektor mit (!nolink [xFSL--Schnittstelle]). Auch
Calvino untersttzt noch die einfache (!nolink [UFSL--Schnittstelle]).

!item [FONT_SEL und FONT_PAL] von Christian Grunenberg (!nl)
Diese beiden Programme arbeiten auf Drag&Drop--Basis, sie unter!-sttzen
also weder die UFSL-- noch die (!nolink [xFSL--Schnittstelle]), dafr aber das
(!nolink [Font--Protokoll]). (!V)FONT_SEL(!v) ist ein Fontselektor, (!V)FONT_PAL(!v)
eine Fontpalette (mit integriertem Fontselektor).
!end_description

!end_node

# ========================================================================
!begin_node Programme, die einen Fontselektor untersttzen
!raw [stg] @index "Programme"
Folgende Programme untersttzen einen externen Fontselektor
(Stand 16.08.1998, alle Angaben und E-Mail-(!nolink [Adressen]) ohne Gew„hr):

!begin_verbatim
 Programm       Kategorie           Autor                    UFSL xFSL
----------------------------------------------------------------------
 800XL-Deejay   Laufwerksemulator   Kolja Koischwitz          +
 APP_List       Systemutility       Ralf Zimmermann @ OF2     +
 Bellini        Grafikprogramm      Ingo Dehne                     +
 BibelST        Bibel-Software      Reinhard Bartel @ LU           +
 Cat2Maus       MausTausch          Harald Sommerfeldt @ W    +
 Chatwin        Shell               Dirk Haun @ LB            +F   +F
 CyPress        Textverarbeitung    Rene Bartholomay @ OL          +F
 DB-Point       Newsreader          Michael Heng @ HH         +
 Disk Cake      Diskutility         Christoph Zwerschke @ KA  +    +
 Egale          Dateiutility        David Reitter @ WI2       +    +
 Everest        Editor              Oliver Schmidt            +
 Face Value     App.Builder/Lib     Vegard Hofsoy             -    +
 Floh           Filelisten-Util.    Heiko Schaefer @ S4            +
 GEMAR          Backup              Steffen Engel @ SZ2       +
 GEM-Fontviewer Zeichensatz-Anzeige Reinhard Bartel @ LU      +    +
 GEM-Plan       Tabellenverwaltung  Reiner Rosin @ WI2             +F
 Hitchcock      Systemutility       Thorsten Pohlmann @ WI2        +
 IdeaList       ASCII-Druckprogramm Christoph Bartholme @ KA2 +
 Imagin         Funktionsplotter    Reinhard Maier @ B             +
 Jedi           GAL-Assembler       Ralf Zimmermann @ OF2     +
 Kandinsky      Zeichenprogramm     Ulrich Rossgoderer @ M         +
 MagiC!Conf     MagiC-Utility       Christian Ratsch @ BI          +
 MasterBrowse   Dateiviewer         Michel Forget             +
 MenuInfo       Systemutility       Dirk Hagedorn @ MK2            +F
 Okami          Newsreader          Wolfram R”sler @ AC2      +
 Photo Line     Bildverarbeitung    Gerhard Huber @ LA             +
 QED            Editor              Christian Felsch @ HH     +
 RoadRunner     Autofahrtplanung    Andreas Schrell @ W2           +F
 SaugUtility    dito                Frank Rger @ OS2         +
 Schecks        Businessoftware     Christian Lehmann @ HG         +
 ST-Guide       Hypertext           Holger Weets @ OL         +
 STJ-Oberon     Programmiersprache  Stephan Junker @ AC2      +    +
 Texel          Tabellenkalkulation Thomas Much @ KA2         +    +
 UpToCASE       CASE-Tool           Michael Nolte @ K2        +
 VESAL          Lernprogramm        Peter Klasen @ D          +
 Zeig's mir     Dateiviewer         Reiner Rosin @ WI2        +    +F
----------------------------------------------------------------------
 (+: untersttzt, F: als Fensterdialog; E-Mail-Adressen: MausNet)
!end_verbatim

!smallskip

Autoren, die nicht ber das MausNet erreichbar sind:
!begin_quote
!begin_verbatim
Kolja Koischwitz: joust@cs.tu-berlin.de
Michel Forget:    mforget@worldgate.edmonton.ab.ca
Oliver Schmidt:   stu30109@mail.uni-kiel.d400.de
Vegard Hofsoy:    vegard@origo.no
!end_verbatim
!end_quote

!end_node
!end_node


!newpage
# !begin_appendix
# ########################################################################

!ifnset [Font-Protokoll_schon_da]
	!include protokol\font.u
!endif

# ########################################################################
!begin_node Die UFSL--Schnittstelle
!raw [stg] @alias UFSL-Schnittstelle
!raw [stg] @autorefoff
Der Vollst„ndigkeit halber folgt hier noch die Original--Beschreibung von
Michael Th„nitz zur ursprnglichen UFSL-Schnittstelle:

(!U)Programmierschnittstelle:(!u) (!nl)

UFSL ist eine Fontauswahlbox fr den Autoordner. Sie bietet dem
Programmierer eine einfache Programmierschnittstelle ber einen Cookie.

Der Cookie lautet: ""(!V)UFSL(!v)"". (!nl)
Der Cookie liefert einen Zeiger auf folgende Struktur:

!begin_verbatim
 typedef struct
 {
  unsigned long  id;      /* UFSL ID (UFSL)       */
  unsigned int   version; /* Version (BCD-Format) */
  int dialtyp;            /* 0=Dialog, 1=Fenster  */
  int cdecl (*font_selinit)(void);
  int cdecl (*font_selinput)(
              int vdihandle,
              int dummy,
              char *text,    /* eigener Text, max. 34 Zeichen      */
              int ftype,     /* 1=nur monospaced Fonts, 0=alles    */
              int *fretid,   /* eingestellte FontId                */
              int *fretsize  /* eingestellte Fontgr”e             */
              );
  OBJECT *helpbutton;           /* Typ: BOXTEXT                    */
  void cdecl (*helpfunc)(void); /* Benutzerdefinierte Helpfkt.     */

  /**** ab Version 0.91 ********************************************/
  char *examplestr;            /* Beispieltext fr Fontdarstellung */

  /**** ab Version 0.96 ********************************************/
  void cdecl (*msgfunc)(int event, int msgbuf[]);/* Redrawfunktion */

  /**** ab Version 0.97 ********************************************/
  int cdecl (*fontsel_exinput)(
              int vdihandle,
              int ftype,     /* 1=nur monospaced Fonts, 0=alles    */
              char *text,    /* eigener Text, max. 34 Zeichen      */
              int *fretid,   /* eingestellte FontId                */
              int *fretsize  /* eingestellte Fontgr”e             */
              );
 } UFSL;
!end_verbatim

(!U)Aufruf:(!u)

!begin_verbatim
UFSL *ufsl;
ufsl=(UFSL *)get_cookie('UFSL');
ufsl->helpfunc= my_helpfunc;   /* Hilfefunktion oder NULL */
ufsl->msgfunc = my_msghandler; /* Redrawfunktion oder NULL,
                                  Dialtyp beachten */
ufsl->fontsel_input(vdihandle,"Bitte Font ausw„hlen",0,&id,&size);
oder
ufsl->fontsel_input(vdihandle,NULL,0,&id,&size);
!end_verbatim

(!U)Returncodes:(!u)

!begin_verbatim
 1 : Alles OK, Werte gltig.
 0 : Abbruch gew„hlt.
-1 : Out of memory.
-2 : Unzul„ssiger Mehrfachaufruf.
-3 : Fontgr”e konnte nicht identifiziert werden.
-4 : Anzahl Fonts mu gr”er null sein.
!end_verbatim

(!U)Sonderfunktionen:(!u)

!begin_verbatim
void cdecl (*helpfunc)(void); /* Benutzerdefinierte Helpfkt.     */
!end_verbatim

UFSL kann eine benutzerdefinierbare Hilfefunktion ber den ebenfalls
optionalen Hilfebutton aufrufen. (!V)helpfunc()(!v) ben”tigt keine
Parameter und liefert auch keinen Wert zurck.

!begin_verbatim
void cdecl (*msgfunc)(int event, int msgbuf[]); /* Redrawfunktion */
!end_verbatim

Bei Verwendung von UFSL als Fensterdialog ist es notwendig eine 
Re!-draw!-funk!-ti!-on zur Verfgung zu stellen. Sie schickt die 
anfallenden Events an das aufrufende Programm zurck, damit nach 
Verschieben des Dialogs die Hintergrundfenster restauriert werden 
k”nnen. (!V)msgfunc()(!v) liefert als ersten Parameter das Ergebnis 
von (!V)evnt_multi()(!v) und als zweiten Parameter die MsgPipe. Ein 
Returncode wird nicht ben”tigt. Das Anwenderprogramm muá die n”tigen 
Routinen zur Fensterbehandlung zur Verfgung stellen. 
(!V)wind_update(..._UPDATE)(!v) wird von UFSL nicht ge!-setzt, obliegt 
also dem rufenden Anwenderprogramm. Prinzip!-be!-dingt (?) ist die 
Memoryprotection von MTOS auszuschalten.

Grunds„tzlich gilt es zu berlegen, ob tats„chlich alle Events
ent!-sprechend beantwortet werden sollen. Ein (!V)WM_TOPPED(!v), das
andere eigene Fenster nach vorn bringt, sollte wohl nicht beantwortet
werden, da UFSL naturgem„á nur applikationsmodal sein kann, da UFSL ja in
einem eigenen (!V)form_do()(!v) sprich (!V)evnt_multi()(!v) kreist.
!raw [stg] @autorefon

!end_node

# ########################################################################
!begin_node Hinweise fr Autoren anderer Fontselektoren
Autoren anderer Fontselektoren sind dazu eingeladen, sich der
xFSL--Schnittstelle anzuschlieen. Im Prinzip kann jeder Fontselektor,
der als TSR konzipiert ist, mit der xFSL--Schnittstelle ausgerstet
wer!-den.

Damit keine Miverst„ndnisse entstehen: Die Overlay--Technik und die
Reentranz, wie sie Calvino und HuGo! bieten, sind nicht Teil der
ei!-gen!-tlichen Schnittstelle und mssen von anderen Fontselektoren daher
auch nicht untersttzt werden. Allerdings ist auch die Schnittstelle
zwischen dem residenten Teil (""Shell"") und dem nachgeladenen Teil
(""Overlay"") genormt und kann daher auch von anderen Fontselektoren
verwendet werden. Eine Beschreibung dieser internen Schnittstelle ist
auf Anfrage erh„ltlich, siehe ""Kontaktadressen"".

Da bereits eine Reihe von Programmen die alte UFSL--Schnittstelle
un!-ter!-sttzen, erscheint es ratsam, auch in neuen Fontselektoren diese
Schnittstelle noch zur Verfgung zu stellen. Jedoch zeigt ein kurzer
Blick auf diese Programme, da sie fast ausschlielich den Fontselektor
als modalen Dialog aufrufen. Die Empfehlung lautet daher, eine minimale
UFSL--Untersttzung einzubauen (nur als modaler Dialog) und dafr die
xFSL--Schnittstelle m”glichst weitgehend zu implementieren,
da zu erwarten steht, da gerade die --- nun endlich genormten ---
Er!-wei!-te!-rungen gegenber der (!nolink [UFSL-Schnittstelle]) von den Programmen
ver!-wen!-det werden sollen.

Ein Fontselektor sollte m”glichst die folgenden zus„tzlichen Features
bieten:
!begin_itemize
!item Gr”en„nderung m”glich (!nl)
      Insbesondere ist damit gemeint, da nicht nur eine Gr”e
      aus!-ge!-w„hlt, sondern bei Vektorfonts auch die Zwischengr”en
      ein!-ge!-stellt werden k”nnen.
!item (!nolink [fix31])--Untersttzung (!nl)
      Fr einige Anwendungen reicht die Einstellung der Fontgr”e in
      Punkt nicht aus, daher sollte auch eine Einstellung in 1/65536 Punkt
      m”glich sein.
!item User--(!nolink [Popup]) (!nl)
      Durch das zus„tzliche (!nolink [Popup]) wird der Fontselektor flexibler
      ein!-setz!-bar.
!item Drag&Drop--Untersttzung (!nl)
      Neben dem ""traditionellen"" Aufruf ber den Cookie kommen L”!-sungen
      auf Drag&Drop--Basis immer mehr in Mode. Wenn der Fontselektor von
      sich aus schon Drag&Drop untersttzt, l„t er sich leicht durch
      ein kleines ""Frontend""-Programm in einen voll!-wer!-ti!-gen
      Drag&Drop--Selektor verwandeln.
!end_itemize

Folgende Konventionen wurden fr einen xFSL--Fontselektor vereinbart:
!begin_itemize
 !item Wenn der Fontselektor ber einen Closer verfgt, so wird dieser
       als ""Abbruch"" interpretiert, d.h. es wird (!V)xFS_STOP(!v)
       zurck!-ge!-ge!-ben. Ist das Kontrollflag (!V)CC_CLOSER(!v) gesetzt,
       wird der gerade aktuelle Font aber trotzdem zurckgegeben (in der
       (!V)PFONTINFO(!v)--Struktur in (!V)xFSL_PAR(!v)).
 !item Wenn der erweiterte Aufruf ((!V)xfsl_init(!v), (!V)xfsl_event(!v)
       und (!V)xfsl_exit(!v)) nicht untersttzt wird, mu zumindest eine
       Dummy--Funktion fr (!V)xfsl_init(!v) installiert werden, die
       immer -32 (Gemdos--Fehler!-mel!-dung (!V)EINVFN(!v), ungltige
       Funktionsnummer) zurckgibt.

       Es wird aber dringend empfohlen, den erweiterten Aufruf
       an!-zu!-bie!-ten, da dieser am h„ufigsten verwendet wird.
 !item Es ist legal, da der Fontselektor beim erweiterten Aufruf nur
       als modaler Dialog erscheint. Bei gesetztem (!V)CC_WINDOW(!v)
       sollte (!V)xfsl_init(!v) dann aber (!V)xFS_NO_WINDOW(!v)
       zurckgeben, damit sich der Auf!-rufer darauf einstellen kann.
!end_itemize

!end_node

# ########################################################################

!ifnset tos_hyp

!begin_node Kontaktadressen
!raw [stg] @alias Kontaktadressen
!raw [stg] @index "Adressen"

Die xFSL--Schnittstelle wurde von Dirk Haun und Stefan Rogel unter
tat!-kr„ftiger Mithilfe von Reiner Rosin und einer Reihe fleiiger
Beta!-tester entwickelt.

Wenn Sie Fragen und/oder (!nolink [Anmerkungen]) zur xFSL--Schnittstelle haben, dann
wenden Sie sich doch einfach an

!begin_quote
 Dirk Haun                  (!nl)
 Johanniterstr. 3           (!nl)
 D-74177 Bad Friedrichshall (!nl)
 Germany

 E-Mail: Dirk Haun @ LB~~~bzw.~~~dirk_haun@lb.maus.de
!end_quote

oder an

!begin_quote
Stefan Rogel    (!nl)
K”hlerweg 1     (!nl)
D-67661 Kaiserslautern

e-mail: Stefan Rogel @ LU (MausNet)
!end_quote

!smallskip

Das Font--Protokoll stammt von

!begin_quote
Christian Grunenberg (!nl)
Traminerweg  5       (!nl)
D-71717 Beilstein
!end_quote

#   !end_appendix

!end_node

!endif

!end_node
#!end_node
