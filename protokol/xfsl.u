!iflang [english]

!begin_node xFSL interface

GDOS, which for years suffered a shadowy existence on the Atari
platform, has enjoyed rising popularity since the introduction of
vector fonts at the latest. Ever more programs offer the possibility
to use a font different from the system font for output (and partly
also for input).

Now to be able to select a font, one needs a font-selector. And so
that not every programmer had to concoct his own brew, and to obtain
consistent operation, there grew a desire for a system extension that
made a font-selector available to all programs - just like a file-
selector.

The first program of this type was the 'UFSL' by Michael Th„nitz.
Via a cookie it makes available routines for calling a font-selector.
This interface is already being used by a number of programs, and
there are also further font-selectors that can be called via this
interface.

Although one can now call a font-selector via the UFSL interface, it
has already been subject to a number of - partly incompatible -
alterations and extensions. That is why most programs today assume
that they have only the original, simple (!nolink [UFSL interface]) available to
them. The result is therefore that the extensions remain unused, and
when a somewhat more powerful font-selector is required in a program,
one is thrown back to having to write a new one specially for that
program. In a somewhat exaggerated form there is presented here the
idea of an external font-selector ad absurdum ...

Due to the 'wild growth' of the (!nolink [UFSL interface]) it seemed more sensible
to draw a clear line under this and develop a completely new interface
that is then also offered via a new cookie.

This text describes this new interface, which can not simply call a
font-selector, but can also exert an influence on it in many ways.


!subtoc [all]

# ########################################################################
!begin_node About the xFSL interface

With the xFSL interface, the caller (i.e. the program that calls the
font-selector) has appreciably more influence on the font-selector,
its behaviour, and on the fonts offered for selection.

During the conception of the new interface, the attempt was made to
pay regard to the capabilities of various programming languages (e.g.
the avoidance of pointers to functions), and at the same time to be
prepared for possible extensions of the interface.

The adaptation of a program to the (!nolink [xFSL interface]) should be a matter
of a few minutes, specially as sample calls in various programming
languages are provided. The conversion of special requests may require
somewhat more effort, of course, but should not present an insoluble
problem.

There follows a description of the xFSL cookie as well as the various
xFSL calls and parameters ...

!subtoc [all]

# ========================================================================
!begin_node The xFSL cookie
!label xFSL cookie

If a font-selector is installed that supports the xFSL interface,
then a cookie 'xFSL' exists whose value is a pointer to the following
structure:

!begin_quote
!begin_verbatim
typedef struct
{
  unsigned long xfsl;       /* Magic 'xFSL'              */
  unsigned int  revision;   /* Interface revision        */
  unsigned long product;    /* Font-selector identifier  */
  unsigned int  version;    /* Font-selector version     */
  xFSL_INPUT    xfsl_input; /* Simplified call           */
  xFSL_INIT     xfsl_init;  /* Init call                 */
  xFSL_EVENT    xfsl_event; /* Event call                */
  xFSL_EXIT     xfsl_exit;  /* Exit call                 */
  xFSL_INFO     xfsl_info;  /* Info call                 */
} xFSL;
!end_verbatim
!end_quote

Die Komponenten der Struktur im einzelnen:
!begin_ilist [xfsl_input]
!item [xfsl]
Here we have for safety's sake once more the ASCII
character string 'xFSL' (= 0x7846534C in hexadecimal).

!item [revision]
This is the revision number of the (!nolink [xFSL interface]); at
           present it contains the value 4. If the interface should
           be extended in the future, one will find correspondingly
           higher values there.

!item [product]
Here one finds the identifier for the actually installed
           font-selector. This entry is intended, however, only as
           additional information, and should (!I)not(!i) be evaluated by
           application programs that want to call the font-selector!

     Identifiers used to date:
!begin_table [l|l]
 Identifier !! Font-selector
!hline
 CLVN  !!  Calvino
 FSEL  !!  FontSel
 HUGO  !!  HuGo!
!end_table

     The identifier (like the following version number too) was only
     introduced for programs that want to output information about
     the installed font-selector (e.g. the program 'SysInfo').

!item [version]
The version number of the installed font-selector as BCD
           number (e.g. hexadecimal 0x100 for Version 1.00). The same
           notes apply here as for the (!I)product(!i) field above.

!item [(!nolink [xfsl_input])]
This is the entry point for a simplified call of the
           font-selector. The font-selector then appears always as a
           modal dialog and most of the additional features of the
           (!nolink [xFSL interface]) can not be accessed.

!item [xfsl_init, xfsl_event, xfsl_exit~]
These three functions together form
           the extended font-selector call. All of the new features
           can be accessed via them. The procedure corresponds to the
           display of a (!nolink [GEM]) dialog:
 !begin_enumerate
  !item Display font-selector (xfsl_init)
  !item Event handling in a loop until 'OK' or 'Cancel' has been selected
        (xfsl_event)
  !item Remove font-selector from the screen (xfsl_exit)
 !end_enumerate

!item [(!nolink[xfsl_info])]
With this call one can inquire about some of the features
           of the installed font-selector, e.g. Drag&Drop support.
!end_ilist

!end_node


# ========================================================================
!begin_node The simplified call (xfsl_input)
!label xfsl_input
xfsl_input is the entry point for a simplified call. With it one can
only call the font-selector as a modal dialog. In addition one can
specify a heading, and restrict the type of fonts that the selector
is to present for selection.

!begin_quote
!begin_verbatim
int xfsl_input (int           vdihandle,
                unsigned int  fontflags,
                const char   *headline,
                int          *id,
                int          *size
               );
!end_verbatim
!end_quote

The parameters in detail:
!begin_xlist [vdihandle~]
!item [(!V)vdihandle(!v)]
Here you pass the handle of a virtual (!nolink [VDI]) workstation
already opened by your program (if you want to set a font
in your program, you have to open such a (!nolink [VDI]) workstation
anyway). The font-selector then adopts the font just set
on this workstation as the current font (provided it is
actually offered for selection by (!I)fontflags(!i)).

Instead of a valid handle you can however just pass a
NULL, in which case the font-selector will display the
font that you pass in the parameters (!I)id(!i) and (!I)size.(!i)

If you pass a (!nolink [VDI]) workstation handle, then the selected
font will also be simultaneously set on this workstation.

!item [(!V)fontflags(!v)]
With the (!link [font-flags][The font-flags]) you can determine which fonts will
             actually be offered for selection.

!item [(!V)headline(!v)]
Here you can specify a header that will then appear in
             the font-selector. If the header is missing (pass 0L),
             then a default text ('Font-selector', 'Fontauswahl' or
             similar) will be shown.

!item [(!V)id(!v)]
In this variable the ID of the selected font will be
             returned (naturally only if a font was really selected).
             This font can now be set directly with the (!nolink [VDI]) function
             vst_font.

             If you pass a NULL in (!I)vdihandle(!i), then the font-selector
             will display the font specified in (!I)id.(!i)

!item [(!V)size(!v)]
In this variable the size of the selected font in points
             will be returned (also only if a new font was really
             selected). If this is a bitmap font, then its size may
             be set with the (!nolink [VDI]) function vst_point. For vector
             fonts one should call the function vst_arbpt.

             If you pass a NULL in (!I)vdihandle(!i), then the font-selector
             will display the font specified in (!I)id(!i) in the size given
             in (!I)size.(!i)
!end_xlist

!smallskip

(!U)(!nolink [Return]) values(!u)

xfsl_input returns a negative number if an error has arisen. A 0 is
returned if 'Cancel' was selected. If a 1 is returned, then a new font
was selected.

The return values are the same for all xFSL functions, and upwardly
compatible to the return values of the UFSL.
!end_node


# ========================================================================
!begin_node The extended xFSL call
The extended xFSL call consists of three individual function calls:
!begin_xlist [xfsl_event~]
!item [(!V)xfsl_init(!v)]
Displays the font-selector on the screen. In addition
              the parameters are passed here.
!item [(!V)xfsl_event(!v)]
This function is called repeatedly until a font has been
              selected in the font-selector, or 'Cancel' selected.
!item [(!V)xfsl_exit(!v)]
      Removes the font-selector from the screen again.
!end_xlist

!smallskip

In C it can look like this, for instance:
!begin_quote
!begin_verbatim
xhandle = xfsl->xfsl_init (vdihandle, &xpar);
if (xhandle >= 0)
{
  do
  {
    ret = xfsl->xfsl_event (xhandle, 0L);
    if (ret == xFS_HELP)
      ...;  /* Call Help function  */
    else if (ret == xFS_POPUP)
      ...;  /* Handle popup       */
    else if (ret == xFS_EVENT)
      ...;  /* Handle AES event   */
  } while ((ret != xFS_OK) && (ret != xFS_STOP));
  xfsl->xfsl_exit (xhandle);
}
!end_verbatim
!end_quote

This splitting up into three has the advantage, amongst others, that
the handling of the events (HELP button, popup, (!nolink [AES]) events) does not
have to pass pointers to functions (which presents difficulties in
some programming languages). Also the interface can be extended easily
by furher events if these should ever become necessary.


# ------------------------------------------------------------------------
!begin_node xfsl_init

This call not only brings up the font-selector on the screen, it also
determines which fonts are to be displayed, whether a user-popup is
being used and several other things.

!begin_quote
!begin_verbatim
int xsfl_init (int       vdihandle,
               xFSL_PAR *xpar
              );
!end_verbatim
!end_quote

The two parameters mean:
!begin_xlist [vdihandle~]
!item [(!V)vdihandle(!v)]
As for the simplified call, here you pass the handle
             of a virtual (!nolink [VDI]) workstation already opened by your
             program, or simply a NULL.

             If you pass a valid workstation handle, then the font-
             selector will adopt the font current on this workstation
             and display it - provided (!I)fontflags(!i) (in the xFSL_PAR
             structure) actually makes it available for selection. If
             this is not the case, then the font-selector will choose
             a font from those available and display it.

             If you pass a NULL as workstation handle, then the font
             from the PFONTINFO structure (to which a pointer in the
             xFSL_PAR structure points) will be adopted and displayed.

             If you pass a (!nolink [VDI]) workstation handle, then the
             font selected on this workstation will also be set.

!item [(!V)xpar(!v)]
This is a pointer (i.e. the address) of an xFSL_PAR
             structure that contains all further specifications for
             the font-selector.

             Due to the large number of options, this structure has
             been given its (!link [own page][The xFSL_PAR structure]).
!end_xlist

The following applies again for the return codes of the function: A
negative return value indicates an error. Positive values here have
a slightly different meaning: A 0 means that the font-selector was
opened (successfully) as a modal dialog. Any other positive values
correspond to the window handle of the opened font-selector. This way
you can register the font-selector window with an AV-server, for
instance.

On success (return value larger or equal to 0) you should store the
handle in a variable, as it will still be needed for the following
calls (xfsl_event and xfsl_exit).

(!B)Note:(!b) If the font-selector is to be displayed as a window, but
xfsl_init returns the error xFS_NO_WINDOW (no more windows available),
then one should attempt to display the font-selector at least as a
dialog (clear (!nolink [control])-flag CC_WINDOW and call xfsl_init again).

(!B)Remember:(!b) The user wants a font-selector, not an error-message!

!end_node


# ------------------------------------------------------------------------
!begin_node xfsl_event

When the font-selector has been initialized and brought to the screen,
xfsl_event takes over the main work.

!begin_quote
!begin_verbatim
int xfsl_event (int    xhandle,
                EVENT *event
               );
!end_verbatim
!end_quote

The two parameters mean:
!begin_xlist [xhandle~]
!item [(!V)xhandle(!v)]
The handle of the font-selector, as returned by xfsl_init.

!item [(!V)event(!v)]
Pointer to an EVENT structure, as used by Pure-C. In this
           structure the font-selector returns (!nolink [AES]) events that it
           could not process itself. In addition, you can also use the
           input parameters to tell the font-selector about which
           events are to be reported.

           However, the pointer can also just be a NULL if you do not
           want to evaluate any (further) events. If the font-selector
           is to be operated as a window-dialog and the caller (i.e.
           your program) has some other windows open, then you have
           to evaluate the redraw messages at least!

           (!B)Example:(!b) If you set the MU_MESAG flag in (!I)ev_mflags(!i) of
           evnt_multi, then the font-selector will return all the
           arriving (!nolink [AES]) messages that it cannot handle itself to
           the caller.

           (!B)Note:(!b) It is also possible, or course, to receive timer
           events; but these should only be used sparingly and not be
           too short, as in that case the font-selector has to leave
           its own event loop each time. 250 ms might serve as the
           - non-binding - lower limit.
!end_xlist

(!B)The possible return values of xfsl_event:(!b)
!begin_xlist [xFS_POPUP~]
!item [(!V)xFS_STOP(!v)]
The 'Cancel' button or (if present) the Closer of the
             window-dialog was selected in the font-selector.

             If the CC_CLOSER (!nolink [control])-flag is set and the Closer is
             clicked on, the PFONTINFO structure to which the pointer
             in the xFSL_PAR structure points nevertheless contains
             data about which font was last selected in the font-
             selector. Otherwise this information would not be
             preserved.

!item [(!V)xFS_OK(!v)]
A font was chosen and 'OK' selected. The font that was
             selected is described in the PFONTINFO structure to which
             the pointer in the xFSL_PAR structure points. If a valid
             (!nolink [VDI]) handle was passed at xfsl_init, then this font will
             also be set immediately on this (!nolink [VDI]) workstation.

!item [(!V)xFS_HELP(!v)]
The HELP button was selected (this can only occur if one
             has been provided, of course). It is up to the caller how
             it reacts to this. Normally help will be provided by the
             display of a Help page (or triggering such a display).

!item [(!V)xFS_EVENT(!v)]
An (!nolink [AES]) event has occurred that the font-selector could
             not process (e.g. a Redraw message for another window).
             Exactly what this event was can be gathered from the
             (!I)ev_mwich(!i) field of the EVENT structure.

             Desk accessories should not forget calling xfsl_exit on
             receipt of an AC_CLOSE message! The same applies for the
             AP_TERM message.

!item [(!V)xFS_POPUP(!v)]
A change was made in the user-popup (if present). For
             the changed popup entry the FF_CHANGED bit is set in
             the (!I)fontflags(!i) element. The popup entry which was then
             selected, and on return to the font-selector will be the
             current one in the popup (at the next xfsl_event call),
             will lie in the (!I)sel_entry(!i) element of xFSL_PAR.

             You now still have the option of making changes to the
             popup entries, for instance to alter the (!link [font-flags][The font-flags]), or
             adopt the changed font in all other popup entries (in
             this way it is possible to use the popup for some other
             kind of information which may have nothing to do with the
             selected font). But the texts and the number of popup
             entries may not be changed!

!item [other values:]
Other positive values should be ignored. It is possible
             that the interface will be extended by further return
             values (events).

             Negative values indicate an error, the font-selector
             should then be aborted. But it is imperative that one
             still calls xfsl_exit beforehand!
!end_xlist

!end_node

# ------------------------------------------------------------------------
!begin_node xfsl_exit

With the xfsl_exit call the font-selector is removed from the screen
again:

!begin_quote
!begin_verbatim
void xfsl_exit (int xhandle);
!end_verbatim
!end_quote

Here (!I)xhandle(!i) is again the handle of the font-selector, as returned
by xfsl_init.

xfsl_exit must be called always when the use of the font-selector is
to be ended, be it that a font was chosen or 'Cancel' was selected,
or that xfsl_event reported an error. If already the (!nolink [xfsl_init]) call
failed, then xfsl_exit may (!I)not(!i) be called (logical, since one has no
valid handle).

The call of xfsl_exit should also not be forgotten on arrival of the
AC_CLOSE and AP_TERM messages!

!end_node

# ========================================================================
!begin_node The info call (xfsl_info)
!label xfsl_info

With this call one can inquire about some of the features of the
(!nolink [installed]) font-selector:

!begin_quote
!begin_verbatim
long xfsl_info (void);
!end_verbatim
!end_quote

If the return value is positive, then the following flags represent
the features that are present (negative return values are, as usual,
error-messages):

!raw [stg] @alabel "XF_SIZE" "XF_COLOR" "XF_ATTR" "XF_WIDTH" "XF_KERN" "XF_SKEW"
!raw [stg] @alabel "XF_ALIGN" "XF_ROTATION" "XF_FIX31" "XF_POPUP" "XF_DRAGDROP"
!raw [stg] @alabel "XF_MAPPING"
!begin_quote
!begin_table [l|l|l]
      Name       !!  Value  !!   Meaning
!hline
      XF_SIZE    !!  0x0001 !!  (!nolink [Size]) changes possible
      XF_COLOR   !!  0x0002 !!  Colour changes possible
      XF_ATTR    !!  0x0004 !!  Attribute changes possible
      XF_WIDTH   !!  0x0008 !!  Width changes possible
      XF_KERN    !!  0x0010 !!  Kerning changes possible
      XF_SKEW    !!  0x0020 !!  Slope/skew changes possible
      XF_ALIGN   !!  0x0040 !!  Alignment changes possible
      XF_ROTATION!!  0x0080 !!  Text rotation possible
      XF_FIX31   !!  0x0100 !!  fix31 support
      XF_POPUP   !!  0x0200 !!  Popup support
      XF_DRAGDROP!!  0x0400 !!  Drag&Drop support
      XF_MAPPING !!  0x0800 !!  Understands mapping
!end_table
!end_quote

Further features of the font-selector can be inquired indirectly via
the (!I)(!nolink [control])(!i) element of the xFSL_PAR structure: On a successful
xfsl_init call, those (!nolink [control])-flags that the font-selector does not
know are cleared.

!end_node

# ========================================================================
!begin_node The VDI workstation in the xFSL interface

With the xfsl_input and xfsl_init calls one can pass the handle of a
virtual (!nolink [VDI]) workstation already opened by the user in each case.

The further behaviour of the font-selector depends on whether one
actually passes a workstation handle or just a NULL:

If one passes a valid handle, then the font-selector will try to
ascertain the current font on the corresponding workstation and then -
provided it matches the passed (!link [font-flags][The font-flags]) - to also set it and offer
it for selection. If the current font does not match the (!I)fontflags(!i)
setting (say if only vector fonts are to be offered but the current
font is a bitmap font), then the font-selector will select a font
from those on offer and present it as the current font.

If the user now selects a font and closes the font-selector with 'OK'
then this font will also be set immediately on the passed workstation,
so that the calling program no longer has to do this.

For this one should note that the font-selector also opens its own
(!nolink [VDI]) workstation and uses this internally and for the selection of the
fonts. Amongst other things it will also call vst_load_fonts for this
workstation (provided a GDOS is (!nolink [installed])). This can lead to some
unexpected results if no (!nolink [vst_load_fonts]) has been called yet on the
passed workstation and the user selects a font in the font-selector
that only becomes available after a (!nolink [vst_load_fonts]) call!

!smallskip

Instead of a workstation handle however one can also simply pass a
NULL. The font-selector will then ascertain the current font from the
passed parameters (for a (!nolink [xfsl_input]) call) or from the xFSL_PAR
structure (for a (!nolink [xfsl_init]) call).

The selected font will then (logically) only be returned in the
parameters or the (!nolink [xFSL_PAR]) structure and the caller then has to set
it him/herself.

!end_node


# ========================================================================
!begin_node The xFSL_PAR structure
!label xFSL_PAR
With this structure you have extensive influence on the behaviour of
the font-selector and the type of fonts displayed. Therefore the
description of the options is somewhat on the long side ...

!begin_quote
!begin_verbatim
typedef struct
{
 int            par_size;    /* Size of xFSL_PAR structure     */
 int            pfi_size;    /* Size of PFONTINFO structure    */
 unsigned long  control;     /* Control-flags                  */
 const char    *headline;    /* Header, or 0L                  */
 const char    *example;     /* Sample text, or 0L             */
 const char    *helptext;    /* Text of the HELP button, or 0L */
 PFONTINFO     *font;        /* Pointer to Fontinfo structure  */
 unsigned int   fontflags;   /* Permitted font types           */
 const char    *poptext;     /* Text before the popup, or 0L   */
 int            num_entries; /* Number of entries (0..n)       */
 int            sel_entry;   /* Selected entry (0..n-1)        */
 xFSL_PENTRY   *popup;       /* Pointer to a popup, or 0L      */
 char          *helpinfo;    /* Pointer to Help-file/-page     */
} xFSL_PAR;
!end_verbatim
!end_quote

Despite the multitude of entries everything is really quite simple,
the more so that the fields that you do not need, or whose meaning is
not yet clear to you, can simply be filled with zeros, whereupon the
font-selector will then assume sensible default values.

The fields in detail:
!begin_xlist [fontflags~]
!item [(!V)par_size(!v)]
This field may not be set to zero; here the size of
             the xFSL_PAR structure in bytes is entered, so that
             in C one can simply write:
!begin_quote
!begin_verbatim
xpar.par_size=sizeof(xFSL_PAR);
!end_verbatim
!end_quote
             The size of the structure currently comprises 42 bytes.
             Should the structure be extended at some time, then the
             font-selector can recognize from the size specification
             whether it is dealing with the old or the new structure.

!item [(!V)pfi_size(!v)]
This field too may not be zero; here one has to enter
             the size of the (!nolink [PFONTINFO]) structure, so in C:
!begin_quote
!begin_verbatim
xpar.pfi_size=sizeof(PFONTINFO);
!end_verbatim
!end_quote
             The current size of the PFONTINFO structure comprises
             38 bytes and might also be extended in the future.

!item [(!V)(!nolink [control])(!v)]
These are the so-called (!nolink [control])-flags, with which
             the behaviour of the font-selector can be influenced
             (e.g. whether it is to appear as a window or a dialog).

             These flags are described in greater detail in their
             (!link [dedicated section][The control-flags]) below.

!item [(!V)headline(!v)]
This, as already familiar from the simplified call, is a
             pointer to a header line for the font-selector. If this
             is missing ((!I)headline(!i) contains 0L), then a default text
             header will inserted.

             The length of the header should be within the limit set
             by UFSL (34 characters), though the font-selector will
             truncate longer headers if necessary.

!item [(!V)example(!v)]
A pointer to a sample text. The font-selector displays an
             example of glyphs in the currently selected font making
             up a text that may be specified here. If this text is
             missing (i.e. (!I)example(!i) contains zero) then the font-
             selector will display a default text (e.g. the name of
             the current font in each case).

!item [(!V)helptext(!v)]
This is the text for a button that can be displayed at
             bottom left of the font-selector. Normally one will want
             to display a button labelled 'HELP' (or 'HILFE'), which
             explains to the user the function of the font-selector,
             and what the selected font is to be used for.

             If this text is missing (i.e. (!I)helptext(!i) contains zero),
             then no HELP button will be displayed and also xfsl_event
             will not return a value for xFS_HELP.

             One should choose a short text (around 8 characters),
             though the font-selector will truncate longer texts if
             necessary.

!item [(!V)font(!v)]
This is a pointer to a structure (PFONTINFO) which
             describes a font. The structure is used both for passing
             values to the font-selector as well as returning the
             selected font.

             This structure too is described in greater detail in its
             (!link [dedicated section][The PFONTINFO structure]) below.

!item [(!V)fontflags(!v)]
These are once more the (!link [font-flags][The font-flags]), familiar from the
             simplified call, with which you can influence the fonts
             available for selection.

!item [(!V)poptext(!v), (!V)num_entries(!v), (!V)sel_entry(!v), (!V)popup(!v):]
With these four parameters
             an additional popup can be made to appear in the font-
             selector. Due to the manifold options there is again a
             (!link [dedicated section][The user-popup]) below for this.

             If you do not want a popup, then simply set these four
             values to zero.

!item [(!V)helpinfo(!v)]
This is a pure output parameter: If the HELP button was
             selected (provided it is present, see `(!I)helptext(!i)'), then
             one will find here a pointer to a filename of a Help-file
             and the name of a page to be displayed. The filename is
             specified without a path or extension, with the page name
             following directly after it, separated by a comma.
 !begin_quote
  (!B)The string may only be read, but not altered!(!b)
 !end_quote
If you do not want to display Help yourself with xFS_HELP
             then you can use the information to call up a help-system
             (e.g. ST-Guide).

             (!B)Example:(!b) xfsl_event returns xFS_HELP, in (!I)helpinfo(!i)
             there is a pointer to the string:
!begin_quote
!begin_verbatim
fine,The finest font-selector of all time
!end_verbatim
!end_quote
From this one can create the following call for ST-Guide:
!begin_quote
!begin_verbatim
*:\fine.hyp The finest font-selector of all time
!end_verbatim
!end_quote
So one appends the extension for the relevant help-system
             to the filename and passes the post-comma portion as a page-name.
!end_xlist

!smallskip

To stress once more: Fields that you do not require or do not yet
understand can simply be set to zero at first. Exceptions are only:
!begin_itemize
 !item (!I)par_size(!i), the size of the xFSL_PAR structure itself
 !item (!I)pfi_size(!i), the size of the PFONTINFO structure
 !item (!I)font(!i), the pointer to the (!nolink [PFONTINFO]) structure
!end_itemize

!end_node

# ------------------------------------------------------------------------
!begin_node The control-flags

With the (!nolink [control])-flags one can influence the benaviour of the font-
selector.

!raw [stg] @alabel "CC_WINDOW" "CC_FIX31" "CC_NOSIZE" "CC_NOCOLOR" "CC_NOATTR"
!raw [stg] @alabel "CC_NOWIDTH" "CC_NOKERN" "CC_NOSKEW" "CC_NOALIGN" "CC_NOROTATION"
!raw [stg] @alabel "CC_DFLTSIZE" "CC_INVSTYLE"
!begin_quote
!begin_table [l|l|l]
      Name          !! Value   !! Meaning
!hline
      CC_WINDOW     !! 0x0001  !! Font-selector as a window
      CC_APPMODAL   !! 0x0002  !! Font-selector is application-modal
      CC_FIX31      !! 0x0004  !! All size specifications in 1/65536 point
      CC_FAKESTYLE  !! 0x0008  !! Simulate styles (only bitmap fonts)
      CC_CLOSER     !! 0x0010  !! Window with Closer, no OK button
      CC_NOSIZE     !! 0x0100  !! Do not alter size
      CC_NOCOLOR    !! 0x0200  !! Do not alter colour
      CC_NOATTR     !! 0x0400  !! Do not alter attributes
      CC_NOWIDTH    !! 0x0800  !! Do not alter width
      CC_NOKERN     !! 0x1000  !! Do not alter kerning
      CC_NOSKEW     !! 0x2000  !! Do not alter skewing
      CC_NOALIGN    !! 0x4000  !! Do not alter alignment
      CC_NOROTATION !! 0x8000  !! Do not alter text rotation
      CC_DFLTSIZE   !! 0x10000 !! 'Default' font size
      CC_INVSTYLE   !! 0x20000 !! 'Inverse' attribute
!end_table
!end_quote
The function of the individual flags should be clear already from the
names and short descriptions. Here still a few notes:
!begin_itemize
!raw [stg] @alabel "CC_APPMODAL"
!item (!V)CC_APPMODAL(!v) (!nl)
     'application-modal' means that the program is put in a mode in
     which only the font-selector can be processed. Essentially this
     means that the font-selector intercepts all WM_TOPPED messages
     for other windows of the calling program and does (!I)not(!i) pass them
     on, but makes itself the topped window instead. This is meant to
     tell the user that he should first deal with the font-selector
     before he can initiate another action in the program.

     The caller in this mode should of course forego topping its own
     windows with wind_set(WF_TOP).

!raw [stg] @alabel "CC_FAKESTYLE"
!item (!V)CC_FAKESTYLE(!v) (!nl)
     This is a specialty that only Calvino offers at present: For
     those bitmap fonts for which no light, italic or bold variants
     are present, the missing cuts are each simulated with the (!nolink [VDI])
     function vst_effects.

!raw [stg] @alabel "CC_CLOSER"
!item (!V)CC_CLOSER(!v) (!nl)
     If this flag and CC_WINDOW are set, then the font-selector is
     provided with a Closer, while the 'OK' and the 'Cancel' buttons
     are hidden. This is intenderd for cases where the font-selector
     is to be used as a pure Drag&Drop selector.

!item (!V)CC_NO...(!v) (!nl)
     With these flags one can determine which settings are not to be
     altered. For instance, a program may want to prevent the size of
     a font being changed, while a change of the font itself is to be
     allowed. In that case the caller only has to set the CC_NOSIZE
     flag.

     But please note that despite a set CC_NO... flag you always have
     to pass a valid value. The meaning of these flags therefore is
     that the preset values may not be changed, and not that these
     values are not of interest.
!end_itemize

(!B)Please note:(!b) Not all font-selectors support all of the (!nolink [control])-flags!
If a font-selector does not support a flag, then it will simply ignore
it. On a successful(!) xfsl_init call, the font-selector will clear
those flags in the (!I)(!nolink [control])(!i) element of the xFSL_PAR structure that it
does not understand.

!end_node

# ------------------------------------------------------------------------
!begin_node The PFONTINFO structure
!label PFONTINFO
This structure describes a font. After calling the font-selector it
contains the selected font. In addition these specifications are
evaluated by the font-selector already at the call (and the described
font displayed), if a zero is passed as the (!nolink [VDI]) handle.
!begin_quote
!begin_verbatim
typedef struct
{
 int          fontid;     /* ID of the font               */
 int          fonttype;   /* Type of font                 */
 char        *fontname;   /* Name of the font             */
 union fsize  fontsize;   /* Font size in pt or fix31     */
 union fsize  fontwidth;  /* Width in pt or fix31         */
 char         trackkern;  /* Track kerning                */
 char         pairkern;   /* Pair kerning                 */
 int          fontattr;   /* Attributes                   */
 int          fontskew;   /* Skew                         */
 int          fontcol;    /* Colour                       */
 int          backcol;    /* Text background colour       */
 int          halign;     /* Horizontal text alignment    */
 int          valign;     /* Vertical text alignment      */
 int          rotation;   /* Text rotation in 1/10 degree */
 int          validtype;  /* Type (V_CHAR_...) or mapping */
 int         *validchars; /* Valid characters, or  0L     */
} PFONTINFO;
!end_verbatim
!end_quote

The elements in detail:
!begin_xlist [fontwidth~]
!item [(!V)fontid(!v)]
The ID of the font, as also returned by the (!nolink [VDI]) function
             vqt_name. The font ID is a non-zero number (so can also
             be negative).

!label BITMAP_FONT
!label SPEEDO_FONT
!label TT_FONT
!label PFB_FONT
!item [(!V)fonttype(!v)]
The type of font, as used as of Speedo 5 or NVDI 3:
!label Fonttyp
!begin_quote
!begin_table [l|l|l]
    Name        !! Value  !! Font type
!hline
    BITMAP_FONT !! 0x0001 !! Pixel
    SPEEDO_FONT !! 0x0002 !! Speedo
    TT_FONT     !! 0x0004 !! TrueType
    PFB_FONT    !! 0x0008 !! Type-1 (Postscript)
!end_table
!end_quote

             These specification are currenly for information only,
             having no meaning for the font-selector. However, in the
             future it will be possible to set a font not just by its
             ID but also by its name, in which case the font type
             will be required as well.

             The font type is also of interest when one wants to
             alter the size of the font: With bitmap fonts this is
             done with the (!nolink [VDI]) function vst_point, for all other
             types (vector fonts) with the function vst_arbpt.

!item [(!V)fontname(!v)]
The name of the font, as returned by vqt_name
             (possibly one or more space characters were removed).

             The caller itself must make enough space available for
             the font name, thus for 32 characters and a NULL-byte!
             If you do not require the font name, then you can also
             simply set the pointer to zero.

!item [(!V)fontsize(!v)]
The size of the font in points (pt) or 1/65536 point (type 'fix31'):
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Font size in points        */
 fix31 size31;  /* Font size in 1/65536 point */
};
!end_verbatim
!end_quote
             Which of these two statements is valid is controlled
             globally with the (!nolink [control])-flag CC_FIX31.

!item [(!V)fontwidth(!v)]
Width of the font in points (pt) or 1/65536 point (type
             (type 'fix31'):
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Font size in points        */
 fix31 size31;  /* Font size in 1/65536 point */
};
!end_verbatim
!end_quote
             Which of these two statements is valid is controlled
             globally with the (!nolink [control])-flag CC_FIX31.

             The width can be set with the (!nolink [VDI]) functions vst_width in
             points and with vst_setsize in fix31.

!label Kerning parameter
!item [trackkern]
This parameter specifies the type of (!link [track kerning][Track kerning])
             for vst_kern. Valid values are:

!begin_table [c|l]
 Value !! (!nolink [Kerning])
!hline
   0 !! No kerning
   1 !! Normal kerning
   2 !! Tight kerning
   3 !! Very tight kerning
!end_table

!item [pairkern]
With this parameter (!link [pair kerning][Pair kerning]) can be switched
             on (0) or off (1), see vst_kern.

!item [(!V)fontattr(!v)]
These are the font attributes (text effects), as also
             used by the (!nolink [VDI]) function vst_effects.

             Calvino only uses this field if the CC_FAKESTYLE
             (!nolink [control])-flag is set.

!item [(!V)fontskew(!v)]
The slope or skew of the font in 1/10 degree, see vst_skew.

!item [(!V)fontcol(!v)]
The colour of the font. The (!nolink [VDI]) colours are used,
             i.e. 0 = White, 1 = Black, etc. See vst_color.

!item [(!V)backcol(!v)]
The background colour to the text. The (!nolink [VDI]) colours are
             used, i.e. 0 = White, 1 = Black etc. The setting of a
             text background colour is not supported directly by the
             (!nolink [VDI]), so it is up to the caller whether and how this
             parameter is used.

!label Text alignment
!label Alignment

!item [(!V)halign(!v)]
With this one can specify the horizontal alignment of the
             text: The text is to be output ranged left, ranged right
             or centred.
!label THA_LEFT
!label THA_CENTER
!label THA_RIGHT
 !begin_table [l|l|l]
 Name       !! Value !! Alignment
!hline
 THA_LEFT   !!  0    !! Ranged left
 THA_CENTER !!  1    !! Centred
 THA_RIGHT  !!  2    !! Ranged right
 !end_table
             These values correspond to the parameter for horizontal
             alignment for the (!nolink [VDI]) call vst_alignment.

!item [(!V)valign(!v)]
With this one can specify the vertical aligment of the
             text: The text is to be output aligned to the top line
             or the bottom line, or (vertically) centred.
!label TVA_BOTTOM
!label TVA_CENTER
!label TVA_TOP
 !begin_table [l|l|l]
 Name       !! Value !! Alignment
!hline
 TVA_BOTTOM !!  0    !! At the text bottom line
 TVA_CENTER !!  1    !! Vertically centred
 TVA_TOP    !!  2    !! At the text top line
 !end_table
             These values deliberately do (!I)not(!i) correspond to the
             parameter for vertical alignment with vst_alignment!
             Values used there ('Base line', 'Character cell bottom
             line') are hardly intuitive for the normal user and hence
             should not form part of the user interface (which they
             would be however for selections in the font-selector).
             The alignment therefore must be converted by the calling
             program to the 'correct' values.

!label Text rotation
!label Rotation
!item [(!V)rotation(!v)]
Text rotation in 1/10 degrees, as also used in the (!nolink [VDI])
             function vst_rotation.
!end_xlist

!smallskip

Still missing are the two parameters (!I)validtype(!i) and (!I)validchars(!i):

Sometimes it is important to ensure that the font contains certain
characters. There are two possibilities for this:

If (!I)validchars(!i) is zero, one can select with (!I)validtype(!i) one of the
following four groups of characters:
!label V_CHAR_IND
!label V_CHAR_ASC
!label V_CHAR_PRT
!label V_CHAR_ALL
!begin_table [l|l|r|l]
   Name       !! Value !! Range  !! Comment
!hline
   V_CHAR_IND !! -1    !!    -   !!  'Doesn't matter'
   V_CHAR_ASC !! -2    !! 32-126 !! All printable ASCII characters
   V_CHAR_PRT !! -3    !! 32-255 !! All printable characters
   V_CHAR_ALL !! -4    !!  0-255 !! Really all characters
!end_table
These four groups ought to cover the most common applications.

If both (!I)validtype(!i) and (!I)validchars(!i) are zero, then the font-selector
will treat this as V_CHAR_IND; the same for othr invalid values in
(!I)validtype.(!i)

 !smallskip

Should the four groups not suffice at times, then one can instead also
specify more precisely with (!I)validtype(!i) and (!I)validchars(!i) which characters
are required:

!begin_ilist
!label Mapping
  !item [validtype] then contains a value for the character mapping to be used
     by GDOS (see vst_charmap and What's mapping?).

     A free choice of mapping is only available with an appropriate
     GDOS (SpeedoGDOS or NVDI from Version 3 onwards). At present
     the following  mappings are defined:
!label MAP_DIRECT
!label MAP_ASCII
!begin_table [l|l|l]
      Name       !! Value !! Meaning
!hline
      MAP_DIRECT !!  0   !!  Direct mapping
      MAP_ASCII  !!  1   !!  ASCII mapping (default)
!end_table
     If the GDOS does not support mapping, then the font-selector
     will only accept MAP_ASCII; in that case all other mappings
     will be ignored and a test for the presence of given characters
     will (!I)not(!i) be performed.
  !item [validchars] is a pointer to an array of integers (WORDs), with which
     one can specify which characters the font (!I)has(!i) to contain.

     The array consists of a series of from-to pairs:
        !begin_itemize
         !item Two values following each other specify a range (from-to)
         !item Individual characters are specified by doubling up
         !item The end of the list is specified by a from-to pair in
               which the 'to' is smaller than the 'from'
        !end_itemize

     (!B)Example:(!b) Only those fonts should be offered for selection that
     contain all printable ASCII characters as well as the German
     Umlauts:
!begin_verbatim
xFSL_PAR xpar;
int chars[] = { ' ', '~',  /* ASCII 32..126 */
                '„','„', '”','”', '','',
                'Ž','Ž', '™','™', 'š','š', 'ž','ž',
                1,0       /* Ende der Liste */
              };

xpar.font->validtype=MAP_ASCII;
xpar.font->validchars=chars;
!end_verbatim

!end_ilist
Future GDOSes will probably support further mappings (BICS, Unicode,
...). (!nolink [Thanks]) to the coding used, the font-selector will also handle
these correctly: The mapping is simply passed in (!I)validtype(!i) and then
the presence of a character tested with (!I)validchars.(!i)

(!B)Note:(!b) The various possibilities available with the (!I)validtype(!i) and
(!I)validchars(!i) parameters should be used sparingly and with some thought,
as the required testing of the characters may - depending on the
GDOS - take quite a lot of time.

!end_node

# ------------------------------------------------------------------------
!begin_node The user-popup
For the user-defined popup (user-popup in short) the following fields
exist in the xFSL_PAR structure:
!begin_xlist [num_entries~]
!item [(!V)poptext(!v)]
Pointer to a text that is to appear before the popup,
or 0L. The font-selector is free to ignore this text.

!item [(!V)num_entries(!v)]
Number of entries (i.e. lines) in popup. If there is a
zero here than no popup will be displayed. One should
not use more than 16 entries, even though some font-
selectors may support more in some circumstances.

!item [(!V)sel_entry(!v)]
The selected entry in the popup (count starts from 0).
The font-selector stores the number of the selected
popup entry here and reads out the value anew at each
xfsl_event call. In this way you can also force the
font-selector to activate the entry with number 5
instead of the selected number 3, for instance, (at
xFS_POPUP the font-selector only reports which entry
was selected, though this is only activated on jumping back into the
font-selector).

!item [(!V)popup(!v)]
This is a pointer to an array of xFSL_PENTRY elements
as shown below. At the specified address there have to
be exactly as many elements as were specified in (!I)num_entries.(!i)
!end_xlist

!label xFSL_PENTRY
An entry in the popup is built up as follows:
!begin_quote
!begin_verbatim
typedef struct
{
 char         *entry;      /* Text of the popup entry        */
 PFONTINFO    *fontinfo;   /* Pointer to Fontinfo structure  */
 unsigned int  fontflags;  /* Permitted font types           */
 long          funcflags;  /* Function-flags, only for HuGo! */
} xFSL_PENTRY;
!end_verbatim
!end_quote
The meaning of the elements of this structure should be clear from the
preceding explanations. The function-flags correspond to the (!nolink [control])-
flags, apart from the flags that influence the (!nolink [global]) behaviour of
the font-selector (CC_WINDOW etc.). These are ignored here.

(!B)Important:(!b) The pointer to the PFONTINFO structure may not be NULL!

If the text of an entry starts with a `-', then the relevant entry is
disabled (displayed in light type and not selectable). This is mainly
intended for separation lines between entries.

!smallskip

(!U)Application(!u)

In principle one can see three fields of use for the user-popup:
!begin_enumerate
!item Each popup entry sets the font for a given part of a program.
     So for example one could allow only non-proportional fonts in a
     given program window, no vector fonts in another one, and all
     fonts in a third.
!item Each entry makes a given group of fonts available. For instance,
     if one frequently requires vector fonts, one could construct a
     popup with the entries 'Vector fonts only' and 'All fonts'.
!item The popup however can be used also for something completely
     different. One could accommodate information here that though
     it has nothing to do with fonts, affects the window for which
     one wants to set a font. For instance, one could offer a choice
     of the way that inverse characters are to be displayed in a
     console window in the form of a popup having entries 'Inverse',
     'Bold', 'Underlined' available for selection.

     If one wants to alienate the purpose of the popup in this way,
     then with the xFS_POPUP message one has to transfer the changed
     font (which can be recognized by the set FF_CHANGED flag) to all
     other popup entries, as otherwise the font that is displayed in
     the font-selector would change!
!end_enumerate

!end_node
!end_node

# ========================================================================
!begin_node The font-flags

With the font-flags one can restrict the fonts offered for selection:

!raw [stg] @alabel "FF_SYSTEM" "FF_MONOSPACED" "FF_PROPORTIONAL"
!raw [stg] @alabel "FF_VECTOR" "FF_BITMAP" "FF_ALL" "FF_CHANGED"
!raw [stg] @alabel "FF_VEKTOR" "FF_MONO" "FF_PROP"
!raw [stg] @alabel "FF_SPD" "FF_TTF" "FF_PFB" "FF_CFN"
!begin_table [l|l|l]
      Name            !! Value  !! Meaning
!hline
      FF_SYSTEM       !! 0x0001 !! Show system font (additionally)
      FF_MONOSPACED   !! 0x0002 !! Show monospaced fonts
      FF_PROPORTIONAL !! 0x0004 !! Show proportional fonts
      FF_BITMAP       !! 0x0008 !! Show bitmap fonts
      FF_SPD          !! 0x0010 !! Show Speedo fonts
      FF_TTF          !! 0x0020 !! Show TrueType fonts
      FF_PFB          !! 0x0040 !! Show Type-1 fonts
      FF_CFN          !! 0x0080 !! Show Calamus fonts (not implemented yet)
      FF_VECTOR       !! 0x00F0 !! Show all vector fonts
      FF_ALL          !! 0x00FE !! Show all fonts
      FF_CHANGED      !! 0x8000 !! Change made (only in the popup)
!end_table

The values have been chosen in such a way that the individual flags
may be OR'd with each other. So, for instance if one uses for the
font-flags FF_MONOSPACED|FF_VECTOR, then only non-proportional vector
fonts will be offered for selection.

In addition the following applies:
!begin_itemize
!item FF_SYSTEM has priority, i.e. if this flag is set then the system
     font will be made available for selection too in any event.
!item If FF_SYSTEM is not set, then the system font will be offered for
     selection only when its properties correspond to the set flags.
!item If neither FF_MONOSPACED nor FF_PROPORTIONAL is set, then the
     font-flags are treated as if both flags are set.

     This applies in a similar way for FF_VECTOR and FF_BITMAP.
!item If FF_VECTOR is set, the all vector font formats will be offered
     automatically. A finer subdivision is possible with the flags
     FF_SPD, ..., FF_CFN, if desired.

     (!B)Please note:(!b) Calamus fonts (and therefore the FF_CFN flag) are
     not supported by any GDOS at present!
!item The flag FF_CHANGED is only used to mark in the user-popup the
     settings that have changed. The font-selector only sets this flag
     but does not itself evaluate it.
!end_itemize

!end_node

# ========================================================================
!begin_node xFSL return codes

All xFSL calls return consistent return codes (return values). A
negative number represents an error, a positive number (or zero)
means success or an event.

!raw [stg] @alabel "xFS_LOADERROR" "xFS_RES_ERROR" "xFS_NO_HANDLE" "xFS_NO_WINDOW"
!raw [stg] @alabel "xFS_NO_FONTS" "xFS_NO_FONTSIZE" "xFS_ACTIVE" "xFS_ERROR"
!raw [stg] @alabel "xFS_STOP" "xFS_OK" "xFS_HELP" "xFS_EVENT" "xFS_POPUP"
!begin_table [l|r|l]
      Name           !! Value !! Meaning
!hline
      xFS_PARERROR   !!  -9  !! Parameter error, e.g. call after Rev. 3
      xFS_LOADERROR  !!  -8  !! Error when loading an xFSL module
      xFS_RES_ERROR  !!  -7  !! Resolution too low (minimum 640x400 pixels)
      xFS_NO_HANDLE  !!  -6  !! No (!nolink [VDI]) handle free
      xFS_NO_WINDOW  !!  -5  !! No window(handle) free
      xFS_NO_FONTS   !!  -4  !! No fonts loaded
      xFS_NO_FONTSIZE !! -3  !! Font size not identifiable
      xFS_ACTIVE     !!  -2  !! Font-selector is active already
      xFS_ERROR      !!  -1  !! General error (memory shortage or similar)
      xFS_STOP       !!   0  !! [Cancel] button selected
      xFS_OK         !!   1  !! [OK] button selected
      xFS_HELP       !!   2  !! [Help] button selected
      xFS_EVENT      !!   3  !! (!nolink [AES]) event occurred
      xFS_POPUP      !!   4  !! Changes to user-popup
!end_table

These values were chosen to be upwardly compatible to the UFSL font-
selector (this knows the return codes -4, -3, -2, -1, 0 and 1).

In addition, GEMDOS error messages (values smaller or equal to -32)
can occur; in particular, xfsl_init can also return the value EINVFN
(-32) if the font-selector does not support the extended call.

With the (!nolink [xfsl_init]) call, positive return values correspond to the
font-selector's window handle (0 means that the font-selector was
opened as a modal dialog).

It is possible that the list of return codes will be extended in the
future for further errors (values smaller than -9) or events (values
greater that 4). This should be respected during the design of the
program: Unknown errors should lead to an abort, unknown events should
be ignored.

!end_node

# ========================================================================
!begin_node The Pure-C event structure
!label EVENT
The (!nolink [GEM]) library of Pure-C uses a special structure in which the
parameters of the (!nolink [AES]) function evnt_multi are coalesced.
This structure is also used by xfsl_event.
!begin_quote
!begin_verbatim
typedef struct /* Special type for EventMulti */
{
 /* Input parameters */
 int ev_mflags,
     ev_mbclicks, ev_bmask, ev_mbstate,
     ev_mm1flags, ev_mm1x, ev_mm1y, ev_mm1width, ev_mm1height,
     ev_mm2flags, ev_mm2x, ev_mm2y, ev_mm2width, ev_mm2height,
     ev_mtlocount, ev_mthicount;

 /* Output parameters */
 int ev_mwich,
     ev_mmox, ev_mmoy, ev_mmobutton, ev_mmokstate,
     ev_mkreturn, ev_mbreturn;

 /* Message-Buffer */
 int ev_mmgpbuf[8];
} EVENT;
!end_verbatim
!end_quote
The elements of the structure correspond to those of the evnt_multi
call. The order of the parameters too - apart from a few exceptions -
is identical. The field (!I)ev_mwich(!i) contains the occurred events in the
same coding as (!I)ev_mflags(!i) in (!nolink [evnt_multi]).

!end_node

!end_node

# ########################################################################
!begin_node xFSL tips and notes
In the following sections an attempt is made to give some tips and
notes for the xFSL interface.

!subtoc stg


# ========================================================================
!begin_node A simple xFSL call
In view of the multitude of parameters and setting options, the
following note seems appropriate:
!begin_center
(!B)Don't panic!(!b)
!end_center

An xFSL call is simpler than it appears at first. In particular one
can adopt here the strategy of 'step-by-step refinement', since one
can set (almost) all parameters to zero at first.

A possible simple xFSL call can look like this, for instance:
!begin_quote
!begin_verbatim
#include <stdio.h>
#include <aes.h>
#include <vdi.h>
#include <xfsl.h>

void call_xfsl (void)
{
  int xhandle, xret;
  xFSL_PAR xpar;
  PFONTINFO pfont;
  xFSL *xfsl;

  memset (&xpar, 0, sizeof (xFSL_PAR));
  memset (&pfont, 0, sizeof (PFONTINFO));

  xpar.par_size = sizeof (xFSL_PAR);
  xpar.pfi_size = sizeof (PFONTINFO);
  xpar.font = &pfont;
  xpar.font->fontcol = BLACK;

  if (get_cookie ('xFSL', &xfsl))
  {
    xhandle = xfsl->xfsl_init (0, &xpar);
    if (xhandle >= 0)
    {
     do
       xret = xfsl->xfsl_event (xhandle, 0L);
     while (xret > xFS_OK);
     xfsl->xfsl_exit (xhandle);
     if (xret == xFS_STOP)
       printf ("Cancel\n");
     else if (xret == xFS_OK)
       printf ("Font with ID %d selected\n", xpar.font->fontid);
     else if (xret < 0)
       printf ("Error %d\n", xret);
   }
   else
     printf ("Error %d\n", xhandle);
  }
  else
    printf ("Cookie not found!\n");
}
!end_verbatim
!end_quote

With the two memset calls all elements of the structures (!nolink [xFSL_PAR]) and
(!nolink [PFONTINFO]) are set to zero. Subsequently some absolutely necessary
values are entered:

!begin_itemize
 !item The size of the two structures xFSL_PAR and PFONTINFO
 !item The address of the (!nolink [PFONTINFO]) structure is entered in the
    (!nolink [xFSL_PAR]) structure
 !item The font colour is set to black (one could also omit this, but
     normally one wants to write in black type on a white background)
!end_itemize

MNo further preparation is required, and now the actual call follows.
First the xFSL cookie is searched for and on success the font-selector
will be initialized by passing the xFSL_PAR structure. If this call
was successful ((!I)xhandle(!i) is greater or equal to zero), then the
font-selector is already on the screen. In the main loop one now waits
until the font-selector is terminated either with xFS_STOP or xFS_OK
by the user, or until an error occurs (other positive return values
are simply ignored here). With the call of xfsl_exit the font-selector
is removed from the screen once more and subsequently the return value
is evaluated.

That wasn't too complicated, was it? From here on you can now continue
experimenting with various parameters and flags.

!end_node

# ========================================================================
!begin_node xFSL Questions and Answers
(!B)How can I find out which features the font-selector offers?(!b)

Directly, this can be done for some features by using the function
xfsl_info. Indirectly, further features can be inquired for with the
(!I)(!nolink [control])(!i) field in the xFSL_PAR structure: After a successful xfsl_init
call the font-selector will clear those (!link [control-flags][The control-flags]) that it does
not understand.


(!B)How should my program behave when it realizes that the font-selector
does not support the desired feature?(!b)

If some kind of font-selector is (!nolink [installed]), then it also ought to be
used in any case. Depending on how important the missing feature is,
your program could look for alternatives (e.g. via the Font protocol)
or attempt to compensate for the missing feature.

Once again: The user wanted a font-selector, not an error-message!
If the missing feature can be compensated for only with difficulty,
then you should inform the user once(!) with a corresponding note,
but call up the font-selector nevertheless. Even if the selection can
then not be made with the desired convenience, it is still far less
frustrating for the user than not being able to select a font at all.

Some examples: If the popup is to be used to set the font for a given
program window, then if the popup is missing the font should be set
for the topped window of the program. If the font-selector does not
support the locking of size-changes, then the returned size should
simply be ignored and - if it differs from the desired size - the user
informed about this by a note.

Incidentally, one should not rely on the font-selector supporting the
same features the next time it is called! The font-selectors that work
with an overlay (XFSL.OVL) can be substituted at any time without a
Reset by re-copying the overlay.


(!B)What's all this 'mapping' about?(!b)
!label What's mapping?

Vector fonts generally contain more than the familiar 256 characters,
and furthermore they are not normally in the accustomed ASCII coding
(for example the space character may lie at position 0 instead of 32).
Therefore the pertinent characters of the font are 'mapped' to the
'normal' 256 characters, so that the space character lies as usual
in position 32, no matter what position it has within the font. This
is designated as 'ASCII mapping'.

The ASCII mapping is active by default, but due to this one cannot
access the characters that lie outside the ASCII character set. Hence
a second mapping, 'Direct mapping', is available. Here one has access
to (!I)all(!i) characters of a font. However, for this one also has to know
what type of font one is dealing with and how many characters the
font contains: Speedo fonts usually have 564 characters, TrueType
fonts can (theoretically) contain up to 65536 characters. One can get
this information after switching to Direct mapping with the (!nolink [VDI])
function vqt_fontinfo:

 int minADE, maxADE;

 vst_charmap(handle,0);
 vqt_fontinfo(handle,&minADE,&maxADE,dumarray,&dummy,dumarray);

In (!I)minADE(!i) one gets the smallest, in (!I)maxADE(!i) the largest valid
character index.

Direct mapping only has limited use for normal applications. Unlike
ASCII mapping which provides consistent mapping for all types of
fonts, one needs to know here exactly what kind of font one is dealing
with. Thus, for instance, the Speedo symbol fonts have a different
coding to the 'normal' Speedo fonts. This means that at position 64
of such a symbol font, say, one will not find the same character as
for a 'normal' Speedo font.

Other mappings than ASCII are therefore of no interest to the majority
of programs at present. But future GDOSes or equivalents may possibly
also offer other consistent mappings (e.g. Unicode or BICS), where one
can once more rely on the same character appearing always at a given
position (similar to ASCII mapping but also including positions higher
than 255).

(!B)Note:(!b) NVDI from NVDI 4 onwards is able to use Unicode mapping.

!end_node

# ========================================================================
!begin_node xFSL technical programming notes
The description of the xFSL interface in this text is effected in
Pure-C. In the following sections the data-types and specifics of
Pure-C are described in greater detail, so that xFSL calls succeed
in other programming languages and C-dialects as well.

!subsubtoc stg


# ------------------------------------------------------------------------
!begin_node Data-types

The following data-types are used in this (part of the) text:
!begin_quote
!begin_table [l|l]
      Name          !!  (!nolink [Size])
!hline
      int           !!  16-bit signed
      unsigned int  !!  16-bit unsigned
      long          !!  32-bit signed
      unsigned long !!  32-bit unsigned
!end_table
!end_quote

The data-type 'char' is an (ASCII) character and is used here only as
a pointer type, i.e. as a pointer to a C-string (series of characters
terminated with a NULL-byte).

!smallskip

!label union
(!U)Union(!u)

A union corresponds to a variable record in Pascal. It is a structure
whose individual elements lie 'on top of each other', i.e. occupy the
same block of memory. Which element is valid at a given time depends
on the context, or is left to the programmer.

(!B)Example:(!b) In the structure PFONTINFO a union `fsize' is used for the
size specification:
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Font size in points        */
 fix31 size31;  /* Font size in 1/65536 point */
};
!end_verbatim
!end_quote
The memory requirement of this union comprises four bytes, as the
type fix31 is four bytes long. One (!B)could(!b) now assign to the element
(!I)size31(!i) a size-specification in 1/65536 point and then read out the
value in whole points from the element (!I)size(!i) - but this is not to be
recommended, as in the conversion of (!nolink [fix31]) to points one should
always round off (see below).

!smallskip

!label Data-type fix31
(!U)(!nolink [fix31])(!u)

The data-type (!nolink [fix31]) is a fixed-point number, in which the upper
16 bits represent the signed pre-decimal point (whole number) portion,
and the lower 16 bits the unsigned decimal portion. It is used only
for the size specification and positioning of fonts, so that one can
obtain a precision of 1/65536 point with it.

In the conversion of (!nolink [fix31]) to points one must not forget rounding.
To quote from the NVDI guide:

(!B)One may never, (!I)never, ever(!i) just cut off the decimal part!(!b)

!end_node

# ------------------------------------------------------------------------
!begin_node xFSL parameter passing
The passing of parameters for all xFSL calls is done via the stack
according to C-convention. This means that at the call the parameter
lying furthest right is placed first on the stack, and the left-most
parameter at the end, i.e. when jumping to the font-selector, lies at
the top.

!end_node

# ------------------------------------------------------------------------
!begin_node Pure-C and 'cdecl'
!raw [stg] @alias "cdecl"
Pure-C normally passes the parameters to functions in registers. For
passing via the stack one must either use the keyword 'cdecl' (as in
the include file XFSL.H) or the compiler switch '-H' must be set.

The keyword 'cdecl' is a Pure-C-specific extension and so will issue
a warning with compiler switch '-A' (ANSI-conform) set.

!end_node
!end_node
!end_node

# ########################################################################
!begin_node xFSL revisions history
!raw [stg] @alias "xFSL History"
(!B)Revision 4(!b)
!begin_itemize
 !item Due to a small design error in the older revisions that limited
     the extendebility of the interface, Revision 4 is (!I)not(!i) compatible
     to older revisions. This should not be a problem in practice, as
     the font-selector will quit calls according to the old scheme
     with an error. The old Revision 3 will disappear in time.
 !item New parameters in the (!nolink [PFONTINFO]) structure:
       !begin_itemize
        !item Text background colour ((!I)backcol(!i))
        !item Text alignment ((!I)halign(!i) and (!I)valign(!i))
        !item Text rotation ((!I)rotation(!i))
        !item Specification of characters that the selected font (!B)has(!b) to
              contain ((!I)validtype(!i) and (!I)validchars(!i))
       !end_itemize
 !item The (!nolink [PFONTINFO]) structure is also filled for returns of (!nolink [xFS_STOP])
     with the values of the last font selected in the font-selector
 !item Coding of the font-flags changed (finer differentiation of the
     vector formats)
!end_itemize

!smallskip

(!B)Revision 3(!b)
!begin_itemize
 !item The first publicly available interfacen revision
!end_itemize

!smallskip

(!B)Older revisions(!b)
!begin_itemize
 !item Older revisions can be safely ignored, as these never appeared
     in a program available to the public at large
!end_itemize
!end_node


# ########################################################################
!begin_node UFSL/xFSL program overview
There follows an overview of all available font-selectors at this time
that dispose of a UFSL or an xFSL interface (or both).

This is followed by a list of programs that use a font-selector with
one or both of these interfaces.

!subtoc stg

!ifnset tos_hyp

Please send any supplements or corrections for this listing to Dirk
Haun (address see under 'Contact adresses').

!endif

# ========================================================================
!begin_node Font-selector overview
!raw [stg] @index "Font-selectors"

A short overview of the currently existig font-selectors:
!begin_description
!label UFSL
!item [UFSL] by Michael Th„nitz (!nl)
     This is the prototype of all external font-selectors. The last
     published version is 0.97, after which Michael unfortunately
     ceased its development. Thankfully however he has published the
     source texts.

!raw [stg] @index "FontSel"
!item [FontSel] by Holger Weets and Christoph Zwerschke (!nl)
     A small but also rather spartan font-selector from Holger Weets,
     which from Version 1.02 has been developed further by Christoph
     Zwerschke. As of the Version 1.02 the xFSL interface is supported
     as well.

!label xUFSL
!item [xUFSL] by Stefan Rogel (!nl)
     The xUFSL offers many additional features to the font-selectors
     named above. As these could not be accessed via the existing
     UFSL interface, Stefan has extended the interface. The design of
     the first version was, to put it carefully, 'controversial'.
     The last published Version: 1.05.
     The successor of the xUFSL is ...

!raw [stg] @index "HuGo!"
!item [HuGo] by Stefan Rogel (!nl)
     HuGo! is the successor of the xUFSL adapted to the xFSL interface
     (the UFSL interface is also still supported, but not the special
     extensions of the xUFSL to the UFSL interface). The name change
     was made to avoid confusion.

!raw [stg] @index "Calvino"
!item [Calvino] by Dirk Haun (!nl)
     Together with HuGo! the first font-selector with a (!nolink [xFSL interface]).
     Calvino too still supports the simple (!nolink [UFSL interface]).

!item [FONT_SEL und FONT_PAL] by Christian Grunenberg (!nl)
     These two programs work on a Drag&Drop basis, so they support
     neither the UFSL nor the (!nolink [xFSL interface]), but instead support the
     (!nolink [Font protocol]). FONT_SEL is a font-selector, FONT_PAL a font
     palette (with integrated font-selector).
!end_description

!end_node

# ========================================================================
!begin_node Programs that support a font-selector
!ignore_index
The following programs support an external font-selector (position at
16.08.1998, all specifications without guarantee):

!begin_table [l|l|l|c|c]
 Program       !! Category            !!  Author                   !! (!nolink [UFSL]) !! xFSL
!hline
 800XL-Deejay  !! Drive emulator      !! Kolja Koischwitz          !! +   !!
 APP_List      !! System utility      !! Ralf Zimmermann           !! +   !!
 Bellini       !! Graphics program    !! Ingo Dehne                !!     !!  +
 BibelST       !! Bible software      !! Reinhard Bartel           !!     !!  +
 Cat2Maus      !! MausTausch          !! Harald Sommerfeldt        !! +   !!
 Chatwin       !! Shell               !! Dirk Haun                 !! +W  !!  +W
 CyPress       !! Text processor      !! Rene Bartholomay          !!     !!  +W
 DB-Point      !! Newsreader          !! Michael Heng              !! +   !!
 Disk Cake     !! Disk utility        !! Christoph Zwerschke       !! +   !!  +
 Egale         !! File utility        !! David Reitter             !! +   !!  +
 Everest       !! Editor              !! Oliver Schmidt            !! +   !!
 Face Value    !! App.builder/Lib     !! Vegard Hofsoy             !! -   !!  +
 Floh          !! FFile list utility  !! Heiko Schaefer            !!     !!  +
 GEMAR         !! Backup              !! Steffen Engel             !! +   !!
 (!nolink [GEM])-Fontviewer!! Font displayer      !! Reinhard Bartel           !! +   !!  +
 (!nolink [GEM])-Plan      !! Spreadsheet         !! Reiner Rosin              !!     !!  +W
 Hitchcock     !! System utility      !! Thorsten Pohlmann         !!     !!  +
 IdeaList      !! ASCII print program !! Christoph Bartholme       !! +   !!
 Imagin        !! Function plotter    !! Reinhard Maier            !!     !!  +
 Jedi          !! GAL-Assembler       !! Ralf Zimmermann           !! +   !!
 Kandinsky     !! Drawing program     !! Ulrich Rossgoderer        !!     !!  +
 (!nolink [MagiC])!Conf    !! MagiC utility       !! Christian Ratsch          !!     !!  +
 MasterBrowse  !! File viewer         !! Michel Forget             !! +   !!
 MenuInfo      !! System utility      !! Dirk Hagedorn             !!     !!  +W
 Okami         !! Newsreader          !! Wolfram R”sler            !! +   !!
 Photo Line    !! Image processor     !! Gerhard Huber             !!     !!  +
 QED           !! Editor              !! Christian Felsch          !! +   !!
 RoadRunner    !! Car journey planner !! Andreas Schrell           !!     !!  +W
 SaugUtility   !! Ditto               !! Frank Rger               !! +   !!
 Schecks       !! Business software   !! Christian Lehmann         !!     !!  +
 ST-Guide      !! Hypertext           !! Holger Weets              !! +   !!
 STJ-Oberon    !! Programming language!! Stephan Junker            !! +   !!  +
 Texel         !! Spreadsheet         !! Thomas Much               !! +   !!  +
 UpToCASE      !! CASE tool           !! Michael Nolte             !! +   !!
 VESAL         !! Learning program    !! Peter Klasen              !! +   !!
 Zeig's mir    !! File viewer         !! Reiner Rosin              !! +   !!  +W
!end_table
(+: supported,   W: as window-dialog)

!smallskip

# Autoren, die nicht ber das MausNet erreichbar sind:
# !begin_quote
# !begin_verbatim
# Kolja Koischwitz: joust@cs.tu-berlin.de
# Michel Forget:    mforget@worldgate.edmonton.ab.ca
# Oliver Schmidt:   stu30109@mail.uni-kiel.d400.de
# Vegard Hofsoy:    vegard@origo.no
# !end_verbatim
# !end_quote

!end_node
!end_node

!newpage
# !begin_appendix
# ########################################################################

# !ifnset [FontProtokollSchonDa]
#  !include protokol\font.u
# !endif

# ########################################################################
!begin_node The UFSL interface
!raw [stg] @alias "UFSL interface"
!raw [stg] @autorefoff
For the sake of completeness, an English translation of the original
description by Michael Th„nitz of the original UFSL interface follows
here :

(!U)Programming interface:(!u)

UFSL is a font-selector box for the AUTO folder. If offers a simple
programming interface to the programmer via a cookie.

The cookie is called: 'UFSL'. (!nl)
The cookie returns a pointer to the following structure:

!begin_verbatim
 typedef struct
 {
  unsigned long  id;      /* UFSL ID (UFSL)       */
  unsigned int   version; /* Version (BCD format) */
  int dialtyp;            /* 0=Dialog, 1=Window   */
  int cdecl (*font_selinit)(void);
  int cdecl (*font_selinput)(
              int vdihandle,
              int dummy,
              char *text,    /* Custom text, max. 34 characters  */
              int ftype,     /* 1=Only monospaced fonts, 0=All   */
              int *fretid,   /* Set Font ID                      */
              int *fretsize  /* Set font size                    */
              );
  OBJECT *helpbutton;           /* Type: BOXTEXT                 */
  void cdecl (*helpfunc)(void); /* User-defined Help function    */

  /**** As of Version 0.91 ********************************************/
  char *examplestr;            /* Sample text for font display     */

  /**** As of Version 0.96 ********************************************/
  void cdecl (*msgfunc)(int event, int msgbuf[]);/* Redraw function */

  /**** As of Version 0.97 ********************************************/
  int cdecl (*fontsel_exinput)(
              int vdihandle,
              int ftype,     /* 1=Only monospaced fonts, 0=All     */
              char *text,    /* Custom text, masx. 34 characters   */
              int *fretid,   /* Set font ID                        */
              int *fretsize  /* Set font size                      */
              );
 } UFSL;
!end_verbatim

(!U)Call:(!u)

!begin_verbatim
UFSL *ufsl;
ufsl=(UFSL *)get_cookie('UFSL');
ufsl->helpfunc= my_helpfunc;   /* Help function, or NULL */
ufsl->msgfunc = my_msghandler; /* Redraw function, or NULL,
                                  respect (!I)dialtyp(!i)       */
ufsl->fontsel_input(vdihandle,"Please select a font",0,&id,&size);
(!U)or(!u)
ufsl->fontsel_input(vdihandle,NULL,0,&id,&size);
!end_verbatim

(!U)Return codes:(!u)

!begin_verbatim
 1 : All OK, values are valid
 0 : Cancel selected
-1 : Out of memory
-2 : Impermissible mutliple call
-3 : Font size could not be identified
-4 : Number of fonts must be greater than zero
!end_verbatim

(!U)Special functions:(!u)

!begin_verbatim
void cdecl (*helpfunc)(void); /* User-defined Help function      */
!end_verbatim

UFSL can call a user-defined Help function via the equally optional
HELP button. (!I)helpfunc(!i) requires no parameters and also has
no return value.

!begin_verbatim
void cdecl (*msgfunc)(int event, int msgbuf[]); /* Redraw function */
!end_verbatim

When using the UFSL as a window-dialog it is necessary to make a
Redraw function available. It sends any received events back to the
calling program, so that after moving the dialog one can restore the
background windows. (!I)msgfunc(!i) returns the result of evnt_multi
as the first parameter and the MsgPipe as the second parameter. A
return code is not required. The calling program must make available
all the required routines for window handling. wind_update(..._UPDATE)
is not set by UFSL, so this is the duty of the calling user program.
On principle (?) the memory protection of MultiTOS should be switched
off.

Basically one should give some thought whether all events should be
replied to appropriately. A WM_TOPPED, which tops other windows of
the program, should not be answered, since UFSL naturally can only be
applications modal as UFSL gyrates in its own form_do / evnt_multi.
!raw [stg] @autorefon

!end_node

# ########################################################################
!begin_node Notes for authors of other font-selectors
Authors of other font-selectors are invited to have their program join
the xFSL interface. In principle, every font-selector that uses a TSR
concept can be furnished with the xFSL interface.

To prevent misunderstandings: The overlay technique and the reentrancy
as offered by Calvino and HuGo! are not part of the actual interface
and hence need not be supported by other font-selectors. Indeed the
interface between the resident part ('shell') and the post-loaded
part ('overlay') is also standardized and therefore can be used by
other font-selectors as well. A description of this internal interface
is available on request, see '(!nolink [Contact]) addresses'.

Since a number of programs already support the old UFSL interface, it
seems advisable to make this interface available in new font-selectors
as well. However a quick look at these programs shows that they call
the font-selector almost exclusively as a modal dialog. Thus the
recommendation is to build in minimal UFSL support (as a modal dialog
only) and instead implement the xFSL interface as widely as possible,
since one can now expect that just those - now finally standardized -
extensions will be used by programs rather than the  (!nolink [UFSL interface]).

A font-selector should offer the following additional features if
possible:
!begin_itemize
!item (!nolink [Size]) changes possible (!nl)
     In particular this means that not just fixed sizes can be chosen,
     but with vector fonts inbetween sizes can be set as well.
!item (!nolink [fix31]) support (!nl)
     For some applications the setting of the font size in points is
     not enough, hence a setting in 1/65536 point should be possible.
!item User-popup (!nl)
     With an additional popup, the font-selector can be used more
     flexibly.
!item Drag&Drop support (!nl)
     Besides the 'traditional' call via the cookie, solutions on the
     Drag&Drop basis are coming more and more into fashion. If the
     font-selector already supports Drag&Drop natively, then it can
     be converted easily with a 'front end' program into a full-blown
     Drag&Drop selector.
!end_itemize

The following conventions were agreed for an xFSL font-selector:
!begin_itemize
 !item If the font-selector has a Closer, then clicking on this will be
     interpreted as 'Cancel', i.e. xFS_STOP will be returned. If the
     CC_CLOSER (!nolink [control])-flag is set, then the font current at the time
     will be returned nevertheless (in the PFONTINFO structure in
     xFSL_PAR).
 !item If the extended call (xfsl_init, xfsl_event and xfsl_exit) is not
     supported, then at least a dummy function for xfsl_init will be
     installed that always returns -32 ((!nolink [GEMDOS]) error-message EINVFN,
     invalid function number).

     But it is urgently requested that the extended call is offered,
     as this is the one used most frequently.
 !item It does not matter if the font-selector only appears as a modal
     dialog for the extended call. But with a set CC_WINDOW, xfsl_init
     should then return xFS_NO_WINDOW, so that the caller can adjust
     himself to this.
!end_itemize

!end_node

# ########################################################################

!ifnset tos_hyp

!begin_node Kontaktadressen
!raw [stg] @alias Kontaktadressen
!raw [stg] @index "Adressen"

Die xFSL--Schnittstelle wurde von Dirk Haun und Stefan Rogel unter
tat!-kr„ftiger Mithilfe von Reiner Rosin und einer Reihe fleižiger
Beta!-tester entwickelt.

Wenn Sie Fragen und/oder (!nolink [Anmerkungen]) zur xFSL--Schnittstelle haben, dann
wenden Sie sich doch einfach an

!begin_quote
 Dirk Haun                  (!nl)
 Johanniterstr. 3           (!nl)
 D-74177 Bad Friedrichshall (!nl)
 Germany

 E-Mail: Dirk Haun @ LB~~~bzw.~~~dirk_haun@lb.maus.de
!end_quote

oder an

!begin_quote
Stefan Rogel    (!nl)
K”hlerweg 1     (!nl)
D-67661 Kaiserslautern

e-mail: Stefan Rogel @ LU (MausNet)
!end_quote

!smallskip

Das Font--Protokoll stammt von

!begin_quote
Christian Grunenberg (!nl)
Traminerweg  5       (!nl)
D-71717 Beilstein
!end_quote

#   !end_appendix

!end_node

!endif

!end_node
#!end_node

!else

!begin_node xFSL-Schnittstelle
Sp„testens seit der Einfhrung von Vektorfonts erfreut sich das GDOS, das
jahrelang auf dem Atari ein Schattendasein fhrte, steigender
Be!-liebt!-heit. Immer mehr Programme bieten die M”glichkeit, fr die
Aus!-ga!-be (und teilweise auch fr die Eingabe) einen anderen Font als
den Systemfont zu verwenden.

Um nun einen Font ausw„hlen zu k”nnen, ben”tigt man einen Fontselektor.
Und damit nicht jeder Programmierer sein eigenes Sppchen kocht und im
Sinne einer einheitlichen Bedienung entstand der Wunsch nach einer
Systemerweiterung, die einen Fontselektor --- „hnlich wie einen
Fileselektor --- fr alle Programme zur Verfgung stellt.

Das erste derartige Programm war der UFSL von Michael Th„nitz. Er stellt
ber einen Cookie Routinen zum Aufruf eines Fontselektors zur Verfgung.
Diese Schnittstelle wird bereits von einer Reihe von Programmen verwendet
und es gibt auch bereits weitere Font!-selektoren, die ber diese
Schnittstelle aufgerufen werden k”nnen.

Zwar l„žt sich nun ber die UFSL--Schnittstelle ein Fontselektor
auf!-rufen, doch hat diese Schnittstelle bereits eine Reihe von --- zum
Teil inkompatiblen --- Žnderungen und Erweiterungen hinter sich. Daher
gehen die meisten Programme heute davon aus, daž sie nur die
ur!-sprng!-liche einfache (!nolink [UFSL-Schnittstelle]) zur Verfgung haben. Im
Endeffekt bleiben also die Erweiterungen ungenutzt und wenn in einem
Programm dann doch einmal ein etwas leistungsf„higerer Fontselektor
ben”tigt wird, dann geht man doch wieder dazu ber, extra fr das Programm
einen neuen Fontselektor zu schreiben. Etwas berspitzt formuliert wird
hier also die Idee eines externen Fontselektors ad absurdum gefhrt !..

Durch den ""Wildwuchs"" an der (!nolink [UFSL-Schnittstelle]) erschien es sinn!-voller,
einen klaren Trennstrich zu ziehen und eine komplett neue Schnittstelle
zu entwickeln, die dann auch ber einen neuen Cookie angeboten wird.

Dieser Text beschreibt diese neue Schnittstelle, ber die nicht nur
einfach ein Fontselektor aufgerufen, sondern auch in vielf„ltiger Weise
Einfluž auf diesen genommen werden kann.

!subtoc [all]

# ########################################################################
!begin_node Die xFSL--Schnittstelle

šber die xFSL--Schnittstelle hat der Aufrufer (d.h. das Programm, das den
Fontselektor aufruft) wesentlich mehr Einfluž auf den Fontselektor, sein
Verhalten und auf die zur Auswahl angebotenen Fonts.

Bei der Konzeption der neuen Schnittstelle wurde versucht, auf die
M”glichkeiten der verschiedenen Programmiersprachen Rcksicht zu neh!-men
(z.B. Vermeidung von Zeigern auf Funktionen) und gleichzeitig fr m”gliche
Erweiterungen der Schnittstelle gerstet zu sein.

Die Anpassung eines Programms an die xFSL--Schnittstelle sollte eine
Sache von wenigen Minuten sein, zumal Beispielaufrufe in
ver!-schie!-de!-nen Programmiersprachen mitgeliefert wer!-den. Die
Umsetzung spezieller Wnsche ist natrlich u.U. etwas aufwendiger, sollte
aber auch kein unl”sbares Problem darstellen.

Es folgt die Beschreibung des xFSL--Cookies sowie der verschiedenen
xFSL--Aufrufe und Parameter !..

!subtoc [all]

# ========================================================================
!begin_node Der xFSL--Cookie
!label xFSL-Cookie

Wenn ein Fontselektor installiert ist, der die xFSL--Schnittstelle
un!-ter!-sttzt, dann existiert ein Cookie ""(!V)xFSL(!v)"", dessen Wert
ein Zeiger auf die folgende Struktur ist:

!begin_quote
!begin_verbatim
typedef struct
{
 unsigned long xfsl;       /* Magic 'xFSL'              */
 unsigned int  revision;   /* Schnittstellen-Revision   */
 unsigned long product;    /* Kennung des Fontselektors */
 unsigned int  version;    /* Version des Fontselektors */
 xFSL_INPUT    xfsl_input; /* einfacher Aufruf          */
 xFSL_INIT     xfsl_init;  /* Init-Aufruf               */
 xFSL_EVENT    xfsl_event; /* Event-Aufruf              */
 xFSL_EXIT     xfsl_exit;  /* Exit-Aufruf               */
 xFSL_INFO     xfsl_info;  /* Info-Aufruf               */
} xFSL;
!end_verbatim
!end_quote

Die Komponenten der Struktur im einzelnen:
!begin_ilist [xfsl_input]
!item [(xfsl]
 Hier steht, nur zur Sicherheit, nochmals die ASCII--Zeichenfolge ""xFSL""
 (entspricht hexadezimal $7846534C).

!item [revision]
 Dies ist die Revisionsnummer der xFSL--Schnittstelle, sie enth„lt z.Z.
 den Wert 4. Sollte die Schnittstelle erweitert wer!-den, so werden dort
 entsprechend h”here Werte zu finden sein.

!item [product]
 Hier findet sich eine Kennung fr den tats„chlich in!-stal!-lier!-ten
 Fontselektor. Diese Angabe ist jedoch nur als zu!-s„tz!-liche Information
 gedacht und sollte von An!-wen!-dungs!-pro!-grammen, die den Fontselektor
 aufrufen wollen, (!I)nicht(!i) ausgewertet werden!

Bisher verwendete Kennungen:
!begin_table [l|l]
Kennung !! Fontselektor
!hline
CLVN !!   Calvino
FSEL !!   FontSel
HUGO !!   HuGo!
!end_table

 Die Kennung (wie auch die folgende Versionsnummer) wurde nur fr
 Programme eingefhrt, die eine Information ber den installierten
 Fontselektor ausgeben wollen (z.B. das Programm SysInfo).

!item [version]
 Die Versionsnummer des installierten Fontselektors als BCD--Zahl
 (z.B. hexadezimal $100 fr Version 1.00). Hier gelten sinn!-ge!-m„ž die
 (!nolink [Anmerkungen]) zum Feld ''(!I)product(!i)''.

!item [xfsl_input]
 Dies ist der Einsprungpunkt fr einen vereinfachten Auf!-ruf des
 Fontselektors. Der Fontselektor erscheint dann immer als modaler
 Dialog und die meisten zus„tzlichen Features der xFSL--Schnittstelle
 k”nnen nicht angesprochen werden.

!item [xfsl_init, xfsl_event, xfsl_exit]
 Diese drei Funktionen bilden zu!-sam!-men den erweiterten
 Fontselektor--Aufruf. Hierber k”nnen alle neuen Features angesprochen
 werden. Die Vorgehensweise entspricht dem Darstellen eines (!nolink [GEM])-Dialogs:
 !begin_enumerate
  !item Fontselektor darstellen ((!I)xfsl_init(!i))
  !item Eventbehandlung in einer Schleife, bis ""OK"" oder ""Abbruch""
        angew„hlt wurde ((!I)xfsl_event(!i))
  !item Fontselektor vom Bildschirm entfernen ((!I)xfsl_exit(!i)
 !end_enumerate

!item [xfsl_info]
 šber diese Aufruf k”nnen einige der Features des in!-stal!-lier!-ten
 Fontselektors abgefragt werden, z.B. Drag&Drop--Unter!-sttzung.
!end_ilist

!end_node


# ========================================================================
!begin_node Der vereinfachte Aufruf (xfsl_input)
!label xfsl_input
(!I)xfsl_input(!i) ist der Einsprungpunkt fr einen vereinfachten Aufruf.
Der Fontselektor kann darber nur als modaler Dialog aufgerufen werden.
Aužerdem kann eine šberschrift angegeben und eingeschr„nkt werden,
welche Arten von Fonts der Selektor zur Auswahl stellen soll.

!begin_quote
!begin_verbatim
int xfsl_input (int           vdihandle,
                unsigned int  fontflags,
                const char   *headline,
                int          *id,
                int          *size
               );
!end_verbatim
!end_quote

Die Parameter im einzelnen:
!begin_ilist [vdihandle~]
!item [vdihandle]
 Hier bergeben Sie das Handle einer von Ihrem Programm be!-reits
 ge”ffneten virtuellen VDI--Workstation (wenn Sie in Ihrem Programm einen
 Font einstellen wollen, mssen Sie ja ohnehin eine solche (!nolink [VDI])-Workstation
 ”ffnen). Der Fontselektor bernimmt dann den auf dieser Workstation gerade
 ein!-ge!-stell!-ten Font als ak!-tu!-ellen Font (voraus!-ge!-setzt,
 er wird durch die Fontflags ber!-haupt zur Auswahl gestellt).

 Statt eines gltigen Handles k”nnen Sie aber auch einfach eine Null
 bergeben, dann wird der Fontselektor den Font anzeigen, den Sie in
 den Parametern ''(!I)id(!i)'' und ''(!I)size(!i)'' ber!-ge!-ben.

 Wenn Sie ein (!nolink [VDI])--Workstation--Handle bergeben, wird der aus!-ge!-w„hlte
 Font auf dieser Workstation auch gleich ein!-ge!-stellt.

!item [fontflags]
 šber die Fontflags k”nnen Sie festlegen, welche Fonts ber!-haupt zur
 Auswahl gestellt werden.

!item [headline]
 Hier k”nnen Sie eine šberschrift angeben, die dann im Fontselektor
 erscheint. Fehlt die šberschrift (šbergabe von 0L), dann wird ein
 Defaulttext (""Fontauswahl"" o.„.) ein!-ge!-setzt.

!item [id]
 In dieser Variablen wird die ID des ausgew„hlten Zeichensatzes
 zurckgeliefert (natrlich nur, wenn auch wirklich ein Zeichensatz
 ausgew„hlt wurde). Dieser Zeichensatz kann nun direkt mit der
 VDI-Funktion (!I)vst_font()(!i) ein!-ge!-stellt wer!-den.

 Wenn Sie in ''(!I)vdihandle(!i)'' eine Null bergeben, wird der
 Fontselektor den in ''(!I)id(!i)'' an!-ge!-ge!-ben!-en Font anzeigen.

!item [size]
 In dieser Variablen wird die Gr”že des ausgew„hlten Fonts in Punkt
 zurckgegeben (auch nur, wenn wirklich ein neuer Zeichensatz ausgew„hlt
 wurde). Wenn es sich um einen Bitmapfont handelt, kann diese Gr”že
 mit der (!nolink [VDI])--Funktion vst_point eingestellt werden. Fr
 Vektorfonts sollte die Funktion vst_arbpt auf!-ge!-ru!-fen
 werden.

 Wenn Sie in ''(!I)vdihandle(!i)'' eine Null bergeben, wird der
 Fontselektor den in ''(!I)id(!i)'' angegebenen Font in der in
 ''(!I)size(!i)'' an!-ge!-ge!-ben!-en Gr”že anzeigen.
!end_ilist

!smallskip

(!U)Rckgaben(!u)

(!I)xfsl_input(!i) liefert eine negative Zahl zurck, wenn ein Fehler
auf!-ge!-tre!-ten ist. Eine 0 wird zurckgegeben, wenn ""Abbruch""
angew„hlt wur!-de. Wird eine 1 zurck geliefert, dann wur!-de ein neuer
Font ausgew„hlt.

Die Rckgabewerte sind fr alle xFSL--Funktionen gleich
und auf!-w„rts!-kom!-pa!-ti!-bel zu den Rckgabewerten des UFSL.
!end_node


# ========================================================================
!begin_node Der erweiterte Aufruf
Der erweiterte xFSL--Aufruf besteht aus drei einzelnen
Funktions!-auf!-rufen:
!begin_xlist [xfsl_event~]
!item [(!V)xfsl_init(!v)]
      Stellt den Fontselektor auf dem Bildschirm dar. Aužerdem werden hier
      die Parameter bergeben.
!item [(!V)xfsl_event(!v)]
      Diese Funktion wird solange immer wieder aufgerufen, bis im
      Fontselektor ein Font ausgew„hlt, oder ""Abbruch"" an!-ge!-w„hlt
      wurde.
!item [(!V)xfsl_exit(!v)]
      Entfernt den Fontselektor wieder vom Bildschirm.
!end_xlist

!smallskip

In C kann das dann beispielsweise so ausssehen:
!begin_quote
!begin_verbatim
xhandle = xfsl->xfsl_init (vdihandle, &xpar);
if (xhandle >= 0)
{
  do
  {
    ret = xfsl->xfsl_event (xhandle, 0L);
    if (ret == xFS_HELP)
      ...;  /* Hilfefunktion aufrufen */
    else if (ret == xFS_POPUP)
      ...;  /* Popup behandeln        */
    else if (ret == xFS_EVENT)
      ...;  /* AES-Event bearbeiten   */
  } while ((ret != xFS_OK) && (ret != xFS_STOP));
  xfsl->xfsl_exit (xhandle);
}
!end_verbatim
!end_quote

Diese ""Dreiteilung"" hat u.a. den Vorteil, daž zur Bearbeitung der
Ereignisse (Hilfe--Button, (!nolink [Popup]), (!nolink [AES])--Events) keine Zeiger auf
Funk!-tionen bergeben werden mssen (was in einigen Programmier!-sprachen
nur schwer zu realisieren ist). Auch l„žt sich die Schnittstelle so
leicht um weitere Ereignisse erweitern, falls dies einmal n”tig sein
sollte.


# ------------------------------------------------------------------------
!begin_node xfsl_init

Dieser Aufruf bringt nicht nur den Fontselektor auf den Bildschirm,
er bestimmt auch, welche Fonts angezeigt werden sollen, ob ein
User--(!nolink [Popup]) verwendet wird und einiges mehr.

!begin_quote
!begin_verbatim
int xsfl_init (int       vdihandle,
               xFSL_PAR *xpar
              );
!end_verbatim
!end_quote

Die beiden Parameter bedeuten:
!begin_xlist [vdihandle~]
!item [(!V)vdihandle(!v)]
 Hier bergeben Sie, wie schon beim vereinfachten Aufruf, das Handle
 einer von Ihrem Programm bereits ge”ffneten virtuellen VDI--Workstation
 oder einfach eine Null.

 Wenn Sie ein gltiges Workstation--Handle bergeben, wird der
 Fontselektor den auf dieser Workstation aktuellen Font bernehmen und
 anzeigen --- sofern er duch die Font!-flags (in der
 (!V)xFSL_PAR(!v)--Struk!-tur) berhaupt zur Auswahl gestellt wird. Ist
 dies nicht der Fall, wird der Fontselektor einen Font aus den zur
 Verfgung stehenden aus!-w„hlen und an!-zei!-gen.

 šbergeben Sie als Workstation--Handle eine Null, dann wird der Font
 aus der (!V)PFONTINFO(!v)--Struktur (auf die ein Zeiger in der
 (!V)xFSL_PAR(!v)--Struktur zeigt) ber!-nommen und angezeigt.

 Wenn Sie ein VDI--Workstation--Handle bergeben, wird der aus!-ge!-w„hlte
 Font auf dieser Workstation auch gleich eingestellt.

!item [(!V)xpar(!v)]
 Dies ist ein Zeiger (d.h. die Adresse) auf eine
 (!V)xFSL_PAR(!v)--Struktur, die alle weiteren Angaben fr den
 Fontselektor enth„lt.

 Wegen der Vielzahl der M”glichkeiten wurde dieser Struk!-tur ein eigener
 Abschnitt gewidmet.
!end_xlist

Fr die Returncodes der Funktion gilt wieder: Ein negativer
Rck!-ga!-be!-wert deutet auf einen Fehler hin. Positive Werte haben hier
eine et!-was abweichende Bedeutung: Eine 0 heižt, der Fontselektor wurde
(er!-folg!-reich) als modaler Dialog ge”ffnet. Andere positive Werte
ent!-sprechen dem Fensterhandle des ge”ffneten Fontselektors. Somit k”nnen
Sie das Fenster des Fontselektors beispielsweise bei einem AV--Server
anmelden.

Im Erfolgsfalle (Rckgabe gr”žer oder gleich 0) sollten Sie sich das
Handle in einer Variablen merken, da es fr die folgenden Aufrufe
((!V)xfsl_event(!v) und (!V)xfsl_exit(!v)) noch ben”tigt wird.

(!B)Hinweis:(!b) Wenn der Fontselektor als Fenster dargestellt werden
sollte, (!V)xfsl_init(!v) aber den Fehler (!V)xFS_NO_WINDOW(!v) liefert
(kein Fenster mehr frei), dann sollte m”glichst versucht werden, den
Fontselektor we!-nig!-stens als Dialog darzustellen (Kontrollflag
(!V)CC_WINDOW(!v) l”schen und nochmals (!V)xfsl_init(!v) aufrufen).

(!B)Merke:(!b) Der Anwender will einen Fontselektor, keine Fehlermeldung.

!end_node


# ------------------------------------------------------------------------
!begin_node xfsl_event

Wenn der Fontselektor initialisiert und auf den Bildschirm gebracht
wurde, bernimmt (!V)xfsl_event(!v) die Hauptarbeit.

!begin_quote
!begin_verbatim
int xfsl_event (int    xhandle,
                EVENT *event
               );
!end_verbatim
!end_quote

Die beiden Parameter bedeuten:
!begin_xlist [xhandle~]
!item [(!V)xhandle(!v)]
 Das Handle des Fontselektors, wie es von (!V)xfsl_init(!v) ge!-lie!-fert
 wurde.

!item [(!V)event(!v)]
 Zeiger auf eine (!V)EVENT(!v)--Struktur, wie sie von Pure C ver!-wen!-det
 wird. In dieser Struktur liefert der Fontselektor (!nolink [AES])--Events zu!-rck,
 die er nicht selbst bearbeiten konnte. Aužer!-dem k”n!-nen Sie ber die
 Eingabeparameter dem Fontselektor auch mit!-tei!-len, ber welche
 Ereignisse sie berhaupt un!-ter!-rich!-tet werden wollen.

 Der Zeiger kann aber auch einfach Null sein, wenn Sie keine (wei!-te!-ren)
 Events auswerten wollen. Soll der Fontselektor als Fenster!-dialog
 betrieben werden und der Aufrufer (d.h. Ihr Programm) hat noch weitere
 Fenster offen, dann mssen Sie aber zu!-min!-dest die Redraw--Meldungen
 auswerten!

 (!B)Beispiel:(!b) Wenn Sie in ''(!V)ev_mflags(!v)'' das Flag
 (!V)MU_MESAG(!v) setzen, wird der Fontselektor alle eintreffenden
 (!nolink [AES])--(!nolink [Nachrichten]), die er nicht selbst bearbeiten kann, an
 den Aufrufer zu!-rck!-lie!-fern.

 (!B)Hinweis:(!b) Es ist natrlich auch m”glich, Timer--Events zu
 be!-kommen. Diese sollten aber sparsam eingesetzt werden und nicht zu
 kurz sein, da der Fontselektor dazu jedesmal erst seine eigene
 Event--Schleife verlassen muž. 250 ms m”gen als --- unverbindliche ---
 un!-te!-re Grenze gelten.
!end_xlist

Die m”glichen Rckgabewerte von (!V)xfsl_event(!v):
!begin_xlist [xFS_POPUP~]
!item [(!V)xFS_STOP(!v)]
 Im Fontselektor wurde der Button ""Abbruch"" oder (so vor!-han!-den) der
 Closer des Fensterdialogs angew„hlt.

 Wenn das Kontrollflag (!V)CC_CLOSER(!v) gesetzt ist und der Closer
 an!-ge!-klickt wurde, enth„lt die (!V)PFONTINFO(!v)--Struktur, auf die der
 Zeiger in der (!V)xFSL_PAR(!v)--Struktur zeigt, aber trotzdem Angaben
 darber, welcher Font zuletzt im Fontselektor angew„hlt worden war.
 Anders w„re diese In!-for!-ma!-ti!-on sonst ja nicht zu erhalten.

!item [(!V)xFS_OK(!v)]
 Es wurde ein Font ausgew„hlt und ""OK"" angew„hlt.
 Welcher Font ausgew„hlt wurde, beschreibt die (!V)PFONTINFO(!v)--Struktur,
 auf die der Zeiger in der (!V)xFSL_PAR(!v)--Struktur zeigt. Wenn bei
 (!V)xfsl_init(!v) ein gltiges (!nolink [VDI])--Handle bergeben wurde, dann wird der
 ausgew„hlte Font auch gleich auf dieser VDI--Workstation eingestellt.

!item [(!V)xFS_HELP(!v)]
 Der Hilfe--Button wurde angew„hlt (kann natrlich nur auf!-tre!-ten, wenn
 Sie ihn haben einblenden lassen). Es liegt nun am Aufrufer, wie er darauf
 reagiert. Im Normalfall wird man wohl eine Hilfe geben, z.B. indem man
 eine Hilfs!-seite anzeigt oder anzeigen l„žt.

!item [(!V)xFS_EVENT(!v)]
 Ein (!nolink [AES])--Event ist aufgetreten, den der Fontselektor nicht bearbeiten
 konnte (z.B. eine Redraw--Meldung fr ein an!-de!-res Fenster). Welcher
 Event es genau war, k”nnen Sie dem Feld ''(!V)ev_mwich(!v)'' der
 (!V)EVENT(!v)--Struktur entnehmen.

 Accessories sollten bei Eintreffen der Nachricht (!V)AC_CLOSE(!v) den
 Aufruf von (!V)xfsl_exit(!v) nicht vergessen! Gleiches gilt analog fr
 die Nachricht (!V)AP_TERM(!v).

!item [(!V)xFS_POPUP(!v)]
 Am User--(!nolink [Popup]) (sofern vorhanden) wurde ein Ver„nderung vor!-ge!-nommen.
 Bei dem (!nolink [Popup])--Eintrag, der ge„ndert wurde, ist im Element
 ''(!V)fontflags(!v)'' das Bit (!V)FF_CHANGED(!v) gesetzt. Der
 (!nolink [Popup])--Eintrag, der jetzt angew„hlt wurde und bei Rckkehr in den
 Fontselektor (beim n„chsten (!V)xfsl_event(!v)--Aufruf) der aktuelle des
 Popups sein wird, steht im Element ''(!V)sel_entry(!v)''.

 Sie haben jetzt noch die M”glichkeit, Žnderungen an den (!nolink [Popup])--Eintr„gen
 vorzunehmen, beispielsweise die Fontflags zu „ndern oder den ge„nderten
 Font in alle anderen (!nolink [Popup])-Eintr„ge zu ber!-nehmen (auf diese Weise ist
 es auch m”g!-lich, das (!nolink [Popup]) fr eine andere Information zu ver!-wen!-den,
 die mit den ausgew„hlten Fonts nichts zu tun hat).
 Die Texte und die Anzahl der (!nolink [Popup])-Eintr„ge drfen aber nicht ver„ndert
 werden!

!item [andere Werte:]
 Andere positive Werte sollten ignoriert werden. Es ist m”glich, daž die
 Schnittstelle um weitere Rckgabewerte (Er!-eig!-nis!-se) erweitert wird.

 Negative Werte zeigen einen Fehler an, der Fontselektor soll!-te dann
 abgebrochen werden. Dazu muž aber unbedingt noch (!V)xfsl_exit(!v)
 aufgerufen werden!
!end_xlist

!end_node

# ------------------------------------------------------------------------
!begin_node xfsl_exit

Mit dem (!V)xfsl_exit(!v)--Aufruf wird der Fontselektor wieder vom
Bildschirm entfernt:

!begin_quote
!begin_verbatim
void xfsl_exit (int xhandle);
!end_verbatim
!end_quote

Dabei ist ''(!V)xhandle(!v)'' wieder das Handle des Fontselektors, wie es
von (!V)xfsl_init(!v) geliefert wurde.

(!V)xfsl_exit(!v) muž immer dann aufgerufen werden, wenn die Behandlung des
Fontselektors beendet werden soll. Sei es dadurch, daž ein Font
aus!-ge!-w„hlt oder ""Abbruch"" angew„hlt wurde, oder daž
(!V)xfsl_event(!v) einen Feh!-ler meldete. Wenn schon der
(!V)(!nolink [xfsl_init])(!v)--Aufruf fehlgeschlagen ist, darf (!V)xfsl_exit(!v) nicht
aufgerufen werden (logisch, da man ja auch kein gl!-tiges Handle hat).

Der Aufruf von (!V)xfsl_exit(!v) sollte auch bei Eintreffen der
(!nolink [Nachrichten]) (!V)AC_CLOSE(!v) und (!V)AP_TERM(!v) nicht vergessen werden!

!end_node

# ========================================================================
!begin_node Der Info--Aufruf (xfsl_info)
!label xfsl_info

šber diesen Aufruf k”nnen einige der Features des installierten
Fontselektors abgefragt werden:

!begin_quote
!begin_verbatim
long xfsl_info (void);
!end_verbatim
!end_quote

Wenn der Rckgabewert positiv ist, dann stehen die folgenden Flags fr
vorhandene Features (negative Rckgabewerte sind, wie blich,
Fehlermeldungen):

!raw [stg] @alabel "XF_SIZE" "XF_COLOR" "XF_ATTR" "XF_WIDTH" "XF_KERN" "XF_SKEW"
!raw [stg] @alabel "XF_ALIGN" "XF_ROTATION" "XF_FIX31" "XF_POPUP" "XF_DRAGDROP"
!raw [stg] @alabel "XF_MAPPING"
!begin_table [l|l|l]
Name         !! Wert  !! Bedeutung
!hline
XF_SIZE     !! 0x0001 !! Gr”žen„nderung m”glich
XF_COLOR    !! 0x0002 !! Farb„nderung m”glich
XF_ATTR     !! 0x0004 !! Attribut„nderung m”glich
XF_WIDTH    !! 0x0008 !! Breiten„nderung m”glich
XF_KERN     !! 0x0010 !! Kerning„nderung m”glich
XF_SKEW     !! 0x0020 !! Neigungs„nderung m”glich
XF_ALIGN    !! 0x0040 !! Žnderung der Ausrichtung m”glich
XF_ROTATION !! 0x0080 !! Textrotation m”glich
XF_FIX31    !! 0x0100 !! fix31-Untersttzung
XF_POPUP    !! 0x0200 !! Popup-Untersttzung
XF_DRAGDROP !! 0x0400 !! Drag&Drop-Untersttzung
XF_MAPPING  !! 0x0800 !! beherrscht Mapping
!end_table

Weitere Features des Fontselektors lassen sich indirekt ber das Element
''(!V)(!nolink [control])(!v)'' der (!V)xFSL_PAR(!v)--Struktur abfragen: Bei einem
er!-folg!-reichen (!V)xfsl_init(!v)--Aufruf werden diejenigen
Kontrollflags ge!-l”scht, die der Fontselektor nicht kennt.

!end_node

# ========================================================================
!begin_node Die VDI--Workstation

Bei den Aufrufen (!V)xfsl_input(!v) und (!V)xfsl_init(!v) kann jeweils
das Handle einer vom Aufrufer bereits ge”ffneten virtuellen
VDI--Workstation bergeben werden. Davon, ob man tats„chlich ein Handle
einer Workstation oder einfach eine Null bergibt, h„ngt das weitere
Verhalten des Fontselektors ab:

šbergibt man ein gltiges Handle, so wird der Fontselektor versuchen, den
auf der entsprechenden Workstation gerade aktuellen Font zu er!-mitteln
und diesen dann --- sofern er zu den bergebenen Fontflags pažt --- auch
einstellen und zur Auswahl anbieten. Pažt der aktuelle Font nicht zu den
Fontflags (wenn z.B. nur Vektorfonts angeboten werden sollen, der aktuelle
Font aber ein Bitmapfont ist), so wird der Fontselektor einen Font aus
den tats„chlich angebotenen ausw„hlen und als aktuellen Font pr„sentieren.

W„hlt der Anwender nun einen Font aus und beendet den Fontselektor mit
""OK"", so wird dieser Font auch gleich auf der bergebenen Workstation
eingestellt, so daž das aufrufende Programm dies nicht mehr bernehmen
muž.

Dabei gilt es zu beachten, daž der Fontselektor ebenfalls eine eigene
(!nolink [VDI])--Workstation ”ffnet und diese intern und zur Auswahl der Fonts
verwendet. U.a. wird er fr diese Workstation auch (!V)vst_load_fonts()(!v)
aufrufen (sofern ein GDOS installiert ist). Dies kann zu unerwarteten
Resultaten fhren, wenn auf der bergebenen Workstation noch kein
(!V)(!nolink [vst_load_fonts])()(!v) aufgerufen wurde und der Anwender im Fontselektor
einen Font ausw„hlt, der erst nach einem (!V)(!nolink [vst_load_fonts])()(!v)--Aufruf
zur Verfgung steht!

!smallskip

Statt eines Workstation--Handles kann man aber auch einfach eine Null
bergeben. Der Fontselektor wird den aktuellen Font dann aus den
bergebenen Parametern (beim (!V)(!nolink [xfsl_input])(!v)--Aufruf) bzw. aus der
(!V)xFSL_PAR(!v)--Struktur (beim (!V)(!nolink [xfsl_init])(!v)--Aufruf) ermitteln.

Der ausgew„hlte Font wird dann (logischerweise) auch nur in den Parametern
bzw. der (!V)(!nolink [xFSL_PAR])(!v)--Struktur zurckgegeben und der Aufrufer muž ihn
dann selbst einstellen.

!end_node


# ========================================================================
!begin_node Die xFSL_PAR-Struktur
!label xFSL_PAR
šber diese Struktur haben Sie weitgehenden Einfluž auf das Verhalten des
Fontselektors und die Art der dargestellten Fonts. Daher f„llt die
Beschreibung der M”glichkeiten auch etwas l„nger aus !..

!begin_quote
!begin_verbatim
typedef struct
{
 int            par_size;    /* Gr”že der xFSL_PAR-Struktur   */
 int            pfi_size;    /* Gr”že der PFONTINFO-Struktur  */
 unsigned long  control;     /* Kontrollflags                 */
 const char    *headline;    /* šberschrift oder 0L           */
 const char    *example;     /* Beispieltext oder 0L          */
 const char    *helptext;    /* Text des Hilfe-Buttons od. 0L */
 PFONTINFO     *font;        /* Zeiger auf Fontinfo-Struktur  */
 unsigned int   fontflags;   /* erlaubte Fontarten            */
 const char    *poptext;     /* Text vor dem Popup oder 0L    */
 int            num_entries; /* Anzahl der Eintr„ge (0..n)    */
 int            sel_entry;   /* Selektierter Eintrag (0..n-1) */
 xFSL_PENTRY   *popup;       /* Zeiger auf ein Popup oder 0L  */
 char          *helpinfo;    /* Zeiger auf Hilfedatei/-seite  */
} xFSL_PAR;
!end_verbatim
!end_quote

Trotz der Vielzahl der Eintr„ge ist eigentlich alles ganz einfach, zumal
Sie Felder, die Sie nicht ben”tigen oder deren Bedeutung Ihnen noch nicht
klar ist, einfach mit Null ausfllen k”nnen, worauf der Fontselektor dann
sinnvolle Defaultwerte annehmen wird.

Die Felder im einzelnen:
!begin_xlist [fontflags~]
!item [(!V)par_size(!v)]
 Dieses Feld darf nicht auf Null gesetzt werden, hier wird die Gr”že der
 (!V)xFSL_PAR(!v)--Struktur in Bytes eingetragen, weshalb man in C einfach
 schreiben kann
!begin_quote
!begin_verbatim
xpar.par_size=sizeof(xFSL_PAR);
!end_verbatim
!end_quote
 Die Gr”že der Struktur betr„gt z.Z. 42 Bytes. Sollte die Struktur
 erweitert werden, kann der Fontselektor an der Gr”ženangabe er!-ken!-nen,
 ob er es mit einer neuen oder einer alten Struktur zu tun hat.

!item [(!V)pfi_size(!v)]
 Auch dieses Feld darf nicht Null sein, hier muž die Gr”že der
 (!V)(!nolink [PFONTINFO])(!v)--Struktur eingetragen werden, also
!begin_quote
!begin_verbatim
xpar.pfi_size=sizeof(PFONTINFO);
!end_verbatim
!end_quote
 Die aktuelle Gr”že der (!V)PFONTINFO(!v)--Struktur betr„gt 38 Bytes
 und k”nnte ebenfalls in Zukunft erweitert werden.

!item [(!V)(!nolink [control])(!v)]
 Dies sind die sogenannten Kontrollflags, ber die das Ver!-hal!-ten des
 Fontselektors beeinflužt werden kann (z.B. ob er als Fenster oder als
 Dialog erscheinen soll).

 Diesen Flags wurde ein eigener Abschnitt gewidmet.

!item [(!V)headline(!v)]
 Dies ist, wie schon vom einfachen Aufruf her bekannt, ein Zeiger auf eine
 šberschrift fr den Fontselektor. Fehlt diese (d.h. ''(!V)headline(!v)''
 enth„lt Null), dann wird der Fontselektor eine Default--šberschrift
 einsetzen.

 Die L„nge der šberschrift sollte sich in dem noch vom UFSL
 vor!-ge!-ge!-be!-nen Rahmen (34 Zeichen) bewegen, der Fontselektor wird
 l„n!-gere šberschriften aber ggfs. krzen.

!item [(!V)example(!v)]
 Ein Zeiger auf einen Beispieltext. Der Fontselektor zeigt fr den jeweils
 eingestellten Font ein Schriftbeispiel an, dessen Text hiermit vorgegeben
 werden kann. Fehlt dieser Text (d.h. ''(!V)example(!v)'' enth„lt Null),
 wird der Fontselektor einen Defaulttext anzeigen (z.B. den Namen des
 jeweiligen Zeichensatzes).

!item [(!V)helptext(!v)]
 Dies ist der Text fr einen Button, der links unten im Fontselektor
 eingeblendet werden kann. Im Normalfall wird man dort einen Button mit
 der Aufschrift ""Hilfe"" oder ""Help"" einblenden wollen, um dem Anwender
 die Funktion des Fontselektors zu er!-kl„!-ren, und wofr der ausgew„hlte
 Font verwendet wird.

 Fehlt dieser Text (d.h. ''(!V)helptext(!v)'' enth„lt Null), wird auch
 kein Hilfe-Button eingeblendet. Dann wird (!V)xfsl_event(!v) auch nicht
 den Rckgabewert (!V)xFS_HELP(!v) liefern.

 Man sollte einen kurzen Text w„hlen (etwa 8 Zeichen), der Fontselektor
 wird l„ngere Texte aber ggfs. krzen.

!item [(!V)font(!v)]
 Dies ist ein Zeiger auf eine Struktur ((!V)PFONTINFO(!v)), die einen Font
 beschreibt. Die Struktur wird sowohl zur šber!-ga!-be von Werten an den
 Fontselektor als auch zur Rckgabe des ausgew„hlten Fonts verwendet.

 Auch dieser Struktur ist ein eigener Abschnitt gewidmet.

!item [(!V)fontflags(!v)]
 Dies sind wieder die vom einfachen Aufruf bekannten Font!-flags, mit
 denen Sie die zur Auswahl gestellten Fonts beeinflužen k”nnen.

!item [(!V)poptext(!v), (!V)num_entries(!v), (!V)sel_entry(!v), (!V)popup(!v):]
 Mit diesen vier Parametern k”nnen Sie ein zus„tzliches (!nolink [Popup]) in den
 Fontselektor einblenden lassen. Wegen der vielf„ltigen M”glichkeiten
 gibt's dafr auch wieder einen eigenen Abschnitt.

 Wollen Sie kein (!nolink [Popup]), so setzen Sie diese vier Werte einfach auf Null.

!item [(!V)helpinfo(!v)]
 Dies ist ein reiner Ausgabeparameter: Wenn der Hilfe--Button angew„hlt
 wurde (sofern vorhanden, siehe ''(!V)help!-text(!v)''), dann steht hier ein
 Zeiger auf einen Dateinamen einer Hilfedatei und den Namen einer Seite,
 die angezeigt werden kann. Der Dateiname wird ohne Pfad und Extension
 angegeben, der Seitenname folgt direkt dahinter, durch ein Komma getrennt.
 !begin_quote
  (!B)Der String darf nur gelesen, aber nicht ver!-„ndert werden!(!b)
 !end_quote
 Wenn Sie bei (!V)xFS_HELP(!v) nicht selbst eine Hilfe anzeigen wollen,
 dann k”nnen Sie mit diesen Informationen ein Hilfesystem (z.B. ST--Guide)
 aufrufen.

 (!B)Beispiel:(!b) (!V)xfsl_event(!v) gibt (!V)xFS_HELP(!v) zurck, in
 ''(!V)helpinfo(!v)'' findet sich ein Zeiger auf den String
!begin_quote
!begin_verbatim
toll,Der tollste Fontselektor aller Zeiten
!end_verbatim
!end_quote
 Daraus l„žt sich dann folgender Aufruf fr ST-Guide erstellen:
!begin_quote
!begin_verbatim
*:\toll.hyp Der tollste Fontselektor aller Zeiten
!end_verbatim
!end_quote
 Man h„ngt also an den Dateinamen die Extension fr das jeweilige
 Hilfesystem an und bergibt den Teil nach dem ersten Komma als Seitenname.
!end_xlist

!smallskip

Um es nochmals zu betonen: Felder, die sie nicht ben”tigen oder noch nicht
verstehen, k”nnen Sie zun„chst einfach auf Null setzen. Aus!-nahmen sind
nur
!begin_itemize
 !item ''(!V)par_size(!v)'', die Gr”že der (!V)xFSL_PAR(!v)--Struktur selbst
 !item ''(!V)pfi_size(!v)'', die Gr”že der (!V)PFONTINFO(!v)--Struktur
 !item ''(!V)font(!v)'', der Zeiger auf die (!V)(!nolink [PFONTINFO])(!v)--Struktur
!end_itemize

!end_node

# ------------------------------------------------------------------------
!begin_node Die Kontrollflags

šber die Kontrollflags kann das Verhalten des Fontselektors be!-ein!-flužt
werden.

!raw [stg] @alabel "CC_WINDOW" "CC_FIX31" "CC_NOSIZE" "CC_NOCOLOR" "CC_NOATTR"
!raw [stg] @alabel "CC_NOWIDTH" "CC_NOKERN" "CC_NOSKEW" "CC_NOALIGN" "CC_NOROTATION"
!raw [stg] @alabel "CC_DFLTSIZE" "CC_INVSTYLE"
!begin_table [l|r|l]
Name          !! Wert   !!  Bedeutung
!hline
CC_WINDOW     !! 0x0001 !! Fontselektor als Fenster
CC_APPMODAL   !! 0x0002 !! Fontselektor ist applikationsmodal
CC_FIX31      !! 0x0004 !! alle Gr”ženangaben in 1/65536 Punkt
CC_FAKESTYLE  !! 0x0008 !! Schnitte simulieren (nur Bitmapfonts)
CC_CLOSER     !! 0x0010 !! Fenster mit Closer, kein OK-Button
CC_NOSIZE     !! 0x0100 !! Gr”že nicht „ndern
CC_NOCOLOR    !! 0x0200 !! Farbe nicht „ndern
CC_NOATTR     !! 0x0400 !! Attribute nicht „ndern
CC_NOWIDTH    !! 0x0800 !! Breite nicht „ndern
CC_NOKERN     !! 0x1000 !! Kerning nicht „ndern
CC_NOSKEW     !! 0x2000 !! Skewing nicht „ndern
CC_NOALIGN    !! 0x4000 !! Ausrichtung nicht „ndern
CC_NOROTATION !! 0x8000 !! Textrotation nicht „ndern
CC_DFLTSIZE   !! 0x10000 !! Schriftgr”že "Default"
CC_INVSTYLE   !! 0x20000 !! Attribut "Invers"
!end_table
Die Funktion der einzelnen Flags sollte sich schon aus den Namen und den
Kurzbeschreibungen ergeben. Hier noch einige (!nolink [Anmerkungen]):
!begin_itemize
!raw [stg] @alabel "CC_APPMODAL"
!item (!V)CC_APPMODAL(!v) (!nl)
 ""Applikationsmodal"" heižt, daž das Programm in einen Modus ver!-setzt
 wird, in dem nur noch der Fontselektor bearbeitet wer!-den kann. Im
 wesentlichen bedeutet das, daž der Fontselektor alle
 (!V)WM_TOPPED(!v)--Nachrichten fr andere Fenster des aufrufenden
 Programms abf„ngt und (!I)nicht(!i) weiterleitet, sondern sich
 statt!-dessen selbst zum obersten Fenster macht. Damit soll dem Anwender
 si!-gna!-lisiert wer!-den, daž er zuerst den Fontselektor bearbeiten soll,
 bevor er eine andere Aktion im Programm aus!-l”sen kann.

 Der Aufrufer sollte in diesem Modus natrlich darauf verzichten, eigene
 Fenster selbst mit (!V)wind_set(WF_TOP)(!v) zum obersten Fenster zu
 machen.

!raw [stg] @alabel "CC_FAKESTYLE"
!item (!V)CC_FAKESTYLE(!v) (!nl)
 Dies ist eine Spezialit„t, die z.Z. nur Calvino anbietet: Bei denjenigen
 Bitmapfonts, bei denen keine leichten, kursiven bzw. fetten Schnitte
 vorliegen, werden die jeweils fehlenden Schnitte mit der VDI--Funktion
 (!V)vst_effects()(!v) simuliert.

!raw [stg] @alabel "CC_CLOSER"
!item (!V)CC_CLOSER(!v) (!nl)
 Wenn dieses Flag und (!V)CC_WINDOW(!v) gesetzt sind, wird der Fontselektor mit
 einem Closer versehen, w„hrend der OK-- und der Abbruch--Button versteckt
 werden. Gedacht ist dies fr die F„lle, in denen der Fontselektor als
 reiner Drag&Drop--Selektor eingesetzt werden soll.

!item (!V)CC_NO...(!v) (!nl)
 šber diese Flags kann bestimmt werden, welche Einstellungen nicht
 ver„ndert werden sollen. Beispielsweise k”nnte ein Programm verhindern
 wollen, daž die Gr”že eines Zeichensatzes ge!-„n!-dert wird, w„hrend eine
 Žnderung des Fonts selbst erm”glicht werden soll. Dann muž der Aufrufer
 nur das Flag (!V)CC_NOSIZE(!v) setzen.

 Beachten Sie aber, daž Sie trotz gesetztem (!V)CC_NO...(!v)--Flag immer
 einen gltigen Wert bergeben mssen. Die Bedeutung dieser Flags ist
 also, daž die vorgegebenen Werte nicht ver„ndert werden k”nnen und nicht,
 daž die Werte nicht von Interesse sind.
!end_itemize

(!B)Bitte beachten:(!b) Nicht alle Fontselektoren untersttzen auch alle
Kontrollflags! Wenn ein Fontselektor ein Flag nicht untersttzt, so wird
er es einfach ignorieren. Bei einem erfolgreichen(!)
(!V)xfsl_init(!v)-Aufruf wird der Fontselektor diejenigen Flags im Element
''(!V)(!nolink [control])(!v)'' der (!V)xFSL_PAR(!v)-Struktur l”schen, die er nicht
versteht.

!end_node

# ------------------------------------------------------------------------
!begin_node Die PFONTINFO-Struktur
!label PFONTINFO
Diese Struktur beschreibt einen Font. Sie enth„lt nach dem Aufruf des
Fontselektors den ausgew„hlten Font. Zudem werden diese Angaben vom
Fontselektor schon beim Aufruf ausgewertet (und der so beschriebene Font
angezeigt), wenn als (!nolink [VDI])--Handle eine Null bergeben wird.
!begin_quote
!begin_verbatim
typedef struct
{
 int          fontid;     /* ID des Fonts                  */
 int          fonttype;   /* Typ des Fonts                 */
 char        *fontname;   /* Name des Fonts                */
 union fsize  fontsize;   /* Fontgr”že in pt oder fix31    */
 union fsize  fontwidth;  /* Breite in pt oder fix31       */
 char         trackkern;  /* Track-Kerning                 */
 char         pairkern;   /* Paar-Kerning                  */
 int          fontattr;   /* Attribute                     */
 int          fontskew;   /* Neigung                       */
 int          fontcol;    /* Farbe                         */
 int          backcol;    /* Text-Hintergrundfarbe         */
 int          halign;     /* horizontale Textausrichtung   */
 int          valign;     /* vertikale Textausrichtung     */
 int          rotation;   /* Textrotation in 1/10 Grad     */
 int          validtype;  /* Typ (V_CHAR_...) oder Mapping */
 int         *validchars; /* ben”tigte Zeichen oder 0L     */
} PFONTINFO;
!end_verbatim
!end_quote

Die Elemente im einzelnen:
!begin_xlist [fontwidth~]
!item [(!V)fontid(!v)]
 Die ID des Fonts, wie sie auch von der VDI--Funktion (!V)vqt_name()(!v)
 zurckgegegeben wird. Die Font--ID ist eine Zahl ungleich Null (kann also
 auch negativ sein).

!label BITMAP_FONT
!label SPEEDO_FONT
!label TT_FONT
!label PFB_FONT
!item [(!V)fonttype(!v)]
 Der Typ des Fonts, wie er ab Speedo 5 bzw. NVDI 3 ver!-wen!-det wird:
!label Fonttyp
!begin_table [l|l|l]
 Name        !! Wert !!   Fontart
!hline
 BITMAP_FONT !! 0x0001 !! Pixel
 SPEEDO_FONT !! 0x0002 !! Speedo
 TT_FONT     !! 0x0004 !! TrueType
 PFB_FONT    !! 0x0008 !! Type 1 (Postscript)
!end_table
 Diese Angaben sind z.Z. nur zur Information, aber ohne Bedeutung fr
 den Fontselektor. Allerdings wird es knf!-tig m”glich sein, einen Font
 nicht nur anhand seiner ID, sondern auch anhand seines Namens zu setzen,
 wobei dann noch zus„tzlich der Fonttyp ben”tigt wird.

 Der Fonttyp ist aber auch von Interesse, wenn man die Gr”že des Fonts
 „ndern will: Bei Bitmapfonts geschieht dies mit der (!nolink [VDI])--Funktion
 (!V)vst_point()(!v), bei allen anderen Typen (Vektorfonts) mit der
 Funktion (!V)vst_arbpt()(!v).
!item [(!V)fontname(!v)]
 Der Name des Fonts, wie er von (!V)vqt_name()(!v) geliefert wurde
 (m”glicherweise wurden mehrfache Leerzeichen entfernt).

 Der Aufrufer muž selbst gengend Platz fr den Fontnamen zur Ver!-fgung
 stellen, also fr 32 Zeichen und ein Null!-byte! Wenn Sie den Fontnamen
 nicht ben”tigen, k”nnen Sie den Zeiger auch einfach auf Null setzen.

!item [(!V)fontsize(!v)]
 Die Gr”že des Fonts in Punkt (pt) oder 1/65536 Punkt
 (Typ ""(!V)(!nolink [fix31])(!v)""):
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Fontgr”že in Punkt         */
 fix31 size31;  /* Fontgr”že in 1/65536 Punkt */
};
!end_verbatim
!end_quote
 Welche der beiden Angaben gltig ist, wird (!nolink [global]) ber das
 Kon!-troll!-flag (!V)CC_FIX31(!v) geregelt.

!item [(!V)fontwidth(!v)]
 Breite des Fonts in Punkt (pt) oder 1/65536 Punkt
 (Typ ""(!V)(!nolink [fix31])(!v)""):
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Fontgr”že in Punkt         */
 fix31 size31;  /* Fontgr”že in 1/65536 Punkt */
};
!end_verbatim
!end_quote
 Welche der beiden Angaben gltig ist, wird (!nolink [global]) ber das
 Kon!-troll!-flag (!V)CC_FIX31(!v) geregelt.

 Die Breite kann mit den VDI--Funktionen (!V)vst_width()(!v) in Punkt und
 mit (!V)vst_setsize()(!v) in (!V)fix31(!v) eingestellt werden.

!label Kerning
!item [trackkern]
 Dieser Parameter gibt die Art des Track--Kernings fr (!V)vst_kern()(!v)
 an. Gltige Werte sind:

!begin_table [c|l]
 Wert !! (!nolink [Kerning])
!hline
   0 !! kein Kerning
   1 !! normales (!nolink [Kerning])
   2 !! enges (!nolink [Kerning])
   3 !! sehr enges (!nolink [Kerning])
!end_table

!item [pairkern]
 Mit diesem Parameter kann das Pair--Kerning aus-- (0) oder eingeschaltet
 (1) werden, vgl. (!V)(!nolink [vst_kern])()(!v).

!item [(!V)fontattr(!v)]
 Dies sind die Fontattribute (Texteffekte), wie sie auch von der
 (!nolink [VDI])--Funktion (!V)vst_effects()(!v) verwendet werden.

 Calvino verwendet dieses Feld nur dann, wenn das Kontroll!-flag
 (!V)CC_FAKESTYLE(!v) gesetzt ist.

!item [(!V)fontskew(!v)]
 Die Neigung des Fonts in 1/10 Grad, vgl. (!V)vst_skew()(!v).

!item [(!V)fontcol(!v)]
 Die Farbe des Fonts. Es werden die VDI--Farben verwendet, d.h. 0 = Weiž,
 1 = Schwarz, usw., vgl. (!V)vst_color()(!v).

!item [(!V)backcol(!v)]
 Die Hintergrundfarbe des Textes. Es werden die (!nolink [VDI])--Farben ver!-wen!-det,
 d.h. 0 = Weiž, 1 = Schwarz, usw. Das Setzen einer Text--Hintergrundfarbe
 wird vom (!nolink [VDI]) nicht direkt untersttzt, es ob!-liegt daher dem Aufrufer,
 ob und wie dieser Parameter verwendet wird.

!label Textausrichtung
!label Ausrichtung

!item [(!V)halign(!v)]
 Hierber kann die horizontale Textausrichtung angegeben wer!-den: Der
 Text soll linksbndig, rechts!-bndig  oder zentriert aus!-ge!-ge!-ben
 werden.
!label THA_LEFT
!label THA_CENTER
!label THA_RIGHT
 !begin_table [l|c|l]
   Name       !! Wert !! Ausrichtung
!hline
   THA_LEFT   !!  0  !! linksbndig
   THA_CENTER !!  1  !! zentriert
   THA_RIGHT  !!  2  !! rechtsbndig
 !end_table
 Diese Werte entsprechen dem Parameter fr die horizontale Aus!-rich!-tung
 beim (!nolink [VDI])--Aufruf (!V)vst_alignment()(!v).

!item [(!V)valign(!v)]
 Hierber kann die vertikale Textausrichtung angegeben werden: Der Text
 soll an der Oberkante oder der Un!-ter!-kan!-te ausgerichtet oder
 (vertikal) zentriert aus!-ge!-ge!-ben wer!-den.
!label TVA_BOTTOM
!label TVA_CENTER
!label TVA_TOP
 !begin_table [l|c|l]
   Name       !! Wert !! Ausrichtung
!hline
   TVA_BOTTOM !!  0  !!  an der Text-Unterkante
   TVA_CENTER !!  1  !!  vertikal zentriert
   TVA_TOP    !!  2  !!  an der Text-Oberkante
 !end_table
 Diese Werte entsprechen absichtlich (!I)nicht(!i) dem Parameter zur
 ver!-ti!-kalen Ausrichtung bei (!V)(!nolink [vst_alignment])()(!v)! Die dort
 ver!-wen!-de!-ten Werte (""Zeichen!-unter!-kante"",
 ""Zeichen!-zellen!-unter!-kante"") sind fr den normalen Anwender wenig
 in!-tui!-tiv und sollten daher nicht Teil des User--Interfaces sein (was
 sie bei der Aus!-wahl im Fontselektor aber w„ren). Die Ausrichtung muž
 daher vom auf!-rufen!-den Programm in die ""richtigen"" Werte konvertiert
 werden.

!label Textrotation
!label Rotation
!item [(!V)rotation(!v)]
 Textrotation in 1/10 Grad, wie sie auch von der VDI--Funktion
 (!V)vst_rotation()(!v) verwendet wird.
!end_xlist

!smallskip

Fehlen noch die beiden Parameter ''(!V)validtype(!v)'' und
''(!V)validchars(!v)'':

 Manchmal ist es wichtig, sicherzustellen, daž der Font be!-stimm!-te
 Zeichen enth„lt. Dafr gibt es zwei M”g!-lich!-kei!-ten:

 Wenn ''(!V)validchars(!v)'' Null ist, kann man mit ''(!V)validtype(!v)''
 eine der fol!-gen!-den vier Gruppen von Zeichen ausw„hlen:
!label V_CHAR_IND
!label V_CHAR_ASC
!label V_CHAR_PRT
!label V_CHAR_ALL
!begin_table [l|c|c|l]
Name       !! Wert Bereich  Kommentar
!hline
V_CHAR_IND !! -1 !!   -    !!  "egal"
V_CHAR_ASC !! -2 !! 32-126 !!  alle druckbaren ASCII-Zeichen
V_CHAR_PRT !! -3 !! 32-255 !!  alle druckbaren Zeichen
V_CHAR_ALL !! -4 !!  0-255 !!  wirklich alle Zeichen
!end_table
Diese vier Gruppen drften die h„ufigsten Anwendungsf„lle ab!-decken.

Wenn sowohl ''(!V)validtype(!v)'' als auch ''(!V)validchars(!v)'' Null
sind, wird der Fontselektor dies wie (!V)V_CHAR_IND(!v) behandeln,
ebenso bei anderen un!-gl!-ti!-gen Werten in ''(!V)validtype(!v)''.

!smallskip

Wenn die vier Gruppen einmal nicht ausreichen, so kann man statt!-dessen
ber ''(!V)validtype(!v)'' und ''(!V)validchars(!v)'' auch genauer
angeben, welche Zeichen be!-n”!-tigt werden:

!begin_ilist
!label Mapping
  !item [validtype] enth„lt dann einen Wert fr das vom GDOS zu
        ver!-wen!-den!-de Mapping (vgl. (!V)vst_charmap()(!v)).

        Die freie Wahl des Mappings steht nur mit einem ent!-sprech!-en!-den
        GDOS (SpeedoGDOS oder NVDI ab Version 3) zur Verfgung. Z.Z.
        sind folgende Mappings definiert:
!label MAP_DIRECT
!label MAP_ASCII
!begin_table [l|c|l]
Name       !! Wert !! Bedeutung
!hline
MAP_DIRECT !! 0  !! "direktes Mapping"
MAP_ASCII  !! 1  !! ASCII-Mapping (Default)
!end_table
        Wenn das GDOS kein Mapping beherrscht, wird der Fontselektor
        nur (!V)MAP_ASCII(!v) akzeptieren, alle anderen Mappings werden
        dann igno!-riert und ein Test auf Vorhandensein bestimmter Zeichen
        wird (!I)nicht(!i) durchgefhrt.
  !item [validchars] ist ein Zeiger auf ein Array von Integers (Words),
        ber das angegeben werden kann, welche Zeichen der Font
        un!-be!-dingt enthalten soll.

        Das Array besteht aus einer Folge von Von--Bis--Paaren:
        !begin_itemize
         !item zwei aufeinanderfolgende Werte geben einen Bereich
               (von--bis) an
         !item einzelne Zeichen werden durch Verdopplung angegeben
         !item das Ende der Liste wird durch ein Von--Bis--Paar
               angegeben, bei dem ''bis'' kleiner ist als ''von''
        !end_itemize

        (!B)Beispiel:(!b) Es sollen nur Fonts angeboten werden, die alle
        druck!-baren ASCII--Zeichen sowie die deutschen Umlaute enthalten.
!begin_verbatim
xFSL_PAR xpar;
int chars[] = { ' ', '~',  /* ASCII 32..126 */
                '„','„', '”','”', '','',
                'Ž','Ž', '™','™', 'š','š', 'ž','ž',
                1,0       /* Ende der Liste */
              };

xpar.font->validtype=MAP_ASCII;
xpar.font->validchars=chars;
!end_verbatim
##!end_xlist
!end_ilist
Zuknftige GDOSse werden wahrscheinlich weitere Mappings unter!-sttzen
(BICS, Unicode, !..). Durch die verwendete Codierung wird der
Fontselektor auch diese korrekt beherrschen: Das in ''(!V)valid!-type(!v)''
bergebene Mapping wird einfach eingestellt und dann das Vorhandensein
der Zeichen aus ''(!V)validchars(!v)'' abgetestet.

(!B)Anmerkung:(!b) Die diversen M”glichkeiten mit den Parametern
''(!V)validtype(!v)'' und ''(!V)validchars(!v)'' sollten sparsam und mit
Bedacht verwendet werden, da das notwendige Testen der Zeichen je nach
GDOS recht lange dauern kann.

!end_node

# ------------------------------------------------------------------------
!begin_node Das User-Popup
Fr das benutzerdefinierte (!nolink [Popup]) (kurz User-(!nolink [Popup])) existieren die
fol!-gen!-den Felder in der (!V)xFSL_PAR(!v)--Struktur:
!begin_xlist [num_entries~]
!item [(!V)poptext(!v)]
Zeiger auf einen Text, der vor dem (!nolink [Popup]) erscheinen soll oder 0L. Dem
Fontselektor steht es frei, diesen Text zu ignorieren.

!item [(!V)num_entries(!v)]
Anzahl Eintr„ge (d.h. Zeilen) im (!nolink [Popup]). Steht hier eine Null, so wird
kein (!nolink [Popup]) angezeigt. Es sollten nicht mehr als 16 Eintr„ge verwendet
werden, auch wenn ein!-zel!-ne Fontselektoren u.U. auch mehr Eintr„ge
un!-ter!-sttzen.

!item [(!V)sel_entry(!v)]
Der selektierte Eintrag im (!nolink [Popup]) (gez„hlt wird ab 0). Der Fontselektor
legt hier die Nummer des angew„hlten (!nolink [Popup])-Eintrags ab und liest den Wert
bei jedem Aufruf von (!V)xfsl_event(!v) wieder neu aus. Somit k”nnen Sie
den Fontselektor z.B. auch zwingen, statt dem angew„hlten Ein!-trag Nummer
3 den mit der Nummer 5 zu aktivieren (bei (!V)xFS_POPUP(!v) meldet der
Fontselektor nur, welcher Eintrag an!-ge!-w„hlt wurde, aktiviert wird
dieser erst beim Rck!-sprung in den Fontselektor).

!item [(!V)popup(!v)]
Dies ist ein Zeiger auf ein Array von (!V)xFSL_PENTRY(!v)-Elementen.
An der angegebenen Adresse mssen genau so viele Elemente stehen, wie in
''(!V)num_entries(!v)'' angegeben wurden.
!end_xlist

!label xFSL_PENTRY
Ein Eintrag im (!nolink [Popup]) ist wie folgt aufgebaut:
!begin_quote
!begin_verbatim
typedef struct
{
 char         *entry;      /* Text des Popup-Eintrags       */
 PFONTINFO    *fontinfo;   /* Zeiger auf Fontinfo-Struktur  */
 unsigned int  fontflags;  /* erlaubte Fontarten            */
 long          funcflags;  /* Funktionsflags, nur fr HuGo! */
} xFSL_PENTRY;
!end_verbatim
!end_quote
Die Bedeutung der Elemente dieser Struktur sollte nach den
vor!-an!-ge!-gan!-gen!-en Ausfhrungen klar sein. Die Funktionsflags
ent!-sprechen den Kontrollflags, bis auf die Flags, die das globale
Verhalten des Fontselektors beeinflužen ((!V)CC_WINDOW(!v) etc.). Diese
wer!-den hier ignoriert.

(!B)Wichtig:(!b) Der Zeiger auf die (!V)PFONTINFO(!v)--Struktur darf
nicht Null sein!

Wenn der Text eines Eintrags mit einem ''(!V)-(!v)'' beginnt, wird der
ent!-sprech!-en!-de Eintrag disabled (in heller Schrift und nicht
an!-w„hl!-bar) dargestellt. Dies ist in erster Linie fr Trennlinien
zwischen den Eintr„gen gedacht.

!smallskip

(!U)Verwendung(!u)

Im Prinzip kann man drei Einsatzgebiete fr das User-(!nolink [Popup]) sehen:
!begin_enumerate
!item Jeder (!nolink [Popup])-Eintrag stellt den Font fr einen bestimmten Programmteil
      ein. Beispielsweise k”nnte man in einem bestimmten Fenster eines
      Programms nur nicht--proportionale Fonts zulassen wol!-len, in einem
      anderen keine Vektorfonts, in einem dritten alle Fonts.
!item Jeder Eintrag stellt eine gewisse Gruppe von Fonts zur Ver!-f!-gung.
      Braucht man beispielsweise oft Vektorfonts, k”nnte ein (!nolink [Popup]) mit
      den Eintr„gen ""nur Vektorfonts"" und ""alle Fonts"" kon!-stru!-iert
      werden.
!item Das (!nolink [Popup]) kann aber auch fr etwas ganz anderes verwendet wer!-den.
      Man k”nnte hier noch eine Information unterbringen, die zwar nichts
      mit Fonts, aber mit dem Fenster zu tun hat, fr das man einen Font
      einstellen will. Beispielsweise k”nnte fr ein Consolen--Fenster
      die Art, wie inverse Zeichen darzustellen sind, in Form eines
      Popups mit den Eintr„gen ""invers"", ""fett"", ""unter!-strichen""
      zur Auswahl angeboten wer!-den.

      Will man das (!nolink [Popup]) so zweckentfremden, so muž man bei der
      Mel!-dung (!V)xFS_POPUP(!v) den ge„nderten Font (der sich am
      gesetzten (!V)FF_CHANGED(!v)--Flag erkennen l„žt) in alle
      anderen (!nolink [Popup])-Eintr„ge bertragen, da sich sonst der im
      Fontselektor angezeigte Font „ndern wrde!
!end_enumerate

!end_node
!end_node

# ========================================================================
!begin_node Die Fontflags

šber die Fontflags k”nnen die zur Auswahl gestellten Fonts
ein!-ge!-schr„nkt werden:

!raw [stg] @alabel "FF_SYSTEM" "FF_MONOSPACED" "FF_PROPORTIONAL"
!raw [stg] @alabel "FF_VECTOR" "FF_BITMAP" "FF_ALL" "FF_CHANGED"
!raw [stg] @alabel "FF_VEKTOR" "FF_MONO" "FF_PROP"
!raw [stg] @alabel "FF_SPD" "FF_TTF" "FF_PFB" "FF_CFN"
!begin_table [l|c|l]
Name            !! Wert   !! Bedeutung
!hline
FF_SYSTEM       !! 0x0001 !! Systemfont (zus„tzlich) anzeigen
FF_MONOSPACED   !! 0x0002 !! monospaced Fonts anzeigen
FF_PROPORTIONAL !! 0x0004 !! proportionale Fonts anzeigen
FF_BITMAP       !! 0x0008 !! Bitmapfonts anzeigen
FF_SPD          !! 0x0010 !! Speedofonts anzeigen
FF_TTF          !! 0x0020 !! TrueType-Fonts anzeigen
FF_PFB          !! 0x0040 !! Type-1-Fonts anzeigen
FF_CFN          !! 0x0080 !! Calamusfonts anzeigen (n.i.)
FF_VECTOR       !! 0x00F0 !! alle Vektorfonts anzeigen
FF_ALL          !! 0x00FE !! alle Fonts anzeigen
FF_CHANGED      !! 0x8000 !! Žnderung erfolgt (nur im Popup)
!end_table

Die Werte sind so gew„hlt, daž die einzelnen Flags miteinander ver!-odert
werden k”nnen. Setzt man fr die Fontflags also beispielsweise
(!V)FF_MONOSPACED|FF_VECTOR(!v) ein, so werden nur unproportionale
Vektorfonts zur Auswahl gestellt.

Zudem gilt:
!begin_itemize
!item (!V)FF_SYSTEM(!v) hat Vorrang, d.h. wenn dieses Flag gesetzt ist,
      wird der Systemfont auf jeden Fall mit zur Auswahl gestellt.
!item Wenn (!V)FF_SYSTEM(!v) nicht gesetzt ist, wird der Systemfont genau
      dann zur Auswahl gestellt, wenn seine Eigenschaften den gesetzten
      Flags entsprechen.
!item Wenn weder (!V)FF_MONOSPACED(!v) noch (!V)FF_PROPORTIONAL(!v)
      gesetzt sind, werden die Fontflags so behandelt, als seien beide
      Flags ge!-setzt.

      Dies gilt analog fr (!V)FF_VECTOR(!v) und (!V)FF_BITMAP(!v).
!item Wenn (!V)FF_VECTOR(!v) gesetzt wird, werden automatisch alle
      Vektorfont--Formate angeboten. Eine feinere Unterteilung ist aber
      auf Wunsch durch die Flags (!V)FF_SPD(!v), !.., (!V)FF_CFN(!v)
      m”glich.

      (!B)Bitte beachten:(!b) Calamus--Fonts (und somit das Flag
      (!V)FF_CFN(!v)) werden z.Z. noch von keinem GDOS untersttzt!
!item Das Flag (!V)FF_CHANGED(!v) wird nur dazu verwendet, um im
      User--(!nolink [Popup]) die Einstellungen zu markieren, die sich ge„ndert haben.
      Der Fontselektor setzt dieses Flag nur, wertet es aber selbst nicht
      aus.
!end_itemize

!end_node

# ========================================================================
!begin_node xFSL Returncodes

Alle xFSL--Aufrufe liefern einheitliche Returncodes (Rckgabewerte)
zurck. Dabei steht eine negative Zahl fr einen Fehler, eine po!-si!-tive
Zahl (oder Null) bedeutet Erfolg bzw. ein Ereignis.

!raw [stg] @alabel "xFS_LOADERROR" "xFS_RES_ERROR" "xFS_NO_HANDLE" "xFS_NO_WINDOW"
!raw [stg] @alabel "xFS_NO_FONTS" "xFS_NO_FONTSIZE" "xFS_ACTIVE" "xFS_ERROR"
!raw [stg] @alabel "xFS_STOP" "xFS_OK" "xFS_HELP" "xFS_EVENT" "xFS_POPUP"
!begin_table [l|r|l]
Name            !! Wert !! Bedeutung
!hline
xFS_PARERROR    !! -9 !! Parameterfehler, z.B. Aufruf nach Rev. 3
xFS_LOADERROR   !! -8 !! Fehler beim Nachladen des xFSL-Moduls
xFS_RES_ERROR   !! -7 !! Aufl”sung zu klein (mind. 640x400 Punkte)
xFS_NO_HANDLE   !! -6 !! Kein VDI-Handle frei
xFS_NO_WINDOW   !! -5 !! Kein Fenster(handle) frei
xFS_NO_FONTS    !! -4 !! Keine Fonts geladen
xFS_NO_FONTSIZE !! -3 !! Fontgr”že nicht identifizierbar
xFS_ACTIVE      !! -2 !! Fontselektor ist bereits aktiv
xFS_ERROR       !! -1 !! allgemeiner Fehler (Speichermangel o.„.)
xFS_STOP        !!  0 !! <Abbruch> gew„hlt
xFS_OK          !!  1 !! <Ok> gew„hlt
xFS_HELP        !!  2 !! Hilfe-Button angew„hlt
xFS_EVENT       !!  3 !! AES-Event aufgetreten
xFS_POPUP       !!  4 !! Žnderung am User-Popup
!end_table

Diese Werte wurden aufw„rtskompatibel zum Fontselektor UFSL gew„hlt
(dieser kennt die Returncodes -4, -3, -2, -1, 0 und 1).

Darber hinaus k”nnen auch Gemdos-Fehlermeldungen (Werte kleiner oder
gleich -32) auftreten, insbesondere kann (!V)xfsl_init(!v) auch den
Wert (!V)EINVFN(!v) (-32) liefern, wenn der Fontselektor den erweiterten
Aufruf nicht untersttzt.

Beim Aufruf (!V)(!nolink [xfsl_init])(!v) entsprechen positive Rckgabewerte dem
Fenster!-handle des Fontselektors (0 bedeutet, daž der Fontselektor als
mo!-daler Dialog ge”ffnet wurde).

Es ist m”glich, daž die Liste der Returncodes in Zukunft um weitere Fehler
(Werte kleiner -9) oder Ereignisse (Werte gr”žer 4) erweitert wird. Dies
sollte beim Programmentwurf bercksichtigt werden: Bei un!-be!-kann!-ten
Fehlern sollte abgebrochen, unbekannte Ereignisse sollten ignoriert
werden.

!end_node

# ========================================================================
!begin_node Die Pure-C-Event-Struktur
!label EVENT
Die (!nolink [GEM])--Bibliothek von Pure C verwendet eine spezielle Struktur, in der
die Parameter der (!nolink [AES])-Funktion (!V)evnt_multi()(!v) zusammengefažt sind.
Diese Struktur wird auch von (!V)xfsl_event(!v) verwendet.
!begin_quote
!begin_verbatim
typedef struct /* Special type for EventMulti */
{
 /* Eingabeparameter */
 int ev_mflags,
     ev_mbclicks, ev_bmask, ev_mbstate,
     ev_mm1flags, ev_mm1x, ev_mm1y, ev_mm1width, ev_mm1height,
     ev_mm2flags, ev_mm2x, ev_mm2y, ev_mm2width, ev_mm2height,
     ev_mtlocount, ev_mthicount;

 /* Ausgabeparameter */
 int ev_mwich,
     ev_mmox, ev_mmoy, ev_mmobutton, ev_mmokstate,
     ev_mkreturn, ev_mbreturn;

 /* Message-Buffer */
 int ev_mmgpbuf[8];
} EVENT;
!end_verbatim
!end_quote
Die Elemente der Struktur entsprechen denen des (!V)(!nolink [evnt_multi])()(!v)--Aufrufs.
Auch die Reihenfolge der Parameter ist --- bis auf wenige Ausnahmen ---
identisch. Das Feld ''(!V)ev_mwich(!v)'' enth„lt die aufgetretenen Events
in der gleichen Kodierung wie ''(!V)ev_mflags(!v)''.

!end_node

!end_node

# ########################################################################
!begin_node xFSL Tips und Hinweise
In den folgenden Abschnitten soll versucht werden, noch einige Tips und
Hinweise zur xFSL--Schnittstelle zu geben.

!subtoc stg


# ========================================================================
!begin_node Ein einfacher Aufruf
Angesichts der Vielzahl der Parameter und Einstellm”glichkeiten
er!-scheint folgender Hinweis angebracht:
!begin_center
(!B)Keine Panik!(!b)
!end_center

Ein xFSL--Aufruf ist einfacher als es zun„chst scheint. Insbesondere kann
hier die Strategie der ""schrittweisen Verfeinerung"" angewendet wer!-den,
da man (fast) alle Parameter zun„chst einmal auf Null setzen kann.

Ein m”glichst einfacher xFSL--Aufruf kann z.B. so aussehen:
!begin_quote
!begin_verbatim
#include <stdio.h>
#include <aes.h>
#include <vdi.h>
#include <xfsl.h>

void call_xfsl (void)
{
  int xhandle, xret;
  xFSL_PAR xpar;
  PFONTINFO pfont;
  xFSL *xfsl;

  memset (&xpar, 0, sizeof (xFSL_PAR));
  memset (&pfont, 0, sizeof (PFONTINFO));

  xpar.par_size = sizeof (xFSL_PAR);
  xpar.pfi_size = sizeof (PFONTINFO);
  xpar.font = &pfont;
  xpar.font->fontcol = BLACK;

  if (get_cookie ('xFSL', &xfsl))
  {
    xhandle = xfsl->xfsl_init (0, &xpar);
    if (xhandle >= 0)
    {
     do
       xret = xfsl->xfsl_event (xhandle, 0L);
     while (xret > xFS_OK);
     xfsl->xfsl_exit (xhandle);
     if (xret == xFS_STOP)
       printf ("Abbruch\n");
     else if (xret == xFS_OK)
       printf ("Font mit ID %d ausgew„hlt\n", xpar.font->fontid);
     else if (xret < 0)
       printf ("Fehler %d\n", xret);
   }
   else
     printf ("Fehler %d\n", xhandle);
  }
  else
    printf ("Cookie nicht gefunden!\n");
}
!end_verbatim
!end_quote

Mit den beiden (!V)memset(!v)--Aufrufen werden alle Elemente der
Strukturen (!V)(!nolink [xFSL_PAR])(!v) und (!V)(!nolink [PFONTINFO])(!v) auf Null gesetzt.
Anschliežend werden einige un!-be!-dingt n”tige Werte eingetragen:
!begin_itemize
 !item die Gr”žen der beiden Strukturen (!V)xFSL_PAR(!v) und
       (!V)(!nolink [PFONTINFO])(!v)
 !item die Adresse der (!V)(!nolink [PFONTINFO])(!v)--Struktur wird in der
       (!V)xFSL_PAR(!v)--Struktur eingetragen
 !item die Schriftfarbe wird auf schwarz gesetzt (dies k”nnte man auch
       weglassen, aber normalerweise wird man ja in schwarzer Schrift
       auf weižem Grund schreiben wollen)
!end_itemize

Mehr ist an Vorbereitungen nicht n”tig, es folgt nun der eigentliche
Aufruf. Zun„chst wird der xFSL--Cookie gesucht. Im Erfolgsfall wird
nun der Fontselektor initialisiert, indem die (!V)xFSL_PAR(!v)--Struktur
ber!-ge!-ben wird. War dieser Aufruf erfolgreich (''(!V)xhandle(!v)'' ist
gr”žer oder gleich Null), so befindet sich der Fontselektor bereits auf
dem Bild!-schirm. In der Hauptschleife wird nun gewartet, bis der
Fontselektor entweder mit (!V)xFS_STOP(!v) oder (!V)xFS_OK(!v) vom
Anwender beendet wird oder bis ein Fehler auftritt (andere positive
Rckgabewerte werden hier ein!-fach ignoriert). Mit dem Aufruf von
(!V)xfsl_exit(!v) wird der Fontselektor wieder vom Bildschirm entfernt
und anschliežend der Rckgabewert aus!-ge!-wer!-tet.

Das war doch gar nicht so kompliziert, oder? Von hier aus k”nnen Sie nun
mit den diversen Parametern und Flags weiter experimentieren.

!end_node

# ========================================================================
!begin_node Fragen und Antworten
(!B)Wie kann ich feststellen, welche Features der Fontselektor
bietet?(!b)

Direkt kann dies fr einige Features ber die Funktion (!V)xfsl_info(!v)
geschehen. Indirekt k”nnen weitere Features ber das Feld
''(!V)(!nolink [control])(!v)'' in der (!V)xFSL_PAR(!v)--Struktur abgefragt werden:
Nach einem erfolgreichen (!V)xfsl_init(!v)--Aufruf wird der Fontselektor
diejenigen Kontrollflags l”!-schen, die er nicht versteht.

!smallskip

(!B)Wie soll sich mein Programm verhalten, wenn es feststellt, daž der
Fontselektor das gewnschte Feature nicht untersttzt?(!b)

Wenn berhaupt ein Fontselektor installiert ist, sollte dieser auch auf
jeden Fall verwendet werden. Je nachdem, wie wichtig das vermižte Feature
ist, k”nnte sich Ihr Programm nach Alternativen umsehen (z.B. ber das
Font-Protokoll) oder versuchen, das fehlende Feature zu kompensieren.

Auch hier gilt wieder: Der Anwender wollte einen Fontselektor, keine
Fehlermeldung. Wenn das fehlende Feature nur schwer zu kompensieren ist,
dann sollten Sie den Anwender einmalig(!) mit einem ent!-sprech!-en!-den
Hinweis informieren, aber trotzdem den Fontselektor aufrufen. Auch wenn
die Auswahl dann nicht mit dem gewnschten Kom!-fort ge!-sche!-hen kann,
ist dies fr den Anwender immer noch weniger fru!-strie!-rend, als
berhaupt keinen Font ausw„hlen zu k”nnen.

Einige Beispiele: Sollte ber das (!nolink [Popup]) der Font fr bestimmte Fenster
des Programms eingestellt werden, so sollte er bei fehlendem Popup fr das
oberste Fenster des Programms bernommen werden. Unter!-sttzt der
Fontselektor das Sperren der Gr”žen„nderung nicht, so sollte die
zurckgelieferte Gr”že einfach ignoriert werden und --- wenn sie von der
gewnschten Gr”že abweicht --- der Anwender durch einen Hinweis davon in
Kenntnis gesetzt werden.

Man sollte sich brigens nicht darauf verlassen, daž der Fontselektor beim
n„chsten Aufruf noch der gleiche ist bzw. die gleichen Features
untersttzt! Die Fontselektoren, die mit einem Overlay ((!V)XFSL.OVL(!v))
arbeiten k”nnen durch einfaches Umkopieren des Overlays jederzeit ohne
Reset ausgewechselt werden.

!smallskip

(!B)Was hat es mit diesem ""(!nolink [Mapping])"" auf sich?(!b)

Vektorfonts enthalten meist wesentlich mehr als die blichen 256 Zeichen,
noch dazu normalerweise nicht in der gewohnten ASCII--Codierung
(beispielsweise k”nnte das Leerzeichen auf Position 0 statt auf 32 liegen).
Daher werden die entsprechenden Zeichen aus dem Font auf die ""normalen""
256 Zeichen ""gemappt"" (d.h. abgebildet), so daž sich das Leerzeichen
wie gewohnt an Position 32 befindet, unabh„ngig davon, welche Position es
innerhalb des Fonts hat. Dieses bezeichnet man als ASCII--(!nolink [Mapping]).

Per Default ist das ASCII--(!nolink [Mapping]) aktiv. Dadurch kann man aber die
Zeichen, die aužerhalb des ASCII--Zeichensatzes liegen, nicht
an!-spre!-chen. Als zweites Mapping steht daher das ""direkte Mapping""
zur Ver!-f!-gung. Hier hat man nun Zugriff auf (!I)alle(!i) Zeichen eines
Fonts. Aller!-dings muž man dazu auch wissen, um welche Art von Font es
sich han!-delt und wieviele Zeichen der Font enth„lt: Speedofonts haben
meist 564 Zeichen, TrueType--Fonts k”nnen (theoretisch) bis zu 65536
Zeichen enthalten. Diese Information erh„lt man nach dem Umschalten auf
das direkte (!nolink [Mapping]) mit der (!nolink [VDI])--Funktion vqt_fontinfo():
!begin_verbatim
 int minADE, maxADE;

 vst_charmap(handle,0);
 vqt_fontinfo(handle,&minADE,&maxADE,dumarray,&dummy,dumarray);
!end_verbatim
In ''(!V)minADE(!v)'' erh„lt man den kleinsten, in ''(!V)maxADE(!v)'' den
gr”žten gl!-ti!-gen Zeichenindex.

Das direkte (!nolink [Mapping]) ist fr normale Anwendungen nur eingeschr„nkt
brauch!-bar. Im Gegensatz zum ASCII--(!nolink [Mapping]), das ein einheitliches
(!nolink [Mapping]) fr alle Arten von Fonts darstellt, muž man hier n„mlich ganz
genau wissen, um welche Art von Font es sich handelt. So haben z.B. die
Speedo--Symbolfonts eine andere Codierung als die ""normalen""
Speedo!-fonts. D.h. daž man an Position 64 eines solchen Symbolfonts nicht
das gleiche Zeichen vorfinden wird wie bei einem ""normalen"" Speedo!-font.

Andere Mappings als ASCII sind daher z.Z. fr den Grožteil der Programme
uninteressant. Knftige GDOSse werden aber m”glicherweise noch andere
einheitliche Mappings (z.B. Unicode oder BICS) anbieten, bei denen man
sich dann wieder darauf verlassen kann, daž an einer be!-stimm!-ten
Position auch immer das gleiche Zeichen liegt („hnlich wie beim
ASCII--(!nolink [Mapping]), nur eben auch bei Positionen gr”žer 255).

!smallskip

!end_node

# ========================================================================
!begin_node xFLS Programmiertechnische Hinweise
Die Beschreibung der xFSL--Schnittstelle in diesem Text erfolgt in Pure C.
In den folgenden Abschnitten werden die (!nolink [Datentypen]) und
Be!-son!-der!-hei!-ten von Pure C n„her beschrieben, damit xFSL--Aufrufe
auch aus anderen Programmiersprachen und C--Dialekten gelingen.

!subsubtoc stg


# ------------------------------------------------------------------------
!begin_node Datentypen

In diesem Text werden die folgenden Datentypen verwendet:
!begin_quote
!begin_verbatim
 Name            Gr”že
----------------------------------------
 int             16 Bit mit Vorzeichen
 unsigned int    16 Bit ohne Vorzeichen
 long            32 Bit mit Vorzeichen
 unsigned long   32 Bit ohne Vorzeichen
!end_verbatim
!end_quote

Der Datentyp (!V)char(!v) ist ein (ASCII--)Zeichen und wird hier nur als
Zei!-ger!-typ verwendet, d.h. als Zeiger auf einen C--String (eine Folge
von Zeichen, die mit einem Nullbyte abgeschložen sind).

!smallskip

!label union
(!U)Union(!u)

Eine Union entspricht einem varianten Record in Pascal. Es handelt sich
um eine Struktur, deren einzelne Elemente ""bereinander"" liegen, d.h.
denselben Speicherbereich belegen. Welches Element gerade gltig ist,
ergibt sich aus dem Kontext bzw. bleibt dem Programmierer ber!-lassen.

(!B)Beispiel:(!b) In der Struktur (!V)PFONTINFO(!v) wird fr die
Gr”ženangabe eine Union ''(!V)fsize(!v)'' verwendet:
!begin_quote
!begin_verbatim
union fsize
{
 int   size;    /* Fontgr”že in Punkt         */
 fix31 size31;  /* Fontgr”že in 1/65536 Punkt */
};
!end_verbatim
!end_quote
Der Speicherbedarf dieser Union betr„gt vier Bytes, da der Typ fix31
vier Bytes grož ist. Man (!I)k”nnte(!i) nun dem Element ''(!V)size31(!v)''
eine Gr”žen!-an!-ga!-be in 1/65536 Punkt zuweisen und dann den Wert in
ganzen Punkt aus dem Element ''(!V)size(!v)'' auslesen --- dies ist aber
nicht empfehlenswert, da bei der Umrechnung (!V)(!nolink [fix31])(!v) nach pt immer
gerundet werden sollte, s.u.

!smallskip

!label fix31
(!U)(!V)fix31(!v)(!u)

Der Datentyp (!V)(!nolink [fix31])(!v) ist eine Festkommazahl, bei dem die oberen
16 Bit den vorzeichenbehafteten Vorkomma-Anteil darstellen und die
unteren 16 Bit den vorzeichenlosen Nachkomma-Anteil. Er wird
ausschliežlich fr Gr”ženangaben von Fonts verwendet, die damit auf
1/65536 Punkt genau angegeben werden k”nnen.

Bei der Umrechnung von (!V)(!nolink [fix31])(!v) nach pt darf man das Runden nicht
ver!-gessen. Zitat aus dem NVDI--Guide:

(!B)Man darf nie, nie, niemals den Nachkommateil einfach abschneiden!(!b)

!end_node

# ------------------------------------------------------------------------
!begin_node xFSL Parameterbergabe
Die šbergabe der Parameter bei allen xFSL--Aufrufen geschieht ber
den Stack nach C--Konvention. D.h. daž der beim Aufruf am weitesten
rechts stehende Parameter zuerst auf den Stack gelegt wird und der am
wei!-testen links stehende Parameter zum Schluž, d.h. beim Einsprung in
den Fontselektor, obenauf liegt.

!end_node

# ------------------------------------------------------------------------
!begin_node Pure C und ''cdecl''
!raw [stg] @alias "cdecl"
Pure C bergibt die Parameter an Funktionen normalerweise in Re!-gi!-stern.
Fr eine šbergabe ber den Stack muž entweder das Schls!-sel!-wort
""(!V)cdecl(!v)"" verwendet werden (wie im Includefile (!V)XFSL.H(!v)
geschehen) oder der Compilerschalter ""(!V)-H(!v)"" gesetzt werden.

Das Schlsselwort ""(!V)cdecl(!v)"" ist eine Pure--C--spezifische
Erweiterung und wird daher bei gesetztem Compilerschalter ""(!V)-A(!v)""
(ANSI-Konformit„t) an!-ge!-mahnt.

!end_node
!end_node
!end_node

# ########################################################################
!begin_node Revisions--History
!raw [stg] @alias History
(!B)Revision 4(!b)
!begin_itemize
 !item Aufgrund eines kleinen Designfehlers in den „lteren Revisionen,
       der die Erweiterbarkeit der Schnittstelle einschr„nkte, ist
       Revision 4 (!I)nicht(!i) kompatibel zu „lteren Revisionen. Dies
       sollte in der Praxis kein Problem darstellen, da der Fontselektor
       Auf!-rufe nach dem alten Schema mit einem Fehler quittieren wird.
       Die alte Revision 3 wird im Laufe der Zeit verschwinden.
 !item neue Parameter in der (!V)(!nolink [PFONTINFO])(!v)--Struktur:
       !begin_itemize
        !item Text--Hintergrundfarbe (''(!V)backcol(!v)'')
        !item (!nolink [Textausrichtung]) (''(!V)halign(!v)'' und ''(!V)valign(!v)'')
        !item (!nolink [Textrotation]) (''(!V)rotation(!v)'')
        !item Angabe von Zeichen, die der ausgew„hlte Font unbedingt
              ent!-hal!-ten soll (''(!V)validtype(!v)'' und
              ''(!V)validchars(!v)'')
       !end_itemize
 !item die (!V)(!nolink [PFONTINFO])(!v)--Struktur wird auch bei Rckgabe
       (!V)(!nolink [xFS_STOP])(!v) mit den Werten des zuletzt im Fontselektor
       ausgew„hlten Fonts gefllt
 !item Codierung der Fontflags ge„ndert (feinere Unterscheidung der
       Vektorformate)
!end_itemize

!smallskip

(!B)Revision 3(!b)
!begin_itemize
 !item die erste ”ffentlich verfgbare Schnittstellen--Revision
!end_itemize

!smallskip

(!B)„ltere Revisionen(!b)
!begin_itemize
 !item „ltere Revisionen k”nnen getrost ignoriert werden, da diese
       nie!-mals in einem fr eine gr”žere ™ffentlichkeit verfgbaren
       Programm in Erscheinung getreten sind
!end_itemize
!end_node


# ########################################################################
!begin_node Programmbersicht
Es folgt eine šbersicht ber alle z.Z. erh„ltlichen Fontselektoren, die
ber eine UFSL-- oder eine xFSL--Schnittstelle (oder beides) ver!-fgen.

Desweiteren folgt eine Liste von Programmen, die einen Fontselektor mit
einer der beiden Schnittstellen verwenden.

!subtoc stg

!ifnset tos_hyp

Erg„nzungen und Berichtigungen zu diesen Aufstellungen schicken Sie bitte
an Dirk Haun (Adresse siehe unter ""Kontaktadressen"").

!endif

# ========================================================================
!begin_node Fontselektor--šbersicht
!raw [stg] @index "Fontselektoren"

Eine kleine šbersicht ber die existierenden Fontselektoren:
!begin_description
!label UFSL
!item [UFSL] von Michael Th„nitz (!nl)
Dies ist der Prototyp aller externen Fontselektoren. Die letzte
ver”ffentliche Version ist 0.97, danach hat Michael leider die Entwicklung
eingestellt. Dankenswerterweise hat er aber die Quell!-texte
ver”ffentlicht.

!raw [stg] @index "FontSel"
!item [FontSel] von Holger Weets und Christoph Zwerschke (!nl)
Ein kleiner, aber auch etwas spartanischer Fontselektor von Holger Weets,
der seit der Version 1.02 von Christoph Zwerschke weiterentwickelt wird.
Ab der Version 1.02 wird auch die xFSL-Schnittstelle untersttzt.

!label xUFSL
!item [xUFSL] von Stefan Rogel (!nl)
Der xUFSL bietet gegenber den bisher genannten Fontselektoren viele
zus„tzliche Features. Da diese ber die existierende UFSL-Schnittstelle
nicht angesprochen werden konnten, hat Stefan die Schnittstelle erweitert.
Das Design der ersten Version war, vor!-sich!-tig ausgedrckt,
""umstritten"". Letzte ver”ffentlichte Ver!-si!-on: 1.05. Nachfolger des
xUFSL ist !..

!raw [stg] @index "HuGo!"
!item [HuGo] von Stefan Rogel (!nl)
HuGo! ist der an die xFSL--Schnittstelle angepažte Nachfolger des xUFSL
(die UFSL-Schnittstelle wird ebenfalls noch untersttzt, nicht aber die
speziellen Erweiterungen des xUFSL an der UFSL--Schnittstelle).
Die Namens„nderung wurde vollzogen, um Ver!-wechs!-lungen zu vermeiden.

!raw [stg] @index "Calvino"
!item [Calvino] von Dirk Haun (!nl)
Zusammen mit HuGo! der erste Fontselektor mit (!nolink [xFSL--Schnittstelle]). Auch
Calvino untersttzt noch die einfache (!nolink [UFSL--Schnittstelle]).

!item [FONT_SEL und FONT_PAL] von Christian Grunenberg (!nl)
Diese beiden Programme arbeiten auf Drag&Drop--Basis, sie unter!-sttzen
also weder die UFSL-- noch die (!nolink [xFSL--Schnittstelle]), dafr aber das
(!nolink [Font--Protokoll]). (!V)FONT_SEL(!v) ist ein Fontselektor, (!V)FONT_PAL(!v)
eine Fontpalette (mit integriertem Fontselektor).
!end_description

!end_node

# ========================================================================
!begin_node Programme, die einen Fontselektor untersttzen
!ignore_index
Folgende Programme untersttzen einen externen Fontselektor (Stand
16.08.1998, alle Angaben und E-Mail-Adressen ohne Gew„hr):

!begin_table [l|l|l|c|c]
 Program       !! Category            !!  Author              !! (!nolink [UFSL]) !! xFSL
!hline
 800XL-Deejay  !! Laufwerksemulator   !! Kolja Koischwitz     !! +   !!
 APP_List      !! Systemutility       !! Ralf Zimmermann      !! +   !!
 Bellini       !! Grafikprogramm      !! Ingo Dehne           !!     !!  +
 BibelST       !! Bibel-Software      !! Reinhard Bartel      !!     !!  +
 Cat2Maus      !! MausTausch          !! Harald Sommerfeldt   !! +   !!
 Chatwin       !! Shell               !! Dirk Haun @ LB       !! +F  !!  +F
 CyPress       !! Textverarbeitung    !! Rene Bartholomay     !!     !!  +F
 DB-Point      !! Newsreader          !! Michael Heng         !! +   !!
 Disk Cake     !! Diskutility         !! Christoph Zwerschke  !! +   !!  +
 Egale         !! Dateiutility        !! David Reitter        !! +   !!  +
 Everest       !! Editor              !! Oliver Schmidt       !! +   !!
 Face Value    !! App.Builder/Lib     !! Vegard Hofsoy        !! -   !!  +
 Floh          !! Filelisten-Util.    !! Heiko Schaefer       !!     !!  +
 GEMAR         !! Backup              !! Steffen Engel        !! +   !!
 (!nolink [GEM])-Fontviewer!! Zeichensatz-Anzeige !! Reinhard Bartel      !! +   !!  +
 (!nolink [GEM])-Plan      !! Tabellenverwaltung  !! Reiner Rosin         !!     !!  +F
 Hitchcock     !! Systemutility       !! Thorsten Pohlmann    !!     !!  +
 IdeaList      !! ASCII-Druckprogramm !! Christoph Bartholme  !! +   !!
 Imagin        !! Funktionsplotter    !! Reinhard Maier       !!     !!  +
 Jedi          !! GAL-Assembler       !! Ralf Zimmermann      !! +   !!
 Kandinsky     !! Zeichenprogramm     !! Ulrich Rossgoderer   !!     !!  +
 (!nolink [MagiC])!Conf    !! MagiC-Utility       !! Christian Ratsch     !!     !!  +
 MasterBrowse  !! Dateiviewer         !! Michel Forget        !! +   !!
 MenuInfo      !! Systemutility       !! Dirk Hagedorn        !!     !!  +F
 Okami         !! Newsreader          !! Wolfram R”sler       !! +   !!
 Photo Line    !! Bildverarbeitung    !! Gerhard Huber        !!     !!  +
 QED           !! Editor              !! Christian Felsch     !! +   !!
 RoadRunner    !! Autofahrtplanung    !! Andreas Schrell      !!     !!  +F
 SaugUtility   !! dito                !! Frank Rger          !! +   !!
 Schecks       !! Businessoftware     !! Christian Lehmann    !!     !!  +
 ST-Guide      !! Hypertext           !! Holger Weets         !! +   !!
 STJ-Oberon    !! Programmiersprache  !! Stephan Junker       !! +   !!  +
 Texel         !! Tabellenkalkulation !! Thomas Much          !! +   !!  +
 UpToCASE      !! CASE-Tool           !! Michael Nolte        !! +   !!
 VESAL         !! Lernprogramm        !! Peter Klasen         !! +   !!
 Zeig's mir    !! Dateiviewer         !! Reiner Rosin         !! +   !!  +F
!end_table
(+: untersttzt, F: als Fensterdialog; E-Mail-Adressen: MausNet)
!smallskip

# Autoren, die nicht ber das MausNet erreichbar sind:
# !begin_quote
# !begin_verbatim
# Kolja Koischwitz: joust@cs.tu-berlin.de
# Michel Forget:    mforget@worldgate.edmonton.ab.ca
# Oliver Schmidt:   stu30109@mail.uni-kiel.d400.de
# Vegard Hofsoy:    vegard@origo.no
# !end_verbatim
# !end_quote

!end_node
!end_node


!newpage
# !begin_appendix
# ########################################################################

# !ifnset [FontProtokollSchonDa]
#  !include protokol\font.u
# !endif

# ########################################################################
!begin_node Die UFSL--Schnittstelle
!raw [stg] @alias UFSL-Schnittstelle
!raw [stg] @autorefoff
Der Vollst„ndigkeit halber folgt hier noch die Original--Beschreibung von
Michael Th„nitz zur ursprnglichen UFSL-Schnittstelle:

(!U)Programmierschnittstelle:(!u) (!nl)

UFSL ist eine Fontauswahlbox fr den Autoordner. Sie bietet dem
Programmierer eine einfache Programmierschnittstelle ber einen Cookie.

Der Cookie lautet: ""(!V)UFSL(!v)"". (!nl)
Der Cookie liefert einen Zeiger auf folgende Struktur:

!begin_verbatim
 typedef struct
 {
  unsigned long  id;      /* UFSL ID (UFSL)       */
  unsigned int   version; /* Version (BCD-Format) */
  int dialtyp;            /* 0=Dialog, 1=Fenster  */
  int cdecl (*font_selinit)(void);
  int cdecl (*font_selinput)(
              int vdihandle,
              int dummy,
              char *text,    /* eigener Text, max. 34 Zeichen      */
              int ftype,     /* 1=nur monospaced Fonts, 0=alles    */
              int *fretid,   /* eingestellte FontId                */
              int *fretsize  /* eingestellte Fontgr”že             */
              );
  OBJECT *helpbutton;           /* Typ: BOXTEXT                    */
  void cdecl (*helpfunc)(void); /* Benutzerdefinierte Helpfkt.     */

  /**** ab Version 0.91 ********************************************/
  char *examplestr;            /* Beispieltext fr Fontdarstellung */

  /**** ab Version 0.96 ********************************************/
  void cdecl (*msgfunc)(int event, int msgbuf[]);/* Redrawfunktion */

  /**** ab Version 0.97 ********************************************/
  int cdecl (*fontsel_exinput)(
              int vdihandle,
              int ftype,     /* 1=nur monospaced Fonts, 0=alles    */
              char *text,    /* eigener Text, max. 34 Zeichen      */
              int *fretid,   /* eingestellte FontId                */
              int *fretsize  /* eingestellte Fontgr”že             */
              );
 } UFSL;
!end_verbatim

(!U)Aufruf:(!u)

!begin_verbatim
UFSL *ufsl;
ufsl=(UFSL *)get_cookie('UFSL');
ufsl->helpfunc= my_helpfunc;   /* Hilfefunktion oder NULL */
ufsl->msgfunc = my_msghandler; /* Redrawfunktion oder NULL,
                                  Dialtyp beachten */
ufsl->fontsel_input(vdihandle,"Bitte Font ausw„hlen",0,&id,&size);
oder
ufsl->fontsel_input(vdihandle,NULL,0,&id,&size);
!end_verbatim

(!U)Returncodes:(!u)

!begin_verbatim
 1 : Alles OK, Werte gltig.
 0 : Abbruch gew„hlt.
-1 : Out of memory.
-2 : Unzul„ssiger Mehrfachaufruf.
-3 : Fontgr”že konnte nicht identifiziert werden.
-4 : Anzahl Fonts muž gr”žer null sein.
!end_verbatim

(!U)Sonderfunktionen:(!u)

!begin_verbatim
void cdecl (*helpfunc)(void); /* Benutzerdefinierte Helpfkt.     */
!end_verbatim

UFSL kann eine benutzerdefinierbare Hilfefunktion ber den ebenfalls
optionalen Hilfebutton aufrufen. (!V)helpfunc()(!v) ben”tigt keine
Parameter und liefert auch keinen Wert zurck.

!begin_verbatim
void cdecl (*msgfunc)(int event, int msgbuf[]); /* Redrawfunktion */
!end_verbatim

Bei Verwendung von UFSL als Fensterdialog ist es notwendig eine
Re!-draw!-funk!-ti!-on zur Verfgung zu stellen. Sie schickt die
anfallenden Events an das aufrufende Programm zurck, damit nach
Verschieben des Dialogs die Hintergrundfenster restauriert werden
k”nnen. (!V)msgfunc()(!v) liefert als ersten Parameter das Ergebnis
von (!V)evnt_multi()(!v) und als zweiten Parameter die MsgPipe. Ein
Returncode wird nicht ben”tigt. Das Anwenderprogramm muá die n”tigen
Routinen zur Fensterbehandlung zur Verfgung stellen.
(!V)wind_update(..._UPDATE)(!v) wird von UFSL nicht ge!-setzt, obliegt
also dem rufenden Anwenderprogramm. Prinzip!-be!-dingt (?) ist die
Memoryprotection von MTOS auszuschalten.

Grunds„tzlich gilt es zu berlegen, ob tats„chlich alle Events
ent!-sprechend beantwortet werden sollen. Ein (!V)WM_TOPPED(!v), das
andere eigene Fenster nach vorn bringt, sollte wohl nicht beantwortet
werden, da UFSL naturgem„á nur applikationsmodal sein kann, da UFSL ja in
einem eigenen (!V)form_do()(!v) sprich (!V)evnt_multi()(!v) kreist.
!raw [stg] @autorefon

!end_node

# ########################################################################
!begin_node Hinweise fr Autoren anderer Fontselektoren
Autoren anderer Fontselektoren sind dazu eingeladen, sich der
xFSL--Schnittstelle anzuschliežen. Im Prinzip kann jeder Fontselektor,
der als TSR konzipiert ist, mit der xFSL--Schnittstelle ausgerstet
wer!-den.

Damit keine Mižverst„ndnisse entstehen: Die Overlay--Technik und die
Reentranz, wie sie Calvino und HuGo! bieten, sind nicht Teil der
ei!-gen!-tlichen Schnittstelle und mssen von anderen Fontselektoren daher
auch nicht untersttzt werden. Allerdings ist auch die Schnittstelle
zwischen dem residenten Teil (""Shell"") und dem nachgeladenen Teil
(""Overlay"") genormt und kann daher auch von anderen Fontselektoren
verwendet werden. Eine Beschreibung dieser internen Schnittstelle ist
auf Anfrage erh„ltlich, siehe ""Kontaktadressen"".

Da bereits eine Reihe von Programmen die alte UFSL--Schnittstelle
un!-ter!-sttzen, erscheint es ratsam, auch in neuen Fontselektoren diese
Schnittstelle noch zur Verfgung zu stellen. Jedoch zeigt ein kurzer
Blick auf diese Programme, daž sie fast ausschliežlich den Fontselektor
als modalen Dialog aufrufen. Die Empfehlung lautet daher, eine minimale
UFSL--Untersttzung einzubauen (nur als modaler Dialog) und dafr die
xFSL--Schnittstelle m”glichst weitgehend zu implementieren,
da zu erwarten steht, daž gerade die --- nun endlich genormten ---
Er!-wei!-te!-rungen gegenber der (!nolink [UFSL-Schnittstelle]) von den Programmen
ver!-wen!-det werden sollen.

Ein Fontselektor sollte m”glichst die folgenden zus„tzlichen Features
bieten:
!begin_itemize
!item Gr”žen„nderung m”glich (!nl)
      Insbesondere ist damit gemeint, daž nicht nur eine Gr”že
      aus!-ge!-w„hlt, sondern bei Vektorfonts auch die Zwischengr”žen
      ein!-ge!-stellt werden k”nnen.
!item (!nolink [fix31])--Untersttzung (!nl)
      Fr einige Anwendungen reicht die Einstellung der Fontgr”že in
      Punkt nicht aus, daher sollte auch eine Einstellung in 1/65536 Punkt
      m”glich sein.
!item User--(!nolink [Popup]) (!nl)
      Durch das zus„tzliche (!nolink [Popup]) wird der Fontselektor flexibler
      ein!-setz!-bar.
!item Drag&Drop--Untersttzung (!nl)
      Neben dem ""traditionellen"" Aufruf ber den Cookie kommen L”!-sungen
      auf Drag&Drop--Basis immer mehr in Mode. Wenn der Fontselektor von
      sich aus schon Drag&Drop untersttzt, l„žt er sich leicht durch
      ein kleines ""Frontend""-Programm in einen voll!-wer!-ti!-gen
      Drag&Drop--Selektor verwandeln.
!end_itemize

Folgende Konventionen wurden fr einen xFSL--Fontselektor vereinbart:
!begin_itemize
 !item Wenn der Fontselektor ber einen Closer verfgt, so wird dieser
       als ""Abbruch"" interpretiert, d.h. es wird (!V)xFS_STOP(!v)
       zurck!-ge!-ge!-ben. Ist das Kontrollflag (!V)CC_CLOSER(!v) gesetzt,
       wird der gerade aktuelle Font aber trotzdem zurckgegeben (in der
       (!V)PFONTINFO(!v)--Struktur in (!V)xFSL_PAR(!v)).
 !item Wenn der erweiterte Aufruf ((!V)xfsl_init(!v), (!V)xfsl_event(!v)
       und (!V)xfsl_exit(!v)) nicht untersttzt wird, muž zumindest eine
       Dummy--Funktion fr (!V)xfsl_init(!v) installiert werden, die
       immer -32 (Gemdos--Fehler!-mel!-dung (!V)EINVFN(!v), ungltige
       Funktionsnummer) zurckgibt.

       Es wird aber dringend empfohlen, den erweiterten Aufruf
       an!-zu!-bie!-ten, da dieser am h„ufigsten verwendet wird.
 !item Es ist legal, daž der Fontselektor beim erweiterten Aufruf nur
       als modaler Dialog erscheint. Bei gesetztem (!V)CC_WINDOW(!v)
       sollte (!V)xfsl_init(!v) dann aber (!V)xFS_NO_WINDOW(!v)
       zurckgeben, damit sich der Auf!-rufer darauf einstellen kann.
!end_itemize

!end_node

# ########################################################################

!ifnset tos_hyp

!begin_node Kontaktadressen
!raw [stg] @alias Kontaktadressen
!raw [stg] @index "Adressen"

Die xFSL--Schnittstelle wurde von Dirk Haun und Stefan Rogel unter
tat!-kr„ftiger Mithilfe von Reiner Rosin und einer Reihe fleižiger
Beta!-tester entwickelt.

Wenn Sie Fragen und/oder (!nolink [Anmerkungen]) zur xFSL--Schnittstelle haben, dann
wenden Sie sich doch einfach an

!begin_quote
 Dirk Haun                  (!nl)
 Johanniterstr. 3           (!nl)
 D-74177 Bad Friedrichshall (!nl)
 Germany

 E-Mail: Dirk Haun @ LB~~~bzw.~~~dirk_haun@lb.maus.de
!end_quote

oder an

!begin_quote
Stefan Rogel    (!nl)
K”hlerweg 1     (!nl)
D-67661 Kaiserslautern

e-mail: Stefan Rogel @ LU (MausNet)
!end_quote

!smallskip

Das Font--Protokoll stammt von

!begin_quote
Christian Grunenberg (!nl)
Traminerweg  5       (!nl)
D-71717 Beilstein
!end_quote

#   !end_appendix

!end_node

!endif

!end_node
#!end_node

!endif
