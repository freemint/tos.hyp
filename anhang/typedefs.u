# OSHEADER: Address from p_root and p_run from the "ATARI Profibuch ST-STE-TT"

!iflang [english]

!begin_node Type definitions

In this hypertext there are references to the following data types:

!begin_table [l l l l l]
AESVARS      !! APPLRECORD   !! ARHEADER     !! BASEPAGE     !! BCB
BCONMAP      !! BITBLK       !! BPB          !! CD_DISC_INFO !! CD_TOC_ENTRY
CICON        !! CICONBLK     !! CPXINFO      !! dev_descr    !! DEVDRV
DISKINFO     !! DITHER_MODE  !! DOSTIME      !! DOSVARS      !! DRV_INFO
DSPBLOCK     !! DTA          !! EVNT         !! fcookie      !! FILEPTR
FILESYS      !! fix31        !! FNTS_ITEM    !! FONT_HDR     !! fs_descr
GEM_MUPB     !! GRECT        !! HDFUNCS      !! HNDL_OBJ     !! ICONBLK
IOREC        !! KBDVBASE     !! KEYTAB       !! LBOX_ITEM    !! LINE
ltchars      !! MAPTAB       !! MCB          !! (!link [MD][Memory Descriptor (MD) in TOS]) !! MEDIA_SIZE
MEDIA_TYPE   !! MENU         !! META_DRVINFO !! META_INFO_1  !! META_INFO_2
META_HEADER  !! MFDB         !! MFORM        !! MN_SET       !! MOUSE
MPB          !! MRETS        !! mutimbuf     !! OBJECT       !! OHEADER
OSHEADER     !! OVERPATCH    !! PARMBLK      !! PBDEF        !! PD
PDLG_SUB     !! PH           !! ploadinfo    !! POPINFO      !! PRN_ENTRY
PRN_MODE     !! PRN_TRAY     !! PRN_SETTINGS !! PRN_SWITCH   !! PUN_INFO
pxyarray     !! RGB_LIST     !! RSHDR        !! SCANX        !! SCREEN
SET_ITEM     !! sgttyb       !! SHELTAIL     !! SLCT_ITEM    !! SWINFO
tchars       !! timeval      !! timezone     !! TEDINFO      !! THREADINFO
USERBLK      !! UTXT_FN      !! winsize      !! XAESMSG      !! XATTR
XCPB         !! XDO_INF      !! XFNT_INFO    !! XFSL_FILTER  !! XSHW_COMMAND
XTED         !! xkey         !! ~      !! ~      !! ~
!end_table



!begin_node AESVARS

!begin_verbatim
typedef struct
{
     int32_t magic;                 /* Has to be 0x87654321       */
     void *membot;                  /* End of the AES variables   */
     void *aes_start;               /* Start address              */
     int32_t magic2;                /* Is 'MAGX'                  */
     int32_t date;                  /* Creation date              */
     void (*chgres)(int16_t res, int16_t txt);  /* Change resolution */
     int32_t (**shel_vector)(void); /* Resident desktop           */
     int8_t *aes_bootdrv;           /* Booting will be from here  */
     int16_t *vdi_device;           /* Driver used by AES         */
     void *reservd1;                /* Reserved                   */
     void *reservd2;                /* Reserved                   */
     void *reservd3;                /* Reserved                   */
     int16_t version;               /* Version (0x0201 is V2.1)   */
     int16_t release;               /* 0=alpha..3=release         */
} AESVARS;
!end_verbatim

(!B)Note:(!b) These variables are (!B)READ-ONLY(!b)!

The first three variables are also present under (!nolink [TOS]), and can be
obtained there from the operating system header. The (!I)vdi_device(!i)
component is superfluous as of MagiC 2.0 as one gets the device
number in a MultiTOS-compatible way with appl_getinfo (opcode 2).
The routine for changing the resolution ((!I)chgres(!i)) expects in register
d2 an optional Falcon-mode (as int16_t).

See also:
(!link [MagiC's cookie][Cookie, MagX]) ~  DOMagixAESVars
!end_node


!begin_node Archive header (ARHEADER)
!label ARHEADER

!begin_verbatim
typedef struct
{
  int8_t  a_fname[14];  /* Filename                  */
  int32_t a_modti;      /* Time of last access       */
  int8_t  a_userid;     /* Unused                    */
  int8_t  a_gid;        /* Unused                    */
  int16_t a_fimode;     /* File mode                 */
  int32_t a_fsize;      /* File length               */
  int16_t reserved;     /* Reserved                  */
} ARHEADER;
!end_verbatim

(!B)Note:(!b) An archive file in (!I)Digital Research(!i) format consists of a file-
header, any number of files (each prefaced with an ARHEADER structure)
as well as an end-identifier. The file-header here consists only of
the WORD 0xff65, the end of the archive file is identified by the
value 0x0000.

See also: OHEADER
!end_node



!begin_node Buffer Control Block (BCB)
!label BCB

!begin_verbatim
typedef struct _bcb
{
  struct _bcb   *b_link;          /* Next BCB              */
  int16_t       b_negl;           /* Initialize to -1      */
  int16_t       b_private[5];     /* Unknown               */
  void          *b_buf;           /* Actual buffer         */
} BCB;
!end_verbatim

!end_node


!begin_node CPXINFO

!begin_verbatim
typedef struct
{
    int16_t cdecl (*cpx_call)();
    void cdecl    (*cpx_draw)();
    void cdecl    (*cpx_wmove)();
    void cdecl    (*cpx_timer)();
    void cdecl    (*cpx_key)();
    void cdecl    (*cpx_button)();
    void cdecl    (*cpx_m1)();
    void cdecl    (*cpx_m2)();
    int16_t cdecl (*cpx_hook)();
    void cdecl    (*cpx_close)();
} CPXINFO;
!end_verbatim

See also:
XCONTROL ~  cpx_init
!end_node


!begin_node FlpDrvInfo

This structure plays a role in connection with (!nolink [MagiC Mac]), and is
defined as follows:

!begin_verbatim
typedef struct
{
   BOOLEAN  inserted;    /* True: disk is inserted and available */
                         /* to GEMDOS/BIOS functions             */
   BOOLEAN  highDensity; /* True: HD disk inserted, false: no or */
                         /* DD disk inserted                     */
   int16_t  res1;        /* Reserved                             */
   int32_t  res2;        /* Reserved                             */
} FlpDrvInfo;
!end_verbatim

See also:
The MagiC Mac cookie
!end_node


!begin_node GEM_MUPB

This structure describes the '(!nolink [GEM]) memory usage parameter block', which
is defined as follows:

!begin_verbatim
typdef struct
{
   int32_t gm_magic;  /* Magical value, has to be 0x87654321 */
   void *gm_end;      /* End of the memory required by GEM   */
   void *gm_init;     /* Start address of GEM                */
} GEM_MUPB;
!end_verbatim

See also:
_sysbase ~  OSHEADER ~  (!link [System variables][The system variables]) ~
(!link [System vectors][The system vectors])
!end_node


!begin_node GRECT

!begin_verbatim
typedef struct
{
   int16_t x;   /* X-coordinate */
   int16_t y;   /* Y-coordinate */
   int16_t w;   /* Width        */
   int16_t h;   /* Height       */
} GRECT;
!end_verbatim

See also:
About the AES ~ GEM ~ About the VDI
!end_node



!begin_node HDFUNCS

!begin_verbatim
typedef struct
{
    int32_t dma_begin ( void);
    int32_t dma_end   ( void );
    int32_t dma_wait  ( d0 = int32_t ticks_200hz );
    int32_t ncr_begin ( void );
    int32_t ncr_end   ( void );
    int32_t ncr_wait  ( d0 = int32_t ticks_200hz );
} HDFUNCS;
!end_verbatim

(!B)Note:(!b) Directly before the structure (2 bytes before) lies an int16_t,
which specifies the table length in int32_ts (in this case 6). All 6
pointers lie in the system variables area and may be altered in case
of need. The internal functions for the floppy drive also jump via
the 6 pointers. (!nl)
(!B)Important:(!b) The pointer (!I)hddrv_functions(!i) in the
(!link [MagX cookie][Cookie, MagX]) may (!I)not(!i) be altered.

See also: Background-DMA in MagiC
!end_node


!begin_node MacVersion

This structure plays a role in connection with (!nolink [MagiC Mac]), and is
defined as follows:

!begin_verbatim
typedef struct /* 'vers' resource definition, see Inside Mac docs */
{
   int8_t vm;       /* First part of version number in BCD */
   int8_t vn;       /* Second and third part of version    */
                    /* number in BCD                       */
   int8_t  vt;      /* Development: 0x20, alpha: 0x40,     */
                    /* beta: 0x60, release: 0x80           */
   int8_t  vd;      /* Stage of pre-release version        */
   int16_t region;  /* Region code                         */
   int8_t  str[];   /* Two version strings                 */
} MacVersion;
!end_verbatim

See also: The MagiC Mac cookie
!end_node


!begin_node Memory-Control-Block (MCB) in MagiC
!label Memory management in MagiC
!label MagiC, Memory management in
!label MCB

!begin_verbatim
typedef struct
{
    int32_t mcb_magic;        /* 'ANDR' or 'KROM' (last)       */
    int32_t mcb_len;          /* Nett length                   */
    int32_t mcb_owner;        /* Pointer to PD structure       */
    int32_t mcb_prev;         /* Previous block, or NULL       */
    int8_t mcb_data[0];
} MCB;
!end_verbatim

(!B)Note:(!b) The component (!I)mcb_magic(!i) has the value 'KROM' if no futher MCB
follows, else the value 'ANDR'. In the latter case the next MCB lies
(!I)mcb_len(!i) bytes behind the currrent MCB. The list is chained
backwards with (!I)mcb_prev(!i) which considerably speeds up many operations.

With all memory operations the component (!I)mcb_magic(!i) is always checked,
and if an error is found the system is halted immediately. For a halt
due to a memory error the address of the faulty MCB as well as the
data (4 LONGwords) are output. Subsequently one is asked on which
!label Core dump
drive one would like a (!B)core dump(!b) to be saved. If one specifies
a valid drive, then the whole ST memory from 0 to phystop is written
to the root directory of the specified drive, and is assigned the
!label Core dump, Name for
name '_sys_'. The file, depending on the ST model, can be up to 4 or
even 16 MB long, of course.

Memory-resident programs (terminating themselves with Ptermres) now
work - unlike earlier - in a way that the blocks are (!I)not(!i) released,
all MCBs remain intact and continue to be used (each time one clicks
in the menu-bar the free memory is output, for which the whole list
is run through once and during this all MCBs are checked). Those who
wish to do so can therefore release memory-resident programs (or also
parts of them) subsequently.

See also:
GEMDOS  ~ MagiC ~  (!link [MD][Memory Descriptor (MD) in TOS]) ~
Memory management
!end_node



!begin_node Memory Descriptor (MD) in TOS
!label Memory management in TOS
!label TOS, Memory management in

!begin_verbatim
typedef struct md
{
    struct md *m_link;      /* Pointer to next MD         */
    int32_t      m_start;   /* Start address of the block */
    int32_t      m_length;  /* Length of the block        */
    BASEPAGE  *m_own;       /* Pointer to the basepage    */
} MD;
!end_verbatim

(!B)Note:(!b) The component (!I)m_own(!i) here points to the basepage of the process
to which the memory block belongs.

These structures are administered in the internal memory management
of (!nolink [TOS]) (but (!I)not(!i) of MagiC!). These descriptors, as far as they are
used, hang in three memory lists, namely for free blocks, occupied
blocks and for the next block to be occupied (mem_rover). With the
mem_rover concept one attempts to achieve that consecutive Malloc
calls reserve consecutive memory if possible (this has been described
as an error already elsewhere). This is intended to reduce memory
segmentation.

(!B)This idea is unusable if several programs are running simultaneously
and call Mallocs alternately, however(!b). The concept implemented by
Atari has the advantage that it is not sensitive to programs that run
amuck, since the MDs lie is system memory, far away from user memory.
A known disadvantage of the described concept is that only a very
restricted number of (!nolink [Malloc]) calls are possible, since every call
swallows an MD of the limited system memory; this is also massively
burdened by opened folders and files. A further disadvantage of the
(!nolink [TOS]) memory management: If a program overspills a memory block, i.e.
writes past its end, then this generally passes completely unnoticed.

Specially in multitasking systems the danger of an overwritten memory
block is very much higher than in (!nolink [TOS]). Furthermore, the number of
memory blocks required, as well as those for folders (each program has
its own files and standard directories) is appreciably higher. For
these resons (!nolink [MagiC]) has a completely different concept; in that there
is only one memory list whose pointers point to the first MCB.

See also:
About the GEMDOS ~  MCB  ~ MPB ~
Memory management ~  themd
!end_node



!begin_node MRETS

!begin_verbatim
typedef struct
{
    int16_t x;
    int16_t y;
    int16_t buttons;
    int16_t kstate;
} MRETS;
!end_verbatim

See also:
cpx_button ~  cpx_m1  ~ cpx_m2 ~  XCONTROL
!end_node



!begin_node OHEADER

This structure describes the header of an object file in (!I)Digital
Research(!i) format:

!begin_verbatim
typedef struct
{
   int16_t magic;         /* Magical value: 0x601a      */
   int32_t tsize;         /* Size of the TEXT segment   */
   int32_t dsize;         /* Size of the DATA segment   */
   int32_t bsize;         /* Size of the BSS            */
   int32_t ssize;         /* Size of the symbol table   */
   int8_t reserved[10];   /* Reserved, set to zero      */
} OHEADER;
!end_verbatim

See also:
ARHEADER ~ BASEPAGE
!end_node



!begin_node OSHEADER
!label SYSHDR
!label TOS, Version number of
!label EmuTOS, Detect

!begin_verbatim
typedef struct _osheader
{
    uint16_t    os_entry;       /* BRAnch instruction to Reset-handler  */
    uint16_t    os_version;     /* TOS version number                   */
    void       *reseth;         /* Pointer to Reset-handler             */
    struct _osheader *os_beg;   /* Base address of the operating system */
    void       *os_end;         /* First byte not used by the OS        */
    int32_t     os_rsvl;        /* Reserved                             */
    GEM_MUPB   *os_magic;       /* GEM memory-usage parameter block     */
    int32_t     os_date;        /* TOS date (English !) in BCD format   */
    uint16_t    os_conf;        /* Various configuration bits           */
    uint16_t    os_dosdate;     /* TOS date in GEMDOS format            */

    /* The following components are available only as of TOS Version
       1.02 (Blitter-TOS)               */
    int8_t    **p_root;         /* Base address of the GEMDOS pool      */
    int8_t    **pkbshift;       /* Pointer to BIOS Kbshift variable
                                   (for TOS 1.00 see Kbshift)           */
    BASEPAGE  **p_run;          /* Address of the variables containing
                                   a pointer to the current GEMDOS
                                   process.                             */
    int8_t     *p_rsv2;         /* Reserved                             */
                                /* If EmuTOS is present, then 'ETOS'    */
} OSHEADER;
!end_verbatim

The structure also appears under the name SYSHDR.

!begin_xlist [os_conf]

!item [os_conf]
The component (!I)os_conf(!i) contains the so-called NTSC/PAL flag
in its lowest bit; if this bit is set, then the machine has a PAL
video system, if cleared NTSC. The remaining bits contain a country
identifier, which can serve to denote the language used for menus etc.
for instance. The folowing assignments apply:

!begin_table [c|l]
Value !! Country
!hline
 1 !! Germany
 2 !! France
 3 !! England
 4 !! Spain
 5 !! Italy
 6 !! Sweden
 7 !! French Schweiz
 8 !! German Schweiz
 9 !! Turkey
10 !! Finnland
11 !! Norway
12 !! Denmark
13 !! Saudi Araba
14 !! Holland
15 !! CSR
16 !! Hungary
127 !! All countries are supported.
!end_table

(!B)Warning:(!b) To obtain the language in use, one should fall back (!I)not(!i)
to the OSHEADER if possible, but use the (!link [_AKP][Cookie, _AKP]) cookie or the
function appl_getinfo (opcode 3).

!item [p_root]
With older TOS versions the address of (!I)p_root(!i) is 0x56FA.

!item [p_run]
!begin_verbatim
BASEPAGE **GetRun (void)
{
  int32_t savessp = Super (0L);
  OSHEADER *O = *((OSHEADER **)(0x4f2L);
  Super ((void *) savessp );

  O = O->os_beg;   /* wegen eines Fehlers in alter AHDI-Version */

  if (O->os_version < 0x102)
  {
    if ((O->os_conf >> 1) == 4)      /* PAL-Modus wegshiften */
      return ((BASEPAGE **)0x873c);  /* Spanisches TOS 1.0   */
    else
      return ((BASEPAGE **)0x602c);
  }
  else
    return O->p_run;
}
!end_verbatim

!end_xlist


See also:
Kbshift ~  _sysbase ~ (!link [System variables][The system variables]) ~
(!link [System vectors][The system vectors])

!end_node


!begin_node PrintDesc

This structure plays a role in connection with (!nolink [MagiC Mac]), and is
defined as follows:

!begin_verbatim
typedef struct
{
    THPrint     printHdl;       /* Printer-configuration for NVDI */
    PrSetupProc doPrintSetup;   /* ditto                          */
    VoidProcPtr saveSetup;      /* ditto                          */
    int32_t     reserved[7];    /* Reserved                       */
} PrintDesc;
!end_verbatim

See also:  The MagiC Mac cookie
!end_node



!begin_node RGB_LIST

!begin_verbatim
typedef struct
{
    uint16_t red;     /* Red proportion in parts per thousand   */
    uint16_t green;   /* Green proportion in parts per thousand */
    uint16_t blue;    /* Blue proportion in parts per thousand  */
} RGB_LIST;
!end_verbatim

See also: (!link [XIMG format][The XIMG format for pixel images])
!end_node



!begin_node THREADINFO

!begin_verbatim
typedef struct
{
   int32_t cdecl (*proc)(void *par);
   void          *user_stack;
   uint32_t      stacksize;
   int16_t       mode;
   int32_t       res1;
} THREADINFO;
!end_verbatim

(!B)Note:(!b) If the component (!I)user_stack(!i) is NULL, then the system will
create the stack itself. When the thread terminates, the system will
release the stack again automatically. The component (!I)stacksize(!i) must
always be specified so that the system can set the stack pointer of
the thread to the end of the stack. The supervisior-stack is set by
the operating system, so that its size cannot be influenced.

The components (!I)mode(!i) and (!I)res1(!i) are reserved for future purposes, so
they should be set to the value 0 or 0L. In Solaris 2.x, for instance,
one can arrest the thread up to the final start with them. The started
thread executes the function (!I)proc(!i), which is passed as a parameter to
the component (!I)par(!i) (on the stack). The CPU registers d0-d2 and a0-a2
may be altered by the function.

See also:
Threads in MagiC ~  shel_write ~
Sample code
!end_node


!begin_node XCPB

!begin_verbatim
typedef struct
{
    int16_t       handle;
    int16_t       booting;
    int16_t       reserved;
    int16_t       SkipRshFix;
    void          *reserve1;
    void          *reserve2;
    void cdecl    (*rsh_fix)      ( int num_objs, int num_frstr, int num_frimg,
                                    int num_tree, OBJECT *rs_object,
                                    TEDINFO *rs_tedinfo, char *rs_strings[],
                                    ICONBLK *rs_iconblk, BITBLK *rs_bitblk,
                                    long *rs_frstr, long *rs_frimg, long *rs_trindex,
                                    struct foobar *rs_imdope );
    void cdecl    (*rsh_obfix)    ( OBJECT *tree, int curob );
    int16_t cdecl (*Popup)        ( char *items[], int num_items, int default_item,
                                    int font_size, GRECT *button, GRECT *world );
    void cdecl    (*Sl_size)      ( OBJECT *tree, int base, int slider, int num_items,
                                    int visible, int direction, int min_size );
    void cdecl    (*Sl_x)         ( OBJECT *tree, int base, int slider, int value,
                                    int num_min, int num_max, void (*foo)() );
    void cdecl    (*Sl_y)         ( OBJECT *tree, int base, int slider,  int value,
                                    int num_min, int num_max, void (*foo)() );
    void cdecl    (*Sl_arrow)     ( OBJECT *tree, int base, int slider, int obj,
                                    int inc, int min, int max, int *numvar,
                                    int direction, void (*foo)() );
    void cdecl    (*Sl_dragx)     ( OBJECT *tree, int base, int slider,
                                    int min, int max, int *numvar, void (*foo)() );
    void cdecl    (*Sl_dragy)     ( OBJECT *tree, int base, int slider,
                                    int min, int max, int *numvar, void (*foo)() );
    int16_t cdecl (*Xform_do)     ( OBJECT *tree, int start_field, int puntmsg[] );
    GRECT * cdecl (*GetFirstRect) ( GRECT *prect );
    GRECT * cdecl (*GetNextRect)  ( void );
    void cdecl    (*Set_Evnt_Mask)( int mask, MOBLK *m1, MOBLK *m2, long time );
    int16_t cdecl (*XGen_Alert)   ( int id );
    int16_t cdecl (*CPX_Save)     ( void *ptr, long num );
    void * cdecl  (*Get_Buffer)   ( void );
    int16_t cdecl (*getcookie)    ( long cookie, long *p_value );
    int16_t       Country_Code;
    void cdecl    (*MFsave)       ( int saveit, MFORM *mf );
} XCPB;
!end_verbatim

See also:
cpx_init ~  XCONTROL
!end_node

!end_node

!else

!begin_node Typdefinitionen

In diesem Hypertext finden sich Verweise auf die folgenden Datentypen:

!begin_table [l l l l l]
AESVARS      !! APPLRECORD   !! ARHEADER     !! BASEPAGE     !! BCB
BCONMAP      !! BITBLK       !! BPB          !! CD_DISC_INFO !! CD_TOC_ENTRY
CICON        !! CICONBLK     !! CPXINFO      !! dev_descr    !! DEVDRV
DISKINFO     !! DITHER_MODE  !! DOSTIME      !! DOSVARS      !! DRV_INFO
DSPBLOCK     !! DTA          !! EVNT         !! fcookie      !! FILEPTR
FILESYS      !! fix31        !! FNTS_ITEM    !! FONT_HDR     !! fs_descr
GEM_MUPB     !! GRECT        !! HDFUNCS      !! HNDL_OBJ     !! ICONBLK
IOREC        !! KBDVBASE     !! KEYTAB       !! LBOX_ITEM    !! LINE
ltchars      !! MAPTAB       !! MCB          !! (!link [MD][Memory-Deskriptor (MD)]) !! MEDIA_SIZE
MEDIA_TYPE   !! MENU         !! META_DRVINFO !! META_INFO_1  !! META_INFO_2
META_HEADER  !! MFDB         !! MFORM        !! MN_SET       !! MOUSE
MPB          !! MRETS        !! mutimbuf     !! OBJECT       !! OHEADER
OSHEADER     !! OVERPATCH    !! PARMBLK      !! PBDEF        !! PD
PDLG_SUB     !! PH           !! ploadinfo    !! POPINFO      !! PRN_ENTRY
PRN_MODE     !! PRN_TRAY     !! PRN_SETTINGS !! PRN_SWITCH   !! PUN_INFO
pxyarray     !! RGB_LIST     !! RSHDR        !! SCANX        !! SCREEN
SET_ITEM     !! sgttyb       !! SHELTAIL     !! SLCT_ITEM    !! SWINFO
tchars       !! timeval      !! timezone     !! TEDINFO      !! THREADINFO
USERBLK      !! UTXT_FN      !! winsize      !! XAESMSG      !! XATTR
XCPB         !! XDO_INF      !! XFNT_INFO    !! XFSL_FILTER  !! XSHW_COMMAND
XTED         !! xkey         !! ~      !! ~      !! ~
!end_table



!begin_node AESVARS

!begin_verbatim
typedef struct
{
     int32_t magic;                 /* muû $87654321 sein         */
     void *membot;                  /* Ende der AES- Variablen    */
     void *aes_start;               /* Startadresse               */
     int32_t magic2;                /* ist 'MAGX'                 */
     int32_t date;                  /* Erstelldatum               */
     void (*chgres)(int16_t res, int16_t txt);  /* Auflîsung Ñndern    */
     int32_t (**shel_vector)(void); /* residentes Desktop         */
     int8_t *aes_bootdrv;           /* von hieraus wurde gebootet */
     int16_t *vdi_device;           /* vom AES benutzter Treiber  */
     void *reservd1;                /* reserviert                 */
     void *reservd2;                /* reserviert                 */
     void *reservd3;                /* reserviert                 */
     int16_t version;               /* Version ($0201 ist V2.1)   */
     int16_t release;               /* 0=alpha..3=release         */
} AESVARS;
!end_verbatim

(!B)Hinweis:(!b) Diese Variablen sind READ-ONLY!

Die ersten drei Variablen sind auch unter TOS vorhanden, und kînnen dort
Åber den Betriebssystem-Header ermittelt werden. Die Komponente
(!I)vdi_device(!i) ist ab MagiC 2.0 ÅberflÅssig, weil man die GerÑtenummer
Multi-TOS kompatibel Åber appl_getinfo (Opcode 2) erhÑlt. Die Routine zum
éndern der Auflîsung ((!I)chgres(!i)) erwartet im Register d2 einen
optionalen Falcon-Modus (als int16_t).

Querverweis:
(!link [Cookie von MagiC][Cookie, MagX]) ~  DOMagixAESVars
!end_node


!begin_node Archivheader (ARHEADER)
!label ARHEADER

!begin_verbatim
typedef struct
{
  int8_t  a_fname[14];  /* Dateiname                 */
  int32_t a_modti;      /* Zeitpunkt letzter Zugriff */
  int8_t  a_userid;     /* unbenutzt                 */
  int8_t  a_gid;        /* unbenutzt                 */
  int16_t a_fimode;     /* Filemodus                 */
  int32_t a_fsize;      /* DateilÑnge                */
  int16_t reserved;     /* reserviert                */
} ARHEADER;
!end_verbatim

(!B)Hinweis:(!b) Eine Archivdatei im (!I)Digital-Research-Format(!i) besteht
aus einem Dateikopf, beliebig vielen Dateien (jeweils durch eine
ARHEADER-Struktur eingeleitet) sowie einer Ende-Kennung. Der Dateikopf
besteht dabei lediglich aus dem Wort 0xff65, das Ende der Archivdatei wird
durch den Wert 0x0000 gekennzeichnet.

Querverweis: OHEADER
!end_node



!begin_node Buffer-Control-Block (BCB)
!label BCB

!begin_verbatim
typedef struct _bcb
{
  struct _bcb   *b_link;          /* nÑchster BCB          */
  int16_t       b_negl;           /* auf -1 initialisieren */
  int16_t       b_private[5];     /* unbekannt             */
  void          *b_buf;           /* eigentlicher Puffer   */
} BCB;
!end_verbatim

!end_node


!begin_node CPXINFO

!begin_verbatim
typedef struct
{
    int16_t cdecl (*cpx_call)();
    void cdecl    (*cpx_draw)();
    void cdecl    (*cpx_wmove)();
    void cdecl    (*cpx_timer)();
    void cdecl    (*cpx_key)();
    void cdecl    (*cpx_button)();
    void cdecl    (*cpx_m1)();
    void cdecl    (*cpx_m2)();
    int16_t cdecl (*cpx_hook)();
    void cdecl    (*cpx_close)();
} CPXINFO;
!end_verbatim

Querverweis:
XCONTROL ~  cpx_init
!end_node


!begin_node FlpDrvInfo

Diese Struktur spielt im Zusammenhang mit (!nolink [MagiC Mac]) eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct
{
   BOOLEAN  inserted;    /* true: disk is inserted and available */
                         /* to GEMDOS/BIOS functions             */
   BOOLEAN  highDensity; /* true: HD disk inserted, false: none  */
                         /* or DD disk inserted                  */
   int16_t    res1;        /* reserved */
   int32_t  res2;        /* reserved */
} FlpDrvInfo;
!end_verbatim

Querverweis:
(!link [Cookie von MagiC Mac][Der Cookie von MagiC Mac])
!end_node


!begin_node GEM_MUPB

Diese Struktur beschreibt den '(!nolink [GEM]) memory usage parameter block', der wie
folgt definiert ist:

!begin_verbatim
typdef struct
{
   int32_t gm_magic;  /* muss 0x87654321 sein                  */
   void *gm_end;      /* Ende des vom GEM benîtigten Speichers */
   void *gm_init;     /* Startadresse von GEM                  */
} GEM_MUPB;
!end_verbatim

Querverweis:
_sysbase ~  OSHEADER ~  (!link [Systemvariablen][Die Systemvariablen]) ~
(!link [Systemvektoren][Die Systemvektoren])
!end_node

!begin_node GRECT

!begin_verbatim
typedef struct
{
   int16_t x;   /* x-Koordinate */
   int16_t y;   /* y-Koordinate */
   int16_t w;   /* Breite       */
   int16_t h;   /* Hîhe         */
} GRECT;
!end_verbatim

Querverweis:
AES ~  GEM  ~ VDI
!end_node



!begin_node HDFUNCS

!begin_verbatim
typedef struct
{
    int32_t dma_begin ( void);
    int32_t dma_end   ( void );
    int32_t dma_wait  ( d0 = int32_t ticks_200hz );
    int32_t ncr_begin ( void );
    int32_t ncr_end   ( void );
    int32_t ncr_wait  ( d0 = int32_t ticks_200hz );
} HDFUNCS;
!end_verbatim

(!B)Hinweis:(!b) Direkt vor der Struktur (2 Bytes vorher) liegt ein int16_t,
das die TabellenlÑnge in int32_ts angibt (in diesem Fall 6). Alle 6 Zeiger
liegen im Systemvariablenbereich und dÅrfen notfalls verÑndert werden. Die
internen Funktionen fÅr die Floppy springen ebenfalls Åber die 6 Zeiger.
(!B)Wichtig:(!b) Der Zeiger (!I)hddrv_functions(!i) im MagX-Cookie darf
(!I)nicht(!i) verÑndert werden.

Querverweis: Hintergrund-DMA in MagiC
!end_node


!begin_node MacVersion

Diese Struktur spielt im Zusammenhang mit MagiC Mac eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct /* 'vers' resource definition, see Inside Mac docs */
{
   int8_t vm;       /* first part of version number in BCD */
   int8_t vn;       /* second and third part of version    */
                    /* number in BCD                       */
   int8_t  vt;      /* development: 0x20, alpha: 0x40,     */
                    /* beta: 0x60, release: 0x80           */
   int8_t  vd;      /* stage of prerelease version         */
   int16_t region;    /* region code                         */
   int8_t  str[];   /* two version strings                 */
} MacVersion;
!end_verbatim

Querverweis: (!link [Cookie von MagiC Mac][Der Cookie von MagiC Mac])
!end_node


!begin_node Memory-Control-Block (MCB)
!label Speicherverwaltung in MagiC
!label MagiC, Speicherverwaltung in
!label MCB

!begin_verbatim
typedef struct
{
    int32_t mcb_magic;        /* 'ANDR' oder 'KROM' (letzter)    */
    int32_t mcb_len;          /* NettolÑnge                      */
    int32_t mcb_owner;        /* Zeiger auf PD-Struktur          */
    int32_t mcb_prev;         /* vorh. Block oder NULL           */
    int8_t mcb_data[0];
} MCB;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)mcb_magic(!i) besitzt den Wert 'KROM',
falls kein weiterer MCB folgt, und anderenfalls den Wert 'ANDR'. Im
letzteren Fall liegt der nÑchste MCB (!I)mcb_len(!i) Bytes hinter dem
aktuellen MCB. Die Liste ist per (!I)mcb_prev(!i) rÅckwÑrts verkettet, was
viele Operationen erheblich beschleunigt.

Bei allen Speicheroperationen wird immer die Komponente (!I)mcb_magic(!i)
ÅberprÅft, und das System bei einem Fehler sofort angehalten. Beim Anhalten
aufgrund eines Speicherfehlers werden die Adresse des fehlerhaften MCB sowie
die Daten (4 Langworte) ausgegeben. Anschlieûend wird man gefragt, auf
!label core dump
!label Systemauszug (core dump)
welches Laufwerk man einen (!B)Systemauszug (core dump)(!b) speichern
mîchte. Gibt man ein gÅltiges Laufwerk an, so wird der gesamte ST-Speicher
von 0 bis phystop auf das Wurzelverzeichnis des angegebenen Laufwerks
!label core dump, Name fÅr
geschrieben, und zwar unter dem Namen "_sys_". Die Datei kann natÅrlich je
nach ST-Modell bis zu 4 oder gar 16 MB lang werden.

Speicherresidente Programme (beenden sich Åber Ptermres) arbeiten jetzt im
Gegensatz zu frÅher einfach nur so, daû die Blîcke (!I)nicht(!i) freigegeben
werden, alle MCBs bleiben intakt und werden auch weiterhin benutzt
(jedesmal, wenn man in die MenÅleiste klickt, wird der freie Speicher
ausgegeben, dazu wird die gesamte Liste einmal durchlaufen und dabei alle
MCBs ÅberprÅft).  Wer mîchte, kann also speicherresidente Programme (oder
auch Teile davon) nachtrÑglich freigeben.

Querverweis:
GEMDOS  ~ MagiC ~  (!link [MD][Memory-Deskriptor (MD)]) ~
Speicherverwaltung
!end_node



!begin_node Memory-Deskriptor (MD)
!label Speicherverwaltung in TOS
!label TOS, Speicherverwaltung in

!begin_verbatim
typedef struct md
{
    struct md *m_link;      /* Zeiger auf nÑchsten MD    */
    int32_t      m_start;   /* Anfangsadresse des Blocks */
    int32_t      m_length;  /* LÑnge des Blocks          */
    BASEPAGE  *m_own;       /* Zeiger auf die Basepage   */
} MD;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)m_own(!i) zeigt dabei auf die Basepage
des Prozesses, dem der Speicherblock gehîrt.

Diese Strukturen werden in der internen Speicherverwaltung von TOS (aber
(!I)nicht(!i) von MagiC!) verwaltet. Diese Deskriptoren, soweit benutzt,
hÑngen in drei Speicherlisten, und zwar fÅr freie Blîcke, belegte Blîcke und
fÅr den nÑchsten zu belegenden Block (mem_rover). Mit dem mem_rover-Konzept
sollte erreicht werden, daû aufeinanderfolgende Malloc-Aufrufe mîglichst
aufeinanderfolgenden Speicher anfordern (wurde an anderer Stelle schon als
Fehler bezeichnet). Damit sollte die Segmentierung verringert werden.

(!B)Diese Idee ist jedoch unbrauchbar, wenn mehrere Programme gleichzeitig
laufen und abwechselnd Mallocs machen(!b). Das von Atari implementierte
Konzept hat den Vorteil, daû es unempfindlich gegen amoklaufende Programme
ist, da die MDs im Systemspeicher liegen, weit weg vom Benutzerspeicher. Ein
bekannter Nachteil des beschriebenen Konzepts ist, daû nur eine sehr
begrenzte Anzahl von (!nolink [Malloc])-Aufrufen mîglich sind, da jeder Aufruf einen MD
des begrenzten Systemspeichers aufzehrt; dieser wird auûerdem noch massiv
von geîffneten Ordnern und Dateien belastet. Ein weiterer Nachteil der
Speicherverwaltung des TOS: Wenn ein Programm einen Speicherblock Åberlaufen
lÑût, d.h. Åber dessen Ende hinausschreibt, bleibt dies i.a. vîllig
unbemerkt.

Besonders im Multitaskingsystem ist die Gefahr eines Åberschriebenen
Speicherblocks ungleich hîher als im TOS. Ferner ist die Anzahl der
benîtigten Speicherblîcke sowie auch die der Ordner (jedes Programm hat
eigene Dateien und Standardverzeichnisse) wesentlich hîher. Aus diesem Grund
hat (!nolink [MagiC]) ein vîllig anderes Konzept; dort gibt es nur noch eine
Speicherliste deren Zeiger auf den ersten MCB zeigt.

Querverweis:
GEMDOS ~  MCB  ~ MPB ~
Speicherverwaltung ~  themd
!end_node



!begin_node MRETS

!begin_verbatim
typedef struct
{
    int16_t x;
    int16_t y;
    int16_t buttons;
    int16_t kstate;
} MRETS;
!end_verbatim

Querverweis:
cpx_button ~  cpx_m1  ~ cpx_m2 ~  XCONTROL
!end_node



!begin_node OHEADER

Diese Struktur beschreibt den Header einer Objektdatei im
(!I)Digital-Research(!i) Format:

!begin_verbatim
typedef struct
{
   int16_t magic;         /* magischer Wert: 0x601a      */
   int32_t tsize;         /* Grîûe des Text-Segments     */
   int32_t dsize;         /* Grîûe des Data-Segments     */
   int32_t bsize;         /* Grîûe der BSS               */
   int32_t ssize;         /* Grîûe der Symboltabelle     */
   int8_t reserved[10];   /* reserviert, auf Null setzen */
} OHEADER;
!end_verbatim

Querverweis:
ARHEADER  ~ BASEPAGE
!end_node



!begin_node OSHEADER
!label SYSHDR

!label TOS, Versionsnummer von
!label EmuTOS, Ermitteln von
!begin_verbatim
typedef struct _osheader
{
    uint16_t    os_entry;       /* BRAnch-Instruktion zum Reset-Handler */
    uint16_t    os_version;     /* TOS-Versionsnummer                   */
    void       *reseth;         /* Zeiger auf Reset-Handler             */
    struct _osheader *os_beg;   /* Basisadresse des Betriebssystems     */
    void       *os_end;         /* erstes nicht vom BS benutztes Byte   */
    int32_t     os_rsvl;        /* reserviert                           */
    GEM_MUPB   *os_magic;       /* GEM-Memory-Usage-Parameter-Block     */
    int32_t     os_date;        /* TOS-Datum (englisch !) im BCD-Format */
    uint16_t    os_conf;        /* verschiedene Konfigurationsbits      */
    uint16_t    os_dosdate;     /* TOS-Datum im GEMDOS-Format           */

    /* Die folgenden Komponenten stehen erst ab TOS-Version 1.02
       (Blitter-TOS) zur VerfÅgung */
    int8_t    **p_root;         /* Basisadresse des GEMDOS-Pools        */
    int8_t    **pkbshift;       /* Zeiger auf BIOS-Kbshift-Variable
                                   FÅr TOS 1.00 siehe Kbshift           */
    BASEPAGE  **p_run;          /* Adresse der Variablen, die einen
                                   Zeiger auf den aktuellen GEMDOS-
                                   Prozess enthÑlt.                     */
    int8_t     *p_rsv2;         /* reserviert                           */
                                /* Falls EmuTOS vorhanden, dann 'ETOS'  */
} OSHEADER;
!end_verbatim

Die Struktur tauch auch unter dem Namen SYSHDR auf.

(!B)Hinweis:(!b)

!begin_xlist [os_conf]

!item [os_conf]
Die Komponente (!I)os_conf(!i) enthÑlt im untersten Bit das
sogenannte NTSC/PAL-Flag; ist dieses Bit gesetzt, so handelt es sich um ein
PAL-Videosystem. Die restlichen Bits beinhalten eine LÑnderkennung, die z.B.
dazu dienen kann, die zu benutzende Sprache zu erkennen. Es gilt die
folgende Belegung:

!begin_table [c|l]
Wert !! Land
!hline
 0 !! USA
 1 !! Deutschland
 2 !! Frankreich
 3 !! England
 4 !! Spanien
 5 !! Italien
 6 !! Schweden
 7 !! franz. Schweiz
 8 !! deutsche Schweiz
 9 !! TÅrkei
10 !! Finnland
11 !! Norwegen
12 !! DÑnemark
13 !! Saudi-Arabien
14 !! Niederlande
15 !! CSSR
16 !! Ungarn
127 !! Alle LÑnder werden unetrstÅtzt.
!end_table

(!B)Achtung:(!b) Um die zu benutzende Sprache zu ermitteln, sollte nach
Mîglichkeit (!I)nicht(!i) auf den OSHEADER, sondern auf den
(!link [_AKP][Cookie, _AKP])-Cookie bzw.
auf die Funktion appl_getinfo (Opcode 3) zurÅckgegriffen werden.

!item [p_root]
Bei TOS 1.00 befindet sich der Zeiger bei der Adresse 0x56FA.

!item [p_run]
!begin_verbatim
BASEPAGE **GetRun (void)
{
  int32_t savessp = Super (0L);
  OSHEADER *O = *((OSHEADER **)(0x4f2L);
  Super ((void *) savessp );

  O = O->os_beg;   /* wegen eines Fehlers in alter AHDI-Version */

  if (O->os_version < 0x102)
  {
    if ((O->os_conf >> 1) == 4)      /* PAL-Modus wegshiften */
      return ((BASEPAGE **)0x873c);  /* Spanisches TOS 1.0   */
    else
      return ((BASEPAGE **)0x0x602c);
  }
  else
    return O->p_run;
}
!end_verbatim

!end_xlist

Querverweis:
Kbshift ~  _sysbase ~
(!link [Systemvariablen][Die Systemvariablen]) ~
(!link [Systemvektoren][Die Systemvektoren])

!end_node


!begin_node PrintDesc

Diese Struktur spielt im Zusammenhang mit MagiC Mac eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct
{
    THPrint     printHdl;       /* Printer-Konfiguration fÅr NVDI */
    PrSetupProc doPrintSetup;   /* dto.                           */
    VoidProcPtr saveSetup;      /* dto.                           */
    int32_t     reserved[7];    /* reserviert                     */
} PrintDesc;
!end_verbatim

Querverweis:  (!link [Cookie von MagiC Mac][Der Cookie von MagiC Mac])
!end_node



!begin_node RGB_LIST

!begin_verbatim
typedef struct
{
    uint16_t red;     /* Rot-Anteil  in Promille */
    uint16_t green;   /* GrÅn-Anteil in Promille */
    uint16_t blue;    /* Blau-Anteil in Promille */
} RGB_LIST;
!end_verbatim

Querverweis: (!link [XIMG-Format][Das XIMG-Format fÅr Pixelbilder])
!end_node



!begin_node THREADINFO

!begin_verbatim
typedef struct
{
   int32_t cdecl (*proc)(void *par);
   void          *user_stack;
   uint32_t      stacksize;
   int16_t       mode;
   int32_t       res1;
} THREADINFO;
!end_verbatim

(!B)Hinweis:(!b) Ist die Komponente (!I)user_stack(!i) NULL, so legt das
System selbst den Stack an. Wenn der Thread terminiert, wird der Stack
automatisch vom System wieder freigegeben. Die Komponente (!I)stacksize(!i)
ist in jedem Fall anzugeben, damit das System den Stackpointer des Threads
auf das Ende des Stacks setzen kann. Der Systemstapel (Supervisior-Stack)
wird vom Betriebssystem selbst festgelegt, so daû dessen Grîûe nicht
beeinfluût werden kann.

Die Komponenten (!I)mode(!i) und (!I)res1(!i) sind fÅr zukÅnftige Zwecke
reserviert, und sollten deshalb auf den Wert 0 bzw. 0L gesetzt werden. In
Solaris 2.x kann man damit z.B. einen Thread bis zum endgÅltigen Start
anhalten. Der gestartete Thread fÅhrt die Funktion (!I)proc(!i) aus, der als
Parameter die Komponente (!I)par(!i) (auf dem Stack) Åbergeben wird. Die
CPU-Register d0-d2 und a0-a2 dÅrfen von der Funktion verÑndert werden.

Querverweis:
Threads in MagiC ~  shel_write ~
(!link [Beispiel-Code][Threads, Beispiel-Code zu])
!end_node


!begin_node XCPB

!begin_verbatim
typedef struct
{
    int16_t       handle;
    int16_t       booting;
    int16_t       reserved;
    int16_t       SkipRshFix;
    void          *reserve1;
    void          *reserve2;
    void cdecl    (*rsh_fix)      ( int num_objs, int num_frstr, int num_frimg,
                                    int num_tree, OBJECT *rs_object,
                                    TEDINFO *rs_tedinfo, char *rs_strings[],
                                    ICONBLK *rs_iconblk, BITBLK *rs_bitblk,
                                    long *rs_frstr, long *rs_frimg, long *rs_trindex,
                                    struct foobar *rs_imdope );
    void cdecl    (*rsh_obfix)    ( OBJECT *tree, int curob );
    int16_t cdecl (*Popup)        ( char *items[], int num_items, int default_item,
                                    int font_size, GRECT *button, GRECT *world );
    void cdecl    (*Sl_size)      ( OBJECT *tree, int base, int slider, int num_items,
                                    int visible, int direction, int min_size );
    void cdecl    (*Sl_x)         ( OBJECT *tree, int base, int slider, int value,
                                    int num_min, int num_max, void (*foo)() );
    void cdecl    (*Sl_y)         ( OBJECT *tree, int base, int slider,  int value,
                                    int num_min, int num_max, void (*foo)() );
    void cdecl    (*Sl_arrow)     ( OBJECT *tree, int base, int slider, int obj,
                                    int inc, int min, int max, int *numvar,
                                    int direction, void (*foo)() );
    void cdecl    (*Sl_dragx)     ( OBJECT *tree, int base, int slider,
                                    int min, int max, int *numvar, void (*foo)() );
    void cdecl    (*Sl_dragy)     ( OBJECT *tree, int base, int slider,
                                    int min, int max, int *numvar, void (*foo)() );
    int16_t cdecl (*Xform_do)     ( OBJECT *tree, int start_field, int puntmsg[] );
    GRECT * cdecl (*GetFirstRect) ( GRECT *prect );
    GRECT * cdecl (*GetNextRect)  ( void );
    void cdecl    (*Set_Evnt_Mask)( int mask, MOBLK *m1, MOBLK *m2, long time );
    int16_t cdecl (*XGen_Alert)   ( int id );
    int16_t cdecl (*CPX_Save)     ( void *ptr, long num );
    void * cdecl  (*Get_Buffer)   ( void );
    int16_t cdecl (*getcookie)    ( long cookie, long *p_value );
    int16_t       Country_Code;
    void cdecl    (*MFsave)       ( int saveit, MFORM *mf );
} XCPB;
!end_verbatim

Querverweis:
cpx_init ~  XCONTROL
!end_node

!end_node

!endif
