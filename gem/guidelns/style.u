!iflang [english]

!include gem/guidelns/style_en.u

!else

!begin_node Drei wichtige Programmierregeln
!html_name guidelines_rules

Da das Betriebssystem TOS relativ sauber in mehrere Schichten gegliedert
ist, sollten alle Programmierer bei der Erstellung einer Applikation die
folgenden drei Regeln im Hinterkopf behalten:

!begin_itemize
!item (!B)Niemals(!b) fÅr eine Aufgabe Aufrufe verschiedener
Betriebssystemschichten vermischen. Beispiel: In GEM-Programmen werden Maus
und Tastatur per AES abgefragt, und nicht etwa Åber das BIOS. Die Miûachtung
dieser Regel kann zu Konflikten zwischen den verschiedenen Schichten fÅhren.
!item (!B)Niemals(!b) von irgendwelchen unsicheren Annahmen Åber interne
ZusammenhÑnge zwischen den einzelnen Schichten ausgehen. Beispiel: Ein
GEMDOS Laufwerk kann sowohl auf einem (!nolink [BIOS])- als auch auf einem MetaDOS
GerÑt liegen. Die Maus hÑngt normalerweise am Tastaturchip, sie muss es aber
nicht (neue Hardware, Tastaturinterfaces etc.)
!item (!B)Immer(!b) nach Mîglichkeit die hîchste Betriebssystemschicht fÅr
eine Aufgabe benutzen. Beispiel: Die zu benutzende Sprache kînnte zwar aus
dem Betriebssystemheader ermittelt werden, besser ist es jedoch, hierfÅr
den (!link [_AKP][Cookie, _AKP])-Cookie bzw. die Funktion appl_getinfo zu benutzen.
!end_itemize

(!B)DarÅber hinaus existieren viele weitere Programmierregeln, die
eigentlich bekannt sein sollten, aber leider immer noch nicht von allen
Applikationen beachtet werden. Einige Beispiele:(!b)

!begin_itemize
!item Nur soviel Speicherplatz belegen wie unbedingt nîtig ist, damit in
einer Multitasking-Umgebung auch noch andere Prozesse gestartet werden bzw.
sinnvoll arbeiten kînnen.
!item Den Eintritt in den Supervisor-Modus so oft wie nur mîglich
(!I)vermeiden(!i), da er eigentlich nur fÅr das Betriebssystem gedacht ist,
und in vielen Umgebungen (!I)kein(!i) Task-Switching stattfindet, wenn sich
ein Prozess in diesem Modus befindet.
!item Niemals direkt in den Bildschirmspeicher schreiben, sondern
stattdessen auf die jeweiligen (!nolink [GEM])-Funktionen ((!nolink [AES]), 
(!nolink [VDI])) zurÅckgreifen.
!item Niemals auf Speicher zugreifen der nicht dem eigenen Programm gehîrt,
oder fÅr dieses zugÑnglich gemacht worden ist, da es in Systemen mit
Speicherschutz sonst zu einer Exception kommt. Ferner sollte Speicher immer
so alloziert werden, daû andere Prozesse mîglichst (!I)nicht(!i) auf diesen
zugreifen kînnen.
!end_itemize
!end_node


!begin_node Style-Guidelines
!label Guidelines, Style-
!html_name guidelines_styles

Wenn man mehrere (!nolink [GEM])-Applikationen der gleichen Kategorie betrachtet, so 
fÑllt auf, daû einige Programme leicht und andere wiederum sehr schwer zu
bedienen sind. Eine Textverarbeitung wie z.B. (!I)Papyrus(!i) dÅrfte
sicherlich von den meisten Anwendern problemlos zu bedienen sein; ganz im
Gegensatz zu Programmen wie (!I)Signum!2(!i), das vielen Benutzern den
Angstschweiû auf die Stirn treibt.

Ob ein Programm leicht zu bedienen ist, hÑngt in hohem Maûe von der
Gestaltung der Benutzerschnittstelle ab. Dieses Kapitel versucht einige Tips
zur Gestaltung des User-Interfaces zu geben, und behandelt die folgenden
Punkte bzw. Aspekte:

!begin_itemize !compressed
!item Dialogboxen
!item Hilfesysteme
!item Mausklicks und Formen
!item MenÅs und MenÅzeilen
!item Optische und akustische RÅckmeldungen
!item Selektionen
!item Spezialeffekte
!item Tastaturbelegung
!item Toolboxen
!end_itemize

Allen Software-Entwicklern wird dringend empfohlen, den hier gemachten
Empfehlungen Folge zu leisten bzw. sich an vorbildlichen GEM-Applikationen
zu orientieren. Die Akzeptanz eines Programms (und damit der
Verkaufserfolg) hÑngt neben der FunktionalitÑt zu einem groûen Teil von der
Gestaltung der Benutzerschnittstelle ab.

Beispiele fÅr Fehler im GUI-Design bzw. eine schlechte BenutzerfÅhrung
findet man unter http://www.iarchitect.com/mshame.htm.

Querverweis: AES ~  VDI  ~ (!link [GDOS][Das GDOS])

!begin_node Dialogboxen
!label Dialogboxen, Gestaltung von

Bei der Gestaltung der Dialogboxen sollte ein Software-Entwickler auf eine
innere und Ñuûere Konsistenz achten, d.h. er sollte sich an vorbildlichen
Dialogboxen anderer Programme orientieren (Ñuûere Konsistenz), und darauf
achten, daû innerhalb seiner Anwendung die Dialogboxen ein einheitliches
Outfit erhalten (innere Konsistenz).

!label Dialogboxen, Design-Regeln fÅr
(!B)Die folgende Liste nennt beispielhaft einige Aspekte, die beim Design
von Dialogboxen beachtet werden sollten:(!b)

!begin_itemize
!item gleicher Aufbau aller Dialogboxen der Applikation
!item mîglichst gleicher Aufbau der Dialogboxen aller Applikationen
!item jeder Dialog sollte eine in sich abgeschlossene Teilaufgabe behandeln
!item fÅr gleiche Aktionen einheitliche Buttons verwenden
!item Informationen in logische Blîcke aufspalten
!item ÅberflÅssige Informationen weglassen
!item nicht zu viele Objekte auf einer Ebene verwenden
!item aktivierbare Elemente deutlich von Anzeigen trennen
!item (!nolink [Spezialeffekte]) und Farben sehr Åberlegt und sparsam einsetzen
!end_itemize

DarÅber hinaus sollte man sich genau Åberlegen, welche Art von Dialog fÅr
welchen Zweck eingesetzt wird. Hier lassen sich die folgenden Dialogarten
unterscheiden:

!label Dialogboxen, Alert-
!label Alertboxen
!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2045
!else
!image (!picture_path)\img2045
!endif
!else
!image (!picture_path)\img2045
!endif
(!B)Alertboxen(!b) werden eingesetzt, um den Benutzer Åber wichtige
Ereignisse zu informieren, oder um RÅckfragen an ihn zu stellen. Sie
informieren in knapper Form Åber den Sachverhalt, und bieten ggfs. mehrere
Alternativen, um auf diesen zu reagieren. Die Abbildung oben zeigt eine
Alertbox, die zur aktiven UnterstÅtzung von Multitasking in ein Fenster
gelegt wurde.

!label Dialogboxen, modale
!label Modale Dialogboxen
!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2044
!else
!image (!picture_path)\img2044
!endif
!else
!image (!picture_path)\img2044
!endif
(!B)Modale Dialogboxen(!b) sollten immer dann benutzt werden, wenn der
Benutzer zu einer sofortigen Aktion gezwungen werden muû bzw. soll. Der
Anwender kann erst dann in der Applikation weiterarbeiten, wenn er den
entsprechenden Dialog verlassen hat. Die Abbildung oben zeigt eine modale
Dialogbox, die zur aktiven UnterstÅtzung von Multitasking in ein Fenster
gelegt wurde. Modale (!nolink [Fensterdialoge]) kînnen vom Benutzer anhand des
(!B)fehlenden Closers(!b) der Fensterkomponenten erkannt werden.

!label Dialogboxen, unmodale
!label Unmodale Dialogboxen
!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2043
!else
!image (!picture_path)\img2043
!endif
!else
!image (!picture_path)\img2043
!endif
(!B)Unmodale Dialogboxen(!b) sollten eingesetzt werden, wann immer dies
mîglich ist. Ein solcher Dialog existiert wie ein Fenster parallel zum
eigentlichen Programm, und bietet dem Anwender ein Maximum an FlexibilitÑt.
Die Abbildung oben zeigt eine nicht-modale Dialogbox, die zur aktiven
UnterstÅtzung von Multitasking in ein Fenster gelegt wurde. Nicht-modale
(!nolink [Fensterdialoge]) kînnen vom Benutzer anhand des (!B)Closer in den
Komponenten(!b) des Fensters erkannt werden.

(!B)Wichtig:(!b) Damit in einer Multitasking-Umgebung alle Applikationen zu
jeder Zeit ungehindert Ausgaben auf dem Bildschirm tÑtigen kînnen, sollten
die Alert- und Dialogboxen eines Programms unbedingt in Fenster gelegt
werden. Einige Applikationen (z.B. der Resource-Editor (!I)Interface(!i)) erlauben
es, jederzeit zwischen konventionellen Dialogen und Fensterdialogen
umzuschalten; diese Mîglichkeit sollte jedoch nur dann angeboten werden,
wenn es wirklich notwendig ist. Im Hinblick auf zukÅnftige bzw. bereits
bestehende, Multitasking-fÑhige TOS-Versionen, werden koventionelle Dialoge
nur noch eine untergeordnete Rolle spielen.

Querverweis: AES  ~ Fensterdialoge ~  (!link [Formulare][Formularfunktionen])

!end_node


!begin_node Hilfesysteme

Mit steigender KomplexitÑt einer Software steigt auch die Notwendigkeit
der aktiven AnwenderunterstÅtzung, durch ein Åberlegt implementiertes
Hilfesystem.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2042
!else
!image (!picture_path)\img2042
!endif
!else
!image (!picture_path)\img2042
!endif

Neben der (!I)Entlastung des LangzeitgedÑchtnisses(!i) sollte solch ein
System dem Anwender die 4 folgenden Fragen beantworten:

!begin_itemize !compressed
!item (!B)Wo bin ich?(!b)
!item (!B)Was kann ich hier tun?(!b)
!item (!B)Wie kam ich hierhin?(!b)
!item (!B)Wo kann ich hin, und wie komme ich dorthin?(!b)
!end_itemize
 
Ein sehr gutes Hilfesystem bietet die relationale Datenbank (!I)Phoenix(!i)
der Firma Application Systems Heidelberg (Ñhnliches bieten auch
(!I)Pure-C(!i), (!I)Grismo(!i) oder der (!I)ST-Guide(!i)).
!label Hilfesystems, Funktionsweise des

Prinzipiell arbeitet solch ein System wie folgt: Die gewÅnschten
Informationen werden in einem Fenster angezeigt, und durch optisch
hervorgehobene (!B)Querverweise(!b) lassen sich per Mausklick jederzeit
weitere Informationen zu bestimmten Themen ermitteln. öber ein
(!nolink [Inhaltsverzeichnis]) ist es mîglich wie in einem Buch zu bestimmten Themen zu
springen, ein Index ermîglicht die gezielte Suche einer bestimmten Information.
!label Hilfe, kontext-sensitive
!label Kontext-Sensitive Hilfe
BewÑhrt hat sich vor allem die (!B)kontext-sensitive Hilfe(!b):
Hierunter versteht man eine Hilfestellung, die sich auf die augenblickliche
Situation bezieht.

Ist beispielsweise ein Fenster oder eine Dialogbox geîffnet, so erscheint
beim Aufruf des Hilfesystems eine ErklÑrung zu genau diesem Fenster bzw.
!label Hilfesystem, Anforderungen ans dieser Dialogbox.
(!B)Bei der Entwicklung eines Hilfesystems fÅr eine
Applikation sollten die folgenden Punkte berÅcksichtigt werden:(!b)

!begin_itemize
!item in (!I)jeder(!i) Dialogbox sollte sich ein Hilfe-Knopf befinden, bei
dessen BetÑtigung Informationen Åber genau diesen Dialog erscheinen.
!item in (!I)jeder(!i) Fehlermeldung sollte sich ein Hilfe-Knopf befinden,
bei dessen BetÑtigung dem Benutzer erklÑrt werden soll, warum der Fehler
aufgetreten ist, und wie er sich beheben lÑût.
!item ist ein Fenster der Applikation (und keine Dialogbox) geîffnet, so muû
zu diesem Fenster eine Hilfemeldung ausgegeben werden. In diesem
Zusammenhang sei darauf hingewiesen, daû auch die Funktionsweise des
Hilfesystems selbst erklÑrt werden muû.
!item falls keine Fenster bzw. (!nolink [Dialogboxen]) geîffnet sind, und auch keine
Objekte (z.B. Icons) der Applikation selektiert sind, so sollte eine
generelle Hilfe zum Programm selbst eingeblendet werden.
!end_itemize

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2041
!else
!image (!picture_path)\img2041
!endif
!else
!image (!picture_path)\img2041
!endif
Jeder Hilfetext sollte mindestens die folgenden Informationen beinhalten:

!begin_itemize
!item auf welches Objekt bezieht sich die Hilfe (Fenster, Dialogbox, Icon
etc.) ?
!item welche Aktionen kînnen an bzw. mit diesem Objekt ausgefÅhrt werden?
!end_itemize

!label Hilfesystemen, Mut zu
Die von vielen Software-Entwicklern geÑuûerte Angst, durch ein zu gutes
Hilfesystem das @{0B}Raubkopieren@{0} zu unterstÅtzen, ist zwar
verstÑndlich, sollte aber nicht auf Kosten der ehrlichen Anwender
ausgetragen werden.

Querverweis: AES ~  Fensterverwaltung

!end_node


!begin_node Mausklicks und Formen

Auch ein relativ unscheinbares Objekt wie der Mauszeiger hat in einem System
mit grafischer BenutzeroberflÑche eine wichtige Bedeutung. Sowohl die Anzahl
der Mausklicks, als auch die Form des Mauszeigers sind fÅr den Anwender
eines Programms von besonderem Interesse.

Es hat sich eingebÅrgert, je nach auszufÅhrender Operation dem Mauszeiger
eine bestimmte Form zuzuordnen; im einzelnen:

!label Mausformen
!label Mausform, Bedeutung der
!begin_table [l|l]
Form des Mauszeigers !! Bedeutung
!hline
Pfeil !! allgemeine Bedienung (Regelfall)
Balken !! Texteingabe
Biene bzw. Sanduhr !! der Computer ist mit einer Operation beschÑftigt,
~                  !! und der menschliche Benutzer kann wÑhrend der
~                  !! AusfÅhrung dieser Aktion nichts machen
Zeigefinger !! Auswahl oder Dimensionierung
flache Hand !! Verschieben oder positionieren von Objekten
Fadenkreuz, dÅnn !! Zeichnen oder Auswahl
Fadenkreuz, dick !! keine feste Bedeutung
Fadenkreuz, Umriû !! keine feste Bedeutung
!end_table

DarÅber hinaus lÑût sich der Mauszeiger auch komplett abschalten; dies ist
z.B. bei der AusfÅhrung von Zeichenoperationen sinnvoll, um PixelmÅll zu
vermeiden. In besonderen FÑllen kann die Form des Mauszeigers auch frei
definiert werden; dabei sollte die neue Form des Mauszeigers allerdings
immer zur jeweiligen Situation passen.

!label Mausform, Faustregel fÅr
(!B)Als Faustregel gilt, daû der Mauszeiger auûerhalb des Arbeitsbereiches
des eigenen Fensters immer die Form eines Pfeils besitzen sollte.(!b)

Auch Åber die (!B)Anzahl der Mausklicks(!b) gibt es einiges zu berichten.
Ein einfacher Klick dient i.a. dazu, bestimmte Elemente auszuwÑhlen. Das
kînnten Elemente einer Dialogbox (Checkboxen, Radiobuttons, etc.), Icons auf
dem Desktop einer Shell, aber auch die Komponenten eines Fensters sein. In
vielen FÑllen lassen sich Åber einen einfachen Klick weitere Aktionen
auslîsen. Wird der Mausknopf beispielsweise nicht losgelassen, so kînnen
Objekte wie Icons verschoben werden, oder es lÑût sich eine ganze Gruppe
von Objekten auswÑhlen, d.h. selektieren.

!label Doppelklick
!label Klick, Doppel-
Ein (!B)Doppelklick(!b) leitet meist eine spezielle Operation ein; der
Desktop startet beispielsweise ein Programm, wenn auf das zugehîrige
Sinnbild doppelt geklickt wird.
!label Klicks, Mehrfach-
!label Mehrfach-Klicks
Prinzipiell stehen neben dem Einfach- und Doppelklick auch (!B)Drei- oder
Vierfachklicks(!b) mit der Maus zur VerfÅgung. Von diesen Varianten ist
jedoch dringend abzuraten, da es vielen Menschen erhebliche Probleme
bereiten dÅrfte, innerhalb eines bestimmten Zeitintervalls die entsprechende
Anzahl von Mausklicks auszufÅhren.

!label Mausklick und Tastatur
Last but not least lassen sich (!B)Mausklicks(!b) auch (!B)in Zusammenhang
mit der Tastatur(!b) (Alternate, Control, Shift) einsetzen. Ein Mausklick in
Verbindung mit einer Shift-Taste sorgt i.a. dafÅr, daû weitere Objekte
ausgewÑhlt werden kînnen. Die Shell (!I)Gemini(!i) îffnet bei einem
Doppelklick auf ein Icon und gleichzeitig gedrÅckter Alternate-Taste, ein
Fenster mit dem zu diesem Icon gehîrenden Verzeichnis.

Querverweis: graf_mouse
!end_node


!begin_node MenÅs und MenÅzeilen
!label MenÅs, Gestaltung von

Die Gestaltung der MenÅs ist in hohem Maûe mitverantwortlich fÅr die
öbersichtlichkeit und Benutzerfreundlichkeit einer Applikation. Deshalb
sollte sich jeder Software-Entwickler genÅgend Zeit nehmen, um diese
sinnvoll und ansprechend zu gestalten.

!label KurzzeitgedÑchtnis, KapazitÑt des
Wie bereits erwÑhnt ist die (!B)KapazitÑt des KurzzeitgedÑchtnisses(!b)
beschrÑnkt. Aus diesem Grund sollte eine MenÅzeile mîglichst nicht mehr als
sieben MenÅ-Punkte anbieten; anderenfalls muû ein Benutzer mehrere Male auf
die MenÅzeile blicken, um entscheiden zu kînnen, welche Auswahl er treffen
will. Die folgende Abbildung zeigt die HauptmenÅzeile des relationalen
Datenbanksystems (!I)Phoenix(!i):

!begin_verbatim
     MANAGER  Datei  Bearbeiten  Prozeû  Parameter  Optionen  Hilfe
!end_verbatim

!label MenÅzeile, Standardaufbau der
Sowohl die MenÅzeile als auch die darin enthaltenen MenÅs sollten einen
(!B)Standardaufbau(!b) besitzen, damit sich ein Anwender nach dem Starten
eines Programms sofort "heimisch" fÅhlt. Das erste MenÅ von links sollte
stets den (!I)Namen der aktuellen Applikation(!i) tragen; dies hat in einer
Multitasking-Umgebung den unschÑtzbaren Vorteil, durch einen kurzen Blick
auf die MenÅzeile die aktive Applikation identifizieren zu kînnen.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2040
!else
!image (!picture_path)\img2040
!endif
!else
!image (!picture_path)\img2040
!endif

Der zweite MenÅtitel sollte immer den Namen (!I)Datei(!i) besitzen, und
MenÅpunkte anbieten, die sich mit verschiedenen Aspekten der Ein- und
Ausgabe befassen. Der unterste Eintrag in diesem MenÅ sollte stets die
Mîglichkeit bieten, das Programm zu verlassen.
!label MenÅs, Untergruppen in
Wie man in der obenstehenden
Abbildung sieht, kînnen einzelne EintrÑge innerhalb eines MenÅs zu
(!B)logischen Untergruppen(!b) zusammengefaût werden, was erheblich zur
Åbersichtlichkeit und Akzeptanz durch den Benutzer beitrÑgt.

Um unnîtige Handbewegungen zwischen Tastatur und Maus zu verhindern, sollte
jeder MenÅpunkt auch durch eine (!B)Tastenkombination (Shortcut)(!b)
aufgerufen werden kînnen. Es handelt sich dabei meist um Control- bzw.
Alternate-Sequenzen, die am rechten Rand eines MenÅs angezeigt werden
sollten, und dabei mindestens ein Leerzeichen Abstand zum eigentlichen
Eintrag bieten. Dieser wiederum beginnt immer zwei Zeichen vom linken 
und eines vom rechten Rand entfernt, um genug Platz fÅr ein HÑkchen zu
bieten.
!label MenÅs, Drei Punkte in
Dabei spielt es keine Rolle, ob Åberhaupt ein solches angezeigt
werden soll oder nicht. (!B)Drei Punkte(!b) hinter einem MenÅpunkt deuten
an, daû sich nach Auswahl dieses Eintrags eine Dialogbox (oder der
Fileselektor) îffnet. Der Benutzer kann sich dann darauf einstellen, und
z.B. den Mauszeiger schon in die Mitte des Bildschirms bewegen, wÑhrend der
Dialog aufgebaut wird.

Weitere und oft benutzte MenÅtitel sind (!I)Bearbeiten, Parameter,
Optionen(!i) und (!I)Hilfe(!i). Ersterer befindet sich stets rechts vom
!label MenÅtiteln, Abgrenzung von
Datei-MenÅ, letzterer sollte immer am rechten Ende einer MenÅzeile plaziert
werden. Jeder (!nolink [Titel]) sollte mit einem Groûbuchstaben beginnen (der ganz links
stehende Name des Programms wird komplett in Groûbuchstaben angegeben), aus
nur einem Wort bestehen, und als (!B)Abgrenzung zu den anderen Titeln(!b)
je ein Leerzeichen nach links und rechts enthalten.

!label MenÅs, kontext-sensitive
!label Kontext-Sensitive MenÅs
DarÅber hinaus sollte man MenÅeintrÑge immer (!B)kontext-sensitiv
gestalten(!b), d.h. ein Eintrag darf nur dann anwÑhlbar sein, wenn dies in
der aktuellen Situation des Programms mîglich bzw. sinnvoll ist. So macht es
beispielsweise keinen Sinn, den MenÅeintrag (!I)Speichern(!i) aufzurufen,
wenn es nichts zu speichern gibt. Gleiches gilt auch fÅr einen Eintrag
(!I)Schlieûen(!i), der nur dann anwÑhlbar sein sollte, wenn es auch ein
Fenster bzw. einen Dialog gibt, der geschlossen werden kann.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2039
!else
!image (!picture_path)\img2039
!endif
!else
!image (!picture_path)\img2039
!endif
Von der konventionellen MenÅzeile abgesehen gibt es noch weitere und
interessante Mîglichkeiten, dem Benutzer eine Auswahl zu ermîglichen. Viele
Programme (z.B. die Shell (!I)Thing(!i) oder (!I)Ease(!i) - vgl. Abbildung) stellen dem
Benutzer (!B)Pop-Up-MenÅs(!b) zur VerfÅgung um schnell zwischen
verschiedenen Alternativen auswÑhlen zu kînnen oder eine Operation
!label MenÅs, Vorteil bei Popup-
!label Popup-MenÅs, Vorteil eines
auszufÅhren. Der Hauptvorteil eines Pop-Up-MenÅs besteht darin, die
(!B)Mauswege(!b) zu (!B)verkÅrzen(!b). Das MenÅ erscheint einfach an der
Bildschirmposition, an der ein Mausklick ausgefÅhrt wird. Bei der
Implementierung von Pop-Up-MenÅs sollte man darauf achten, daû diese immer
vollstÑndig auf dem Bildschirm erscheinen.

!label MenÅs in Fenstern
Last but not least gibt es die Mîglichkeit, eine (!B)MenÅzeile im
Fenster(!b) unterzubringen. Diese Methode bietet verschiedene Vorteile:
erstens lÑût sich auf diese Art und Weise die HauptmenÅzeile entlasten und
dadurch viel Åbersichtlicher gestalten, zweitens ist es dadurch mîglich,
eine Applikation viel logischer aufzubauen. Alle Operationen die lokal auf
ein Fenster wirken, wandern in das FenstermenÅ, alle anderen in die globale
MenÅzeile.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2038
!else
!image (!picture_path)\img2038
!endif
!else
!image (!picture_path)\img2038
!endif

!label MenÅs, scrollbare
Da man Fenster nicht nur auf dem Bildschirm verschieben, sondern i.a. auch
in der Grîûe verÑndern kann, ist es mîglich, daû nicht alle (!nolink [Titel]) eines
Fenster-MenÅs sichtbar sind. Einige Programme erlauben es daher, die
MenÅzeile zu (!B)scrollen(!b). Dies ist z.B. beim Texteditor (!I)Grismo(!i),
oder beim Resource Editor (!I)Interface(!i) der Fall.

Querverweis: AES ~  MenÅfunktionen
!end_node


!begin_node Optische und akustische RÅckmeldungen
!label akustische RÅckmeldungen
!label RÅckmeldungen, optische
!label RÅckmeldungen, akustische

Beim Arbeiten am Computer ist der menschliche Benutzer auf optische oder
akustische RÅckmeldungen angewiesen, um stets das GefÅhl zu haben, die
auszufÅhrende Aufgabe zu kontrollieren, bzw. den aktuellen Stand der
Bearbeitung erfassen zu kînnen.

Das GEM bietet eine Vielzahl von Mîglichkeiten, dem Anwender ein
FeedbackgefÅhl zu vermitteln. So werden z.B. MenÅtitel oder Icons
invertiert, wenn der Benutzer diese mit der Maus selektiert.

(!B)Akustische RÅckmeldungen(!b) sind besonders im Zusammenhang mit Fehler-,
bzw. Warnmeldungen sinnvoll, die in (!nolink [Dialogboxen]) angezeigt werden kînnen.

(!B)Optische RÅckmeldungen(!b) sind immer dann einzusetzen, wenn der
Benutzer Objekte auf dem Bildschirm selektiert, oder eine Aufgabe mit einer
lÑngeren Bearbeitungsphase startet. Der Anwender darf niemals darÅber im
Unklaren gelassen werden, welche Operation gerade ausgefÅhrt wird, und wie
weit sie fortgeschritten ist. Dabei sind (!B)grafische Kontrollanzeigen(!b)
i.a. den textuellen vorzuziehen, da letztere vom Benutzer erst dekodiert
werden mÅssen.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2037
!else
!image (!picture_path)\img2037
!endif
!else
!image (!picture_path)\img2037
!endif

Optische RÅckmeldungen werden z.B. vom relationalen Datenbanksystem Phoenix
eingesetzt, um den Benutzer Åber den Stand einer Abfrage zu unterrichten;
die Shell Gemini benutzt diese Methode, um dem Anwender beim Formatieren
von Disketten ein ZeitgefÅhl zu vermitteln, und der Texteditor
(!I)Grismo(!i) invertiert u.a. Querverweise seines Hilfesystems, wenn der
Benutzer diese mit der Maus aktiviert.

Querverweis: AES ~  Style-Guidelines
!end_node


!begin_node Selektionen

Unter einer Selektion versteht man das AuswÑhlen eines oder mehrerer
Objekte. Auf dem Desktop lassen sich beispielsweise die Dateien eines
Laufwerkfensters per Mausklick, Shift-Mausklick oder durch Aufziehen eines
Gummibandes selektieren.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2036
!else
!image (!picture_path)\img2036
!endif
!else
!image (!picture_path)\img2036
!endif
GrunsÑtzlich gelten die folgenden Konventionen:

!label AuswÑhlen per Maus
!label Selektion per Maus
(!B)Mausklick:(!b) Durch einen einfachen Klick mit der Maus wird das
ausgewÑhlte Objekt selektiert; bereits ausgewÑhlte Objekte mÅssen wieder
deselektiert werden.

!label AuswÑhlen per Shift-Maus
!label Selektion per Shift-Maus
(!B)Shift-Mausklick:(!b) fÅgt das ausgewÑhlte Objekt in die Menge der
bereits selektierten Objekte ein (bereits ausgewÑhlte Objekte bleiben also
weiterhin selektiert). Durch einen Shift-Mausklick auf ein selektiertes
Objekt wird dieses aus der Menge der ausgewÑhlten Objekte wieder
entfernt.

!label AuswÑhlen per Gummiband
!label Selektion per Gummiband
(!B)Gummiband:(!b) Durch Aufziehen eines Gummibandes (Rubberbox) werden alle
Objekte die von diesem Band geschnitten werden, selektiert; bereits
ausgewÑhlte Objekte mÅssen wieder deselektiert werden. Durch Kombination mit
der Shift Taste kînnen die betroffenen Objekte in die Menge der ausgewÑhlten
Objekte eingefÅgt werden.

!label Echtzeit-Selektion
!label Selektion, Echtzeit-
Eine besonders angenehme Art der Selektion ist die
(!B)Echtzeit-Selektion(!b). Hierunter versteht man, daû der ausgewÑhlte
Bereich bereits wÑhrend der Bewegung des Mauszeigers invertiert wird. Viele
Programme wie (!I)Pure-C(!i), (!I)Gemini(!i) oder (!I)Grismo(!i) nutzen
diese Methode der Selektion, und scrollen dabei sogar automatisch den
Inhalt des Fensters, wenn der Fensterrand erreicht wird.

Querverweis: AES ~  Style-Guidelines
!end_node


!begin_node Spezialeffekte

Beim Einsatz von Farben, Texteffekten etc. ist besondere Vorsicht
angebracht. Hier gilt die zumeist die Devise: (!B)Weniger ist mehr !(!b)

Es kann an dieser Stelle kein Patent-Rezept, sondern nur der Ratschlag
gegeben werden, sich an vorbildlichen Applikationen zu orientieren.
!label Farbe, SubjektivitÑt der
Speziell
bei Verwendung von Farben sollte ein Software-Entwickler immer im Hinterkopf
haben, daû das (!B)Farbempfinden eines Menschen(!b) sehr subjektiv ist;
daraus folgt, daû es dem Benutzer mîglich sein sollte, die fÅr ihn
angenehmen Farben einstellen zu kînnen.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2045
!else
!image (!picture_path)\img2035
!endif
!else
!image (!picture_path)\img2035
!endif

Eine vorbildliche Applikation in dieser Hinsicht ist z.B. das relationale
Datenbanksystem Phoenix von Application Systems Heidelberg. Hier lÑût sich
nahezu die gesamte BenutzeroberflÑche vom Anwender frei konfigurieren.

!label Texteffekten, Einsatz von
In Textdokumenten sollte darauf geachtet werden, nicht zu viele (!nolink [Texteffekte])
gleichzeitig einzusetzen bzw. zu vermischen. Auch hier gilt: (!B)Weniger ist
mehr !(!b) Doch kann diese Aussage auch nicht pauschalisiert werden: Es gibt
FÑlle, in denen der Einsatz mehrerer Effekte zum gleichen Zeitpunkt nicht
nur toleriert werden kann, sondern sogar sinnvoll ist. In einem
(!B)Hypertext(!b)-system beispielsweise mÅssen (!B)Querverweise(!b) dem
Benutzer besonders deutlich gemacht werden. Auf nahezu allen Plattformen
gilt der Standard, diese Referenzen unterstrichen, und wenn mîglich,
gleichzeitig auch in Farbe darzustellen. Das hat den Vorteil, daû
Textstellen, die einen einfachen Effekt nutzen, trotzdem noch von
Querverweisen unterschieden werden kînnen.

Das Fehlen eines Patent-Rezeptes fÅhrt bei vielen Entwicklern zu
Unsicherheit, die darin gipfelt, auf Spezialeffekte bzw. Farbe ganz zu
verzichten. (!B)Das kann jedoch nicht Sinn der Sache sein !(!b) So kann
Farbe, sinnvoll eingesetzt, nicht nur zu erheblich mehr öbersichtlichkeit
beitragen, sondern auch die AttraktivitÑt einer Applikation drastisch
erhîhen.

Lange Rede - kurzer Sinn: Spezialeffekte (gleich welcher Art) sollten sehr
Åberlegt und sparsam eingesetzt werden.

!label User-Testing
!label Testing, User-
Bei der Entwicklung eines
Softwareproduktes tut ein Programmierer gut daran, mîglichst frÅh den
Benutzer in seine Arbeit einzubeziehen (!B)(User-Testing)(!b), und sich an
vorbildlichen Programmen zu orientieren. Am sinnvollsten ist es, alle
heiklen Punkte fÅr den Anwender frei konfigurierbar zu machen !

Querverweis: AES ~  Style-Guidelines
!end_node


!begin_node Tastaturbelegung

Da der Mensch ein Gewohnheitstier ist, wÑre es wÅnschenswert, wenn nicht
nur Dialoge und MenÅs mîglichst einheitlich aufgebaut werden, sondern
die wichtigsten Funktionen eines Programms auch per Tastatur einheitlich
aufgerufen werden kînnten. 

!label Shortcuts, Liste der
TatsÑchlich gibt es eine Reihe von Befehlstasten-Kombinationen (Shortcuts)
die entweder fest genormt sind, oder sich aber als quasi Standard etabliert
haben; im einzelnen:

!label Shortcuts, genormte
(!B)Genormt laut Beschluû der Entwicklerkonferenz (August '89):(!b)

!begin_table [l|l]
Tasten-Kombination !! Funktion
!hline
Control-C !! kopieren
Control-F !! suchen
Control-O !! îffnen
Control-Q !! Programm beenden
Control-V !! einfÅgen
Control-X !! ausschneiden
Shift-"Pfeil hoch" !! eine Seite zurÅck blÑttern
Shift-"Pfeil runter" !! eine Seite vorwÑrts blÑttern
Shift-"Pfeil links" !! Cursor zum Anfang der Zeile
Shift-"Pfeil rechts" !! Cursor an das Ende der Zeile
Control-"Pfeil links" !! um ein Wort zurÅck
Control-"Pfeil rechts" !! um ein Wort vorwÑrts
Home !! an den Anfang des Dokumentes
Shift-Home (Clr) !! an das Ende des Dokumentes
!end_table

!label Shortcuts, nicht genormte
(!B)Nicht genormt, aber Quasi-Standard:(!b)

!begin_table [l|l]
Tasten-Kombination !! Funktion
!hline
Control-A !! alles auswÑhlen
Control-G !! nÑchste Fundstelle
Control-M !! Sichern unter...
Control-N !! Neues Dokument
Control-P !! Drucken
Control-S !! Sichern
Control-R !! Ersetzen
Control-U !! Oberstes Fenster schlieûen
Control-W !! zum nÑchsten Fenster blÑttern
Control-Y !! aktuelle Zeile ausschneiden
Control-Z !! Shell starten
!end_table

!label Shortcuts, reservierte
(!B)Wichtiger Hinweis:(!b) Alle 'Alternate-Control'-Tastenkombinationen
sind fÅr das Betriebssystem reserviert. Als Beispiele seien an dieser
Stelle genannt:

!label Iconify, Shortcuts fÅr
!begin_table [l|l]
Tasten-Kombination !! Funktion
!hline
Alternate-Control-(!nolink [Tab]) !! Taskwechsel unter MagiC
Alternate-Control-Delete !! Shut-Down-Sequenz starten
Alternate-Control-Esc !! Programm-Manager unter (!nolink [MagiC])
Alternate-Control-Space !! aktuelles Fenster ikonifizieren
dto. jedoch mit Shift !! Applikation ikonifizieren
!end_table

Querverweis:
(!link [Bedienung des Fileselektors][Die Bedienung des File-Selektors ab MagiC 4])  ~
ASCII-Tabelle ~
(!link [Scan-Code Tabelle][Der Scan-Code])
!end_node


!begin_node Toolboxen

Es kann vorkommen, daû der Platz in der MenÅleiste und den (!nolink [Dialogboxen])
einer Applikation nicht ausreicht, um die volle FunktionalitÑt darin
unterzubringen.

Anstatt nun die MenÅleiste zu ÅberfÅllen, oder zu viele Informationen in
einen Dialog zu quetschen, sollte man in diesen FÑllen auf eine
Werkzeugleiste (Toolbox) oder (!B)lokale MenÅzeilen(!b) in Fenstern
zurÅckgreifen.

In nahezu allen FÑllen lassen sich dadurch die entsprechenden Funktionen in
der Benutzerschnittstelle unterbringen, - und dazu noch Åbersichtlich.

Toolboxen werden i.a. am oberen oder rechten Rand eines Fensters
angeboten.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image img2034
!else
!image (!picture_path)\img2034
!endif
!else
!image (!picture_path)\img2034
!endif

Lokale MenÅzeilen und Werkzeugleisten werden z.B. vom Resource-Editor
Interface eingesetzt. Es kann nÅtzlich sein, wenn man eine Toolbox
(zumindest kurzfristig) (!B)ausblenden(!b) kann, um so mehr der eigentlich
wichtigen Informationen im Fenster darstellen zu kînnen; dies erlaubt
beispielsweise der Texteditor (!I)Grismo(!i).

Querverweis: AES ~  Style-Guidelines
!end_node

!end_node

!endif
