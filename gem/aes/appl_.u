## Hypertext zum TOS-Betriebssystem
## entwickelt fr den ST-Guide
##
## Last Edit: 29.08.1998
##
## Kapitel 4: AES-Applikationsbibliothek



!begin_node appl_bvset
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application Bitvektor-Set® - setzt die angeschlossenen logischen
Laufwerke fr die Dateiauswahlbox
!item [AES-Nummer:]
16
!item [Binding:]
(!link [Bindings fr appl_bvset] [Bindings fr appl_bvset])
!item [Beschreibung:]
Die Funktion informiert das GEM ber die vorhandenen logischen Laufwerke,
die u.a. fr die Dateiauswahl-box (Fileselector) ben”tigt werden. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [bvdisk]
Bitvektor der vorhandenen Diskettenlaufwerke (Bit-15 = Laufwerk-A etc).
!item [bvhard]
Bitvektor der vorhandenen Festplattenlaufwerke (Bit-15 = Laufwerk-A etc).
!end_xlist
(!B)Hinweis:(!b) Die Funktion steht erst ab PC-GEM Version 2.0 zur Verfgung.
!item [Ergebnis:]
Der Rckgabewert der Funktion ist z.Zt. nicht bekannt.
!item [Gruppe:]
Applikationen
!item [Querverweis:]
Dsetdrv
(!ende_liste)



!begin_node Bindings fr appl_bvset
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_bvset ( UWORD bvdisk, UWORD bvhard );
!item [Implementierung:]
!begin_verbatim
WORD appl_bvset (UWORD bvdisk, UWORD bvhard)
{
   int_in[0]  = bvdisk;
   int_in[1]  = bvhard;
   return ( crys_if(16) );	
}
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 16    Opcode der Funktion
control+2 !! control[1] !! 2     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 0     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_in !! int_in[0] !! bvdisk
int_in+2 !! int_in[1] !! bvhard
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_control
(!begin_liste) [Beschreibung:]
!item [Name:]
Gezieltes Steuern von Anwendungen.
!item [AES-Nummer:]
129
!item [Binding:]
(!link [Bindings fr appl_control] [Bindings fr appl_control])
!item [Beschreibung:]
Die Funktion erlaubt ein gezieltes Steurern von Anwendungen.
!begin_xlist [Parameter]
!item [Parameter]
Bedeutung

!item [ap_cid]
Die Applikationsidentifikation (apid) der Anwendung, die gesteuert
werden soll.

!item [ap_cwhat]
Die Art der Steuerung:

!begin_xlist [APC_WIDGETS ]

!item [0 bis 9]              reserviert fr N.AES

!label APC_HIDE
!item [APC_HIDE (10)]         Applikation ausblenden (!nl)
                     Wird fr ap_cid -1 bergeben, so wird die 
                     aktuelle Anwendung ausgeblendet.

!label APC_SHOW
!item [APC_SHOW (11)]         Applikation einblenden (!nl)
                     Wird fr ap_cid -1 bergeben, so werden alle
                     ausgeblendeten Anwendungen eingeblendet.

!label APC_TOP
!item [APC_TOP (12)]          Applikation in den Vordergrund bringen (zur 
                     aktuellen Anwendung machen).

!label APC_HIDENOT
!item [APC_HIDENOT(13)]      Ausblenden aller Anwendungen bis auf die in 
                     ap_cid angegebene, welche zur neuen aktu- 
                     ellen Anwendung wird.
                     Wird fr ap_cid -1 bergeben, so werden alle
                     Anwendungen bis auf die aktuelle 
                     ausgeblendet.

!label APC_INFO
!item [APC_INFO(14)]         Abfragen von Applikationsparametern der An- 
                     wendung ap_cid. Wird fr ap_cid -1 
                     bergeben, so werden die Parameter der aktu-
                     ellen Anwendung geliefert.

                     Fr ap_cout ist ein Zeiger auf einen Integer
                     zu bergeben. N.AES hinterlegt hier die 
                     Applikationsparameter in Form einer 
                     Bitmaske:

										 !begin_xlist  [APCI_HIDD]
										 !label APCI_HIDDEN
                     !item [APCI_HIDDEN (1)]     Bit 0 ist gesetzt, wenn 
                                        die Applikation 
                                        ausgeblendet ist.

										 !label APCI_HASMBAR
                     !item [APCI_HASMBAR (2)]    Bit 1 ist gesetzt, wenn 
                                        die Applikation eine 
                                        Menleiste besitzt.

										 !label APCI_HASDESK
                     !item [APCI_HASDESK (4)]    Bit 2 ist gesetzt, wenn 
                                        die Applikation einen 
                                         eigenen Desktop besitzt.
										!end_xlist
!label APC_MENU
!item [APC_MENU(15)]         Liefert die Adresse des Menbaums, den die 
                     Anwendung ap_cid zuletzt angemeldet hat. 
                     Hierzu ist fr ap_cout ein Zeiger auf einen 
                     OBJECT-Zeiger zu bergeben; letzterer wird 
                     vom N.AES mit der gesuchten Menbaumadresse 
                     gefllt.

                     Wird fr ap_cid -1 bergeben, so wird die 
                     Menbaumadresse der aktuellen Anwendung 
                     geliefert. šbergibt man fr ap_cid den Wert 
                     0, so wird die Adresse des vom (!nolink [N.AES]) intern 
                     verwalteten Systemmens geliefert. Dies ist 
                     die Menbox, die aufklappt, wenn man den am 
                     weitesten links stehenden Mentitel anw„hlt 
                     und welche die Liste aller beim N.AES 
                     angemeldeten Anwendungen und Accessories 
                     enth„lt.

                     Hat die abgefragte Anwendung keine 
                     Menleiste angemeldet oder existiert keine 
                     Anwendung mit der Identifikation ap_cid, so 
                     wird ein Nullzeiger nach ap_cout 
                     geschrieben.

                     Der Rckgabewert von appl_control, Modus 
                                    APC_MENU ist immer der Wert 1.

                                    Hinweis:
                                    Wenn man diesen Modus verwendet, sollte man 
                                    sich ganz sicher sein, was man tut! Das 
                                    Ver„ndern des gelieferten Menbaums kann zu 
                                    undefinierten Systemzust„nden fhren. Bei 
                                    aktivem MiNT-Speicherschutz kann bereits ein
                                    Lesezugriff auf den Menbaum den Abbruch der
                                    Anwendung bewirken.

!label APC_WIDGETS
!item [APC_WIDGETS (16)]      Erfragt oder setzt die 'default' Positionen 
                                    der Fensterobjekte. (!I)ap_cout(!i) ist ein Zeiger 
!label MINWINOBJ
                                    auf einen MINWINOBJ(12) groen (WORD) 
                                    Buffer, der zum abfragen der 
                                    Objektreihenfolge komplett mit -1 gefllt 
                                    sein mu. Das letzte Word mu eine 0 sein. 
                                    Wird eine Fehlermeldung zurckgeliefert 
                                    reicht der Buffer nicht fr alle Objekte und
                                    sollte vergr”ert werden. Im Buffer liegen 
                                    als erstes die Objekte der Titelleiste von 
                                    links nach rechts, danach die Objekte des 
                                    Vertikalsliders von oben nach unten und dann
                                    die Objekte des Horizontalsliders von links 
                                    nach rechts. Abgeschlossen wird die Liste 
                                    mit einem 0 Word. Zum setzen der Positionen 
                                    men die ersten Objekte vom Typ topwidgets 
                                    sein (von links nach rechts), danach die 
                                    Objekte des Typs rightwidgets (von oben nach 
                                    unten) und dann die Objekte des Typs 
                                    bottomwidgets (von links nach rechts). 
                                    Sollten Objekte doppelt oder falsch gesetzt 
                                    sein wird ein Fehler gemeldet.
!end_xlist

!item [ap_cout]     Wird abh„ngig von (!I)ap_cwhat(!i) gefllt oder gelesen und hat nur fr 
              APC_INFO, APC_MENU und APC_WIDGETS eine Bedeutung. In den anderen 
              F„llen wird dieser Parameter ignoriert, die šbergabe eines 
              Nullzeigers ist dann m”glich.

!end_xlist

(!B)Hinweis:(!b)
Ausgeblendeten Anwendungen wird in der Menleiste ein '*' vorangestellt, es sei 
denn, sie hatten im Moment der Ausblendung kein Fenster offen. In diesem Fall 
wird nur die Anwendung gewechselt.

Der '*' vor dem Namen bedeutet genau: Einige oder alle ge”ffneten Fenster dieser
Anwendung sind ausgeblendet.

Das Vorhandensein der Funktion ist ber (!link [appl_getinfo][%apgi_65]) (Opcode 65)
nachprfbar.

!item [Ergebnis:]
~0 = ein Fehler ist aufgetreten (!nl)
>0 = kein Fehler aufgetreten

!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])

#!item [Querverweis:]
(!ende_liste)



!begin_node Bindings fr appl_control
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_control ( WORD ap_cid, WORD ap_cwhat, VOID *ap_cout);

!item [Implementierung:]
!begin_verbatim
WORD appl_control ( WORD ap_cid, WORD ap_cwhat, VOID *ap_cout);
{
   int_in[0]  = ap_cid;
   int_in[1]  = ap_cwhat;
   addr_in[0] = ap_cout;
		   
   return ( crys_if(129) );	
}
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 129    Opcode der Funktion
control+2 !! control[1] !! 2     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 1     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_in !! int_in[0] !! ap_cid
int_in+2 !! int_in[1] !! ap_cwhat
addr_in  !! addr_in[0] !! ap_cout
int_out !! int_out[0] !! ap_creturn
!end_table
(!ende_liste)
!end_node
!end_node


!begin_node appl_exit
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application exit® - meldet eine Applikation vom (!nolink [AES]) ab.
!item [AES-Nummer:]
19
!item [Binding:]
(!link [Bindings fr appl_exit] [Bindings fr appl_exit])
!item [Beschreibung:]
Meldet eine Applikation beim AES wieder ab und gibt deren Applikations-ID
frei.
!item [Ergebnis:]
Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis 0 zurckgegeben wird.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_init
(!ende_liste)



!begin_node Bindings fr appl_exit
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_exit ( VOID );
!item [Implementierung:]
!begin_verbatim
WORD appl_exit (VOID)
{
   return ( crys_if(19) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 19    Opcode der Funktion
control+2 !! control[1] !! 0     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 0     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_find
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application find® - ermittelt die Applikationsnummer einer
(!nolink [AES])-Anwendung.
!item [AES-Nummer:]
13
!item [Binding:]
(!link [Bindings fr appl_find] [Bindings fr appl_find])
!item [Beschreibung:]
Diese Funktion ermittelt die Applikationsidentifikation einer anderen,
parallel laufenden Applikation. Dabei zeigt (!I)ap_fpname(!i) auf den Namen
der Applikation deren Identifikator gefunden werden soll.

(!B)Wichtig:(!b) Der Name mu unbedingt acht Zeichen lang sein, ist er
krzer, so mu er mit Leerzeichen aufgefllt werden.

In MagiC und AES 4.0 kann man zus„tzlich durch šbergabe eines Nullpointers
die ID der aktuellen Applikation ermitteln. Darber hinaus ist es m”glich,
die AES-ID einer Applikation in die MiNT-ID umzurechnen und umgekehrt, und
zwar wie folgt:
!begin_xlist !short [von ap_fpname ]
!item [High-Word] Bedeutung
!item [von ap_fpname] ~
!item [~]
~
!item [-1]
Die Funktion erwartet im Low-Word die MiNT-ID einer Applikation und liefert
nach dem Aufruf die (!nolink [AES])-ID dieser Applikation zurck.

!item [-2]
Die Funktion erwartet im Low-Word die (!nolink [AES])-ID einer Applikation und liefert
nach dem Aufruf die MiNT-ID dieser Applikation zurck.
!item [-3]
Es wird die (!nolink [AES])-ID der obersten Applikation geliefert. Das Low-Word spielt
dabei keine rolle und kann 0 sein. Steht nur unter N.AES zur Verfgung.
!end_xlist

(!B)Hinweis:(!b) Die Funktion arbeitet nur dann korrekt, wenn das
betreffende Programm per (!I)shel_write(!i) gestartet worden ist. Es sei
ferner darauf hingewiesen, da Threads ber diese Funktion (!I)nicht(!i)
gefunden werden k”nnen.

Das Vorhandensein der zus„tzlichen Features ist ber (!link [appl_getinfo][%apgi_4]) (Opcode 4)
nachprfbar.
!item [Ergebnis:]
Ein Rckgabewert kleiner Null kennzeichnet einen aufgetretenen Fehler.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_search ~ (!link [Screen-Manager][Der Screen-Manager])
(!ende_liste)



!begin_node Bindings fr appl_find
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_find ( CONST BYTE *ap_fpname );
!item [Implementierung:]
!begin_verbatim
WORD appl_find (CONST BYTE *ap_fpname)
{
   addr_in[0] = ap_fpname;
   return ( crys_if(13) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 13    Opcode der Funktion
control+2 !! control[1] !! 0     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 1     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
addr_in   !! addr_in[0] !! ap_fpname
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_getinfo
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application get information® - Informationen ber vorhandene
Funktionsaufrufe und Eigenschaften erfragen.
!item [AES-Nummer:]
130
!item [Binding:]
(!link [Bindings fr appl_getinfo] [Bindings fr appl_getinfo])
!item [Beschreibung:]
Mit dieser Funktion lassen sich gezielt Eigenschaften des Betriebssystems
zur Laufzeit erfragen.

(!I)ap_gtype(!i) bestimmt die Art der Informationen, die erfragt werden
sollen. Es bedeutet:

!label %apgi_0
(!B)0: Informationen ber den normalen AES-Zeichensatz(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
Fonth”he
!item [ap_gout2:]
Font-ID
!item [ap_gout3:]
Font-Typ (0=system, 1=FSM)
!end_xlist

!label %apgi_1
(!B)1: Informationen ber den kleinen Zeichensatz(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
Fonth”he
!item [ap_gout2:]
Font-ID
!item [ap_gout3:]
Font-Typ (0=system, 1=FSM)
!end_xlist

!label %apgi_2
!label VDI-Ger„tenummer
!label Ger„tenummer des VDI
!label Resource-Format, neues
!label Farbicons vorhanden?
!label Icons vorhanden?, Farb-
(!B)2: Farben(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
VDI-Ger„tenummer (device id)
!item [ap_gout2:]
Farben fr OBJECTs
!item [ap_gout3:]
Farbicons vorhanden (1) bzw. nicht (0)
!item [ap_gout4:]
neues RSC-Format vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_3
!label Sprache des Betriebssystems
(!B)3: Sprache(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
!begin_table [l l l]
0 !! - !! Englisch
1 !! - !! Deutsch
2 !! - !! Franz”sisch
3 !! - !! reserviert
4 !! - !! Spanisch
5 !! - !! Italienisch
6 !! - !! Schwedisch
!end_table
!end_xlist

!label %apgi_4
!label Multitasking preemptive?
!label Pr„emptives Multitasking?
!label Preemptives Multitasking?
(!B)4: allgemeine Informationen-1(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
Multitasking pr„emptiv (1) oder nicht (0)
!item [ap_gout2:]
appl_find konvertiert MiNT/(!nolink [AES])-ID's (1) oder nicht (0)
!item [ap_gout3:]
appl_search vorhanden (1) oder nicht (0)
!item [ap_gout4:]
rsrc_rcfix vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_5
(!B)5: allgemeine Informationen-2(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
objc_xfind vorhanden (1) oder nicht (0)
!item [ap_gout2:]
reserviert, immer 0
!item [ap_gout3:]
menu_click vorhanden (1) oder nicht (0)
!item [ap_gout4:]
shel_r/wdef vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_6
(!B)6: allgemeine Informationen-3(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
appl_read (-1) vorhanden (1) oder nicht (0)
!item [ap_gout2:]
shel_get (-1) vorhanden (1) oder nicht (0)
!item [ap_gout3:]
menu_bar (-1) vorhanden (1) oder nicht (0)
!item [ap_gout4:]
menu_bar (100) (MagiC) vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_7
(!B)7: reserviert fr (!nolink [MagiC]) und andere Erweiterungen, MultiTOS setzt alle
Rckgabewerte immer auf 0. In MagiC gilt:(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
!begin_xlist !short
!item [Bit-0 =]
wdlg_xx()-Funktionen vorhanden (1) 
!item [Bit-1 =]
lbox_xx()-Funktionen vorhanden (1)
!item [Bit-2 =]
fnts_xx()-Funktionen vorhanden (1)
!item [Bit-3 =]
fslx_xx()-Funktionen vorhanden (1)
!item [Bit-4 =]
pdlg_xx()-Funktionen vorhanden (1)
!end_xlist
!item [ap_gout2:]
reserviert 
!item [ap_gout3:]
reserviert
!item [ag_gout4:]
reserviert
!end_xlist

!label %apgi_8
!label Mausformverwaltung, Art der
!label Verwaltung der Mausform
(!B)8: Maus(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
graf_mouse Modi (258-260) vorhanden (1) oder nicht (0)
!item [ap_gout2:]
Mausform vom (!nolink [AES]) fr jede Applikation verwaltet (1) oder nicht (0)
!end_xlist

!label %apgi_9
(!B)9: Mens(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
MultiTOS-Submens vorhanden (1) oder nicht (0)
!item [ap_gout2:]
MultiTOS-Popups vorhanden (1) oder nicht (0)
!item [ap_gout3:]
MultiTOS-Scrollmens vorhanden (1) oder nicht (0)
!item [ap_gout4:]
erweiterte MN_SELECTED-Nachricht vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_10
(!B)10: shel_write(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
vorhandene Modi
!begin_xlist !short [Bit 8..15:]
!item [Bit 0..7:]
h”chster zul„ssiger Wert fr sh_wdoex & 0x00ff
!item [Bit 8..15:]
Bits von sh_wdoex & 0xff00, die wie in MultiTOS behandelt werden.
!end_xlist
!item [ap_gout2:]
!begin_xlist !short [0:]
!item [1:]
(!nolink [shel_write]) (0) macht vorherige (!nolink [shel_write]) Aufrufe ungltig (d.h. das Desktop
wird Nachfolgeprogramm) (TOS 1.04 und MagiC)
!item [0:]
startet Programm (MultiTOS)
!end_xlist
!item [ap_gout3:]
!begin_xlist !short [0:]
!item [1:]
(!nolink [shel_write]) (1) startet Programm nach Beendigung des laufenden (TOS 1.04 und
(!nolink [MagiC]))
!item [0:]
startet Programm sofort (MultiTOS)
!end_xlist
!item [ap_gout4:]
ARGV via sh_wiscr untersttzt (1) oder nicht (0)
!end_xlist

!label %apgi_11
(!B)11: Fenster(!b)
!begin_xlist !short [ap_gout1:]
!item [ag_gout1:]
gesetzte Bits sind untersttzte Funktionen:
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
WF_TOP liefert zweitoberstes Fenster
!item [1:]
(!nolink [wind_get]) (WF_NEWDESK)
!item [2:]
wind_g/set (WF_COLOR)
!item [3:]
wind_g/set (WF_DCOLOR)
!item [4:]
(!nolink [wind_get]) (WF_OWNER)
!item [5:]
wind_g/set (WF_BEVENT)
!item [6:]
WF_BOTTOM
!item [7:]
WF_ICONIFY
!item [8:]
WF_UNICONIFY
!item [9..15:]
reserviert, immer 0
!end_xlist

!item [ap_gout2:]
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
(!nolink [wind_get])/set (WF_WIDGETS), N.AES
!item [1..15:]
reserviert
!end_xlist
!item [ap_gout3:]
vorhandene Fensterbuttons
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
Iconifier
!item [1:]
Backdrop-Button (MagiC)
!item [2:]
Shift-Click fr Backdrop
!item [3:]
"Hot" Closebox (GEM/3 und MagiC)
!item [4..15:]
reserviert, 0
!end_xlist
!item [ap_gout4:]
wind_update 'check and set' vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_12
(!B)12: Nachrichten(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
gesetzte Bits sind untersttzte Nachrichten:
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
WM_NEWTOP
!item [1:]
WM_UNTOPPED
!item [2:]
WM_ONTOP
!item [3:]
AP_TERM
!item [4:]
MultiTOS-Aufl”sungswechsel
!item [5:]
CH_EXIT
!item [6:]
WM_BOTTOM
!item [7:]
WM_ICONIFY
!item [8:]
WM_UNICONIFY
!item [9:]
WM_ALLICONIFY
!end_xlist
!item [ap_gout2:]
reserviert, alle 0
!item [ap_gout3:]
WM_ICONIFY liefert Koordinaten (1) oder nicht (0)
!end_xlist

!label %apgi_13
(!B)13: OBJECTs(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
3D-Objekte ber ob_flags vorhanden (1) oder nicht (0)
!item [ap_gout2:]
objc_sysvar vorhanden (1) oder nicht (0)
!item [ap_gout3:]
Speedo- und GDOS-Fonts im TEDINFO erlaubt (1) oder nicht (0)
!item [ap_gout4:]
reserviert fr MagiC und andere Erweiterungen, MultiTOS setzt alle
Rckgabewerte immer auf 0. In (!nolink [MagiC]) und N.AES gilt:
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
G_SWBUTTON vorhanden
!item [1:]
G_POPUP vorhanden
!item [2:]
WHITEBAK steuert Unterstriche und Buttons
!item [3:]
G_SHORTCUT vorhanden
!end_xlist
!end_xlist

!label %apgi_14
!label Flydials vorhanden?
!label Tastaturtabellen vorhanden?
!label MagiC-Flydials vorhanden?
!label MagiC-Tastaturtab. vorhanden?
!label Cursorposition, Rckgabe der
(!B)14: Formulare ((!nolink [MagiC]) form_xdo und form_xdial)(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
(!nolink [MagiC])-Flydials vorhanden (1) oder nicht (0)
!item [ap_gout2:]
(!nolink [MagiC])-Tastaturtabellen vorhanden (1) oder nicht (0)
!item [ap_gout3:]
letzte Cursorposition wird zurckgegeben (1) oder nicht (0)
!item [ap_gout4:]
reserviert, 0
!end_xlist

!label %apgi_64
(!B)64: Erweiterte Funktionen(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
shel_write(10) mit AP_AESTERM m”glich (1) oder nicht (0)
!item [ap_gout2:]
extended (!nolink [shel_write])() SHW_SHUTDOWN(4)/SHW_RESCHANGE(5) vorhanden (1)
oder nicht (0)
!item [ap_gout3:]
appl_search() mit Langnamen vorhanden (1) oder nicht (0)
!item [ap_gout4:]
form_error() mit allen GEMDOS-Fehlercodes vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_65
(!B)65: Zus„tzliche N.(!nolink [AES]) Funktionen(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:] appl_control() vorhanden (1) oder nicht (0)
!item [ap_gout2:] h”chster Opcode fr appl_control()
!item [ap_gout3:] shel_help() vorhanden (1) oder nicht (0)
!item [ap_gout4:] wind_draw() vorhanden (1) oder nicht (0)
!end_xlist

(!B)Hinweis:(!b) Ein Problem dieser Funktion besteht darin, festzustellen,
wann sie berhaupt aufgerufen werden darf. Zwar sollte sie ab AES-Version
4.0 vorhanden sein, MagiC 2.0 (und auch MagiC 3.0) besitzt
aber beispielsweise die Version 3.99. Aus diesem Grund definieren viele
Programmierer die Funktion appl_xgetinfo, in der berprft wird, ob
appl_getinfo in der aktuellen Systemumgebung vorhanden ist.
!item [Ergebnis:]
Ein Rckgabewert von 0 zeigt einen Fehler an; bei einem Wert von 1 ist kein
Fehler aufgetreten.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
(!ende_liste)



!begin_node Bindings fr appl_getinfo
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_getinfo ( WORD ap_gtype, WORD *ap_gout1, WORD *ap_gout2,
                    WORD *ap_gout3, WORD *ap_gout4 );
!item [Implementierung:]
!begin_verbatim
WORD appl_getinfo (WORD ap_gtype, WORD *ap_gout1, WORD *ap_gout2,
                   WORD *ap_gout3, WORD *ap_gout4)
{
   int_in[0] = ap_gtype;

   crys_if (130);

   *ap_gout1 = int_out[1];
   *ap_gout2 = int_out[2];
   *ap_gout3 = int_out[3];
   *ap_gout4 = int_out[4];

   return ( int_out[0] );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 130   Opcode der Funktion
control+2 !! control[1] !! 1     # Eintr„ge in int_in
control+4 !! control[2] !! 5     # Eintr„ge in int_out
control+6 !! control[3] !! 0     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_in !! int_in[0] !! ap_gtype
int_out !! int_out[0] !! Return-Wert
int_out+2 !! int_out[1] !! ap_gout1
int_out+4 !! int_out[2] !! ap_gout2
int_out+6 !! int_out[3] !! ap_gout3
int_out+8 !! int_out[4] !! ap_gout4
!end_table
(!ende_liste)
!end_node



!begin_node appl_xgetinfo
!label appl_getinfo, Existenz von
!begin_verbatim
/* Der folgende Code testet, ob appl_getinfo in der aktuellen
   Systemumgebung zur Verfgung steht, und ruft im positiven
   Fall die besagte Funktion auf.
   
   Es bietet sich an, statt appl_getinfo nur appl_xgetinfo
   in eigenen Programmen zu verwenden. */
   
   
GLOBAL WORD appl_xgetinfo ( WORD type, WORD *out1, WORD *out2,
                            WORD *out3, WORD *out4 )
{

   BOOLEAN has_agi = FALSE;

   has_agi = ((_GemParBlk.global[0] == 0x399 && (is_MagiC() >= 0x0200))
             || (_GemParBlk.global[0] >= 0x400)
             || (appl_find ("?AGI") >= 0));

   if (has_agi)
      return (appl_getinfo (type, out1, out2, out3, out4));
   else
      return (0);
} /* appl_xgetinfo */
!end_verbatim

Die Abfrage is_MagiC ist eine Funktion, welche den (!nolink [MagiC])-Cookie
auswertet und die
Versionsnummer zurckliefert. Dies ist notwendig da bereits (!nolink [MagiC]) 2
die Funktion
(!nolink [appl_getinfo]) kennt, allerdings noch nicht die Abfrage per "?AGI" erlaubt.

Querverweis: (!link [Applikationen][Applikationsfunktionen]) ~  GEM ~
Style-Guidelines
!end_node
!end_node



!begin_node appl_init
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application Initialization® - meldet die Applikation unter (!nolink [AES]) an.
!item [AES-Nummer:]
10
!item [Binding:]
(!link [Bindings fr appl_init] [Bindings fr appl_init])
!item [Beschreibung:]
Die Funktion meldet das Programm beim AES an, und initialisiert die
internen Parameterbergabefelder.

(!B)Hinweis:(!b) Die Versionsnummer des AES l„t sich nach diesem Aufruf
ber das Globalfeld (global[0]) erfragen.

!label Auto-Ordner, Start aus dem
Um zu testen, ob ein Programm aus dem Auto-Ordner heraus gestartet worden
ist, bietet sich folgendes Verfahren an:
!begin_xlist !short
!item [ù]
Wert 0 in (!nolink [global])[0] schreiben
!item [ù]
Funktion appl_init aufrufen
!item [ù]
Globalfeld ((!nolink [global])[0]) inspizieren: steht dort immer noch eine Null, so ist
das (!nolink [AES]) noch nicht betriebsbereit, und das Programm wurde aus dem
Auto-Ordner heraus gestartet.
!end_xlist
Dieses Verfahren ist zwar nicht offiziell dokumentiert, wird aber auch im
Mausbeschleuniger MACCEL von Atari so angewendet.
!item [Ergebnis:]
Die Funktion liefert die ID der Applikation zurck. Im Fehlerfall wird der
Wert -1 zurckgegeben.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:] appl_find ~ appl_search ~ appl_exit
(!ende_liste)



!begin_node Bindings fr appl_init
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_init ( VOID );
!item [Implementierung:]
!begin_verbatim
EXTERN AESPB c;

WORD appl_init (VOID)
{
   c.cb_pcontrol = control;
   c.cb_pglobal  = global;
   c.cb_pintin   = int_in;
   c.cb_pintout  = int_out;
   c.cb_padrin   = addr_in;
   c.cb_padrout  = addr_out;

   control[4] = 0;
   crys_if (10);

   return (int_out[0]);
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 10    Opcode der Funktion
control+2 !! control[1] !! 0     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 0     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_read
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application read® - empf„ngt eine Mitteilung einer anderen Applikation.
!item [AES-Nummer:]
11
!item [Binding:]
(!link [Bindings fr appl_read] [Bindings fr appl_read])
!item [Beschreibung:]
Die Funktion liest eine Anzahl von Bytes aus der Message-Pipe. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_rid]
ID der Applikation, aus deren Ereignispuffer gelesen werden soll.
!item [ap_rlength]
Anzahl der zu lesenden Bytes
!item [ap_rpbuff]
Adresse des Puffers, in dem die Daten abgelegt werden sollen
!end_xlist
Die Funktion wartet ggfs. bis die angeforderte Anzahl an Bytes tats„chlich
zur Verfgung steht. In MagiC und MultiTOS ist die Funktion so erweitert
worden, da sie mit einer entsprechenden Meldung zurckkehrt, wenn keine
Daten vorhanden sind ((!I)ap_rid:(!i) -1).

(!B)Hinweis:(!b) appl_read arbeitet destruktiv, d.h. da Nachrichten nach
dem Auslesen aus der Message-Pipe entfernt werden. Dies macht es notwendig,
die gelesene Nachricht so auszuwerten, wie es beispielsweise nach einem
evnt_multi-Aufruf geschieht.

Das Vorhandensein des erweiterten Feature kann ber appl_getinfo (Opcode 6)
abgefragt werden.
!item [Ergebnis:]
Wird eine Null zurckgegeben, so ist ein Fehler aufgetreten, sonst wird
eine positive Zahl als Ergebnis zurckgegeben.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_init ~  appl_write ~  evnt_mesag ~  evnt_multi
(!ende_liste)



!begin_node Bindings fr appl_read
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_read ( WORD ap_rid, WORD ap_rlength, VOID *ap_rpbuff );
!item [Implementierung:]
!begin_verbatim
WORD appl_read (WORD ap_rid, WORD ap_rlength, VOID *ap_rpbuff)
{
   int_in[0]  = ap_rid;
   int_in[1]  = ap_rlength;
   addr_in[0] = ap_rpbuff;

   return ( crys_if(11) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 11    Opcode der Funktion
control+2 !! control[1] !! 2     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 1     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_in !! int_in[0]  !! ap_rid
int_in+2  !! int_in[1]  !! ap_rlength
addr_in !! addr_in[0] !! ap_rpbuff
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_search
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application search® - im System vorhandene Applikationen suchen.
!item [AES-Nummer:]
18
!item [Binding:]
(!link [Bindings fr appl_search] [Bindings fr appl_search])
!item [Beschreibung:]
Je nach Parameter sucht die Funktion verschiedene im System vorhandene
Applikationen. Es bedeuten:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_smode]
(!B)Suche(!b)
!begin_table [l l l]
0 !! = !! erste Applikation
1 !! = !! n„chste Applikation
2 !! = !! System Shell
!end_table
!item [ap_sname]
Puffer der den Namen der gefundenen Applikation aufnimmt (mindestens
9 Bytes).
!item [ap_stype]
(!B)Typ des Prozesses als Bitvektor(!b)
!begin_table [l l l]
Bit-0 !! = !! System-Proze
Bit-1 !! = !! Applikation
Bit-2 !! = !! Accessory
Bit-3 !! = !! System Shell
!end_table
!item [ap_sid]
ID der gefundenen Applikation
!end_xlist

Bei N.AES kann der Langname einer Applikation ermittelt werden, wenn 
man ihre Applikations-ID kennt.

Der Langname ist derjenige, der von der Applikation bei einem menu_register()- 
Aufruf bergeben wurde und auch in der Menleiste dargestellt wird.

Kennt man die Applikations-ID apid einer Anwendung, so wird ihr Langname vom 
(!nolink [N.AES]) durch folgenden Aufruf von appl_search in den Buffer langname
bertragen:

     appl_search(-apid, &langname[0], &typ, &pid)

typ ist hierbei die auch normalerweise gelieferte Bitmaske des Applikationstyps,
pid die MiNT-pid (nicht: apid) der Applikation.

Als erster Parameter ist also der negative Wert der Applikations-ID zu 
bergeben, um den Langnamen eben dieser Applikation zu ermitteln. Dieser Name 
kann maximal 32 Zeichen lang sein (31 Zeichen plus ein Nullbyte), man sollte 
also einen entsprechend groen Buffer fr langname reservieren.

(!B)Hinweis:(!b) Mit dieser Routine k”nnen (!I)keine(!i) Threads gefunden
werden. Das Vorhandensein dieser Funktion kann per (!link [appl_getinfo][%apgi_4])
(Opcode 4)
festgestellt werden. Die Ermittlung des Langname erkennt man an
(!link [appl_getinfo][%apgi_64]) (Opcode 64).
!item [Ergebnis:]
Die Funktion liefert den Wert 1, wenn kein Fehler aufgetreten ist, bzw. den
Wert 0, wenn keine weiteren Applikationen vorhanden sind.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_find ~  appl_getinfo ~  (!link [Broadcasting][AES-Broadcasting])
(!ende_liste)



!begin_node Bindings fr appl_search
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_search ( WORD ap_smode, BYTE *ap_sname, WORD *ap_stype,
                   WORD *ap_sid );
!item [Implementierung:]
!begin_verbatim
WORD appl_search (WORD ap_smode, BYTE *ap_sname, WORD *ap_stype,
                  WORD *ap_sid)
{
   int_in[0]  = ap_smode;
   addr_in[0] = ap_sname;

	crys_if(18);
	
	*ap_stype = int_out[1];
	*ap_sid   = int_out[2];
	
   return ( int_out[0] );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 18    Opcode der Funktion
control+2 !! control[1] !! 1     # Eintr„ge in int_in
control+4 !! control[2] !! 3     # Eintr„ge in int_out
control+6 !! control[3] !! 1     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_in !! int_in[0]  !! ap_smode
addr_in !! addr_in[0] !! ap_sname
int_out !! int_out[0] !! Return-Wert
int_out+2 !! int_out[1] !! ap_stype
int_out+4 !! int_out[2] !! ap_sid
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_tplay
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application play® - spielt aufgezeichnete (!nolink [AES])-Ereignisse ab.
!item [AES-Nummer:]
14
!item [Binding:]
(!link [Bindings fr appl_tplay] [Bindings fr appl_tplay])
!item [Beschreibung:]
Die Funktion bietet die M”glichkeit, aufgezeichnete Benutzeraktionen wieder
abzuspielen. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_tpmem]
Adresse des Puffers, in welchem sich die abzuspielenden Ereignisse befinden
!item [ap_tpnum]
Anzahl der auszufhrenden Ereignisse
!item [ap_tpscale]
Geschwindigkeitsfaktor fr das Abspielen der Ereignisse. Ein Wert von 100
steht fr normale Geschwindigkeit
!end_xlist
!item [Ergebnis:]
Als Ergebnis wird immer der Wert 1 zurckgegeben.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_trecord
(!ende_liste)



!begin_node Bindings fr appl_tplay
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_tplay ( APPLRECORD *ap_tpmem, WORD ap_tpnum, WORD ap_tpscale );
!item [Implementierung:]
!begin_verbatim
WORD appl_tplay (APPLRECORD *ap_tpmem, WORD ap_tpnum, WORD ap_tpscale)
{
   int_in[0]  = ap_tpnum;
   int_in[1]  = ap_tpscale;
   addr_in[0] = ap_tpmem;

   return ( crys_if(14) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 14    Opcode der Funktion
control+2 !! control[1] !! 2     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 1     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_in !! int_in[0] !! ap_tpnum
int_in+2  !! int_in[1] !! ap_tpscale
addr_in !! addr_in[0] !! ap_tpmem
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_trecord
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application record® - nimmt (!nolink [AES])-Ereignisse auf.
!item [AES-Nummer:]
15
!item [Binding:]
(!link [Bindings fr appl_trecord] [Bindings fr appl_trecord])
!item [Beschreibung:]
Die Funktion dient zum Speichern von Benutzeraktionen, um diese sp„ter
wieder abzuspielen. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_tbuffer]
Adresse des Speicherbereichs, in dem die Ereignisse abgelegt werden sollen
!item [ap_trcount]
Anzahl der zu speichernden Ereignisse
!end_xlist
(!B)Hinweis:(!b) Die Funktion ist erst ab GEM-Version 1.2 richtig
implementiert.
!item [Ergebnis:]
Als Ergebnis wird die Anzahl der tats„chlich aufgezeichneten Ereignisse
zurckgeliefert.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_tplay
(!ende_liste)    



!begin_node Bindings fr appl_trecord
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_trecord ( APPLRECORD *ap_tbuffer, WORD ap_trcount );
!item [Implementierung:]
!begin_verbatim
WORD appl_trecord (APPLRECORD *ap_tbuffer, WORD ap_trcount)
{
   int_in[0]  = ap_trcount;
   addr_in[0] = ap_tbuffer;

   return ( crys_if(15) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 15    Opcode der Funktion
control+2 !! control[1] !! 1     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 1     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_in !! int_in[0] !! ap_trcount
addr_in !! addr_in[0] !! ap_tbuffer
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)       
!end_node
!end_node


                        
!begin_node appl_write
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application write® - sendet eine Mitteilung an eine andere Applikation.
!item [AES-Nummer:]
12
!item [Binding:]
(!link [Bindings fr appl_write] [Bindings fr appl_write])
!item [Beschreibung:]
Die Funktion schreibt eine Anzahl von Bytes in eine Message-Pipe. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_wid]
ID der Applikation, zu der die Nachricht geschickt werden soll
!item [ap_wlength]
Anzahl der zu sendenden Bytes
!item [ap_wpbuff]
Adresse des Puffers mit der zu bertragenden Nachricht
!end_xlist
(!B)Hinweis:(!b) Durch diese Funktion besitzt eine Applikation auch die
M”glichkeit, sich selbst eine Redraw-Nachricht zukommen zu lassen. Ab MagiC
Version 4.0 gilt: besitzt der Parameter (!I)ap_wid(!i) den Wert -2, so zeigt
(!I)ap_wpbuff(!i) auf eine XAESMSG-Struktur.
!item [Ergebnis:]
Wird eine Null zurckgegeben, so ist ein Fehler aufgetreten, sonst wird
eine positive Zahl als Ergebnis zurckgegeben.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_init  ~ appl_read ~  appl_find ~  Nachrichten
(!ende_liste)



!begin_node Bindings fr appl_write
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_write ( WORD ap_wid, WORD ap_wlength, VOID *ap_wpbuff );
!item [Implementierung:]
!begin_verbatim
WORD appl_write (WORD ap_wid, WORD ap_wlength, VOID *ap_wpbuff)
{
   int_in[0]  = ap_wid;
   int_in[1]  = ap_wlength;
   addr_in[0] = ap_wpbuff;

   return ( crys_if(12) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 12    Opcode der Funktion
control+2 !! control[1] !! 2     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 1     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_in !! int_in[0] !! ap_wid
int_in+2 !! int_in[1] !! ap_wlength
addr_in !! addr_in[0] !! ap_wpbuff
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_yield
(!begin_liste) [Beschreibung:]
!item [Name:]
¯Application yield® - Prozewechsel erzwingen
!item [AES-Nummer:]
17
!item [Binding:]
(!link [Bindings fr appl_yield] [Bindings fr appl_yield])
!item [Beschreibung:]
Mit Hilfe dieser Funktion kann ein AES-Prozewechsel erzwungen werden.

(!B)Hinweis:(!b) Dies kann analog durch einen kurzen Aufruf der Funktion
evnt_timer erreicht werden. Die Funktion steht nur unter PC-GEM sowie MagiC
(jeweils) ab Version 2.0 und N.AES zur Verfgung.
!item [Ergebnis:]
Der Rckgabewert der Funktion ist z.Zt. nicht bekannt.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
evnt_timer
(!ende_liste)



!begin_node Bindings fr appl_yield
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_yield ( VOID );
!item [Implementierung:]
!begin_verbatim
WORD appl_yield (VOID)
{
   return ( crys_if(17) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 17    Opcode der Funktion
control+2 !! control[1] !! 0     # Eintr„ge in int_in
control+4 !! control[2] !! 1     # Eintr„ge in int_out
control+6 !! control[3] !! 0     # Eintr„ge in addr_in
control+8 !! control[4] !! 0     # Eintr„ge in addr_out
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node
