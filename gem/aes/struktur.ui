!begin_node AES-Strukturen

!subtoc [stg, html]

!begin_node APPLRECORD

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    LONG type;      /* Art des Ereignisses */
    LONG what;      /* genaue Beschreibung des Ereignisses */
} APPLRECORD
!end_verbatim

(!B)FÅr die Komponenten gilt dabei:(!b)

!begin_xlist !short [type tastatur-event]
!item [type Bedeutung]
what
!item [~]
~
!item [0~~ Timer-Event]
Anzahl der Millisekunden
!item [1~~ Button-Event]
Anzahl der TastendrÅcke (High-Word), Status der Maustaste (Low-Word),
und zwar: 0 = nicht gedrÅckt, 1 = gedrÅckt.
!item [2~~ Maus-Event]
X-Koordinate (High-Word), Y-Koordinate (Low-Word).
!item [3~~ Tastatur-Event]
eingegebenes Zeichen (Low-Word), Tastatur-Status (High-Word), und zwar:
!begin_xlist !short [Shift-Rechts:]
!item [Shift-Rechts:]
0x0001
!item [Shift-Links:]
0x0002
!item [Control:]
0x0004
!item [Alternate:]
0x0008
!end_xlist
!end_xlist

(!B)Hinweis:(!b) Unter PC-GEM belegt jedes Ereignis nur 6 Bytes, da die
Komponente (!I)type(!i) von APPLRECORD dort als WORD definiert ist.

Querverweis: appl_tplay ~ appl_trecord
!end_node


!begin_node Die Bit-Block-Struktur
!label BITBLK
Ein Bit-Image kann immer dort eingesetzt werden, wo ein nicht anwÑhlbares
Icon stehen kînnte; der entscheidende Unterschied ist nÑmlich, daû es zu
einem Bit-Image (!I)keine Maske(!i) gibt.

!begin_verbatim
typedef struct
{
	WORD  *bi_pdata;     /* Zeiger auf die Grafikdaten    */
	WORD  bi_wb;         /* Breite des Bildes in Bytes    */
	WORD  bi_hl;         /* Hîhe in Zeilen                */
	WORD  bi_x;          /* x-Position                    */
	WORD  bi_y;          /* y-Position                    */
	WORD  bi_color;      /* Farbe                         */
} BITBLK;
!end_verbatim

(!B)Hinweis:(!b) Die Breite eines Bit-Images (Komponente (!I)bi_wb(!i)) muû
stets durch 2 teilbar sein.

Querverweis: OBJECT ~ Objektarten des AES
!end_node


!begin_node CICON

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct cicon_data
{
	WORD num_planes;   /* Anzahl der Planes fÅr die folgenden Daten */
	WORD *col_data;    /* Zeiger auf Farb-Bitmap in Standardform    */
	WORD *col_mask;    /* Zeiger auf einzelne Farb-Plane Maske      */
	WORD *sel_data;    /* Zeiger auf Farb-Bitmap des selekt. Icons  */
	WORD *sel_mask;    /* Zeiger auf einzelne Plane-Maske des Icons */
	struct cicon_data *next_res; /* Zeiger auf Icon anderer Auflîsung */
} CICON;
!end_verbatim

Querverweis: CICONBLK ~ ICONBLK ~ OBJECT
!end_node


!begin_node CICONBLK

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct cicon_blk
{
   ICONBLK monoblk;    /* Default: monochrome Icons */
   CICON   *mainlist;  /* Farb-Icons fÅr verschiedene Auflîsungen */
} CICONBLK;
!end_verbatim

Querverweis: OBJECT ~ (!link [Objektstruktur im AES][Die Objekt-Struktur])
!end_node

!begin_node DIALOG

!begin_verbatim
typedef VOID *DIALOG;
!end_verbatim
!end_node

!begin_node DITHER_MODE

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _dither_mode
{
   struct _dither_mode  *next;  /* Zeiger auf Nachfolger     */
   LONG        length;          /* StrukturlÑnge             */
   LONG        format;          /* Datenformat               */
   LONG        reserved;        /* reserviert                */
   LONG        dither_id;       /* Kennung                   */
   LONG        color_modes;     /* unterstÅtzte Farbtiefen   */
   LONG        reserved1;       /* reserviert                */
   LONG        reserved2;       /* reserviert                */
   BYTE        name[32];        /* Name des Rasterverfahrens */
} DITHER_MODE;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node DRV_ENTRY

!begin_verbatim
typedef struct _drv_entry
{
   struct _drv_entry *next; /* Zeiger auf Nachfolger */
} DRV_ENTRY;
!end_verbatim
!end_node


!begin_node DRV_INFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   LONG        magic;           /* 'pdnf'                           */
   LONG        length;          /* StrukturlÑnge                    */
   LONG        format;          /* Datenformat                      */
   LONG        reserved;        /* reserviert                       */
   WORD        driver_id;       /* Treibernummer fÅrs VDI           */
   WORD        driver_type;     /* Treibertyp                       */
   LONG        reserved1;       /* reserviert                       */
   LONG        reserved2;       /* reserviert                       */
   LONG        reserved3;       /* reserviert                       */
   PRN_ENTRY   *printers;       /* zum Treiber gehîrenden Drucker   */
   DITHER_MODE *dither_modes;   /* unterstÅtzte Rasterverfahren     */
   LONG        reserved4;       /* reserviert                       */
   LONG        reserved5;       /* reserviert                       */
   LONG        reserved6;       /* reserviert                       */
   LONG        reserved7;       /* reserviert                       */
   LONG        reserved8;       /* reserviert                       */
   LONG        reserved9;       /* reserviert                       */
   BYTE        device[128];     /* Ausgabedatei des Druckertreibers */
} DRV_INFO;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node 

!begin_node EVNT

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    WORD mwhich;         /* Art der Ereignisse                */
    WORD mx;             /* x-Koordinate des Mauszeigers      */
    WORD my;             /* y-Koordinate des Mauszeigers      */
    WORD mbutton;        /* gedrÅckte Maustaste               */
    WORD kstate;         /* Status der Sondertasten (kbshift) */
    WORD key;            /* Scancode der gedrÅckten Taste     */
    WORD mclicks;        /* Anzahl der Mausklicks             */
    WORD reserved[9];    /* reserviert                        */
    WORD msg[16];        /* Message-Buffer                    */
} EVNT;
!end_verbatim

Querverweis: fnts_evnt ~ fslx_evnt ~  wdlg_evnt
!end_node


!begin_node FNT_DIALOG

!begin_verbatim
typedef VOID *FNT_DIALOG;
!end_verbatim
!end_node


!begin_node FNTS_ITEM

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _fnts_item
{
    struct   _fnts_item  *next; /* Zeiger auf den nÑchsten Font oder 0L */
    UTXT_FN  display;           /* Anzeige-Funktion fÅr eigene Fonts    */
    LONG     id;                /* ID des Fonts                         */
    WORD     index;             /* muû 0 sein, da kein VDI-Font         */
    BYTE     mono;              /* Flag fÅr Ñquidistante Fonts          */
    BYTE     outline;           /* Flag fÅr Vektorfont                  */
    WORD     npts;              /* Anzahl der vordefinierten Punkthîhen */
    BYTE     *full_name;        /* Zeiger auf den vollstÑndigen Namen   */
    BYTE     *family_name;      /* Zeiger auf den Familiennamen         */
    BYTE     *style_name;       /* Zeiger auf den Stilnamen             */
    BYTE     *pts;              /* Zeiger auf Feld mit Punkthîhen       */
    LONG     reserved[4];       /* reserviert, mÅssen 0 sein            */
} FNTS_ITEM;
!end_verbatim

Querverweis: fnts_add ~ Zeichensatzauswahl
!end_node


!begin_node HNDL_OBJ

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef WORD (cdecl *HNDL_OBJ) ( VOID *dialog, EVNT *events, WORD obj,
                                 WORD clicks, void *data );
!end_verbatim

Dabei gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [dialog]
Zeiger auf eine Dialogstruktur. Auf diese sollte nicht direkt, sondern nur
mit Hilfe der wdlg_xxx Funktionen zugegriffen werden.
!item [events]
Zeiger auf die EVNT-Strukur, die bei wdlg_evnt Åbergeben wurde (falls der
Parameter (!I)obj(!i) >= 0 ist), oder NULL.
!item [obj]
!begin_xlist !short
!item [>=0:]
Objektnummer
!item [<0:]
Funktionsnummer. Definiert sind z.Zt:
!begin_verbatim
 -1 = HNDL_INIT    // Dialog initialisieren
 -2 = HNDL_MESG    //
 -3 = HNDL_CLSD    // Dialogfenster wurde geschlossen
 -5 = HNDL_OPEN    // Dialog-Initialisierung abschlieûen
 -6 = HNDL_EDIT    // Zeichen fÅr ein Editfeld prÅfen
 -7 = HNDL_EDDN    // Zeichen wurde ins Editfeld gesetzt
 -8 = HNDL_EDCH    // Editfeld wurde gewechselt
 -9 = HNDL_MOVE    // Dialog wurde verschoben
-10 = HNDL_TOPW    // Dialogfenster kam nach oben
-11 = HNDL_UNTP    // Dialogfenster ist nicht aktiv
!end_verbatim
!end_xlist
Von diesen Funktionsnummern muû nur auf HNDL_CLSD reagiert werden; alle
anderen Ereignisse kînnen je nach Bedarf beachtet werden.
!item [clicks]
Anzahl der Mausklicks, falls es sich bei (!I)obj(!i) um eine Objektnummer
handelt.
!item [data]
Falls der Parameter (!I)obj(!i) eine positive Objektnummer ist, wird hier
die Variable (!I)user_data(!i) aus der Funktion wdlg_create Åbergeben.
Anderenfalls ist der Wert von der entsprechenden Funktionsnummer abhÑngig.
!end_xlist

(!B)Hinweis:(!b) Die Funktion wird aufgerufen, wenn auf ein EXIT- oder
TOUCHEXIT Objekt geklickt wurde (in diesem Fall ist (!I)obj(!i) eine
positive Objektnummer) oder wenn ein den Dialog betreffendes Ereignis
eingetreten ist (dann ist (!I)obj(!i) negativ und enthÑlt eine entsprechende
Funktionsnummer (s.o.)).

Die Parameter werden Åber den Stack Åbergeben und die Routine darf die
Register d0-d2/a0-a2 verÑndern. Falls die Funktion mit einer unbekannten
Funktionsnummer in (!I)obj(!i) aufgerufen wird oder eine der obigen
Funktionsnummern ignoriert werden soll, muû der Wert 1 zurÅckgeliefert
werden.

Querverweis: (!link [Beispiel-Implementation] [Beispiel zu HNDL_OBJ])



!begin_node Beispiel zu HNDL_OBJ

!begin_verbatim
/* Der folgende Code ist ein Beispiel fÅr eine Implementation
   der handle_exit Funktion, wie sie z.B. als Parameter bei
   wdlg_create vorkommt. */

WORD cdecl handle_exit ( VOID *dialog, EVNT *events, WORD obj, 
                         WORD clicks, void *data )
{
    /*
     * Ereignis oder Objektnummer?
     * Alle Ereignisse auûer HNDL_CLSD werden bei diesem Beispiel
     * ignoriert
     */
     
    if ( obj < 0 )
    {
        if ( obj == HNDL_CLSD )     /* Closer betÑtigt? */
            return( 0 );            /* beenden */
        if ( obj == HNDL_EDIT )
        {
            /*  In Fensterdialogen kann es nÅtzlich sein, Tasten-
                kombinationen mit Control in Eingabefeldern zu igno-
                rieren, damit Shortcuts wie z.B. Ctrl-U, Ctrl-W oder
                Ctrl-Q in der Eventschleife des Programms abgearbei-
                tet werden kînnen. In diesem Fall sollte nach HNDL_EDIT
                eine 0 zurÅckgeliefert werden, damit die Taste nicht
                von objc_edit bearbeitet wird.
            */
        }
    }
    else 
    {                          /* ein Objekt ist angewÑhlt worden */
        switch ( obj )        /* Aktionen einleiten (falls nîtig) */
        {            
            case ...
              .
              .
              .
            case MY_EXIT_OBJECT:    ..... return( 0 );  /* beenden */
        }
    }
    return( 1 ); /* weitermachen */
}
!end_verbatim
!end_node



!begin_node HNDL_INIT

(!I)data(!i) ist die bei (!B)wdlg_init(!b) Åbergebene Variable. Falls
handle_exit den Wert 0 zurÅckliefert, legt (!B)wdlg_create(!b) keine
Dialog-Struktur an (Fehler). Die Variable code wird in (!I)clicks(!i)
Åbergeben.
!end_node



!begin_node HNDL_MESG

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.
(!I)events(!i) zeigt auf die bei wdlg_evnt Åbergebene EVNT-Struktur.

(!B)Hinweis:(!b) Dieser Code wird nur dann Åbergeben, wenn ein
Nachrichtencode zwischen 20 und 39 empfangen wurde, der nicht mit den
anderen Opcodes bearbeitet wird. Er wird z.B. fÅr die Ikonifizierung
benîtigt. (!B)Achtung:(!b) Dieser Opcode wird erst seit der MagiC-Version
4.50 vom 18.04.96 unterstÅtzt.
!end_node



!begin_node HNDL_OPEN

(!I)data(!i) ist die bei (!B)wdlg_open(!b) Åbergebene Variable. Die Variable
code wird in (!I)clicks(!i) Åbergeben.
!end_node



!begin_node HNDL_CLSD

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.

(!I)events(!i) zeigt auf die bei wdlg_evnt Åberg. EVNT-Struktur.
!end_node



!begin_node HNDL_MOVE

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.

(!I)events(!i) zeigt auf die bei wdlg_evnt Åberg. EVNT-Struktur.
!end_node



!begin_node HNDL_TOPW

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.

(!I)events(!i) zeigt auf die bei wdlg_evnt Åberg. EVNT-Struktur.
!end_node



!begin_node HNDL_UNTP

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.

(!I)events(!i) zeigt auf die bei wdlg_evnt Åberg. EVNT-Struktur.
!end_node



!begin_node HNDL_EDIT

(!I)data(!i) zeigt auf ein Wort mit dem Tastencode. Falls handle_exit den
Wert 1 zurÅckliefert, wird der Tastendruck verarbeitet, bei 0 ignoriert.

(!I)events(!i) zeigt auf die bei (!B)wdlg_evnt(!b) Åberg. EVNT-Struktur.
!end_node



!begin_node HNDL_EDDN

(!I)data(!i) zeigt auf ein Wort mit dem Tastencode. (!I)events(!i) zeigt auf
die bei (!B)wdlg_evnt(!b) Åberg. EVNT-Struktur.
!end_node



!begin_node HNDL_EDCH

(!I)data(!i) zeigt auf ein Wort mit der Objektnummer des neuen Edit-Felds.
!end_node
!end_node

!begin_node ICONBLK

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
	UWORD   *ib_pmask;    /* Zeiger auf die Icon-Maske     */
	UWORD   *ib_pdata;    /* Zeiger auf das Icon-Bild      */
	BYTE    *ib_ptext;    /* Zeiger auf den Icon-Text      */
	UWORD   ib_char;      /* Zeichen das im Icon erschei-
	                         nen soll, sowie Vorder- und
	                         Hintergrundfarbe des Icons    */
	UWORD   ib_xchar;     /* x-Koordinate des Buchstabens  */
	UWORD   ib_ychar;     /* y-Koordinate des Buchstabens  */
	UWORD   ib_xicon;     /* x-Koordinate des Icons        */
	UWORD   ib_yicon;     /* y-Koordinate des Icons        */
	UWORD   ib_wicon;     /* Breite des Icons              */
	UWORD   ib_hicon;     /* Hîhe des Icons                */
	WORD    ib_xtext;     /* x-Koordinate des Textes       */
	WORD    ib_ytext;     /* y-Koordinate des Textes       */
	UWORD   ib_wtext;     /* Breite des Textes             */
	UWORD   ib_htext;     /* Hîhe des Textes               */
	UWORD   ib_resvd;     /* reserviert                    */
} ICONBLK;
!end_verbatim

(!B)Hinweise zu einzelnen Komponenten:(!b)

!begin_itemize
!item (!B)ib_pmask:(!b) Zeiger auf ein Feld von 16-Bit-Werten, in denen das
      Bit-Image der Icon-Maske abgelegt ist. Die Icon-Maske legt fest, an
      welchen Stellen das Icon Åberhaupt gezeichnet werden soll und welche
      Pixel transparent bleiben sollen. Erzielt wird dieser Effekt dadurch,
      daû der Iconhintergrund zunÑchst mit den Bits der Maske 'undiert' und
      dann mit den Icondaten 'geodert' wird.
!item (!B)ib_char:(!b)
!begin_xlist !short [15..12]
!item [Bits]
Bedeutung
!item [~]
~
!item [15..12]
Vordergrundfarbe des Icons
!item [11..08]
Hintergrundfarbe des Icons
!item [07..00]
Zeichen das im Icon erscheinen soll
!end_xlist
!item (!B)ib_resvd:(!b) unbenutzt, wird allerdings von den meisten
      RCS-Programmen beim Schreiben in die Resourcedatei aufgenommen.
!end_itemize

Querverweis: CICONBLK ~ OBJECT
!end_node

!begin_node MENU

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    OBJECT *mn_tree;    /* Adresse des MenÅ-Objektbaumes  */
    WORD mn_menu;       /* Index des Parent-Objektes      */
    WORD mn_item;       /* Anfangs-MenÅeintrag (bestimmt  */
                        /* die Position des MenÅs         */
    WORD mn_scroll;     /* 0 = nicht scrollen,            */
                        /* 1 = scrollen                   */
    WORD mn_keystate;   /* Tastaturstatus (Shift, Control */
                        /* bzw. Alternate)                */
} MENU;
!end_verbatim

Querverweis: AES ~ menu_attach ~ menu_popup
!end_node


!begin_node MFORM

Die Struktur MFORM legt das Aussehen des Mauszeigers fest, und ist wie folgt
definiert:

!begin_verbatim
typedef struct mfstr
{
    WORD  mf_xhot;       /* X-Pos. Aktionspunkt */
    WORD  mf_yhot;       /* Y-Pos. Aktionspunkt */
    WORD  mf_nplanes;    /* Anzahl der Planes   */
    WORD  mf_fg;         /* Maskenfarbe         */
    WORD  mf_bg;         /* Zeigerfarbe         */
    WORD  mf_mask[16];   /* Maskenform          */
    WORD  mf_data[16];   /* Zeigerform          */
} MFORM;
!end_verbatim

Querverweis: AES ~ graf_mouse
!end_node


!begin_node MN_SET

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    LONG display;    /* Anzeigeverzîgerung              */
    LONG drag;       /* Auswahlverzîgerung              */
    LONG delay;      /* Einfachklick Scroll-Verzîgerung */
    LONG speed;      /* Scroll-Verzîgerung              */
    WORD height;     /* Scroll-Hîhe (Anzahl der darzu-  */
                     /* stellenden EintrÑge)            */
} MN_SET;
!end_verbatim

(!B)Hinweis:(!b) Alle Verzîgerungszeiten werden in Millisekunden gemessen.

Querverweis: AES ~ menu_settings
!end_node

!begin_node LBOX_ITEM

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef struct _lbox_item
{
   struct _lbox_item *next;  /* Zeiger auf den nÑchsten Eintrag */
                             /* in der Scroll-Liste             */
   WORD    selected;         /* Objekt selektiert?     */
   WORD    data1;            /* Daten fÅr das Programm */
   VOID    *data2;
   VOID    *data3;
} LBOX_ITEM;
!end_verbatim

(!B)Hinweis:(!b) Die Struktur kann aber, wenn bei den Aufrufen entsprechend
gecastet wird, durchaus wie das folgende Beispiel aussehen:

!begin_verbatim
typedef struct
{
   VOID    *next;
   WORD    selected;

   ... ab hier nach Belieben der Applikation...
} LB_EXAMPLE;
!end_verbatim

Es ist lediglich darauf zu achten, daû als erstes Element ein Zeiger auf
den Nachfolger, und als zweites Element ein Wort das angibt, ob der
entsprechende Eintrag selektiert ist, vorhanden ist.

Querverweis: lbox_create ~ lbox_free_list ~ lbox_get_idx ~ lbox_get_item ~
lbox_get_items
!end_node

!begin_node LIST_BOX

!begin_verbatim
typedef VOID *LIST_BOX;
!end_verbatim
!end_node

!begin_node OBJECT

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   WORD    ob_next;   /* das nÑchste Objekt            */
   WORD    ob_head;   /* erstes Kind                   */
   WORD    ob_tail;   /* letztes Kind                  */
   UWORD   ob_type;   /* Objektart                     */
   UWORD   ob_flags;  /* Manipulationsflags            */
   UWORD   ob_state;  /* Objektstatus                  */
   BYTE   *ob_spec;   /* mehr unter Objektart          */
   WORD    ob_x;      /* x-Koordinate des Objekts      */
   WORD    ob_y;      /* y-Koordinate des Objekts      */
   WORD    ob_width;  /* Breite des Objekts            */
   WORD    ob_height; /* Hîhe des Objekts              */
} OBJECT;
!end_verbatim

Querverweis: (!link [Objektstruktur im AES][Die Objekt-Struktur])
!end_node


!begin_node PARMBLK

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   OBJECT  *pb_tree;         /* Zeiger auf den Objektbaum        */
   WORD     pb_obj;          /* Nummer des Objekts               */
   WORD     pb_prevstate;    /* vorheriger Objektstatus          */
   WORD     pb_currstate;    /* neuer Objektstatus               */
   WORD     pb_x;            /* x-Position des Objektes          */   
   WORD     pb_y;            /* y-Position des Objektes          */
   WORD     pb_w;            /* Breite des Objektes              */
   WORD     pb_h;            /* Hîhe des Objektes                */
   WORD     pb_xc;           /* x-Position des Clipping-Bereichs */
   WORD     pb_yc;           /* y-Position des Clipping-Bereichs */
   WORD     pb_wc;           /* Breite des Clipping-Bereichs     */
   WORD     pb_hc;           /* Hîhe des Clipping-Bereichs       */
   LONG     pb_parm;         /* Parameter der USERBLK-Struktur   */
} PARMBLK;
!end_verbatim

(!B)Hinweis:(!b) Das Objekt muû nur neu gezeichnet werden, wenn alter und
neuer Status identisch sind; anderenfalls reicht ein 'Update' des
Objektbaums aus. Ferner sollten folgende Punkte beachtet werden:

!begin_itemize
!item die eigene Funktion muû im Datenregister d0 dem (!nolink [AES]) zurÅckliefern,
      welche Aspekte des Objektstatus noch aktualisiert werden mÅssen. Damit
      ist es nicht unbedingt nîtig, in der eigenen Ausgabefunktion den Code
      zum invertieren des Objektes auszuprogrammieren. Im allgemeinen wird
      man einige Bits des Objektstatus selbst bearbeiten wollen, und andere
      dem (!nolink [AES]) Åberlassen.
!item die Funktion erhÑlt den PARMBLK-Zeiger auf dem Stack, und muû daher in
      Pure-C als 'cdecl' deklariert werden.
!item ein vollstÑndiges Neuzeichnen des Objektes ist nur dann nîtig, wenn
      die Komponenten (!I)pb_prevstate(!i) und (!I)pb_currstate(!i) gleich
      sind; anderenfalls hat sich nur der Objektstatus geÑndert (zum
      Beispiel durch Anklicken).
!item die eigene Funktion wird de facto als Unterprogramm der (!nolink [AES])
      ausgefÅhrt. Daher sollte man im Hinblick auf die Stackbenutzung
      vorsichtig sein. Auûerdem darf man natÅrlich (!I)keine(!i) weiteren
      (!nolink [AES])-Aufrufe machen, da das (!nolink [AES]) (!I)nicht(!i) re-entrant ist.
      Aufrufe
      der VDI-Eingabefunktionen sind hingegen an dieser Stelle erlaubt.
!item die Komponente (!I)pb_parm(!i) dient dazu, der eigenen Funktion
      weitere Informationen (wie etwa einen Zeiger auf einen String) mit auf
      den Weg zu geben.
!item man sollte sich nie zu weit von der ursprÅnglichen Optik von (!nolink [GEM])
      entfernen. Abgerundete Rechtecke oder kursive Texte passen sicherlich
      nicht in das normale Erscheinungsbild einer (!nolink [GEM])-Applikation.
!end_itemize

Querverweis: AES ~ GEM ~ USERBLK
!end_node

!begin_node PDLG_HNDL

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef LONG (cdecl *PDLG_HNDL)( struct _prn_settings *settings,
                                 struct _pdlg_sub *sub, 
                                 WORD exit_obj );
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_sub_dialogs ~ PDLG_SUB
!end_node


!begin_node PDLG_INIT

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef LONG (cdecl *PDLG_INIT) (struct _prn_settings *settings,
                                 struct _pdlg_sub *sub );
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_sub_dialogs ~ PDLG_SUB
!end_node


!begin_node PDLG_RESET

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef LONG (cdecl *PDLG_RESET) ( struct _prn_settings *settings,
                                   struct _pdlg_sub *sub );
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_sub_dialogs ~ PDLG_SUB
!end_node


!begin_node PDLG_SUB

Diese Struktur dient der Beschreibung einer GerÑteeinstellung, und ist wie
folgt definiert:

!begin_verbatim
typedef struct _pdlg_sub            
{
   struct _pdlg_sub *next;      /* Zeiger auf Nachfolger           */
   LONG        length;          /* StrukturlÑnge                   */
   LONG        format;          /* Datenformat                     */
   LONG        reserved;        /* reserviert                      */
   VOID        *drivers;        /* nur fÅr interne Dialoge         */
   WORD        option_flags;    /* verschiedene Flags              */
   WORD        sub_id;          /* Kennung des Unterdialogs        */
   DIALOG      *dialog;         /* Zeiger auf die Struktur des
                                   Fensterdialogs oder 0L          */
   OBJECT      *tree;           /* Zeiger auf den Objektbaum       */
   WORD        index_offset;    /* Offset des Unterdialogs         */
   WORD        reserved1;       /* reserviert                      */
   LONG        reserved2;       /* reserviert                      */
   LONG        reserved3;       /* reserviert                      */
   LONG        reserved4;       /* reserviert                      */
   PDLG_INIT   init_dlg;        /* Initialisierungsfunktion        */
   PDLG_HNDL   do_dlg;          /* Behandlungsfunktion             */
   PDLG_RESET  reset_dlg;       /* ZurÅcksetzfunktion              */
   LONG        reserved5;       /* reserviert                      */
   OBJECT      *sub_icon;       /* Zeiger auf das Icon der Listbox */
   OBJECT      *sub_tree;       /* Objektbaum des Unterdialogs     */
   LONG        reserved6;       /* reserviert                      */
   LONG        reserved7;       /* reserviert                      */
   LONG        private1;        /* dialogeigene Informationen-1    */
   LONG        private2;        /* dialogeigene Informationen-2    */
   LONG        private3;        /* dialogeigene Informationen-3    */
   LONG        private4;        /* dialogeigene Informationen-4    */
} PDLG_SUB;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_sub_dialogs
!end_node


!begin_node POPINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    OBJECT *tree;    /* Popup-MenÅ                  */
    WORD   obnum;    /* aktuelles Objekt von <tree> */
} POPINFO;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente tree zeigt auf einen Objektbaum, der etwa
fÅr form_popup als Eingabe dienen kînnte. D.h. die Box sollte als Objekt 0
eine G_BOX oder G_IBOX enthalten, die von den anderen Objekten vollstÑndig
bedeckt wird. Objekte die nicht auswÑhlbar sind, sollten wie im DropdownmenÅ
den Status DISABLED erhalten.

Alle wÑhlbaren Objekte mÅssen den Status SELECTABLE haben. ZusÑtzlich mÅssen
bei der Verwendung durch (!nolink [G_POPUP]) alle selektierbaren Objekte vom Typ
G_STRING (bzw. G_SHORTCUT) oder G_BUTTON sein und mit zwei Leerstellen
beginnen, letzteres wegen des HÑkchens, das von form_button bzw. form_do
automatisch gesetzt wird!

Wichtig ist, daû ob_x und ob_y von Objekt 0 des MenÅs relativ zum
(!nolink [G_POPUP])-Objekt angegeben werden, d.h. sie werden meistens beide 0 sein. Es
wird empfohlen, einen Schatten und einen Rand der StÑrke -1  anzugeben.

Querverweis: MagiC ~ G_POPUP
!end_node


!begin_node PRN_DIALOG

!begin_verbatim
typedef VOID *PRN_DIALOG;
!end_verbatim
!end_node


!begin_node PRN_ENTRY

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _prn_entry        
{
   struct _prn_entry *next;          /* Zeiger auf Nachfolger           */
   LONG        length;               /* StrukturlÑnge                   */
   LONG        format;               /* Datenformat                     */
   LONG        reserved;             /* reserviert                      */
   WORD        driver_id;            /* Treiberkennung                  */
   WORD        driver_type;          /* Treibertyp                      */
   LONG        printer_id;           /* Druckerkennung                  */
   LONG        printer_capabilities; /* Druckereigenschaften            */
   LONG        reserved1;            /* reserviert                      */
   LONG        flags;                /* verschiedene Flags              */
   struct _pdlg_sub  *sub_dialogs;   /* Zeiger auf Unterdialoge         */
   PRN_SWITCH  setup_panel;          /* Unterdialog bei Druckerwechsel
                                        initialisieren                  */
   PRN_SWITCH  close_panel;          /* Unterdialog bei Druckerwechsel
                                        schlieûen                       */
   PRN_MODE    *modes;               /* Liste vorhand. Auflîsungen      */
   MEDIA_SIZE  *papers;              /* Liste vorhand. Papierformate    */
   PRN_TRAY    *input_trays;         /* Liste der EinzÅge               */
   PRN_TRAY    *output_trays;        /* Liste der AuswÅrfe              */
   BYTE        name[32];             /* Name des Druckers               */
} PRN_ENTRY;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node PRN_MODE

Diese Struktur dient der Beschreibung eines Druckermodus, und ist wie folgt
definiert:

!begin_verbatim
typedef struct _prn_mode
{
   struct _prn_mode *next;         /* Zeiger auf Nachfolger             */
   LONG        mode_id;            /* Modus (Index innerhalb der Datei) */
   WORD        hdpi;               /* horizontale Auflîsung in dpi      */
   WORD        vdpi;               /* vertikale Auflîsung in dpi        */
   LONG        mode_capabilities;  /* Moduseigenschaften                */
   LONG        color_capabilities; /* einstellbare Farbmodi             */
   LONG        dither_flags;       /* Flags, die angeben, ob der
                                      korrespondierende Farbmodus mit
                                      oder ohne Dithern ansprechbar ist */
   MEDIA_TYPE  *paper_types;       /* geeignete Papiertypen             */
   LONG        reserved;           /* reserviert                        */
   BYTE        name[32];           /* Modusname                         */
} PRN_MODE;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node PRN_TRAY

Diese Struktur dient der Beschreibung eines Einzugs bzw. Auswurfs, und ist
wie folgt definiert:

!begin_verbatim
typedef struct _prn_tray      
{
   struct _prn_tray  *next;    /* Zeiger auf Nachfolger       */
   LONG        tray_id;        /* Nummer des Einzugs/Auswurfs */
   BYTE        name[32];       /* Name des Schachts           */
} PRN_TRAY;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node PRN_SETTINGS

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _prn_settings
{
   LONG  magic;            /* 'pset'                                 */
   LONG  length;           /* (+) StrukturlÑnge                      */
   LONG  format;           /* Strukturtyp                            */
   LONG  reserved;         /* reserviert                             */
   LONG  page_flags;       /* (+) Flags, u.a. gerade/ungerade Seiten
                              0x0001 = nur Seiten mit gerader Nummer
                              0x0002 = dto. mit ungeraden Nummern    */
   WORD  first_page;       /* (+) erste zu druckende Seite (min.1)   */
   WORD  last_page;        /* (+) dto. letzte Seite (max. 9999)      */
   WORD  no_copies;        /* (+) Anzahl der Kopien                  */
   WORD  orientation;      /* (+) Drehung                            
                               0x0000 = Ausichtung unbekannt und
                                        nicht verstellbar
                               0x0001 = Seite im Hochformat ausgeben
                               0x0002 = Seite im Querformat ausgeben */
   LONG  scale;            /* (+) Skalierung: 0x10000L = 100%        */
   WORD  driver_id;        /* (+) VDI-GerÑtenummer                   */
   WORD  driver_type;      /* Typ des eingestellten Treibers         */
   LONG  driver_mode;      /* Flags, u.a. fÅr Hintergrunddruck       */
   LONG  reserved1;        /* reserviert                             */
   LONG  reserved2;        /* reserviert                             */
   LONG  printer_id;       /* Druckernummer                          */
   LONG  mode_id;          /* Modusnummer                            */
   WORD  mode_hdpi;        /* horizontale Auflîsung in dpi           */
   WORD  mode_vdpi;        /* vertikale Auflîsung in dpi             */
   LONG  quality_id;       /* Druckmodus (hardwÑremÑûige QualitÑt,
                              z.B. Microweave oder Econofast)        */
   LONG  color_mode;       /* Farbmodus                              */
   LONG  plane_flags;      /* Flags fÅr auszugebende Farbebenen
                              (z.B. nur cyan)                        */
   LONG  dither_mode;      /* Rasterverfahren                        */
   LONG  dither_value;     /* Parameter fÅr das Rasterverfahren      */
   LONG  size_id;          /* Papierformat                           */
   LONG  type_id;          /* Papiertyp (normal, glossy)             */
   LONG  input_id;         /* Papiereinzug                           */
   LONG  output_id;        /* Papierauswurf                          */
   LONG  contrast;         /* Kontrast:   0x10000L = normal          */
   LONG  brightness;       /* Helligkeit: 0x1000L  = normal          */
   LONG  reserved3;        /* reserviert                             */
   LONG  reserved4;        /* reserviert                             */
   LONG  reserved5;        /* reserviert                             */
   LONG  reserved6;        /* reserviert                             */
   LONG  reserved7;        /* reserviert                             */
   LONG  reserved8;        /* reserviert                             */
   BYTE  device[128];      /* Dateiname fÅr den Ausdruck             */
   #ifdef __PRINTING__
   TPrint   mac_settings;  /* Einstellung des Mac-Druckertreibers    */
   #else
   struct
   {
      UBYTE inside[120];
   } mac_settings;
   #endif
} PRN_SETTINGS;
!end_verbatim

(!B)Hinweis:(!b) Die mit (+) gekennzeichneten Strukturelemente kînnen von
der Applikation ausgelesen werden. Auf alle anderen EintrÑge sollte
(!I)nicht(!i) zugegriffen werden. Daten wie z.B. die Druckerauflîsung oder
die Farbanzahl sollten (!I)nicht(!i) der Einstellstruktur entnommen werden,
sondern beim Start des Ausdrucks vom Drucker erfragt werden (es wÑre z.B.
mîglich, daû der Druckertreiber durch Speichermangel gezwungen wird, die
Druckauflîsung gegenÅber der in PRN_SETTINGS eingetragenen Einstellung zu
verringern).

Querverweis: Druckdialoge ~ pdlg_open
!end_node


!begin_node PRN_SWITCH

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef LONG (cdecl *PRN_SWITCH) ( struct _drv_entr *drivers,
                                   struct _prn_settings *settings,
                                   struct _prn_entry *old_printer,
                                   struct _prn_entry *new_printer );
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)old_printer(!i) kann auch 0L sein!

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node SCANX

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    BYTE scancode;
    BYTE nclicks;
    WORD  objnr;
} SCANX;
!end_verbatim

(!B)Hinweis:(!b) Die Struktur enthÑlt die Zuordnung fÅr die Taste mit dem
Scancode (!I)scancode(!i), bei deren BetÑtigung ein (!I)nclicks(!i)-facher
Mausklick auf das Objekt mit der Nummer (!I)objnr(!i) ausgefÅhrt wird. Das
Ende der Tabelle wird durch einen Scancode von Null markiert.

Querverweis: AES ~ MagiC ~ XDO_INF ~ (!link [Scan-Code Tabelle][Der Scan-Code])
!end_node


!begin_node SET_ITEM

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef WORD (cdecl *SET_ITEM)( LIST_BOX *box, OBJECT *tree, 
                                struct _lbox_item *item,
                                WORD obj_index, VOID *user_data,
                                GRECT *rect, WORD first );
!end_verbatim

Dabei gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [box]
Zeiger auf die Listbox-Struktur
!item [tree]
Zeiger auf den Objektbaum des Dialogs
!item [item]
Zeiger auf LBOX_ITEM-Struktur des zu setzenden Eintrags
!item  [obj_index]
Nummer des zu setzenden Objektes
!item [user_data]
Zeiger der bei (!nolink [lbox_create]) Åbergeben wurde
!item [rect]
Rechteck fÅr das Objekt-Redraw (oder NULL)
!item [first]
Nummer des ersten sichtbaren Elements fÅr Slider-B
!end_xlist

(!B)Hinweis:(!b) Bei einer Listbox, die nur Text-Strings enthÑlt, ist dies
typischerweise eine Funktion, die einen String, auf den die LBOX_ITEM
Struktur verweist, in das Objekt (!I)obj_index(!i) kopiert. Der Parameter
(!I)rect(!i) ist 0L, wenn ein Redraw der Dialogbox durchgefÅhrt wird oder
wenn lbox_update aufgerufen wurde. Er ist hingegen (!I)nicht(!i) 0L, wenn
der Anwender ein Objekt selektiert oder deselektiert hat, und zeigt auf das
GRECT fÅr den Redraw.

Der RÅckgabewert der Funktion ist die Nummer des Startobjekts fÅr die
Funktion objc_draw bzw. wdlg_redraw.

Bei EintrÑgen in der Listbox, die aus mehreren Objekten bestehen, ist es
manchmal sinnvoll bei Selektion/Deselektion eines Objekts das Redrawrechteck
zu verkleinern oder das Startobjekt zu Ñndern, um unnîtige
Zeichenoperationen und unnîtiges Geflacker zu vermeiden. In den meisten
FÑllen rufen die Listbox-Routinen nach der oben beschriebenen Funktion die
Routinen (!nolink [objc_draw]) bzw. (!nolink [wdlg_redraw]) auf, um den geÑnderten Inhalt
anzuzeigen.

Der Parameter (!I)first(!i) enthÑlt die Nummer des ersten sichtbaren
Elements fÅr Slider B, wenn die Listbox 2 Slider hat. Bei einer (vertikalen)
Listbox mit Text-Strings und zwei Slidern gibt man z.B. beim  Aufruf von
lbox_create die Anzahl der sichtbaren Zeichen in (!I)visible_b(!i), die
gesamte StringlÑnge in (!I)entries_b(!i) und den Index des ersten sichtbaren
Zeichens in (!I)first_b(!i) an. Wird der Text horizontal gescrollt, wird die
Funktion fÅr alle sichtbaren Strings aufgerufen und der Bereich
neugezeichnet bzw. verschoben. Wenn die Listbox nur einen Slider hat, ist
first immer 0.

Querverweis: Listboxen ~ lbox_create
!end_node


!begin_node SLCT_ITEM

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef VOID (cdecl *SLCT_ITEM)( LIST_BOX *box, OBJECT *tree, 
                                 struct _lbox_item *item, 
                                 VOID *user_data, WORD obj_index,
                                 WORD last_state );
!end_verbatim

Dabei gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [box]
Zeiger auf Listbox-Struktur
!item [tree]
Zeiger auf den Objektbaum des Dialogs
!item [item]
Zeiger auf die LBOX_ITEM-Struktur des ausgewÑhlten Eintrags
!item [user_data]
Zeiger der bei (!nolink [lbox_create]) Åbergeben wurde
!item [obj_index]
ist die Nummer des angewÑhlten Objekts. Bei einem (!nolink [Doppelklick]) ist Ñhnlich
wie nach form_do das oberste Bit gesetzt. Wenn (!I)obj_index(!i) 0 ist,
heiût das, daû dem Eintrag kein Objekt zugeordnet ist; er ist nicht
sichtbar. Normalerweise ist das nur der Fall, wenn gescrollt wird und durch
Auswahl eines neuen Objekts die (mittlerweile nicht mehr sichtbare)
Selektion gelîscht werden muû.
!item [last_state]
ist der vorhergehende Status des Objekts. (!I)last_state(!i) kann auch den
gleichen Wert wie item->selected haben. In diesem Fall kann die Funktion
slct normalerweise sofort verlassen werden.
!end_xlist

Querverweis: lbox_create
!end_node


!begin_node SWINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    BYTE *string;     /* etwa "TOS|KAOS|MAG!X"          */
    WORD  num;        /* Nr. der aktuellen Zeichenkette */
    WORD  maxnum;     /* maximal erlaubtes <num>        */
} SWINFO;
!end_verbatim

Querverweis: AES ~ GEM ~ G_SWBUTTON
!end_node


!begin_node TEDINFO

Die TEDINFO-Struktur wird benutzt um ein Textobjekt nÑher zu beschreiben,
und ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    BYTE    *te_ptext;          /* Zeiger auf einen String          */
    BYTE    *te_ptmplt;         /* Zeiger auf die Stringmaske       */
    BYTE    *te_pvalid;         /* Zeiger auf den GÅltigkeitsstring */
    WORD     te_font;           /* Zeichensatz                      */
    WORD     te_fontid;         /* GDOS Font-ID                     */
    WORD     te_just;           /* Justierung des Textes:
                                   0 = linksbÅndig
                                   1 = rechtsbÅndig
                                   2 = zentriert                    */
    WORD     te_color;          /* Farbe                            */
    WORD     te_fontsize;       /* GDOS Font-Grîûe in Punkten       */
    WORD     te_thickness;      /* Rahmenbreite                     */
    WORD     te_txtlen;         /* Maximale LÑnge des Textes        */
    WORD     te_tmplen;         /* LÑnge der Stringmaske            */
} TEDINFO;
!end_verbatim

Dabei gilt es, die folgenden Einzelheiten zu beachten:

!begin_itemize
!item (!B)te_ptext:(!b) Wenn das erste Zeichen ein Klammeraffe (!) ist,
      werden alle folgenden Zeichen als Platzhalter angesehen, und der
      zunÑchst ausgegebene String besteht aus Leerzeichen. Folge: Der
      Klammeraffe kann niemals am Anfang eines Edit-Feldes stehen!
!item (!B)te_ptmplt:(!b) Schablone (template). Sie wird nur bei G_FTEXT und
      G_FBOXTEXT verwendet, d.h. bei G_TEXT und G_BOXTEXT kann hier ein
      Null-Zeiger stehen. Bei der Ausgabe werden alle '_' Zeichen in der
      Schablone sukzessive durch die Zeichen in (!I)te_ptext(!i) ersetzt,
      d.h. es wird eine Misch-Zeichenkette gebildet. I.A. wird die Schablone
      also soviele '_' Zeichen enthalten, wie der Puffer fÅr
      (!I)te_ptext(!i) lang ist (ohne abschlieûendes Nullbyte).
!item (!B)te_pvalid:(!b) String, der fÅr jedes Zeichen in (!I)te_ptext(!i)
      eine Zeichenkette enthÑlt, die Åber die GÅltigkeit verschiedener
      Zeichen an dieser Stringposition Auskunft gibt. Es gilt:
!begin_xlist !short [Zeichen]
!item [Zeichen]
Bedeutung
!item [~]
~
!item [9]
nur Ziffern
!item [A]
nur Groûbuchstaben/Leerzeichen
!item [a]
nur Buchstaben/Leerzeichen
!item [N]
Groûbuchstaben, Ziffern, Leerzeichen
!item [n]
Buchstaben, Ziffern, Leerzeichen
!item [F]
alle Zeichen, die zu einem Dateinamen gehîren und '*', '?' und ':'.
!item [f]
alle Zeichen, die zu einem Dateinamen, ohne '*', '?' und ':'.
!item [P]
alle Zeichen, die zu einem Pfadnamen gehîren
!item [p]
analog 'P', aber ohne die Zeichen '?' und '*'
!item [m]
alle Zeichen, die fÅr einen langen Dateinamen gÅltig sind; d.h. alle Zeichen
auûer Steuerzeichen (ASCII < 32), sowie auûer ':' und '\'. Dieser Code wird
z.Zt. nur von MagiC unterstÅtzt.
!item [X]
alle Zeichen
!item [x]
alle Zeichen, Kleinbuchstaben werden automatisch in Groûbuchstaben umgewandelt.
!end_xlist

!item (!B)te_color:(!b) FÅr die Farbe des begrenzenden Rechteckes gilt die
      folgende Belegung:
!begin_xlist !short [0..23]
!item [Bit]
Bedeutung
!item [~]
~
!item [12..15]
Rahmenfarbe (0..15)
!item [08..11]
Textfarbe (0..15)
!item [7]
Text (0 = transparent, 1 = deckend)
!item [4..06]
IntensitÑt
!begin_xlist !short [1..6 =]
!item [0 =]
hohl
!item [1..6 =]
ansteigende IntensitÑt
!item [7 =]
solide FlÑche
!end_xlist
!item [0..03]
Innenfarbe (0..15)
!end_xlist
!item (!B)te_thickness:(!b) FÅr den Rahmen sind folgende Werte gÅltig:
!begin_xlist !short [-1..-127]
!item [Wert]
Bedeutung
!item [~]
~
!item [0]
kein Rahmen
!item [1..128]
Rand liegt 1 bis 128 Pixel im Inneren
!item [-1..-127]
Rand liegt 1 bis 127 Pixel auûerhalb des Objektes
!end_xlist
!end_itemize

!label GDOS-Fonts in Dialogen
!label Dialogen, GDOS-Fonts in
!label ZeichensÑtze in Dialogen
(!B)Hinweis:(!b) Die Komponenten (!I)te_fontid(!i) und (!I)te_fontsize(!i)
waren bisher reserviert. Ab AES-Version 4.1 ist es mîglich, beliebige
GDOS-Fonts fÅr TEDINFO-Objekte zu benutzen.

Dazu ist Åber die Komponente (!I)te_font(!i) die Art des Zeichensatzes zu
spezifizieren:

!begin_table [c l]
te_font !! Bedeutung
!hline
0 !! (!nolink [Speedo-GDOS]) Font
1 !! (!nolink [Speedo-GDOS]) Font (monospaced)
2 !! GDOS Bitmap-Font
3 !! System-Zeichensatz
5 !! kleiner System-Zeichensatz
!end_table

FÅr Werte im Bereich 0..2 von (!I)te_font(!i) kann dann Åber die Komponenten
(!I)te_fontid(!i) bzw. (!I)te_fontsize(!i) der gewÅnschte Zeichensatz und
die gewÅnschte Punktgrîûe eingestellt werden.

Das Vorhandensein der neuen Mîglichkeiten kann am einfachsten per
(!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

Querverweis: AES ~ GEM  ~ OBJECT ~ XTED ~
(!link [Scrollende Eingabefelder][scrollende Eingabefelder])
!end_node

!begin_node XDO_INF

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    SCANX *unsh;    /* Tabellen fÅr UnShift-Kombinationen   */
    SCANX *shift;   /* Tabellen fÅr Shift-Kombinationen     */
    SCANX *ctrl;    /* Tabellen fÅr Control-Kombinationen   */
    SCANX *alt;     /* Tabellen fÅr Alternate-Kombinationen */
    VOID  *resvd;   /* reserviert */
} XDO_INF;
!end_verbatim

(!B)Hinweis:(!b) In dieser Struktur liegen Zeiger auf Tabellen, die einem
Scancode eine Objektnummer der Dialogbox zuordnen. Hiermit ist es auf
einfache Weise mîglich, Dialoge vollstÑndig Åber die Tastatur zu bedienen.
Der Parameter (!I)resvd(!i) ist fÅr spÑtere Zwecke reserviert, und muss
immer NULL sein.

Querverweis: AES ~ form_keybd ~ form_xdo ~ MagiC ~
(!link [Scan-Code Tabelle][Der Scan-Code])
!end_node


!begin_node XFSL_FILTER

Dieser Typ ist wie folgt definiert

!begin_verbatim
typedef WORD (cdecl XFSL_FILTER) (BYTE *path, BYTE *name, XATTR *xa);
!end_verbatim

Querverweis: fslx_do ~ fslx_open
!end_node


!end_node
