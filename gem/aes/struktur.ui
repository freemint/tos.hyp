!begin_node AES-Strukturen

!subtoc [stg, html]

!begin_node APPLRECORD

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int32_t type;      /* Art des Ereignisses */
    int32_t what;      /* genaue Beschreibung des Ereignisses */
} APPLRECORD
!end_verbatim

(!B)FÅr die Komponenten gilt dabei:(!b)

!begin_xlist !short [type tastatur-event]
!item [type Bedeutung]
what
!item [~]
~
!item [0~~ Timer-Event]
Anzahl der Millisekunden
!item [1~~ Button-Event]
Anzahl der TastendrÅcke (High-Word), Status der Maustaste (Low-Word),
und zwar: 0 = nicht gedrÅckt, 1 = gedrÅckt.
!item [2~~ Maus-Event]
X-Koordinate (High-Word), Y-Koordinate (Low-Word).
!item [3~~ Tastatur-Event]
!begin_xlist !short [Bit 16-31:]
	!item [Bit 0-7] Ascii-Code

	!item [Bit 8-15] Scan-Code

	!item [Bit 16-31] Zustand der Umschaltasten
	!begin_xlist !short [Shift-Rechts:]
	!item [Shift-Rechts:]
		0x0001
	!item [Shift-Links:]
		0x0002
	!item [Control:]
		0x0004
	!item [Alternate:]
	0x0008
	!end_xlist
!end_xlist

!end_xlist

(!B)Hinweis:(!b) Unter PC-GEM belegt jedes Ereignis nur 6 Bytes, da die
Komponente (!I)type(!i) von APPLRECORD dort als WORD definiert ist.

Querverweis: appl_tplay ~ appl_trecord
!end_node


!begin_node Die Bit-Block-Struktur
!label BITBLK
Ein Bit-Image kann immer dort eingesetzt werden, wo ein nicht anwÑhlbares
Icon stehen kînnte; der entscheidende Unterschied ist nÑmlich, daû es zu
einem Bit-Image (!I)keine Maske(!i) gibt.

!begin_verbatim
typedef struct
{
  int16_t  *bi_pdata;     /* Zeiger auf die Grafikdaten    */
  int16_t  bi_wb;         /* Breite des Bildes in Bytes    */
  int16_t  bi_hl;         /* Hîhe in Zeilen                */
  int16_t  bi_x;          /* x-Position                    */
  int16_t  bi_y;          /* y-Position                    */
  int16_t  bi_color;      /* Farbe                         */
} BITBLK;
!end_verbatim

(!B)Hinweis:(!b) Die Breite eines Bit-Images (Komponente (!I)bi_wb(!i)) muû
stets durch 2 teilbar sein.

Querverweis: OBJECT ~ Objektarten des AES
!end_node


!begin_node CICON

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct cicon_data
{
  int16_t num_planes;   /* Anzahl der Planes fÅr die folgenden Daten */
  int16_t *col_data;    /* Zeiger auf Farb-Bitmap in Standardform    */
  int16_t *col_mask;    /* Zeiger auf einzelne Farb-Plane Maske      */
  int16_t *sel_data;    /* Zeiger auf Farb-Bitmap des selekt. Icons  */
  int16_t *sel_mask;    /* Zeiger auf einzelne Plane-Maske des Icons */
  struct cicon_data *next_res; /* Zeiger auf Icon anderer Auflîsung */
} CICON;
!end_verbatim

Querverweis: CICONBLK ~ ICONBLK ~ FOBJECT
!end_node


!begin_node CICONBLK

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct cicon_blk
{
   ICONBLK monoblk;    /* Default: monochrome Icons */
   CICON   *mainlist;  /* Farb-Icons fÅr verschiedene Auflîsungen */
} CICONBLK;
!end_verbatim

Querverweis: OBJECT ~ (!link [Objektstruktur im AES][Die Objekt-Struktur])
!end_node


!begin_node CLRCAT
!begin_verbatim
typedef struct clrcat
{
  int16_t cc_foreground     /* Foreground colour    */
  int16_t cc_background     /* Background colour    */
  int16_t cc_style          /* Fill style           */
  int16_t cc_pattern        /* Fill pattern         */
} CLRCAT;
!end_verbatim

The CLRCAT is used internally by ViewMAX/2 and later to store the
colour categories.

See Also: X_BUF_V2
!end_node

!begin_node DIALOG

!begin_verbatim
typedef void *DIALOG;
!end_verbatim
!end_node

!begin_node DITHER_MODE

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _dither_mode
{
   struct _dither_mode  *next;    /* Zeiger auf Nachfolger     */
   int32_t       length;          /* StrukturlÑnge             */
   int32_t       format;          /* Datenformat               */
   int32_t       reserved;        /* reserviert                */
   int32_t       dither_id;       /* Kennung                   */
   int32_t       color_modes;     /* unterstÅtzte Farbtiefen   */
   int32_t       reserved1;       /* reserviert                */
   int32_t       reserved2;       /* reserviert                */
   int8_t        name[32];        /* Name des Rasterverfahrens */
} DITHER_MODE;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node DRV_ENTRY

!begin_verbatim
typedef struct _drv_entry
{
   struct _drv_entry *next; /* Zeiger auf Nachfolger */
} DRV_ENTRY;
!end_verbatim
!end_node


!begin_node DRV_INFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int32_t     magic;           /* 'pdnf'                           */
   int32_t     length;          /* StrukturlÑnge                    */
   int32_t     format;          /* Datenformat                      */
   int32_t     reserved;        /* reserviert                       */
   int16_t     driver_id;       /* Treibernummer fÅrs VDI           */
   int16_t     driver_type;     /* Treibertyp                       */
   int32_t     reserved1;       /* reserviert                       */
   int32_t     reserved2;       /* reserviert                       */
   int32_t     reserved3;       /* reserviert                       */
   PRN_ENTRY   *printers;       /* zum Treiber gehîrenden Drucker   */
   DITHER_MODE *dither_modes;   /* unterstÅtzte Rasterverfahren     */
   int32_t     reserved4;       /* reserviert                       */
   int32_t     reserved5;       /* reserviert                       */
   int32_t     reserved6;       /* reserviert                       */
   int32_t     reserved7;       /* reserviert                       */
   int32_t     reserved8;       /* reserviert                       */
   int32_t     reserved9;       /* reserviert                       */
   int8_t      device[128];     /* Ausgabedatei des Druckertreibers */
} DRV_INFO;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node

!begin_node EVNT

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int16_t mwhich;         /* Art der Ereignisse                */
    int16_t mx;             /* x-Koordinate des Mauszeigers      */
    int16_t my;             /* y-Koordinate des Mauszeigers      */
    int16_t mbutton;        /* gedrÅckte Maustaste               */
    int16_t kstate;         /* Status der Sondertasten (kbshift) */
    int16_t key;            /* Scancode der gedrÅckten Taste     */
    int16_t mclicks;        /* Anzahl der Mausklicks             */
    int16_t reserved[9];    /* reserviert                        */
    int16_t msg[16];        /* Message-Buffer                    */
} EVNT;
!end_verbatim

Querverweis: fnts_evnt ~ fslx_evnt ~  wdlg_evnt
!end_node


!begin_node FNT_DIALOG

!begin_verbatim
typedef void *FNT_DIALOG;
!end_verbatim
!end_node

!iflang [english]

!begin_node FNTS_ITEM

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _fnts_item
{
    struct   _fnts_item  *next; /* Pointer to the next font or 0L (end of the list)   */
    UTXT_FN  display;           /* Pointer to the display function for the user fonts */
    int32_t  id;                /* Font ID, >= 65536 for user fonts     */
    int16_t  index;             /* Must be 0, as not a VDI font         */
    int8_t   mono;              /* Flag for mono-spaced font            */
    int8_t   outline;           /* Flag for vector font                 */
    int16_t  npts;              /* Number of predefined point sizes     */
    int8_t   *full_name;        /* Pointer to the complete name         */
    int8_t   *family_name;      /* Pointer to the family name           */
    int8_t   *style_name;       /* Pointer to the style name            */
    int8_t   *pts;              /* Pointer to field with point sizes    */
    int32_t  reserved[4];       /* Reserved, must be 0                  */
} FNTS_ITEM;
!end_verbatim

See Also: fnts_add ~ Zeichensatzauswahl
!end_node
!else

!begin_node FNTS_ITEM

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _fnts_item
{
    struct   _fnts_item  *next; /* Zeiger auf den nÑchsten Font oder 0L */
    UTXT_FN  display;           /* Anzeige-Funktion fÅr eigene Fonts    */
    int32_t  id;                /* ID des Fonts                         */
    int16_t  index;             /* muû 0 sein, da kein VDI-Font         */
    int8_t   mono;              /* Flag fÅr Ñquidistante Fonts          */
    int8_t   outline;           /* Flag fÅr Vektorfont                  */
    int16_t  npts;              /* Anzahl der vordefinierten Punkthîhen */
    int8_t   *full_name;        /* Zeiger auf den vollstÑndigen Namen   */
    int8_t   *family_name;      /* Zeiger auf den Familiennamen         */
    int8_t   *style_name;       /* Zeiger auf den Stilnamen             */
    int8_t   *pts;              /* Zeiger auf Feld mit Punkthîhen       */
    int32_t  reserved[4];       /* reserviert, mÅssen 0 sein            */
} FNTS_ITEM;
!end_verbatim

Querverweis: fnts_add ~ Zeichensatzauswahl
!end_node

!endif

!begin_node HNDL_OBJ

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef int16_t (cdecl *HNDL_OBJ) ( void *dialog, EVNT *events, int16_t obj,
                                 int16_t clicks, void *data );
!end_verbatim

Dabei gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [dialog]
Zeiger auf eine Dialogstruktur. Auf diese sollte nicht direkt, sondern nur
mit Hilfe der wdlg_xxx Funktionen zugegriffen werden.
!item [events]
Zeiger auf die EVNT-Strukur, die bei wdlg_evnt Åbergeben wurde (falls der
Parameter (!I)obj(!i) >= 0 ist), oder NULL.
!item [obj]
!begin_xlist !short
!item [>=0:]
Objektnummer
!item [<0:]
Funktionsnummer. Definiert sind z.Zt:
!begin_verbatim
 -1 = HNDL_INIT    // Dialog initialisieren
 -2 = HNDL_MESG    //
 -3 = HNDL_CLSD    // Dialogfenster wurde geschlossen
 -5 = HNDL_OPEN    // Dialog-Initialisierung abschlieûen
 -6 = HNDL_EDIT    // Zeichen fÅr ein Editfeld prÅfen
 -7 = HNDL_EDDN    // Zeichen wurde ins Editfeld gesetzt
 -8 = HNDL_EDCH    // Editfeld wurde gewechselt
 -9 = HNDL_MOVE    // Dialog wurde verschoben
-10 = HNDL_TOPW    // Dialogfenster kam nach oben
-11 = HNDL_UNTP    // Dialogfenster ist nicht aktiv
!end_verbatim
!end_xlist
Von diesen Funktionsnummern muû nur auf HNDL_CLSD reagiert werden; alle
anderen Ereignisse kînnen je nach Bedarf beachtet werden.
!item [clicks]
Anzahl der Mausklicks, falls es sich bei (!I)obj(!i) um eine Objektnummer
handelt.
!item [data]
Falls der Parameter (!I)obj(!i) eine positive Objektnummer ist, wird hier
die Variable (!I)user_data(!i) aus der Funktion wdlg_create Åbergeben.
Anderenfalls ist der Wert von der entsprechenden Funktionsnummer abhÑngig.
!end_xlist

(!B)Hinweis:(!b) Die Funktion wird aufgerufen, wenn auf ein EXIT- oder
TOUCHEXIT Objekt geklickt wurde (in diesem Fall ist (!I)obj(!i) eine
positive Objektnummer) oder wenn ein den Dialog betreffendes Ereignis
eingetreten ist (dann ist (!I)obj(!i) negativ und enthÑlt eine entsprechende
Funktionsnummer (s.o.)).

Die Parameter werden Åber den Stack Åbergeben und die Routine darf die
Register d0-d2/a0-a2 verÑndern. Falls die Funktion mit einer unbekannten
Funktionsnummer in (!I)obj(!i) aufgerufen wird oder eine der obigen
Funktionsnummern ignoriert werden soll, muû der Wert 1 zurÅckgeliefert
werden.

Querverweis: (!link [Beispiel-Implementation] [Beispiel zu HNDL_OBJ]) ~ wdlg_create



!begin_node Beispiel zu HNDL_OBJ

!begin_verbatim
/* Der folgende Code ist ein Beispiel fÅr eine Implementation
   der handle_exit Funktion, wie sie z.B. als Parameter bei
   wdlg_create vorkommt. */

int16_t cdecl handle_exit ( void *dialog, EVNT *events, int16_t obj,
                         int16_t clicks, void *data )
{
    /*
     * Ereignis oder Objektnummer?
     * Alle Ereignisse auûer HNDL_CLSD werden bei diesem Beispiel
     * ignoriert
     */

    if ( obj < 0 )
    {
        if ( obj == HNDL_CLSD )     /* Closer betÑtigt? */
            return( 0 );            /* beenden */
        if ( obj == HNDL_EDIT )
        {
            /*  In Fensterdialogen kann es nÅtzlich sein, Tasten-
                kombinationen mit Control in Eingabefeldern zu igno-
                rieren, damit Shortcuts wie z.B. Ctrl-U, Ctrl-W oder
                Ctrl-Q in der Eventschleife des Programms abgearbei-
                tet werden kînnen. In diesem Fall sollte nach HNDL_EDIT
                eine 0 zurÅckgeliefert werden, damit die Taste nicht
                von objc_edit bearbeitet wird.
            */
        }
    }
    else
    {                         /* ein Objekt ist angewÑhlt worden  */
        switch ( obj )        /* Aktionen einleiten (falls nîtig) */
        {
            case ...
              .
              .
              .
            case MY_EXIT_OBJECT:    ..... return( 0 );  /* beenden */
        }
    }
    return( 1 ); /* weitermachen */
}
!end_verbatim
!end_node



!begin_node HNDL_INIT

(!I)data(!i) ist die bei (!B)wdlg_init(!b) Åbergebene Variable. Falls
handle_exit den Wert 0 zurÅckliefert, legt (!B)wdlg_create(!b) keine
Dialog-Struktur an (Fehler). Die Variable code wird in (!I)clicks(!i)
Åbergeben.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_MESG

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.
(!I)events(!i) zeigt auf die bei wdlg_evnt Åbergebene EVNT-Struktur.

(!B)Hinweis:(!b) Dieser Code wird nur dann Åbergeben, wenn ein
Nachrichtencode zwischen 20 und 39 empfangen wurde, der nicht mit den
anderen Opcodes bearbeitet wird. Er wird z.B. fÅr die Ikonifizierung
benîtigt.

(!B)Achtung:(!b) Dieser Opcode wird erst seit der MagiC-Version
4.50 vom 18.04.96 unterstÅtzt.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_OPEN

(!I)data(!i) ist die bei (!B)wdlg_open(!b) Åbergebene Variable. Die Variable
code wird in (!I)clicks(!i) Åbergeben.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_CLSD

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.

(!I)events(!i) zeigt auf die bei wdlg_evnt Åberg. EVNT-Struktur.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_MOVE

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.

(!I)events(!i) zeigt auf die bei wdlg_evnt Åberg. EVNT-Struktur.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_TOPW

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.

(!I)events(!i) zeigt auf die bei wdlg_evnt Åberg. EVNT-Struktur.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_UNTP

(!I)data(!i) ist user_data. Falls handle_exit den Wert 0 zurÅckliefert, wird
der Dialog geschlossen - (!B)wdlg_evnt(!b) liefert den Wert 0 zurÅck.

(!I)events(!i) zeigt auf die bei wdlg_evnt Åberg. EVNT-Struktur.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_EDIT

(!I)data(!i) zeigt auf ein Wort mit dem Tastencode. Falls handle_exit den
Wert 1 zurÅckliefert, wird der Tastendruck verarbeitet, bei 0 ignoriert.

(!I)events(!i) zeigt auf die bei (!B)wdlg_evnt(!b) Åberg. EVNT-Struktur.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_EDDN

(!I)data(!i) zeigt auf ein Wort mit dem Tastencode. (!I)events(!i) zeigt auf
die bei (!B)wdlg_evnt(!b) Åberg. EVNT-Struktur.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node



!begin_node HNDL_EDCH

(!I)data(!i) zeigt auf ein Wort mit der Objektnummer des neuen Edit-Felds.

Querweise: HNDL_OBJ ~ wdlg_create
!end_node
!end_node

!begin_node ICONBLK

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
  uint16_t  *ib_pmask;    /* Zeiger auf die Icon-Maske     */
  uint16_t  *ib_pdata;    /* Zeiger auf das Icon-Bild      */
  int8_t    *ib_ptext;    /* Zeiger auf den Icon-Text      */
  uint16_t  ib_char;      /* Zeichen das im Icon erschei-
                             nen soll, sowie Vorder- und
                             Hintergrundfarbe des Icons    */
  uint16_t  ib_xchar;     /* x-Koordinate des Buchstabens  */
  uint16_t  ib_ychar;     /* y-Koordinate des Buchstabens  */
  uint16_t  ib_xicon;     /* x-Koordinate des Icons        */
  uint16_t  ib_yicon;     /* y-Koordinate des Icons        */
  uint16_t  ib_wicon;     /* Breite des Icons              */
  uint16_t  ib_hicon;     /* Hîhe des Icons                */
  int16_t   ib_xtext;     /* x-Koordinate des Textes       */
  int16_t   ib_ytext;     /* y-Koordinate des Textes       */
  uint16_t  ib_wtext;     /* Breite des Textes             */
  uint16_t  ib_htext;     /* Hîhe des Textes               */
  uint16_t  ib_resvd;     /* reserviert                    */
} ICONBLK;
!end_verbatim

(!B)Hinweise zu einzelnen Komponenten:(!b)

!begin_itemize
!item (!B)ib_pmask:(!b) Zeiger auf ein Feld von 16-Bit-Werten, in denen das
      Bit-Image der Icon-Maske abgelegt ist. Die Icon-Maske legt fest, an
      welchen Stellen das Icon Åberhaupt gezeichnet werden soll und welche
      Pixel transparent bleiben sollen. Erzielt wird dieser Effekt dadurch,
      daû der Iconhintergrund zunÑchst mit den Bits der Maske 'undiert' und
      dann mit den Icondaten 'geodert' wird.
!item (!B)ib_char:(!b)
!begin_xlist !short [15..12]
!item [Bits]
Bedeutung
!item [~]
~
!item [15..12]
Vordergrundfarbe des Icons
!item [11..08]
Hintergrundfarbe des Icons
!item [~7..~0]
Zeichen das im Icon erscheinen soll
!end_xlist
!item (!B)ib_resvd:(!b) unbenutzt, wird allerdings von den meisten
      RCS-Programmen beim Schreiben in die Resourcedatei aufgenommen.
!end_itemize

FÅr Farbicon unter PC GEM gilt: (!nl)
In a colour icon, ib_pdata and ib_pmask point to MFDB
objects. Otherwise, they point to the lines of the bitmap.

Querverweis: CICONBLK ~ OBJECT
!end_node

!begin_node MENU

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    OBJECT  *mn_tree;    /* Adresse des MenÅ-Objektbaumes  */
    int16_t mn_menu;     /* Index des Parent-Objektes      */
    int16_t mn_item;     /* Anfangs-MenÅeintrag (bestimmt  */
                         /* die Position des MenÅs         */
    int16_t mn_scroll;   /* 0 = nicht scrollen,            */
                         /* 1 = scrollen                   */
    int16_t mn_keystate; /* Tastaturstatus (Shift, Control */
                         /* bzw. Alternate)                */
} MENU;
!end_verbatim

Querverweis: AES ~ menu_attach ~ menu_popup
!end_node


!begin_node MFORM

Die Struktur MFORM legt das Aussehen des Mauszeigers fest, und ist wie folgt
definiert:

!begin_verbatim
typedef struct mfstr
{
    int16_t  mf_xhot;       /* X-Pos. Aktionspunkt */
    int16_t  mf_yhot;       /* Y-Pos. Aktionspunkt */
    int16_t  mf_nplanes;    /* Anzahl der Planes   */
    int16_t  mf_fg;         /* Maskenfarbe         */
    int16_t  mf_bg;         /* Zeigerfarbe         */
    int16_t  mf_mask[16];   /* Maskenform          */
    int16_t  mf_data[16];   /* Zeigerform          */
} MFORM;
!end_verbatim

Querverweis: AES ~ graf_mouse
!end_node


!begin_node MN_SET

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int32_t display;    /* Anzeigeverzîgerung              */
    int32_t drag;       /* Auswahlverzîgerung              */
    int32_t delay;      /* Einfachklick Scroll-Verzîgerung */
    int32_t speed;      /* Scroll-Verzîgerung              */
    int16_t height;     /* Scroll-Hîhe (Anzahl der darzu-  */
                        /* stellenden EintrÑge)            */
} MN_SET;
!end_verbatim

(!B)Hinweis:(!b) Alle Verzîgerungszeiten werden in Millisekunden gemessen.

Querverweis: AES ~ menu_settings
!end_node

!begin_node LBOX_ITEM

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef struct _lbox_item
{
   struct _lbox_item *next;  /* Zeiger auf den nÑchsten Eintrag */
                             /* in der Scroll-Liste             */
   int16_t  selected;        /* Objekt selektiert?              */
   int16_t  data1;           /* Daten fÅr das Programm          */
   void     *data2;
   void     *data3;
} LBOX_ITEM;
!end_verbatim

(!B)Hinweis:(!b) Die Struktur kann aber, wenn bei den Aufrufen entsprechend
gecastet wird, durchaus wie das folgende Beispiel aussehen:

!begin_verbatim
typedef struct
{
   void    *next;
   int16_t    selected;

   ... ab hier nach Belieben der Applikation...
} LB_EXAMPLE;
!end_verbatim

Es ist lediglich darauf zu achten, daû als erstes Element ein Zeiger auf
den Nachfolger, und als zweites Element ein Wort das angibt, ob der
entsprechende Eintrag selektiert ist, vorhanden ist.

Querverweis: lbox_create ~ lbox_free_list ~ lbox_get_idx ~ lbox_get_item ~
lbox_get_items
!end_node

!begin_node LIST_BOX

!begin_verbatim
typedef void *LIST_BOX;
!end_verbatim
!end_node

!begin_node OBJECT

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int16_t    ob_next;   /* das nÑchste Objekt            */
   int16_t    ob_head;   /* erstes Kind                   */
   int16_t    ob_tail;   /* letztes Kind                  */
   uint16_t   ob_type;   /* Objektart                     */
   uint16_t   ob_flags;  /* Manipulationsflags            */
   uint16_t   ob_state;  /* Objektstatus                  */
   int8_t     *ob_spec;  /* mehr unter Objektart          */
   int16_t    ob_x;      /* x-Koordinate des Objekts      */
   int16_t    ob_y;      /* y-Koordinate des Objekts      */
   int16_t    ob_width;  /* Breite des Objekts            */
   int16_t    ob_height; /* Hîhe des Objekts              */
} OBJECT;
!end_verbatim

!begin_itemize
!item (!B)ob_next:(!b) Nummer das folgenden Objekts gleicher Ebene oder -falls
es das letzte Element in der Ebene ist - es Parent-Objekta.
!item (!B)ob_head:(!b) Nummer des erstes Kind des Objekts, falls keines -1
!item (!B)ob_next:(!b) Nummer des letzen Kind des Objekts, falls keines -1
!item (!B)ob_type:(!b) Objektarten des AES
!item (!B)ob_flags:(!b) Objektflags des AES
!item (!B)ob_state:(!b) Objektstati des AES
!end_itemize

Querverweis: (!link [Objektstruktur im AES][Die Objekt-Struktur])
!end_node


!begin_node PARMBLK

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   OBJECT   *pb_tree;        /* Zeiger auf den Objektbaum        */
   int16_t  pb_obj;          /* Nummer des Objekts               */
   int16_t  pb_prevstate;    /* vorheriger Objektstatus          */
   int16_t  pb_currstate;    /* neuer Objektstatus               */
   int16_t  pb_x;            /* x-Position des Objektes          */
   int16_t  pb_y;            /* y-Position des Objektes          */
   int16_t  pb_w;            /* Breite des Objektes              */
   int16_t  pb_h;            /* Hîhe des Objektes                */
   int16_t  pb_xc;           /* x-Position des Clipping-Bereichs */
   int16_t  pb_yc;           /* y-Position des Clipping-Bereichs */
   int16_t  pb_wc;           /* Breite des Clipping-Bereichs     */
   int16_t  pb_hc;           /* Hîhe des Clipping-Bereichs       */
   int32_t  pb_parm;         /* Parameter der USERBLK-Struktur   */
} PARMBLK;
!end_verbatim

(!B)Hinweis:(!b) Das Objekt muû nur neu gezeichnet werden, wenn alter und
neuer Status identisch sind; anderenfalls reicht ein 'Update' des
Objektbaums aus. Ferner sollten folgende Punkte beachtet werden:

!begin_itemize
!item die eigene Funktion muû im Datenregister d0 dem (!nolink [AES]) zurÅckliefern,
      welche Aspekte des Objektstatus noch aktualisiert werden mÅssen. Damit
      ist es nicht unbedingt nîtig, in der eigenen Ausgabefunktion den Code
      zum invertieren des Objektes auszuprogrammieren. Im allgemeinen wird
      man einige Bits des Objektstatus selbst bearbeiten wollen, und andere
      dem (!nolink [AES]) Åberlassen.
!item die Funktion erhÑlt den PARMBLK-Zeiger auf dem Stack, und muû daher in
      Pure-C als 'cdecl' deklariert werden.
!item ein vollstÑndiges Neuzeichnen des Objektes ist nur dann nîtig, wenn
      die Komponenten (!I)pb_prevstate(!i) und (!I)pb_currstate(!i) gleich
      sind; anderenfalls hat sich nur der Objektstatus geÑndert (zum
      Beispiel durch Anklicken).
!item die eigene Funktion wird de facto als Unterprogramm der (!nolink [AES])
      ausgefÅhrt. Daher sollte man im Hinblick auf die Stackbenutzung
      vorsichtig sein. Auûerdem darf man natÅrlich (!I)keine(!i) weiteren
      (!nolink [AES])-Aufrufe machen, da das (!nolink [AES]) (!I)nicht(!i) re-entrant ist.
      Aufrufe
      der VDI-Eingabefunktionen sind hingegen an dieser Stelle erlaubt.
!item die Komponente (!I)pb_parm(!i) dient dazu, der eigenen Funktion
      weitere Informationen (wie etwa einen Zeiger auf einen String) mit auf
      den Weg zu geben.
!item man sollte sich nie zu weit von der ursprÅnglichen Optik von (!nolink [GEM])
      entfernen. Abgerundete Rechtecke oder kursive Texte passen sicherlich
      nicht in das normale Erscheinungsbild einer (!nolink [GEM])-Applikation.
!end_itemize

Querverweis: AES ~ GEM ~ USERBLK
!end_node

!begin_node PDLG_HNDL

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef int32_t (cdecl *PDLG_HNDL)( struct _prn_settings *settings,
                                 struct _pdlg_sub *sub,
                                 int16_t exit_obj );
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_sub_dialogs ~ PDLG_SUB
!end_node


!begin_node PDLG_INIT

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef int32_t (cdecl *PDLG_INIT) (struct _prn_settings *settings,
                                 struct _pdlg_sub *sub );
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_sub_dialogs ~ PDLG_SUB
!end_node


!begin_node PDLG_RESET

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef int32_t (cdecl *PDLG_RESET) ( struct _prn_settings *settings,
                                   struct _pdlg_sub *sub );
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_sub_dialogs ~ PDLG_SUB
!end_node


!begin_node PDLG_SUB

Diese Struktur dient der Beschreibung einer GerÑteeinstellung, und ist wie
folgt definiert:

!begin_verbatim
typedef struct _pdlg_sub
{
   struct _pdlg_sub *next;      /* Zeiger auf Nachfolger           */
   int32_t     length;          /* StrukturlÑnge                   */
   int32_t     format;          /* Datenformat                     */
   int32_t     reserved;        /* reserviert                      */
   void        *drivers;        /* nur fÅr interne Dialoge         */
   int16_t     option_flags;    /* verschiedene Flags              */
   int16_t     sub_id;          /* Kennung des Unterdialogs        */
   DIALOG      *dialog;         /* Zeiger auf die Struktur des
                                   Fensterdialogs oder 0L          */
   OBJECT      *tree;           /* Zeiger auf den Objektbaum       */
   int16_t     index_offset;    /* Offset des Unterdialogs         */
   int16_t     reserved1;       /* reserviert                      */
   int32_t     reserved2;       /* reserviert                      */
   int32_t     reserved3;       /* reserviert                      */
   int32_t     reserved4;       /* reserviert                      */
   PDLG_INIT   init_dlg;        /* Initialisierungsfunktion        */
   PDLG_HNDL   do_dlg;          /* Behandlungsfunktion             */
   PDLG_RESET  reset_dlg;       /* ZurÅcksetzfunktion              */
   int32_t     reserved5;       /* reserviert                      */
   OBJECT      *sub_icon;       /* Zeiger auf das Icon der Listbox */
   OBJECT      *sub_tree;       /* Objektbaum des Unterdialogs     */
   int32_t     reserved6;       /* reserviert                      */
   int32_t     reserved7;       /* reserviert                      */
   int32_t     private1;        /* dialogeigene Informationen-1    */
   int32_t     private2;        /* dialogeigene Informationen-2    */
   int32_t     private3;        /* dialogeigene Informationen-3    */
   int32_t     private4;        /* dialogeigene Informationen-4    */
} PDLG_SUB;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_sub_dialogs
!end_node


!begin_node POPINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    OBJECT *tree;    /* Popup-MenÅ                  */
    int16_t   obnum;    /* aktuelles Objekt von <tree> */
} POPINFO;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente tree zeigt auf einen Objektbaum, der etwa
fÅr form_popup als Eingabe dienen kînnte. D.h. die Box sollte als Objekt 0
eine G_BOX oder G_IBOX enthalten, die von den anderen Objekten vollstÑndig
bedeckt wird. Objekte die nicht auswÑhlbar sind, sollten wie im DropdownmenÅ
den Status DISABLED erhalten.

Alle wÑhlbaren Objekte mÅssen den Status SELECTABLE haben. ZusÑtzlich mÅssen
bei der Verwendung durch (!nolink [G_POPUP]) alle selektierbaren Objekte vom Typ
G_STRING (bzw. G_SHORTCUT) oder G_BUTTON sein und mit zwei Leerstellen
beginnen, letzteres wegen des HÑkchens, das von form_button bzw. form_do
automatisch gesetzt wird!

Wichtig ist, daû ob_x und ob_y von Objekt 0 des MenÅs relativ zum
(!nolink [G_POPUP])-Objekt angegeben werden, d.h. sie werden meistens beide 0 sein. Es
wird empfohlen, einen Schatten und einen Rand der StÑrke -1  anzugeben.

Querverweis: MagiC ~ G_POPUP
!end_node


!begin_node PRN_DIALOG

!begin_verbatim
typedef void *PRN_DIALOG;
!end_verbatim
!end_node


!begin_node PRN_ENTRY

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _prn_entry
{
   struct _prn_entry *next;          /* Zeiger auf Nachfolger           */
   int32_t     length;               /* StrukturlÑnge                   */
   int32_t     format;               /* Datenformat                     */
   int32_t     reserved;             /* reserviert                      */
   int16_t     driver_id;            /* Treiberkennung                  */
   int16_t     driver_type;          /* Treibertyp                      */
   int32_t     printer_id;           /* Druckerkennung                  */
   int32_t     printer_capabilities; /* Druckereigenschaften            */
   int32_t     reserved1;            /* reserviert                      */
   int32_t     flags;                /* verschiedene Flags              */
   struct _pdlg_sub  *sub_dialogs;   /* Zeiger auf Unterdialoge         */
   PRN_SWITCH  setup_panel;          /* Unterdialog bei Druckerwechsel
                                        initialisieren                  */
   PRN_SWITCH  close_panel;          /* Unterdialog bei Druckerwechsel
                                        schlieûen                       */
   PRN_MODE    *modes;               /* Liste vorhand. Auflîsungen      */
   MEDIA_SIZE  *papers;              /* Liste vorhand. Papierformate    */
   PRN_TRAY    *input_trays;         /* Liste der EinzÅge               */
   PRN_TRAY    *output_trays;        /* Liste der AuswÅrfe              */
   int8_t      name[32];             /* Name des Druckers               */
} PRN_ENTRY;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node PRN_MODE

Diese Struktur dient der Beschreibung eines Druckermodus, und ist wie folgt
definiert:

!begin_verbatim
typedef struct _prn_mode
{
   struct _prn_mode *next;         /* Zeiger auf Nachfolger             */
   int32_t     mode_id;            /* Modus (Index innerhalb der Datei) */
   int16_t     hdpi;               /* horizontale Auflîsung in dpi      */
   int16_t     vdpi;               /* vertikale Auflîsung in dpi        */
   int32_t     mode_capabilities;  /* Moduseigenschaften                */
   int32_t     color_capabilities; /* einstellbare Farbmodi             */
   int32_t     dither_flags;       /* Flags, die angeben, ob der
                                      korrespondierende Farbmodus mit
                                      oder ohne Dithern ansprechbar ist */
   MEDIA_TYPE  *paper_types;       /* geeignete Papiertypen             */
   int32_t     reserved;           /* reserviert                        */
   int8_t      name[32];           /* Modusname                         */
} PRN_MODE;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node PRN_TRAY

Diese Struktur dient der Beschreibung eines Einzugs bzw. Auswurfs, und ist
wie folgt definiert:

!begin_verbatim
typedef struct _prn_tray
{
   struct _prn_tray  *next;    /* Zeiger auf Nachfolger       */
   int32_t     tray_id;        /* Nummer des Einzugs/Auswurfs */
   int8_t      name[32];       /* Name des Schachts           */
} PRN_TRAY;
!end_verbatim

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node PRN_SETTINGS

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _prn_settings
{
   int32_t  magic;            /* 'pset'                                 */
   int32_t  length;           /* (+) StrukturlÑnge                      */
   int32_t  format;           /* Strukturtyp                            */
   int32_t  reserved;         /* reserviert                             */
   int32_t  page_flags;       /* (+) Flags, u.a. gerade/ungerade Seiten
                              0x0001 = nur Seiten mit gerader Nummer
                              0x0002 = dto. mit ungeraden Nummern    */
   int16_t  first_page;       /* (+) erste zu druckende Seite (min.1)   */
   int16_t  last_page;        /* (+) dto. letzte Seite (max. 9999)      */
   int16_t  no_copies;        /* (+) Anzahl der Kopien                  */
   int16_t  orientation;      /* (+) Drehung
                               0x0000 = Ausichtung unbekannt und
                                        nicht verstellbar
                               0x0001 = Seite im Hochformat ausgeben
                               0x0002 = Seite im Querformat ausgeben */
   int32_t  scale;            /* (+) Skalierung: 0x10000L = 100%        */
   int16_t  driver_id;        /* (+) VDI-GerÑtenummer                   */
   int16_t  driver_type;      /* Typ des eingestellten Treibers         */
   int32_t  driver_mode;      /* Flags, u.a. fÅr Hintergrunddruck       */
   int32_t  reserved1;        /* reserviert                             */
   int32_t  reserved2;        /* reserviert                             */
   int32_t  printer_id;       /* Druckernummer                          */
   int32_t  mode_id;          /* Modusnummer                            */
   int16_t  mode_hdpi;        /* horizontale Auflîsung in dpi           */
   int16_t  mode_vdpi;        /* vertikale Auflîsung in dpi             */
   int32_t  quality_id;       /* Druckmodus (hardwÑremÑûige QualitÑt,
                              z.B. Microweave oder Econofast)        */
   int32_t  color_mode;       /* Farbmodus                              */
   int32_t  plane_flags;      /* Flags fÅr auszugebende Farbebenen
                              (z.B. nur cyan)                        */
   int32_t  dither_mode;      /* Rasterverfahren                        */
   int32_t  dither_value;     /* Parameter fÅr das Rasterverfahren      */
   int32_t  size_id;          /* Papierformat                           */
   int32_t  type_id;          /* Papiertyp (normal, glossy)             */
   int32_t  input_id;         /* Papiereinzug                           */
   int32_t  output_id;        /* Papierauswurf                          */
   int32_t  contrast;         /* Kontrast:   0x10000L = normal          */
   int32_t  brightness;       /* Helligkeit: 0x1000L  = normal          */
   int32_t  reserved3;        /* reserviert                             */
   int32_t  reserved4;        /* reserviert                             */
   int32_t  reserved5;        /* reserviert                             */
   int32_t  reserved6;        /* reserviert                             */
   int32_t  reserved7;        /* reserviert                             */
   int32_t  reserved8;        /* reserviert                             */
   int8_t   device[128];      /* Dateiname fÅr den Ausdruck             */
   #ifdef __PRINTING__
   TPrint   mac_settings;     /* Einstellung des Mac-Druckertreibers    */
   #else
   struct
   {
      uint8_t inside[120];
   } mac_settings;
   #endif
} PRN_SETTINGS;
!end_verbatim

(!B)Hinweis:(!b) Die mit (+) gekennzeichneten Strukturelemente kînnen von
der Applikation ausgelesen werden. Auf alle anderen EintrÑge sollte
(!I)nicht(!i) zugegriffen werden. Daten wie z.B. die Druckerauflîsung oder
die Farbanzahl sollten (!I)nicht(!i) der Einstellstruktur entnommen werden,
sondern beim Start des Ausdrucks vom Drucker erfragt werden (es wÑre z.B.
mîglich, daû der Druckertreiber durch Speichermangel gezwungen wird, die
Druckauflîsung gegenÅber der in PRN_SETTINGS eingetragenen Einstellung zu
verringern).

Querverweis: Druckdialoge ~ pdlg_open
!end_node


!begin_node PRN_SWITCH

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef int32_t (cdecl *PRN_SWITCH) ( struct _drv_entr *drivers,
                                   struct _prn_settings *settings,
                                   struct _prn_entry *old_printer,
                                   struct _prn_entry *new_printer );
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)old_printer(!i) kann auch 0L sein!

Querverweis: Druckdialoge ~ pdlg_add_printers
!end_node


!begin_node SCANX

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int8_t scancode;
    int8_t nclicks;
    int16_t  objnr;
} SCANX;
!end_verbatim

(!B)Hinweis:(!b) Die Struktur enthÑlt die Zuordnung fÅr die Taste mit dem
Scancode (!I)scancode(!i), bei deren BetÑtigung ein (!I)nclicks(!i)-facher
Mausklick auf das Objekt mit der Nummer (!I)objnr(!i) ausgefÅhrt wird. Das
Ende der Tabelle wird durch einen Scancode von Null markiert.

Querverweis: AES ~ MagiC ~ XDO_INF ~ (!link [Scan-Code Tabelle][Der Scan-Code])
!end_node


!begin_node SET_ITEM

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef int16_t (cdecl *SET_ITEM)( LIST_BOX *box, OBJECT *tree,
                                struct _lbox_item *item,
                                int16_t obj_index, void *user_data,
                                GRECT *rect, int16_t first );
!end_verbatim

Dabei gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [box]
Zeiger auf die Listbox-Struktur
!item [tree]
Zeiger auf den Objektbaum des Dialogs
!item [item]
Zeiger auf LBOX_ITEM-Struktur des zu setzenden Eintrags
!item  [obj_index]
Nummer des zu setzenden Objektes
!item [user_data]
Zeiger der bei (!nolink [lbox_create]) Åbergeben wurde
!item [rect]
Rechteck fÅr das Objekt-Redraw (oder NULL)
!item [first]
Nummer des ersten sichtbaren Elements fÅr Slider-B
!end_xlist

(!B)Hinweis:(!b) Bei einer Listbox, die nur Text-Strings enthÑlt, ist dies
typischerweise eine Funktion, die einen String, auf den die LBOX_ITEM
Struktur verweist, in das Objekt (!I)obj_index(!i) kopiert. Der Parameter
(!I)rect(!i) ist 0L, wenn ein Redraw der Dialogbox durchgefÅhrt wird oder
wenn lbox_update aufgerufen wurde. Er ist hingegen (!I)nicht(!i) 0L, wenn
der Anwender ein Objekt selektiert oder deselektiert hat, und zeigt auf das
GRECT fÅr den Redraw.

Der RÅckgabewert der Funktion ist die Nummer des Startobjekts fÅr die
Funktion objc_draw bzw. wdlg_redraw.

Bei EintrÑgen in der Listbox, die aus mehreren Objekten bestehen, ist es
manchmal sinnvoll bei Selektion/Deselektion eines Objekts das Redrawrechteck
zu verkleinern oder das Startobjekt zu Ñndern, um unnîtige
Zeichenoperationen und unnîtiges Geflacker zu vermeiden. In den meisten
FÑllen rufen die Listbox-Routinen nach der oben beschriebenen Funktion die
Routinen (!nolink [objc_draw]) bzw. (!nolink [wdlg_redraw]) auf, um den geÑnderten Inhalt
anzuzeigen.

Der Parameter (!I)first(!i) enthÑlt die Nummer des ersten sichtbaren
Elements fÅr Slider B, wenn die Listbox 2 Slider hat. Bei einer (vertikalen)
Listbox mit Text-Strings und zwei Slidern gibt man z.B. beim  Aufruf von
lbox_create die Anzahl der sichtbaren Zeichen in (!I)visible_b(!i), die
gesamte StringlÑnge in (!I)entries_b(!i) und den Index des ersten sichtbaren
Zeichens in (!I)first_b(!i) an. Wird der Text horizontal gescrollt, wird die
Funktion fÅr alle sichtbaren Strings aufgerufen und der Bereich
neugezeichnet bzw. verschoben. Wenn die Listbox nur einen Slider hat, ist
first immer 0.

Querverweis: Listboxen ~ lbox_create
!end_node


!begin_node SLCT_ITEM

Dieser Typ ist wie folgt definiert:

!begin_verbatim
typedef void (cdecl *SLCT_ITEM)( LIST_BOX *box, OBJECT *tree,
                                 struct _lbox_item *item,
                                 void *user_data, int16_t obj_index,
                                 int16_t last_state );
!end_verbatim

Dabei gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [box]
Zeiger auf Listbox-Struktur
!item [tree]
Zeiger auf den Objektbaum des Dialogs
!item [item]
Zeiger auf die LBOX_ITEM-Struktur des ausgewÑhlten Eintrags
!item [user_data]
Zeiger der bei (!nolink [lbox_create]) Åbergeben wurde
!item [obj_index]
ist die Nummer des angewÑhlten Objekts. Bei einem (!nolink [Doppelklick]) ist Ñhnlich
wie nach form_do das oberste Bit gesetzt. Wenn (!I)obj_index(!i) 0 ist,
heiût das, daû dem Eintrag kein Objekt zugeordnet ist; er ist nicht
sichtbar. Normalerweise ist das nur der Fall, wenn gescrollt wird und durch
Auswahl eines neuen Objekts die (mittlerweile nicht mehr sichtbare)
Selektion gelîscht werden muû.
!item [last_state]
ist der vorhergehende Status des Objekts. (!I)last_state(!i) kann auch den
gleichen Wert wie item->selected haben. In diesem Fall kann die Funktion
slct normalerweise sofort verlassen werden.
!end_xlist

Querverweis: lbox_create
!end_node


!begin_node SWINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int8_t  *string;     /* etwa "TOS|KAOS|MAG!X"          */
    int16_t  num;        /* Nr. der aktuellen Zeichenkette */
    int16_t  maxnum;     /* maximal erlaubtes <num>        */
} SWINFO;
!end_verbatim

Querverweis: AES ~ GEM ~ G_SWBUTTON
!end_node


!begin_node TEDINFO

Die TEDINFO-Struktur wird benutzt um ein Textobjekt nÑher zu beschreiben,
und ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int8_t    *te_ptext;          /* Zeiger auf einen String          */
    int8_t    *te_ptmplt;         /* Zeiger auf die Stringmaske       */
    int8_t    *te_pvalid;         /* Zeiger auf den GÅltigkeitsstring */
    int16_t    te_font;           /* Zeichensatz                      */
    int16_t    te_fontid;         /* GDOS Font-ID                     */
    int16_t    te_just;           /* Justierung des Textes:
                                     0 = linksbÅndig
                                     1 = rechtsbÅndig
                                     2 = zentriert                    */
    int16_t    te_color;          /* Farbe                            */
    int16_t    te_fontsize;       /* GDOS Font-Grîûe in Punkten       */
    int16_t    te_thickness;      /* Rahmenbreite                     */
    int16_t    te_txtlen;         /* Maximale LÑnge des Textes        */
    int16_t    te_tmplen;         /* LÑnge der Stringmaske            */
} TEDINFO;
!end_verbatim

Dabei gilt es, die folgenden Einzelheiten zu beachten:

!begin_itemize
!item (!B)te_ptext:(!b) Wenn das erste Zeichen ein Klammeraffe (!) ist,
      werden alle folgenden Zeichen als Platzhalter angesehen, und der
      zunÑchst ausgegebene String besteht aus Leerzeichen. Folge: Der
      Klammeraffe kann niemals am Anfang eines Edit-Feldes stehen!
!item (!B)te_ptmplt:(!b) Schablone (template). Sie wird nur bei G_FTEXT und
      G_FBOXTEXT verwendet, d.h. bei G_TEXT und G_BOXTEXT kann hier ein
      Null-Zeiger stehen. Bei der Ausgabe werden alle '_' Zeichen in der
      Schablone sukzessive durch die Zeichen in (!I)te_ptext(!i) ersetzt,
      d.h. es wird eine Misch-Zeichenkette gebildet. I.A. wird die Schablone
      also soviele '_' Zeichen enthalten, wie der Puffer fÅr
      (!I)te_ptext(!i) lang ist (ohne abschlieûendes Nullbyte).
!item (!B)te_pvalid:(!b) String, der fÅr jedes Zeichen in (!I)te_ptext(!i)
      eine Zeichenkette enthÑlt, die Åber die GÅltigkeit verschiedener
      Zeichen an dieser Stringposition Auskunft gibt. Es gilt:
!begin_xlist !short [Zeichen]
!item [Zeichen]
Bedeutung
!item [~]
~
!item [9]
nur Ziffern
!item [A]
nur Groûbuchstaben/Leerzeichen
!item [a]
nur Buchstaben/Leerzeichen
!item [N]
Groûbuchstaben, Ziffern, Leerzeichen
!item [n]
Buchstaben, Ziffern, Leerzeichen
!item [F]
alle Zeichen, die zu einem Dateinamen gehîren und '*', '?' und ':'.
!item [f]
alle Zeichen, die zu einem Dateinamen, ohne '*', '?' und ':'.
!item [P]
alle Zeichen, die zu einem Pfadnamen gehîren
!item [p]
analog 'P', aber ohne die Zeichen '?' und '*'
!item [m]
alle Zeichen, die fÅr einen langen Dateinamen gÅltig sind; d.h. alle Zeichen
auûer Steuerzeichen (ASCII < 32), sowie auûer ':' und '\'. Dieser Code wird
z.Zt. nur von MagiC unterstÅtzt.
!item [X]
alle Zeichen
!item [x]
alle Zeichen, Kleinbuchstaben werden automatisch in Groûbuchstaben umgewandelt.
!end_xlist

!item (!B)te_font:(!b) (!nl)
3 = normal (!nl)
5 = kleiner Zeichensatz

FÅr weiters siehe unten.

!item (!B)te_fontid:(!b) (!nl)
FÅr weiters siehe unten.

!item (!B)te_color:(!b) FÅr die Farbe des begrenzenden Rechteckes gilt die
      folgende Belegung:
!begin_xlist !short [0..23]
!item [Bit]
Bedeutung
!item [~]
~
!item [12..15]
Rahmenfarbe (0..15)
!item [08..11]
Textfarbe (0..15)
!item [~7]
Text (0 = transparent, 1 = deckend)
!item [~4..~6]
IntensitÑt
!begin_xlist !short [1..6 =]
!item [0~~~ =]
hohl
!item [1..6 =]
ansteigende IntensitÑt
!item [7~~~ =]
solide FlÑche
!end_xlist
!item [~0..~3]
Innenfarbe (0..15)
!end_xlist
!item (!B)te_thickness:(!b) FÅr den Rahmen sind folgende Werte gÅltig:
!begin_xlist !short [-1..-127]
!item [Wert]
Bedeutung
!item [~]
~
!item [~0]
kein Rahmen
!item [~1..~128]
Rand liegt 1 bis 128 Pixel im Inneren
!item [-1..-127]
Rand liegt 1 bis 127 Pixel auûerhalb des Objektes
!end_xlist
!end_itemize

!label GDOS-Fonts in Dialogen
!label Dialogen, GDOS-Fonts in
!label ZeichensÑtze in Dialogen
(!B)Hinweis:(!b) Die Komponenten (!I)te_fontid(!i) und (!I)te_fontsize(!i)
waren bisher reserviert. Ab AES-Version 4.1 ist es mîglich, beliebige
GDOS-Fonts fÅr TEDINFO-Objekte zu benutzen.

Dazu ist Åber die Komponente (!I)te_font(!i) die Art des Zeichensatzes zu
spezifizieren:

!begin_table [c l]
te_font !! Bedeutung
!hline
0 !! (!nolink [SpeedoGDOS]) Font
1 !! (!nolink [SpeedoGDOS]) Font (monospaced)
2 !! GDOS Bitmap-Font
3 !! System-Zeichensatz
5 !! kleiner System-Zeichensatz
!end_table

FÅr Werte im Bereich 0..2 von (!I)te_font(!i) kann dann Åber die Komponenten
(!I)te_fontid(!i) bzw. (!I)te_fontsize(!i) der gewÅnschte Zeichensatz und
die gewÅnschte Punktgrîûe eingestellt werden.

Das Vorhandensein der neuen Mîglichkeiten kann am einfachsten per
(!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

Querverweis: AES ~ GEM  ~ OBJECT ~ XTED ~
(!link [Scrollende Eingabefelder][scrollende Eingabefelder])
!end_node


!begin_node USERBLK

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int16_t cdecl (*ub_code)(PARMBLK *parmblock);
   int32_t ub_parm;
} USERBLK;
!end_verbatim

(!B)Hinweis:(!b) Die Funktion (!I)ub_code(!i) wird bei jedem Aufruf von
objc_draw und objc_change fÅr das entsprechende Objekt aufgerufen. Die
Komponente (!I)ub_parm(!i) kann als optionaler Parameter angesehen werden.
!end_node


!begin_node X_BUF_V2

!label ABLE_GETINFO
!label ABLE_PROP
!label ABLE_WTREE
!label ABLE_X3D
!label ABLE_XSHL
!label ABLE_PROP2
!label ABLE_EMSDESK
!label ABLE_XBVSET
!begin_verbatim
typedef struct x_buf_v2
{

int16_t  buf_len   /* Length of the structure, including this word. Future        */
                   /* versions of this structure (X_BUF_V3 etc.) may be bigger.   */
int16_t  arch      /* 16 for 16-bit AES, 32 for hypothetical 32-bit AES.          */
CLRCAT   *cc       /* Address of an array of 16 CLRCAT structures.                */
                   /* This is so that they can be read by a program; in           */
                   /* ViewMAX, the colours could be set but not reread.           */
OBJECT   *w_active /* Address of an object tree (19 elements) used to             */
                   /* draw window elements. Included so a program can             */
                   /* change symbols on window buttons.                           */
int8_t   *info     /* Address of a 0-terminated ASCII string (at most             */
                   /* 40 characters, no newlines) describing the AES              */
int32_t  abilities /* A bitmapped field describing what optional functions        */
                   /* this AES provides:                                          */
/* ABLE_GETINFO  1    bit 0 : xapp_getinfo supported                              */
/* ABLE_PROP     2    bit 1 : prop_get, prop_put and prop_del supported           */
/* ABLE_WTREE    4    bit 2 : wind_get and wind_set can change glyphs             */
/* ABLE_X3D      8    bit 3 : GEM/5 3D using DRAW3D                               */
/* ABLE_XSHL    16    bit 4 : xshl_getshell & xshl_putshell                       */
/* ABLE_PROP2   32    bit 5 : prop_gui_get, prop_gui_set                          */
/* ABLE_EMSDESK 64    bit 6 : xgrf_dtimage supports EMS                           */
/* ABLE_XBVSET 128    bit 7 : supports 32 disc drives                             */

} X_BUF_V2;
!end_verbatim


An initialised X_BUF_V2 is one in which all members are 0 except buf_len. This
initialised buffer is then passed to appl_init. On return, if arch
is 0 then the structure was not filled in by the AES; otherwise it was. The
buf_len field may be reduced, if the AES was expecting an
earlier version of the structure (ie, X_BUF_V1); this should not be a
problem because the structures are forward and backward compatible.

See Also: appl_init
!end_node

!begin_node XDO_INF

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    SCANX *unsh;    /* Tabellen fÅr UnShift-Kombinationen   */
    SCANX *shift;   /* Tabellen fÅr Shift-Kombinationen     */
    SCANX *ctrl;    /* Tabellen fÅr Control-Kombinationen   */
    SCANX *alt;     /* Tabellen fÅr Alternate-Kombinationen */
    void  *resvd;   /* reserviert */
} XDO_INF;
!end_verbatim

(!B)Hinweis:(!b) In dieser Struktur liegen Zeiger auf Tabellen, die einem
Scancode eine Objektnummer der Dialogbox zuordnen. Hiermit ist es auf
einfache Weise mîglich, Dialoge vollstÑndig Åber die Tastatur zu bedienen.
Der Parameter (!I)resvd(!i) ist fÅr spÑtere Zwecke reserviert, und muss
immer NULL sein.

Querverweis: AES ~ form_keybd ~ form_xdo ~ MagiC ~
(!link [Scan-Code Tabelle][Der Scan-Code])
!end_node


!begin_node XFSL_FILTER

Dieser Typ ist wie folgt definiert

!begin_verbatim
typedef int16_t (cdecl XFSL_FILTER) (int8_t *path, int8_t *name, XATTR *xa);
!end_verbatim

Querverweis: fslx_do ~ fslx_open
!end_node


!end_node
