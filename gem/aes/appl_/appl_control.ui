0# Source: APC_TOPNEXT, APC_KILL and APC_SYSTEM from the sourcecode.

!iflang [english]

!begin_node appl_control
#!html_name appl_control
(!begin_liste) [Availability]
!item [Name:]
ØApplication (!nolink [control])Æ - Targeted (!nolink [control]) of applications.
!item [Opcode:]
129
!item [Syntax:]
int16_t appl_control ( int16_t ap_cid, int16_t ap_cwhat, void *ap_cout);

!item [Description:]
The call appl_control can be used to (!nolink [control]) the activity of
applications.

!begin_xlist [Paramete]
!item [Parameter]
Meaning

!item [ap_cid]
The (!nolink [AES]) ID (apid) of the application you want to
(!nolink [control]).

!item [ap_cwhat]
The type of (!nolink [control]):

!begin_xlist [APC_TOPNEXT]

!item [0 to 9]
 (!nl)
Reserved for (!nolink [N.AES])

!label APC_TOPNEXT
!item [APC_TOPNEXT (0)]
 (!nl)
OAESis internal mode

!label APC_KILL
!item [APC_KILL (1)]
 (!nl)
OAESis internal mode

!label APC_SYSTEM
!item [APC_SYSTEM (2)]
 (!nl)
XaAES internal mode

!label APC_HIDE
!item [APC_HIDE (10)]
 (!nl)
Hide (fade out) application; (!nl)
if (!I)ap_cid(!i) is -1, the active application will be hidden


!label APC_SHOW
!item [APC_SHOW (11)]
Show (fade in) application; (!nl)
if (!I)ap_cid(!i) is -1, all hidden applications are shown


!label APC_TOP
!item [APC_TOP (12)]
 (!nl)
Bring application to front (the application becomes the active one)

!label APC_HIDENOT
!item [APC_HIDENOT (13)]
 (!nl)
Hide all applications except the one referred to by (!I)ap_cid(!i) (which
becomes the active application)

If (!I)ap_cid(!i) is -1, all applications except the active one will be hidden

!label APC_INFO
!item [APC_INFO (14)]
 (!nl)
Inquire the application parameters of application (!I)ap_cid(!i); if -1 is
passed for (!I)ap_cid(!i), then the parameters of the current application
will be returned

For (!I)ap_cout(!i) a pointer to an integer is to be passed

(!nolink [N.AES]) here deposits the application parameters in the form of a
bitmask:

!begin_xlist  [APCI_HIDD]
!label APCI_HIDDEN
!item [APCI_HIDDEN (1)]  Bit 0 is set if the application is faded out

!label APCI_HASMBAR
!item [APCI_HASMBAR (2)]  Bit 1 is set if the application posseses a menu bar

!label APCI_HASDESK
!item [APCI_HASDESK (4)]  Bit 2 is set if the application possesses its own
desktop
!end_xlist

!label APC_MENU
!item [APC_MENU (15)]
 (!nl)
Returns address of the menu tree that the application (!I)ap_cid(!i) last
initialized. For this a pointer to an OBJECT pointer is to be passed for
(!I)ap_cout(!i); the latter will be filled by (!nolink [shel_write]) with the
searched for menu tree address.

If -1 is passed for (!I)ap_cid(!i), then the menu tree address of the current
application will be returned. If the value 0 is passed for (!I)ap_cid(!i)
then the address of the system menu managed inter!-nally by (!nolink [shel_write])
will be returned. This is the menu box that pops open when one selects the
left-most menu title and which contains the list of all applications and
desk accessories initialized by (!nolink [shel_write]).

If the application inquired for has not initialized a menu bar, or no application
with the identification (!I)ap_cid(!i) exists, then a NULL pointer will be
written to (!I)ap_cout(!i)

The return value of appl_control, mode APC_MENU is always the value 1

(!B)Note:(!b) If one uses this mode, one should be quite certain what one is
doing! Altering the returned menu tree can lead to undefined system states.
With active MiNT memory protection even a read access to the menu tree can
lead to a termination of the application!


!label APC_WIDGETS
!label MINWINOBJ
!item [APC_WIDGETS (16)]
 (!nl)
Inquires or sets the 'default' positions of the window objects.
(!I)ap_cout(!i) is a pointer to a MINWINOBJ(12)-sized (int16_t) buffer, which
must be filled comple!-tely with -1 for inquiring the object order. The last
WORD must be a 0. If an error-message is returned, then the buffer is too small
for all objects and should be enlarged. In the buffer lie first of all the objects
of the title-bar from left to right, followed by the objects of the vertical
slider from top to bottom and then the objects of the horizontal slider from left
to right. The list is termi!-nated with a NULL-word. For setting the positions,
the first objects have to be of the type topwidgets (from left to right),
followed by the objects of the type rightwidgets (from top to bottom) and then
the objects of the type bottomwidgets (from left to right). If the objects are
duplicated or set incorrectly then an error will be reported.


!label APC_APP_CONFIG
!item [APC_APP_CONFIG (17)]
 (!nl)
With this option you are able to inform to AES how you want your application
should be considered. (!nl)
(!I)ap_cout(!i) is a pointer to a string. At this time value supported are:
!begin_itemize !compressed
!item "app_debug=true" or "app_debug" : put the application in debug mode
!item "app_debug=false" : stop debug mode
!item "app_topmost=true" or "app_topmost" : Application windows will be
       always on top (compare to other classical application) but without
       focus (can be usefull for tesk bar for exemple)
!item "app_topmost=false" : remove previous option
!item "app_system" : application is a system application (used in appl_search
      for type APP_SYSTEM)
!item "app_texticon=opaque" : background icon text is opaque
!item "app_texticon=transparent" : background icon text is transparent
!item "app_signal_mesag=true": Request receive Unix Signal when even message
       is waiting see APC_INFORM_MESAG as it do exactly the same
!item "app_signal_mesag=false": Request stop receive Unix Signal when even message is waiting
!end_itemize

!label APC_INFORM_MESAG
!item [APC_INFORM_MESAG (18)]
 (!nl)
Request to AES to inform the application when there 
is a AES message waiting with a Unix Signal. (!nl)
(!I)ap_cout(!i) : not used. (!nl)
When the application receive a message the AES send the Signal SIGUSR2 (30)
to the application, to manage the message should use classical event_mesag
or event_multi functions. Calling one time this call request to AES to
send Signal, calling a second time remove this order.

!end_xlist

!item [ap_cout]
Is filled by the (!nolink [AES]) dependent on (!I)ap_cwhat(!i) and only has a
meaning for APC_INFO, APC_MENU, APC_WIDGETS and APC_APP_CONFIG. In other cases this parameter is
ignored and passing of a NULL-pointer is then possible.

!end_xlist

(!B)Note:(!b) Hidden application have a '*' placed in front of their names in the
applications menu, unless they did not have a window open during hiding. If the
latter is the case only the active application is changed.

So the '*' in front of the name means: One or more windows of this application
are hidden.

!item [(!nolink [Return]) value:]
~0 = An error has occurred (!nl)
>0 = No error has arisen

!item [Availability:]
The presence of the function can be checked via
(!link [appl_getinfo][%apgi_65]) (opcode 65).

!item [Group:]
Application library

!item [See also:]
(!link [Binding] [Bindings for appl_control]) ~ SM_M_SPECIAL
(!ende_liste)



!begin_node Bindings for appl_control
#!html_name Bindings_for_appl_control
!ignore_index
(!begin_liste) [GEM-Arrays]
!item [C:]
int16_t appl_control ( int16_t ap_cid, int16_t ap_cwhat, void *ap_cout);

!item [Binding:]
!begin_verbatim
int16_t appl_control ( int16_t ap_cid, int16_t ap_cwhat,
                       void *ap_cout);
{
   int_in[0]  = ap_cid;
   int_in[1]  = ap_cwhat;
   addr_in[0] = ap_cout;

   return ( crys_if(129) );
}
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Address !! Element !! Contents
!hline
control   !! control[0] !! 129   # Function opcode
control+2 !! control[1] !! 2     # Entry in int_in
control+4 !! control[2] !! 1     # Entry in int_out
control+6 !! control[3] !! 1     # Entry in addr_in
control+8 !! control[4] !! 0     # Entry in addr_out
int_in !! int_in[0] !! ap_cid
int_in+2 !! int_in[1] !! ap_cwhat
addr_in  !! addr_in[0] !! ap_cout
int_out !! int_out[0] !! ap_creturn
!end_table
(!ende_liste)
!end_node
!end_node

!else

!begin_node appl_control
#!html_name appl_control

(!begin_liste) [Beschreibung]
!item [Name:]
ØApplication controlÆ - Gezieltes Steuern von Anwendungen.
!item [AES-Nummer:]
129
!item [Deklaration:]
int16_t appl_control ( int16_t ap_cid, int16_t ap_cwhat, void *ap_cout);

!item [Beschreibung:]
Die Funktion erlaubt ein gezieltes Steuern von Anwendungen.
!begin_xlist [Paramete]
!item [Parameter]
Bedeutung

!item [ap_cid]
Die Applikationsidentifikation (apid) der Anwendung, die gesteuert
werden soll.

!item [ap_cwhat]
Die Art der Steuerung:

!begin_xlist [APC_TOPNEXT ]

!item [0 bis 9]
 (!nl)
Reserviert fÅr N.AES.

!label APC_TOPNEXT
!item [APC_TOPNEXT (0)]
 (!nl)
OAESis interner Mode

!label APC_KILL
!item [APC_KILL (1)]
 (!nl)
OAESis interner Mode

!label APC_SYSTEM
!item [APC_SYSTEM (2)]
 (!nl)
XaAES interner Mode

!label APC_HIDE
!item [APC_HIDE (10)]
 (!nl)
Applikation ausblenden (!nl)
Wird fÅr (!I)ap_cid(!i) -1 Åbergeben, so wird die  aktuelle Anwendung ausgeblendet.

!label APC_SHOW
!item [APC_SHOW (11)]
 (!nl)
Applikation einblenden (!nl)
Wird fÅr (!I)ap_cid(!i) -1 Åbergeben, so werden alle ausgeblendeten Anwendungen
ein!-ge!-blendet.

!label APC_TOP
!item [APC_TOP (12)]
 (!nl)
Applikation in den Vordergrund bringen (zur  aktuellen Anwendung machen).

!label APC_HIDENOT
!item [APC_HIDENOT (13)]
 (!nl)
Ausblenden aller Anwendungen bis auf die in  (!I)ap_cid(!i) angegebene, welche zur
neuen aktu!-ellen Anwendung wird. Wird fÅr (!I)ap_cid(!i) -1 Åbergeben, so werden alle
Anwendungen bis auf die aktuelle aus!-ge!-blendet.

!label APC_INFO
!item [APC_INFO (14)]
 (!nl)
Abfragen von Applikations!-parametern der An!-wendung (!I)ap_cid(!i). Wird fÅr (!I)ap_cid(!i) -1
Åbergeben, so werden die Parameter der aktu!-ellen Anwendung geliefert.

FÅr (!I)ap_cout(!i) ist ein Zeiger auf einen Integer zu Åbergeben. N.AES hinterlegt hier
die Applikationsparameter in Form einer  Bitmaske:

!begin_xlist  [APCI_HIDD]
!label APCI_HIDDEN
!item [APCI_HIDDEN (1)]
Bit 0 ist gesetzt, wenn die Applikation aus!-ge!-blendet ist.

!label APCI_HASMBAR
!item [APCI_HASMBAR (2)]
Bit 1 ist gesetzt, wenn die Applikation eine MenÅleiste besitzt.

!label APCI_HASDESK
!item [APCI_HASDESK (4)]
Bit 2 ist gesetzt, wenn die Applikation einen eigenen Desktop besitzt.
!end_xlist

!label APC_MENU
!item [APC_MENU (15)]
 (!nl)
Liefert die Adresse des MenÅbaums, den die Anwendung (!I)ap_cid(!i) zuletzt an!-ge!-meldet
hat. Hierzu ist fÅr (!I)ap_cout(!i) ein Zeiger auf einen OBJECT-Zeiger zu Åbergeben;
letzterer wird vom N.AES mit der gesuchten MenÅbaumadresse gefÅllt.

Wird fÅr (!I)ap_cid(!i) -1 Åbergeben, so wird die MenÅbaumadresse der aktuellen
An!-wendung geliefert. öbergibt man fÅr (!I)ap_cid(!i) den Wert 0, so wird die Adresse
des vom (!nolink [N.AES]) intern verwalteten SystemmenÅs geliefert. Dies ist
die MenÅbox, die aufklappt, wenn man den am weitesten links stehenden MenÅtitel
anwÑhlt und welche die Liste aller beim N.AES angemeldeten Anwendungen und
Accessories enthÑlt.

Hat die abgefragte Anwendung keine MenÅleiste angemeldet oder existiert keine
Anwendung mit der Identifikation (!I)ap_cid(!i), so wird ein Nullzeiger nach (!I)ap_cout(!i)
geschrieben.

Der RÅckgabewert von appl_control, Modus APC_MENU ist immer der Wert 1.

(!B)Hinweis:(!b) Wenn man diesen Modus verwendet, sollte man sich ganz sicher
sein, was man tut! Das VerÑndern des gelieferten MenÅbaums kann zu
un!-definierten SystemzustÑnden fÅhren. Bei aktivem MiNT-Speicherschutz kann
bereits ein Lesezugriff auf den MenÅbaum den Abbruch der Anwendung bewirken.

!label APC_WIDGETS
!label MINWINOBJ
!item [APC_WIDGETS (16)]
 (!nl)
Erfragt oder setzt die 'default' Positionen der Fensterobjekte. (!I)ap_cout(!i)
ist ein Zeiger
auf einen MINWINOBJ(12) groûen (int16_t) Buffer, der zum abfragen der
Objektreihenfolge komplett mit -1 gefÅllt sein muû. Das letzte Word muû eine 0
sein. Wird eine Fehlermeldung zurÅckgeliefert reicht der Buffer nicht fÅr alle
Objekte und sollte vergrîûert werden. Im Buffer liegen als erstes die Objekte
der Titelleiste von links nach rechts, danach die Objekte des Vertikalsliders
von oben nach unten und dann die Objekte des Horizontalsliders von links nach
rechts. Abgeschlossen wird die Liste mit einem 0 Word. Zum setzen der Positionen
mÅûen die ersten Objekte vom Typ topwidgets sein (von links nach rechts), danach
die Objekte des Typs rightwidgets (von oben nach unten) und dann die Objekte des
Typs bottomwidgets (von links nach rechts). Sollten Objekte doppelt oder falsch
gesetzt sein wird ein Fehler gemeldet.

!label APC_APP_CONFIG
!item [APC_APP_CONFIG (17)]
 (!nl)
With this option you are able to inform to AES how you want your application
should be considered. (!nl)
(!I)ap_cout(!i) is a pointer to a string. At this time value supported are:
!begin_itemize  !compressed
!item "app_debug=true" or "app_debug" : put the application in debug mode
!item "app_debug=false" : stop debug mode
!item "app_topmost=true" or "app_topmost" : Application windows will be
       always on top (compare to other classical application) but without
       focus (can be usefull for tesk bar for exemple)
!item "app_topmost=false" : remove previous option
!item "app_system" : application is a system application (used in appl_search
      for type APP_SYSTEM)
!item "app_texticon=opaque" : background icon text is opaque
!item "app_texticon=transparent" : background icon text is transparent
!item "app_signal_mesag=true": Request receive Unix Signal when even message
       is waiting see APC_INFORM_MESAG as it do exactly the same
!item "app_signal_mesag=false": Request stop receive Unix Signal when even message is waiting
!end_itemize

!label APC_INFORM_MESAG
!item [APC_INFORM_MESAG (18)]
 (!nl)
Request to AES to inform the application when there 
is a AES message waiting with a Unix Signal. (!nl)
(!I)ap_cout(!i) : not used. (!nl)
When the application receive a message the AES send the Signal SIGUSR2 (30)
to the application, to manage the message should use classical event_mesag
or event_multi functions. Calling one time this call request to AES to
send Signal, calling a second time remove this order.

!end_xlist

!item [ap_cout]
Wird abhÑngig von (!I)ap_cwhat(!i) gefÅllt oder gelesen und hat nur fÅr
APC_INFO, APC_MENU, APC_WIDGETS und APC_APP_CONFIG eine Bedeutung. In den
anderen FÑllen wird dieser Parameter ignoriert, die öbergabe eines
Nullzeigers ist dann mîglich.

!end_xlist

(!B)Hinweis:(!b)
Ausgeblendeten Anwendungen wird in der MenÅleiste ein '*' vorangestellt, es sei
denn, sie hatten im Moment der Ausblendung kein Fenster offen. In diesem Fall
wird nur die Anwendung gewechselt.

Der '*' vor dem Namen bedeutet genau: Einige oder alle geîffneten Fenster dieser
Anwendung sind ausgeblendet.

!item [Ergebnis:]
~0 = ein Fehler ist aufgetreten (!nl)
>0 = kein Fehler aufgetreten

!item [VerfÅgbar:]
Das Vorhandensein der Funktion ist Åber (!link [appl_getinfo][%apgi_65]) (Opcode 65)
nachprÅfbar.

!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])

!item [Querverweis:]
(!link [Binding] [Bindings fÅr appl_control]) ~ SM_M_SPECIAL
(!ende_liste)



!begin_node Bindings fÅr appl_control
#!html_name Bindings_for_appl_control
!ignore_index
(!begin_liste) [GEM-Arrays]
!item [C:]
int16_t appl_control ( int16_t ap_cid, int16_t ap_cwhat, void *ap_cout);

!item [Umsetzung:]
!begin_verbatim
int16_t appl_control ( int16_t ap_cid, int16_t ap_cwhat,
                       void *ap_cout);
{
   int_in[0]  = ap_cid;
   int_in[1]  = ap_cwhat;
   addr_in[0] = ap_cout;

   return ( crys_if(129) );
}
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control   !! control[0] !! 129   # Opcode der Funktion
control+2 !! control[1] !! 2     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 1     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0] !! ap_cid
int_in+2 !! int_in[1] !! ap_cwhat
addr_in  !! addr_in[0] !! ap_cout
int_out !! int_out[0] !! ap_creturn
!end_table
(!ende_liste)
!end_node
!end_node

!endif
