## Hypertext zum TOS-Betriebssystem
## entwickelt fr den ST-Guide
##
## Last Edit: 29.08.1998
##
## Kapitel 4: AES-Funktionsaufrufe


!begin_node Das AES

Das AES (Application Environment (!nolink [Services])) ist der Teil des GEM, der die
direkte (grafische) Schnittstelle zum Benutzer realisiert. Mit Hilfe des
(!nolink [AES]) lassen sich verschiedene Konzepte wie Bildschirmfenster, Menzeilen,
Drop-Down oder Pop-Up Mens, Dialogboxen usw. komfortabel handhaben.
Dazu dienen die folgenden Bibliotheken:

!begin_xlist [ù Applikationsverwaltung ] !short
!item [ù (!link [Applikationsverwaltung][Applikationsfunktionen])] (appl_...)
!item [ù Dateiauswahl]           (fsel_...)
!item [ù Druckdialoge]           (pdlg_...)
!item [ù Editobjekt-Funktionen]  (edit_...)
!item [ù Ereignisverwaltung]     (evnt_...)
!item [ù Fensterdialoge]         (wdlg_...)
!item [ù Fensterverwaltung]      (wind_...)
!item [ù Fileselektoren]         (fslx_...)
!item [ù (!link [Formulare][Formularfunktionen])]              (form_...)
!item [ù Grafikfunktionen]       (graf_...)
!item [ù Listboxen]              (lbox_...)
!item [ù (!link [Mens][Menfunktionen])]                  (menu_...)
!item [ù (!link [Objekte][Objektfunktionen])]                (objc_...)
!item [ù (!link [Resourceorganisation][Resourcefunktionen])]   (rsrc_...)
!item [ù (!link [Shell-Kommunikation][Shellfunktionen])]    (shel_...)
!item [ù (!link [X-Grafikfunktionen][Erweiterte Grafikfunktionen])]     (xgrf_...)
!item [ù Zeichensatzauswahl]     (fnts_...)
!item [ù (!link [Zwischenspeicher][Klemmbrett-Funktionen])]       (scrp_...)
!end_xlist

!label AES, Entstehung des
!label Entstehung des AES
Die Entwicklung des (!nolink [AES]) reicht bis in das Jahr 1984 zurck, als es von
(!I)Digital Research(!i) zun„chst fr MS-DOS-Rechner entwickelt, und sp„ter
auf die Apple Lisa (unter CP/M 68K) portiert wurde. Diese Version wurde dann
anschlieend auf den Atari-ST (unter GEMDOS) portiert.

In der Version 4.0 wurde das (!nolink [AES]) stark berarbeitet, und stellt nun viele
neue und erweiterte Routinen zur Verfgung. šber die Funktion appl_getinfo
kann leicht festgestellt werden, ob (bzw. welche) neue(n) M”glichkeiten zur
Verfgung stehen.

Querverweis: Grundlagen des AES ~ Bindings des AES ~ VDI
!end_node


!begin_node Applikationsfunktionen

In dieser Bibliothek sind Funktionen enthalten, um eine GEM-Applikation zu
initialisieren und zu terminieren; darber hinaus erlauben diese Routinen
die Kommunikation mit anderen Prozessen. Insgesamt stehen die folgenden
Funktionen zur Verfgung:

!begin_xlist [ù appl_trecord] !short
!item [ù appl_bvset]
Angeschlossene Laufwerke setzen.
!item [ù appl_control]
Gezieltes Steuern von Anwendungen.
!item [ù appl_exit]
(!nolink [AES])-Anwenderprogramm abmelden und Kennung freigeben.
!item [ù appl_find]
(!nolink [AES])-Kennung einer anderen AES-Applikation ermitteln.
!item [ù appl_getinfo]
System-Informationen ermitteln.
!item [ù appl_init]
(!nolink [AES])-Anwendung anmelden.
!item [ù appl_read]
(!nolink [AES])-Mitteilungen lesen.
!item [ù appl_search]
Applikationen im System suchen.
!item [ù appl_tplay]
Ereignisse abspielen.
!item [ù appl_trecord]
Ereignisse aufzeichnen.
!item [ù appl_write]
(!nolink [AES])-Mitteilungen schreiben.
!item [ù appl_yield]
(!nolink [AES])-Proze-Switch erzwingen.
!end_xlist

(!B)Hinweis:(!b) Besondere Beachtung verdient dabei appl_getinfo, mit dessen
Hilfe sich leicht Eigenschaften des Betriebssystems zur Laufzeit erfragen
lassen.

Querverweis: Style-Guidelines

!include gem\aes\appl_.u
!end_node


!begin_node Dateiauswahl

Die Funktionen dieser Bibliothek stellen eine Dateiauswahl zur Verfgung,
mit deren Hilfe sich Dateien laden bzw. abspeichern lassen. Fr diesen Zweck
sind die folgenden Routinen vorhanden:

!begin_xlist [ù fsel_exinput] !short
!item [ù fsel_boxinput]
Dateinamen per File-Selektor ausw„hlen.
!item [ù fsel_exinput]
Dateinamen per File-Selektor ausw„hlen.
!item [ù fsel_input]
Dateinamen per File-Selektor ausw„hlen.
!end_xlist

(!B)Hinweis:(!b) Leider werden alternative Dateisysteme (Stichwort: lange
Dateinamen) nicht untersttzt; ab MagiC-4 wird dies jedoch von den
Funktionen der FSLX-Library bernommen.

Querverweis: Style-Guidelines

!include gem\aes\fsel_.u
!end_node


!begin_node Druckdialoge

Die folgenden Routinen wurden mit MagiC eingefhrt, und erlauben die
Erstellung und Handhabung von Druckdialogen:

!begin_xlist [ù pdlg_remove_sub_dialogs] !short
!item [ù pdlg_add_printers]
Druckerbeschreibungen hinzufgen.
!item [ù pdlg_add_sub_dialogs]
Erstellt Unterdialoge zum Druckdialog.
!item [ù pdlg_close]
Schliet das Fenster des Druckdialogs.
!item [ù pdlg_create]
Initialisiert den Druckdialog.
!item [ù pdlg_delete]
Gibt den Speicher des Dialogs frei.
!item [ù pdlg_dflt_settings]
šbernimmt die Default-Initialisierung.
!item [ù pdlg_do]
™ffnet einen modalen Druckdialog.
!item [ù pdlg_evnt]
šbernimmt die Event-Verwaltung.
!item [ù pdlg_free_settings]
Speicher fr Druckeinstellung freigeben.
!item [ù pdlg_get_setsize]
Ermittelt die L„nge der (!nolink [PRN_SETTINGS]) Struktur.
!item [ù pdlg_new_settings]
Fordert Speicher fr Druckeinstellungen.
!item [ù pdlg_open]
™ffnet ein Fenster mit dem Dialog.
!item [ù pdlg_remove_printers]
Druckerbeschreibungen entfernen.
!item [ù pdlg_remove_sub_dialogs]
Entfernt Unterdialoge des Druckdialogs.
!item [ù pdlg_save_default_settings]
-
!item [ù pdlg_update]
Setzt einen neuen Fensternamen.
!item [ù pdlg_use_settings]
Anwendung der Druckereinstellungen.
!item [ù pdlg_validate_settings]
šberprft die Druckereinstellungen.
!end_xlist

(!B)Hinweis:(!b) Die Existenz dieser Funktionen kann per (!link [appl_getinfo][%apgi_7])
(Opcode 7) festgestellt werden.

Querverweis: (!nl)
(!link [Darstellung im Fenster][Druckauswahl im Fenster]) ~
(!link [Darstellung als mod. Dialog][Druckauswahl als Dialog]) ~
AES ~ GEM ~ WDIALOG   ~   Style-Guidelines

!include gem\aes\pdlg_.u
!end_node


!begin_node Editobjekt-Funktionen

Diese Bibliothek stellt Funktionen zur Verfgung, um Editieroperationen
an einem Objekt vorzunehmen.

!begin_xlist [ù edit_get_scrollinfo] !short
!item [ù edit_close]
Schliet ein Editobjekt.
!item [ù edit_create]
Erstellt ein neues Editobjekt.
!item [ù edit_cursor]
Schaltet den Objekt-Cursor an bzw. aus.
!item [ù edit_delete]
Entfernt ein Editobjekt aus dem Speicher.
!item [ù edit_evnt]
(!nolink [Ereignisverwaltung]) fr das Objekt.
!item [ù edit_get_buf]
Textpuffer des Objektes abfragen.
!item [ù edit_get_colour]
Farben ermitteln.
!item [ù edit_get_cursor]
Cursorposition ermitteln.
!item [ù edit_get_dirty]
Objekt auf Ver„nderungen berprfen.
!item [ù edit_get_font]
Zeichensatz ermitteln.
!item [ù edit_get_format]
Formatierungen ermitteln.
!item [ù edit_get_pos]
~
!item [ù edit_get_scrollinfo]
Informationen fr Scrollbalken ermitteln.
!item [ù edit_get_sel]
Selektierten Bereich ermitteln.
!item [ù edit_open]
™ffnet ein Editobjekt.
!item [ù edit_resized]
Objektgr”e ver„ndern.
!item [ù edit_scroll]
Scrollt das Objekt in eine Richtung.
!item [ù edit_set_buf]
Weist dem Objekt einen Textpuffer zu.
!item [ù edit_set_colour]
Farben setzen.
!item [ù edit_set_cursor]
Cursorposition setzen.
!item [ù edit_set_dirty]
Objekt als ver„ndert markieren.
!item [ù edit_set_font]
Zeichensatz setzen.
!item [ù edit_set_format]
Formatierungen setzen.
!item [ù edit_set_pos]
~
!end_xlist

(!B)Hinweis:(!b) Das Edit-Objekt steht ab MagiC 5.20 zur Verfgung, und ist
als SharedLibrary implementiert. Aus diesem Grund muss die entsprechende
Bibliothek mit Slbopen("EDITOBJC.SLB", NULL, 0L, &slb, &slbexec) ge”ffnet
werden. Anschliessend stehen dann die o.g. Funktionen, sowie der neue
AES-Objekttyp G_EDIT zur Verfgung.

Querverweis: Verwendung G_EDIT-Objekt ~ AES ~ GEM ~ Objektfunktionen

!include gem\aes\edit_.u
!end_node


!begin_node Ereignisverwaltung

Diese Bibliothek stellt Funktionen zur Verfgung, mit deren Hilfe Ereignisse
erkannt und bearbeitet werden k”nnen. Fr diesen Zweck stehen die folgenden
Routinen zur Verfgung:

!begin_xlist [ù evnt_button] !short
!item [ù evnt_button]
Auf Maustastendruck warten.
!item [ù evnt_dclick]
Geschwindigkeit fr Doppelklicks ermitteln/„ndern.
!item [ù evnt_keybd]
Auf Tastendruck warten.
!item [ù evnt_mesag]
Auf Mitteilung warten.
!item [ù evnt_mouse]
Auf Bewegungen des Mauszeigers warten.
!item [ù evnt_multi]
Auf mehrere Ereignisse reagieren.
!item [ù evnt_timer]
Auf Zeit-Ereignis warten.
!end_xlist

(!B)Hinweis:(!b) Unter Ereignissen sind in diesem Fall Nachrichten,
Tastaturklicks, Mausbewegungen, Zeitereignisse usw. zu verstehen.

Querverweis: AES ~  GEM  ~ Style-Guidelines

!include gem\aes\evnt_.u
!end_node



!begin_node Fensterdialoge

Die folgenden Funktionen wurden mit MagiC-4 eingefhrt und erlauben die
einfache Konstruktion von (!nolink [Dialogboxen]) in Fenstern:

!begin_xlist [ù wdlg_set_uniconify] !short
!item [ù wdlg_close]
Fensterdialog schlieen.
!item [ù wdlg_create]
Fensterdialog erstellen.
!item [ù wdlg_delete]
Fensterdialog schlieen.
!item [ù wdlg_evnt]
Auswerten der Dialog-Events.
!item [ù wdlg_get_edit]
Aktuelles Edit-Feld ermitteln.
!item [ù wdlg_get_handle]
Fenster-Kennung eines Dialogs ermitteln.
!item [ù wdlg_get_tree]
Objektbaum des Fensters ermitteln.
!item [ù wdlg_get_udata]
Userdaten ermitteln.
!item [ù wdlg_open]
Fensterdialog ”ffnen.
!item [ù wdlg_redraw]
Zeichnet ein Objekt in einem Fensterdialog.
!item [ù wdlg_set_edit]
Edit-Feld im Dialog aktivieren.
!item [ù wdlg_set_iconify]
Fensterdialog ikonifizieren.
!item [ù wdlg_set_size]
Gr”e eines Dialogs ver„ndern.
!item [ù wdlg_set_tree]
Neuen Objektbaum im Dialog verankern. 
!item [ù wdlg_set_uniconify]
Fensterdialog unikonifizieren.
!end_xlist

(!B)Hinweis:(!b) Die Existenz dieser Funktionen kann per (!link [appl_getinfo][%apgi_7])
(Opcode 7) festgestellt werden.

Querverweis: Fensterverwaltung ~ Style-Guidelines ~ WDIALOG

!include gem\aes\wdlg_.u
!end_node



!begin_node Fensterverwaltung

Diese Bibliothek stellt Funktionen zur Verfgung um Fenster zu erzeugen,
zu ”ffnen, zu schlieen und vieles mehr. Insgesamt stehen die folgenden
Routinen zur Verfgung:

!begin_xlist [ù wind_update] !short
!item [ù wind_calc]
Fensterdimensionen berechnen.
!item [ù wind_close]
Fenster schlieen.
!item [ù wind_create]
Fenster erzeugen.
!item [ù wind_delete]
Fenster l”schen.
!item [ù wind_draw] Fensterelemente neu Zeichnen.
!item [ù wind_find]
Fensterhandle anhand einer Positionsangabe ermitteln.
!item [ù wind_get]
Eigenschaften eines Fensters ermitteln.
!item [ù wind_new]
Alle Fenster l”schen.
!item [ù wind_open]
Fenster ”ffnen.
!item [ù wind_set]
Eigenschaften eines Fensters ver„ndern.
!item [ù wind_update]
Bildschirmoperationen sperren oder freigeben.
!end_xlist

(!B)Hinweis:(!b) Unter MagiC sollte eine einzelne Applikation nicht mehr als
16 Fenster benutzen, da sonst der Nachrichtenpuffer des Systems berlaufen
kann, und evtl. Redraws nicht mehr ausgefhrt werden k”nnen.

Querverweis: Komponenten eines Fensters ~  Style-Guidelines ~
             Fensterdialoge

!include gem\aes\wind_.u
!end_node



!begin_node Fileselektoren

Die folgenden Funktionen wurden mit MagiC-4 eingefhrt, und erm”glichen
die Verwaltung der Dateiauswahl (Fileselektor):

!begin_xlist [ù fslx_getnxtfile] !short
!item [ù fslx_close]
Auswahl schlieen und Speicher freigeben.
!item [ù fslx_do]
Schneller Aufruf des Fileselektors.
!item [ù fslx_evnt]
Auswahl zur Benutzung freigeben.
!item [ù fslx_getnxtfile]
Alle weiteren selekt. Eintr„ge ermitteln.
!item [ù fslx_open]
Auswahl initialisieren und ”ffnen.
!item [ù fslx_set_flags]
Setzt bestimmte Flags fr das ganze System.
!end_xlist

(!B)Hinweis:(!b) Die Existenz dieser Funktionen kann per (!link [appl_getinfo][%apgi_7])
(Opcode 7) festgestellt werden. Der Hauptvorteil bei der Verwendung dieser
Routinen ist darin zu sehen, da die hier angegebenen Funktionen auch mit
alternativen Dateisystemen (Stichwort: lange Dateinamen) zurechtkommen.

Querverweis: Fileselektor als Dialog  ~ Fileselektor im Fenster ~
             (!link [Bedienung der Dateiauswahl][Die Bedienung des File-Selektors ab MagiC-4])

!include gem\aes\fslx_.u
!end_node


!begin_node Formularfunktionen

Diese Bibliothek enth„lt ntzliche Funktionen zur Verarbeitung von Dialog-
bzw. Alarmboxen aller Art. Fr diesen Zweck stehen die folgenden Routinen
zur Verfgung:

!begin_xlist [form_wbutton] !short
!item [ù form_alert]
Alertbox darstellen.
!item [ù form_button]
Simulieren eines Mausklicks.
!item [ù form_center]
Zentrieren eines Objektes.
!item [ù form_dial]
Bildschirmspeicher reservieren und freigeben.
!item [ù form_do]
Behandlung eines Dialogs.
!item [ù form_error]
Betriebssystemfehlermeldung ausgeben.
!item [ù form_keybd]
Auswerten einer Tastatureingabe.
!item [ù form_popup]
Verwaltung eines (!nolink [Popup])-Mens.
!item [ù form_wbutton]
Simulieren eines Mausklicks (im Fenster).
!item [ù form_wkeybd]
Auswerten einer Tastatureingabe (im Fenster).
!item [ù form_xdial]
Bildschirmspeicher reservieren/freigeben (Flydials).
!item [ù form_xdo]
Erweiterte Dialogbehandlung.
!item [ù form_xerr]
Betriebssystemfehlermeldung ausgeben.
!end_xlist

(!B)Hinweis:(!b) Einige dieser Funktionen sind nur unter (!nolink [MagiC]) vorhanden,
und bieten viel zus„tzlichen Komfort (z.B. (!I)verschiebbare(!i)
(!nolink [Dialogboxen])).

Querverweis: Dialogboxen ~  Style-Guidelines ~ 
(!link [Scrollende Eingabefelder][scrollende Eingabefelder])

!include gem\aes\form_.u
!end_node



!begin_node Grafikfunktionen

Diese Bibliothek bernimmt die Verwaltung von Rechtecken; so kann etwa
ein Rechteck aufgezogen werden, da sich automatisch mit dem Mauszeiger
mitbewegt. Insgesamt stehen die folgenden Funktionen zur Verfgung:

!begin_xlist [graf_multirubber] !short
!item [ù graf_dragbox]
Verschieben eines Rechtecks.
!item [ù graf_growbox]
Animation eines sich vergr”ernden Rechtecks.
!item [ù graf_handle]
Kennung der (!nolink [AES])-Workstation ermitteln.
!item [ù graf_mbox]
Rechteckverschiebung darstellen.
!item [ù graf_mkstate]
Maus- und Tastaturstatus ermitteln.
!item [ù graf_mouse]
Form des Mauszeigers bestimmen.
!item [ù graf_multirubber]
Zwei Rechteckhlle (¯Gummiband®) darstellen.
!item [ù (!link [graf_rubbox][graf_rubberbox])]
Rechteckhlle (¯Gummiband®) darstellen.
!item [ù graf_shrinkbox]
Animation eines sich verkleinernden Rechtecks.
!item [ù graf_slidebox]
Sliderposition ermitteln.
!item [ù graf_watchbox]
Objektstatus an Position des Mauszeigers koppeln.
!item [ù graf_wwatchbox]
Objektstatus an Mausposition koppeln (im Fenster).
!end_xlist

(!B)Hinweis:(!b) Eine besondere Beachtung hat dabei graf_handle verdient,
mit dessen Hilfe die Kennung der (!I)physikalischen(!i)
Bildschirm-Workstation erfragt werden kann.

Querverweis: Style-Guidelines

!include gem\aes\graf_.u
!end_node



!begin_node Klemmbrett-Funktionen

Diese Bibliothek stellt Funktionen zur Verfgung, die einen standardisierten
Datenaustausch zwischen verschiedenen Programmen erm”glichen. Fr diesen
Zweck sind die folgenden Routinen vorhanden:

!begin_xlist [ù scrp_write] !short
!item [ù scrp_clear]
Dateien im Klemmbrett l”schen.
!item [ù scrp_read]
Pfad des Klemmbrettes ermitteln.
!item [ù scrp_write]
Pfad des Klemmbrettes setzen.
!end_xlist

(!B)Hinweis:(!b) Neben diesen Funktionen sind beim Datenaustausch ber das
Klemmbrett noch weitere Einzelheiten zu beachten.

Querverweis: Nachrichten ~  SC_CHANGED ~  SH_WDRAW ~  Style-Guidelines

!include gem\aes\scrp_.u
!end_node


!begin_node Listboxen

Die folgenden Routinen wurden mit MagiC-4 eingefhrt, und erlauben die
Erstellung und Handhabung von Listboxen:

!begin_xlist [ù lbox_get_slct_item] !short
!item [ù lbox_ascroll_to]
Slider-A der Listbox positionieren
!item [ù lbox_bscroll_to]
Slider-B der Listbox positionieren.
!item [ù lbox_cnt_items]
Anzahl der Listenelemente ermitteln.
!item [ù lbox_create]
Listbox initialisieren.
!item [ù lbox_delete]
Speicher fr Listbox freigeben.
!item [ù lbox_do]
Button einer Listbox abarbeiten.
!item [ù lbox_free_items]
Elementliste freigeben.
!item [ù lbox_free_list]
Elementliste freigeben.
!item [ù lbox_get_afirst]
Index der ersten sichtbaren Elements ermitteln.
!item [ù lbox_get_avis]
Anzahl sichtbarer Eintr„ge (Slider-A) ermitteln.
!item [ù lbox_get_bentries]
Anzahl der Elemente ermitteln (Slider B).
!item [ù lbox_get_bfirst]
Index des ersten sichtbaren Elements fr Slider B ermitteln.
!item [ù lbox_get_bvis]
Anzahl sichtbarer Eintr„ge ermitteln (Slider B).
!item [ù lbox_get_idx]
Index eines Elementes ermitteln.
!item [ù lbox_get_item]
Zeiger auf n-tes Element zurckliefern.
!item [ù lbox_get_items]
Zeiger auf das erste Element zurckliefern.
!item [ù lbox_get_slct_idx]
Index des ersten selekt. Elementes ermitteln.
!item [ù lbox_get_slct_item]
Zeiger auf das erste selekt. Element ermitteln.
!item [ù lbox_get_tree]
Objektbaum des Dialogs ermitteln.
!item [ù lbox_get_udata]
Zeiger auf programmeigene Daten holen.
!item [ù lbox_set_asldr]
Position des Sliders-A setzen.
!item [ù lbox_set_bentries]
Anzahl der Elemente fr Slider-B setzen.
!item [ù lbox_set_bsldr]
Position des Sliders-B setzen.
!item [ù lbox_set_items]
Neue Elementliste setzen.
!item [ù lbox_update]
Listbox aktualisieren.
!end_xlist

(!B)Hinweis:(!b) Die Existenz dieser Funktionen kann per (!link [appl_getinfo][%apgi_7])
(Opcode 7) festgestellt werden.

Querverweis: Listboxen im Dialog ~  Style-Guidelines ~  WDIALOG

!include gem\aes\lbox_.u
!end_node



!begin_node Menfunktionen

Diese Bibliothek stellt Funktionen zur Verfgung um Menzeilen zu zeichnen
und zu manipulieren; fr diesen Zweck sind die folgenden Routinen vorhanden:

!begin_xlist [menu_unregister] !short
!item [ù menu_attach]
Hinzufgen, ver„ndern, l”schen eines Submens.
!item [ù menu_bar]
Behandlung der Menleiste.
!item [ù menu_click]
Behandlung von Pull-Down-Mens.
!item [ù menu_icheck]
H„kchen bei Menoptionen setzen oder l”schen.
!item [ù menu_ienable]
Meneintrag sperren oder freigeben.
!item [ù menu_istart]
Ausrichten eines Submen-Eintrages.
!item [ù menu_popup]
Darstellung und Bearbeitung eines (!nolink [Popup])-Mens.
!item [ù menu_register]
Accessory im Desk-Men eintragen.
!item [ù menu_settings]
Menparameter setzen bzw. abfragen.
!item [ù menu_text]
Text eines Meneintrages ver„ndern.
!item [ù menu_tnormal]
Mentitel invertieren.
!item [ù menu_unregister]
Accessory-Namen aus dem Men entfernen.
!end_xlist

(!B)Hinweis:(!b) Ab AES-Version 4.0 (bzw. MagiC-3) wurde diese Bibliothek
stark berarbeitet, und bernimmt nun auch die Darstellung und Verwaltung
von (!nolink [Popup])- und Submens.

Querverweis: Mens und Menzeilen  ~ Style-Guidelines ~  XMEN_MGR

!include gem\aes\menu_.u
!end_node



!begin_node Objektfunktionen

Diese Bibliothek stellt Funktionen zur Verfgung, um Objekte (gleich welcher
Art) zu zeichnen und zu manipulieren; hierzu gibt es die folgenden Routinen:

!begin_xlist [  objc_wchange] !short
!item [ù objc_add]
Objekt im Objektbaum einfgen.
!item [ù objc_change]
Status eine Objekts „ndern.
!item [ù objc_delete]
Objekt aus dem Objektbaum entfernen.
!item [ù objc_draw]
Objekt (mit Unterobjekten) zeichnen.
!item [ù objc_edit]
Text eines Objektes editieren.
!item [ù objc_find]
Objekt an der Mausposition ermitteln.
!item [ù objc_offset]
Bildschirmkoordinaten eines Objekts ermitteln.
!item [ù objc_order]
Reihenfolge im Objektbaum umstellen.
!item [ù objc_sysvar]
Modifikation der 3D-Objekte.
!item [ù objc_wchange]
Status eines Objektes „ndern (im Fenster).
!item [ù objc_wdraw]
Objekt (mit Unterobjekten) zeichnen (im Fenster).
!item [ù objc_wedit]
Text eines Objektes editieren (im Fenster).
!item [ù objc_xfind]
Objektindex ber Position ermitteln.
!item [ù objc_xoffset]
z.Zt. keine Informationen bekannt.
!end_xlist

(!B)Hinweis:(!b) Eine besondere Beachtung hat dabei objc_sysvar verdient,
mit dessen Hilfe der 3D-Look der Objekte gesteuert (und ab MagiC-3 auch
abgeschaltet) werden kann.

Querverweis:
AES ~ (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~
(!link [Scrollende Eingabefelder][scrollende Eingabefelder]) ~
             Style-Guidelines

!include gem\aes\objc_.u
!end_node


!begin_node Resourcefunktionen

Diese Bibliothek enth„lt Funktionen, um die Resourcen eines GEM-Programms
(Menzeilen, Dialogboxen, Icons etc.) in den Speicher zu laden, und die
(!nolink [Adressen]) der relevanten Objekte zu bestimmen. Fr diesen Zweck stehen die
folgenden Routinen zur Verfgung:

!begin_xlist [ù rsrc_gaddr] !short
!item [ù rsrc_free]
Resourcespeicher freigeben.
!item [ù rsrc_gaddr]
Adresse einer Datenstruktur ermitteln.
!item [ù rsrc_load]
Resourcedatei laden.
!item [ù rsrc_obfix]
Zeichen- in Pixelkoordinaten wandeln.
!item [ù rsrc_rcfix]
Zeichen- in Pixelkoordinaten wandeln.
!item [ù rsrc_saddr]
Adresse einer Datenstruktur speichern.
!end_xlist

(!B)Hinweis:(!b) Die Auslagerung in eine Resource-Datei hat den
unsch„tzbaren Vorteil, das optische Erscheinungsbild (und insbesondere die
Sprache) leicht „ndern zu k”nnen, (!I)ohne(!i) am Programm selbst
Modifizierungen vornehmen zu mssen.

Querverweis: AES ~ Style-Guidelines

!include gem\aes\rsrc_.u
!end_node



!begin_node Shellfunktionen

Diese Bibliothek enth„lt Funktionen um Informationen aus der
Programmumgebung zu lesen bzw. in diese zu schreiben; auerdem kann hierber
der Start anderer GEM-Programme bernommen werden. Insgesamt stehen die
folgenden Routinen zur Verfgung:

!begin_xlist [ù shel_envrn] !short
!item [ù shel_envrn]
Environment-Variable abfragen.
!item [ù shel_find]
Datei suchen.
!item [ù shel_get]
Aus dem Environment-Puffer lesen.
!item [ù shel_put]
In den Environment-Puffer schreiben.
!item [ù shel_rdef]
Abfragen des Default-Programms.
!item [ù shel_read]
Kommandozeilenparameter lesen.
!item [ù shel_wdef]
Setzen des Default-Programms.
!item [ù shel_write]
Applikation starten.
!end_xlist

(!B)Hinweis:(!b) Eine besondere Beachtung hat dabei shel_write verdient,
welches ab AES-Version 4.0 (bzw. MagiC-3) viele weitere ntzliche Dinge wie
ein Herunterfahren des Systems (Shut-Down), Aufl”sungswechsel,
AES-Broadcasting usw. zur Verfgung stellt.

Querverweis: AES ~ Style-Guidelines

!include gem\aes\shel_.u
!end_node



!begin_node Erweiterte Grafikfunktionen

Diese Bibliothek enth„lt Funktionen um sich bewegende (ausdehnende bzw.
zusammenziehende) Rechtecke zu animieren; fr diesen Zweck gibt es die
folgenden Routinen:

!begin_xlist [ù xgrf_stepcalc] !short
!item [ù xgrf_2box]
Animation sich bewegender Rechtecke.
!item [ù xgrf_stepcalc]
Parameter-Berechnung fr Rechteck-Animation.
!end_xlist

(!B)Hinweis:(!b) Diese Funktionen sind in erster Linie als Ersatz fr die
Funktionen (!I)(!nolink [graf_growbox])(!i) und (!I)(!nolink [graf_shrinkbox])(!i) zu verstehen,
die in PC-GEM dem Rechtsstreit zwischen Apple und Digital Research zum Opfer
gefallen sind.

Querverweis: graf_growbox ~ graf_shrinkbox ~ Style-Guidelines

!include gem\aes\xgrf_.u
!end_node



!begin_node Zeichensatzauswahl

Diese Bibliothek enth„lt Routinen zur Handhabung eines Font-Selektors, mit
dem eine Applikation Zeichens„tze ausw„hlen kann. Die Routinen wurden mit
MagiC-4 eingefhrt.

!begin_xlist [ù fnts_get_no_styles] !short
!item [ù fnts_add]
Eigene Fonts zur Auswahl hinzufgen.
!item [ù fnts_close]
Auswahl schlieen.
!item [ù fnts_create]
Initialisiert die Zeichensatzauswahl.
!item [ù fnts_delete]
Speicher freigeben.
!item [ù fnts_do]
Modalen Dialog anzeigen.
!item [ù fnts_evnt]
Ereignisse fr Dialog im Fenster bearbeiten.
!item [ù fnts_get_info]
Informationen ber einen Font ermitteln.
!item [ù fnts_get_name]
Namen eines Fonts ermitteln.
!item [ù fnts_get_no_styles]
Zahl der Stile einer Fontfamilie ermitteln.
!item [ù fnts_get_style]
ID des n-ten Stil einer Familie ermitteln.
!item [ù fnts_open]
Auswahl im Fenster ”ffnen.
!item [ù fnts_remove]
Eigene Fonts aus der Liste entfernen.
!item [ù fnts_update]
Zeichensatzauswahl aktualisieren.
!end_xlist

(!B)Hinweis:(!b) Die Existenz dieser Funktionen sollte am besten durch einen
Aufruf von (!link [appl_getinfo][%apgi_7]) (Opcode 7) festgestellt werden.

Querverweis: (!nl)
(!link [Auswahl im Fenster][Zeichensatzauswahl im Fenster]) ~
(!link [Auswahl als Dialog][Zeichensatzauswahl als Dialog]) ~ WDIALOG ~
xFSL-Schnittstelle

!include gem\aes\fnts_.u
!end_node

!include gem\aes\struktur.ui

!include gem\aes\aes_f.u


!begin_node Grundlagen des AES
!label AES, Grundlagen des

(!nolink [Das AES]) (Application Environment (!nolink [Services])) bildet die obere Schicht des
GEM. Es befasst sich mit all jenen GEM-Bestandteilen, die ber elementare
Grafikausgaben und -eingaben hinausgehen. Da das AES ausschlielich VDI-
und GEMDOS-Aufrufe t„tigt, ist es sowohl von der Grafikhardware, vom
Eingabeger„t als auch vom Dateisystem unabh„ngig. In diesem Abschnitt
werden die folgenden Punkte behandelt:

!begin_itemize !short
!item Accessories in MagiC
!item (!link [Bindings des AES][AES-Bindings])
!item Das Desktop-Fenster
!item (!link [Datenaustausch per Klemmbrett][Der Datenaustausch ber das GEM-Klemmbrett])
!item Nachrichten
!item (!link [Objektstruktur im AES][Die Objekt-Struktur])
!item (!link [Quarter-Screen-Buffer][Der Quarter-Screen-Buffer])
!item (!link [Rechteckliste eines Fensters][Die Rechteckliste eines Fensters])
!item (!link [Screen-Manager][Der Screen-Manager])
!item Startupcode fr Accessories
!item Toolbar-Support
!end_itemize
!label AES-Clones
!label Clones, AES-
!label NAES
!label MinA
!label AES im Quelltext?
!label Quelltext, AES im

Auch beim (!nolink [AES]) gibt es eine interessante Entwicklung, denn verschiedene
Programmierer haben mittlerweile eigene (!B)AES-Clones(!b) angekndigt; zur
Zeit sind hier die Projekte (!I)N.AES(!i) und (!I)XAAES(!i) zu nennen. Neben
einer stetigen Weiterentwicklung darf man wohl auch auf eine
Quelltext-Version dieser GEM Komponente hoffen.

Querverweis: Style-Guidelines


!begin_node Accessories in MagiC
!label MagiC, Accessories in

Unter MagiC sind Accessories den Programmen fast gleichgestellt. Ihre
Fenster bleiben beim Programmwechsel erhalten. Sie drfen Men und
Desktophintergrund besitzen, Programme nachladen, Speicher anfordern,
Dateien ”ffnen, schlieen, l”schen, kopieren usw.

Da kein Grund mehr besteht, beim Programmwechsel Fenster zu schlieen,
gibt es keine AC_CLOSE Meldung mehr. Accessories werden vom System nicht
von Programmen unterschieden, abgesehen davon, da sie sich keinesfalls
beenden drfen. ACCs drfen sich wie unter (!nolink [GEM])/2 auch wieder im Men
abmelden, und zwar mit dem (!nolink [AES])-Aufruf menu_unregister(). Anstelle von
ACCs sind unter (!nolink [MagiC]) Applikationen sinnvoll, die einfach nur eine
Menleiste mit einem Men anmelden und im APP- Autostart- Ordner liegen.
Diese Applikationen kann man dann bei Bedarf nachladen und auch wieder
entfernen.

(!B)Hinweis:(!b) Ab (!nolink [MagiC])-4 k”nnen Accessories zur Laufzeit nachgestartet
werden. Ferner ist es m”glich, bei einem Klick auf einen Accessory-Eintrag
(und gedrckter Control-Taste) das entsprechende Accessory zu entfernen. Ein
Nachteil ist, da Accessories z.Zt. noch kein Pexec mit Modus 104 ausfhren
drfen.

Querverweis: AES ~  GEM ~  Startupcode fr Accessories ~  shel_write
!end_node



!begin_node Das Desktop-Fenster
!label Fenster, Desktop-

Unter den verfgbaren Fenstern nimmt das Desktop- oder Hintergrundfenster
eine besondere Rolle ein. Es besitzt die Kennung 0, nimmt die gesamte
Bildschirmfl„che in Anspruch, ist immer ge”ffnet und kann auch nicht
geschlossen werden. Der (!I)Arbeitsbereich(!i) ist die Fl„che unter der
Menleiste. Nur in diesem Arbeitsbereich drfen andere Programme
Bildschirmausgaben machen oder eigene Fenster ”ffnen.

Normalerweise erscheint der Arbeitsbereich des Desktop als solide grne
Fl„che (im Farbbetrieb) bzw. als graues Raster (im Monochrombetrieb). Der
Screen-Manager kmmert sich v”llig selbstt„tig um den Redraw; ber einen
Aufruf von (!I)wind_set(!i) k”nnen Anwendungsprogramme einen beliebigen
anderen Objektbaum als Hintergrund verankern. Auch dann kmmert sich der
Screen-Manager um das f„llige Neuzeichnen von Bildausschnitten. Obwohl diese
M”glichkeit sehr verlockend ist, gibt es etliche Grnde, die (!I)gegen(!i)
eine Benutzung des Desktop-Fensters sprechen; der wichtigste:

!begin_itemize
!item auch unter einem multitaskingf„higen GEM (MagiC oder MultiTOS), kann
es (!I)nur einen(!i) Bildschirmhintergrund geben. Dieser sollte dem Programm
vorbehalten bleiben, das daraus den meisten Nutzen ziehen kann - in der
Regel ist dies das Desktop bzw. ein Desktop-Ersatz wie z.B. die Shell
Gemini.
!end_itemize

Fazit: Der Desktop-Hintergrund sollte nach M”glichkeit in eigenen Programmen
(!I)nicht(!i) benutzt werden.

Querverweis: AES  ~ wind_set ~  WF_NEWDESK
!end_node



!begin_node Der Datenaustausch ber das GEM-Klemmbrett
!label Datenaustausch per Clipboard
!label Klemmbrett, Datenaustausch per
!label Clipboard, Datenaustausch per

Um Dateien im Klemmbrett abzulegen, sollte man folgendermaen vorgehen:

!begin_itemize
!item alle Klemmbrett-Dateien, die auf die Maske 'scrap.*' und 'SCRAP.*'
passen, l”schen. Anmerkung: Die Maske 'SCRAP.*' muss bercksichtigt werden,
da alte Programme noch nichts von alternativen und case-sensitiven
Dateisystemen wussten.
!item die abzulegenden Daten in einem oder mehreren Formaten sichern.
!item die Nachricht SC_CHANGED an (!I)alle(!i) Applikationen im System,
SH_WDRAW an die System-Shell schicken.
!end_itemize

Der Dateiname ist (!I)immer(!i) 'scrap.', die Namenserweiterung (Suffix)
h„ngt dabei vom gew„hlten Format ab; nach M”glichkeit sollte (!I)immer(!i)
eines der folgenden Standardformate untersttzt werden:

!begin_xlist [Suffix] !short
!item [Suffix]
Bedeutung
!item [~]
~
!item [gem]
Vektorgrafiken im Metafile-Format
!item [img]
Pixelbilder im XIMG-Format
!item [txt]
ASCII-Textdatei, jede Zeile mit CR/LF abgeschlossen
!end_xlist

Zus„tzlich kann man eines oder mehrere der folgenden Formate untersttzen
(der Empf„nger hat dann die M”glichkeit, das Format mit den meisten
Informationen zu benutzen):

!begin_xlist [Suffix] !short
!item [Suffix]
Bedeutung
!item [~]
~
!item [asc]
ASCII-Textdatei, jeder Absatz mit CR/LF abgeschlossen
!item [csv]
ASCII-Datei mit durch Kommata getrennten Zahlen
!item [cvg]
Calamus Vektorgrafik-Format
!item [dif]
Export-Datei von Tabellenkalkulationen
!item [eps]
Encapsulated PostScript
!item [iwp]
Wordplus-Format
!item [rtf]
Microsoft Rich Text Format
!item [tex]
TeX
!end_xlist

Das empfangende Programm sollte zun„chst berprfen, welche der vorhandenen
Dateien die meisten Informationen enth„lt, und dann diese Datei nehmen.

(!B)Wichtig:(!b) Jede der Dateien im Klemmbrett enth„lt prinzipiell die
gleichen Informationen, nur eben in einem anderen Format. Die
Textverarbeitung (!I)Papyrus(!i) z.B. importiert 'scrap.rtf' nur dann, wenn
das eigene Format 'scrap.pap' nicht gefunden werden konnte.

Aus den obigen Erkl„rungen wird ersichtlich, da sich immer nur (!I)ein(!i)
Datenobjekt (allerdings in verschiedenen Formaten) auf einmal im Klemmbrett
befinden kann.

Querverweis: Klemmbrett-Funktionen ~  scrp_clear  ~ Style-Guidelines
!end_node



!begin_node Nachrichten
!label AES-Messages

(!B)Die Standardmessages des Screenmanagers sind wie folgt aufgebaut:(!b)

!begin_xlist [ev_mgpbuff___]
!item [ev_mgpbuff[0!]]
Art der Message
!item [ev_mgpbuff[1!]]
ID der Applikation, die die Nachricht abgeschickt hat
!item [ev_mgpbuff[2!]]
Anzahl der Bytes die ber die Standardl„nge von 16 Bytes hinausgehen, und
dann mit appl_read gelesen werden mssen
!end_xlist

(!B)Arten der Standardmessages:(!b)

!begin_xlist [RESCH_COMPLETED (61)]
!item [Nachricht]
Bedeutung
!item [~]
~

!label AC_CLOSE
!item [AC_CLOSE (41)]
wird an ein Accessory geschickt, wenn die aktuelle Applikation beendet, der
Bildschirm gel”scht und der Windowmanager neu initialisiert wird.
!begin_xlist !short
!item [ev_mgpbuff[4!]]
Identifikator des Accessories 
!end_xlist
(!B)Hinweis:(!b) Diese Nachricht spielt in Multitaskingsystemen praktisch
keine Rolle mehr, und ist in MagiC auch nicht mehr vorhanden!

!label AC_OPEN
!item [AC_OPEN (40)]
ein Accessory wurde aktiviert
!begin_xlist !short
!item [ev_mgpbuff[4!]]
Identifikator des Accessories
!end_xlist

!label AP_DRAGDROP
!item [AP_DRAGDROP (63)]
ist ein Teil des Drag&Drop-Protokolls und wird vom Sender an den Empf„nger
geschickt.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Kennung des Zielfensters
!item [ev_mgpbuff[4!]]
X-Position des Mauszeigers
!item [ev_mgpbuff[5!]]
Y-Position des Mauszeigers
!item [ev_mgpbuff[6!]]
Keyboard-Shift-Status
!item [ev_mgpbuff[7!]]
zwei Zeichen der Pipe-Extension
!end_xlist
(!B)Hinweis:(!b) Wird anstelle einer gltigen Fensterkennung der Wert -1
bergeben, so ist das Ziel der Drag&Drop Operation kein spezielles Fenster,
sondern die Applikation selbst. Es sollte dann normalerweise ein
zus„tzliches Fenster fr die angegebenen Daten ge”ffnet werden.

!label AP_RESCHG
!item [AP_RESCHG (57)]
durch diese Nachricht wird die betreffende Applikation darber informiert,
da ein (!nolink [Aufl”sungswechsel]) stattfinden soll. Der Empf„nger dieser Nachricht
sollte sich dann sobald wie m”glich beenden.

!label AP_TERM
!item [AP_TERM (50)]
das Betriebssystem fordert die Applikation auf, sich zu beenden. Dies kann
z.B. beim Aufl”sungswechsel notwendig sein, oder von einem allgemeinen
Shut-Down Utility ausgel”st werden.
!begin_xlist !short
!item [ev_mgpbuff[5!]]
Grund des Shut-Downs, also z.B.
!begin_xlist [AP_RESCHG]!short
!item [AP_TERM]
(generell beenden)
!item [AP_RESCHG]
((!nolink [Aufl”sungswechsel]))
!end_xlist
!end_xlist
(!B)Achtung:(!b) Entgegen der blichen Konvention (!I)muss(!i) in
ev_mgpbuff[1] der Wert -1 eingetragen werden, da lt. MagiC-Dokumentation
sonst nicht garantiert ist, da der Desktop von einer Shut-Down-Sequenz
(Alternate-Control-Delete) ausgeht.

!label AP_TFAIL
!item [AP_TFAIL (51)]
wird vom Empf„nger einer AC_CLOSE bzw. AP_TERM Nachricht verschickt, falls
dieser sich (!I)nicht(!i) beenden m”chte oder kann.

!label CH_EXIT
!item [CH_EXIT (90)]
wird an den Parent-Prozess geschickt, wenn ein Child terminiert.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Applikations-ID des Childs
!item [ev_mgpbuff[4!]] 
Exit-Code des Childs
!end_xlist

!label CT_KEY
!item [CT_KEY (53)]
wird vom modularen Kontrollfeld XCONTROL verschickt, um Tastendrcke
auswerten zu k”nnen, die keine Auswirkungen auf Editfelder haben k”nnen,
also z.B. HELP oder UNDO.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Highbyte: Scancode der gedrckten Taste.
(!nl)
Lowbyte : ASCII-Code der Taste.
!end_xlist

!label FNT_CHANGED
!item [FNT_CHANGED (83)]
wird verschickt, wenn zur Laufzeit GDOS-Fonts an- bzw. abgemeldet wurden.
(!nl)
Auf den Empfang dieser Nachricht sollte mit vst_unload_fonts und direkt
anschlieendem vst_load_fonts reagiert werden. Dadurch ist sichergestellt,
da die Applikation mit den aktuellen Zeichens„tzen arbeiten kann.

!label MN_SELECTED
!item [MN_SELECTED (10)]
ein Meneintrag wurde ausgew„hlt
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Objektnummer des Titeleintrags
!item [ev_mgpbuff[4!]]
Objektnummer des Eintrags
!item [ev_mgpbuff[5!]]
Zeiger auf die OBJECT-Struktur des Menbaums, wie er auch an
!item [ev_mgpbuff[6!]]
menu_bar bergeben wurde.
!item [ev_mgpbuff[7!]]
Parent des angew„hlten Eintrags, d.h. die Objektnummer der
'heruntergefallenen' Box, die den Eintrag enth„lt.
!end_xlist
(!B)Hinweis:(!b) Das Vorhandensein der erweiterten Nachricht (ev_mgpbuff[5]
und folgende) sollte am besten per (!link [appl_getinfo][%apgi_9]) (Opcode 9) ermittelt werden.

!label PRN_CHANGED
!item [PRN_CHANGED (82)]
Diese Nachricht wird vom GDOS-Konfigurationsprogramm an alle erreichbaren
Applikationen verschickt, um diese ber nderungen an Ger„tetreibern zu
informieren. Es gilt:
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Ger„tenummer
!item [ev_mgpbuff[4!]]
Aktion
!begin_table [c c l]
0 !! = !! neu
1 !! = !! ge„ndert
2 !! = !! entfernt
!end_table
!end_xlist
Eine Applikation kann nach dem Empfang dieser Nachricht z.B. die
entsprechende Workstation neu ”ffnen, die jetzt aktuellen Einstellungen
ermitteln, und einen evtl. Preview neu anbieten.

!label RESCH_COMPLETED
!item [RESCH_COMPLETED (61)]
diese Nachricht wird an diejenige Applikation geschickt, die einen
Aufl”sungswechsel eingeleitet hat. Wenn kein Fehler aufgetreten ist, mu
diese sich nun auch beenden.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Status (0 = Fehler, 1 = 0k)
!end_xlist

!label SC_CHANGED
!item [SC_CHANGED (80)]
diese Nachricht sollte von einem Programm an alle anderen Applikationen im
System verschickt werden, wenn dieses den Inhalt des GEM-Klemmbrettes
ver„ndert hat.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Beschreibung des File-Formats:
!begin_xlist !short
!item [0x0000 =]
keine genauere Spezifizierung
!item [0x0001 =]
Daten fr eine Datenbank
!item [0x0002 =]
Textdateien
!item [0x0004 =]
Vektor-Grafiken
!item [0x0008 =]
Raster-Grafiken
!item [0x0010 =]
Spreadsheet-Daten
!item [0x0020 =]
Samples, MIDI-Files, Sound
!item [0x0040 =]
Archivdateien (z.B. ".zip", ".lzh")
!item [0x8000 =]
Systemdateien (z.B. Farbpaletten)
!end_xlist
Dabei sollte das Format 0x0000 nach M”glichkeit vermieden werden!
!item [ev_mgpbuff[4!]]
4 Zeichen, die das "beste" Format (m”glichst wenig Informationsverlust) fr
!item [ev_mgpbuff[5!]]
den Datenimport beschreiben. Beispiel: ".RTF" statt ".TXT"
!item [ev_mgpbuff[6!]]
reserviert, 0
!item [ev_mgpbuff[7!]]
reserviert, 0
!end_xlist

!label SH_WDRAW
!item [SH_WDRAW (72)]
diese Nachricht sollte von einer Applikation an die System-Shell versandt
werden, wenn der Inhalt eines Laufwerkes ver„ndert worden ist. Die Shell
kann daraufhin die entsprechenden Fenster aktualisieren.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Laufwerk (0 = A, 1 = B, usw).
!end_xlist
(!B)Hinweis:(!b) Ein Wert von -1 bedeutet, da die Shell alle Fenster
aktualisieren soll.

!label SHUT_COMPLETED
!item [SHUT_COMPLETED (60)]
wird vom Betriebssystem an den Initiator eines Shut-Down geschickt, wenn
alle anderen Applikationen davon bereits informiert wurden, und diese
positiv reagiert haben.

!label SM_M_SPECIAL
!label Applikation, Einfrieren einer
!label Prozesses, Einfrieren eines
!label Einfrieren einer Applikation
!label Applikation, Auftauen einer
!label Prozesses, Auftauen eines
!label Auftauen einer Applikation
!label Applikation, Umschalten auf
!label Prozess, Umschalten auf einen
!label Umschalten auf eine Applikation
!item [SM_M_SPECIAL (101)]
diese Nachricht steht nur unter (!nolink [MagiC]) (ab Version 2.0) zur
Verfgung, und mu an den Screen-Manager geschickt werden.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
0
!item [ev_mgpbuff[4!]]
'MA'
!item [ev_mgpbuff[5!]]
'GX'
!item [ev_mgpbuff[6!]]
gewnschte Aktion; es gilt:
!begin_xlist !short
!item [0 =]
Redraw ausfhren
!item [1 =]
Applikation beenden
!item [2 =]
auf Applikation umschalten
!item [3 =]
Applikation einfrieren
!item [4 =]
Applikation wieder auftauen
!item [5 =]
z.Zt. keine Information bekannt
!item [6 =]
alle Applikationen einblenden
!item [7 =]
andere Applikationen ausblenden
!item [8 =]
aktuelle Applikation ausblenden
!end_xlist
!item [ev_mgpbuff[7!]]
ID der zu behandelnden Applikation
!end_xlist
(!B)Hinweis:(!b) Die Codes 6..8 von ev_mgpbuff[6] stehen dabei erst ab
MagiC-Version 3.1 zur Verfgung.

!label THR_EXIT
!item [THR_EXIT (88)]
Diese Nachricht wird an den Thread bzw. die Applikation geschickt, der bzw.
die den beendeten Thread erzeugt hat. Es gilt:
!begin_xlist !short
!item [ev_mgpbuff[3!]]
AES ID des beendeten Threads
!item [ev_mgpbuff[4!]]
Rckgabe- bzw. Fehlercode als
!item [ev_mgpbuff[5!]]
LONG-Wert
!end_xlist

!label WM_ALLICONIFY
!item [WM_ALLICONIFY (36)]
alle Fenster der Applikation sollen zu einem ikonifizierten Fenster
zusammengefat werden.
!begin_xlist !short
!item [ev_mgpbuff[4!]]
X-Koordinate
!item [ev_mgpbuff[5!]]
Y-Koordinate
!item [ev_mgpbuff[6!]]
Breite
!item [ev_mgpbuff[7!]]
H”he des ikonifizierten Fensters
!end_xlist

!label WM_ARROWED
!label WA_UPPAGE
!label WA_DNPAGE
!label WA_UPLINE
!label WA_DNLINE
!label WA_LFPAGE
!label WA_RTPAGE
!label WA_LFLINE
!label WA_RTLINE
!item [WM_ARROWED (24)]
ein Pfeil oder Rollbalken wurde angeklickt.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
einer der folgenden Werte:
!begin_xlist !short
!item [WA_UPPAGE (0) =]
Seite nach oben
!item [WA_DNPAGE (1) =]
Seite nach unten
!item [WA_UPLINE (2) =]
Zeile nach oben
!item [WA_DNLINE (3) =]
Zeile nach unten
!item [WA_LFPAGE (4) =]
Seite nach links
!item [WA_RTPAGE (5) =]
Seite nach rechts
!item [WA_LFLINE (6) =]
Spalte nach links
!item [WA_RTLINE (7) =]
Spalte nach rechts  
!end_xlist
!end_xlist

!label WM_BOTTOMED
!item [WM_BOTTOMED (33)]
wird vom Screen-Manager benutzt um die Applikation aufzufordern, ein Fenster
in den Hintergrund zu legen.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des betreffenden Fensters
!end_xlist
(!B)Hinweis:(!b) das Fenster kann von der Applikation dann einfach per
wind_set (ev_mgpbuff[3], WF_BOTTOM, 0, 0 ,0, 0) in den Hintergrund gelegt
werden. Unter MagiC 2.0 heit diese Meldung noch WM_M_BDROPPED.

!label WM_CLOSED
!item [WM_CLOSED (22)]
das oberste Fenster soll geschlossen werden
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des zu schlieenden Fensters
!end_xlist

!label WM_FULLED
!item [WM_FULLED (23)]
der Fullsizeknopf des obersten Fensters wurde angeklickt.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters, das auf volle Gr”e gebracht werden soll
!end_xlist

!label WM_HSLID
!item [WM_HSLID (25)]
der horizontale Rollbalken wurde verschoben
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
die neue Sliderposition:
!begin_table [c c l]
0000 !! = !! ganz links
1000 !! = !! ganz rechts
!end_table
!end_xlist

!label WM_ICONIFY
!item [WM_ICONIFY (34)]
ein Fenster der Applikation soll ikonifiziert werden.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Kennung des betreffenden Fensters
!item [ev_mgpbuff[4!]]
X-Koordinate
!item [ev_mgpbuff[5!]]
Y-Koordinate
!item [ev_mgpbuff[6!]]
Breite
!item [ev_mgpbuff[7!]]
H”he des ikonifizierten Fensters
!end_xlist

!label WM_M_BDROPPED
!item [WM_M_BDROPPED (100)]
wird vom Screen-Manager benutzt um die Applikation aufzufordern, ein Fenster
in den Hintergrund zu legen. Ab MagiC-3 wird nicht mehr dieser Opcode,
sondern WM_BOTTOMED verschickt.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des betreffenden Fensters
!end_xlist

!label WM_MOVED
!item [WM_MOVED (28)]
das ganze Fenster wurde verschoben
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
neue x-Koordinate
!item [ev_mgpbuff[5!]]
neue y_Koordinate
!item [ev_mgpbuff[6!]]
neue Fensterbreite (unver„ndert)
!item [ev_mgpbuff[7!]]
neue Fensterh”he (unver„ndert)
!end_xlist

!label WM_NEWTOP
!item [WM_NEWTOP (29)]
das Fenster wurde nach oben gebracht
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!end_xlist

!label WM_ONTOP
!item [WM_ONTOP (31)]
ein Fenster wird (nach dem Schlieen oder Deaktivieren eines anderen
Fensters) zum aktuellen bzw. aktiven.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des betreffenden Fensters
!end_xlist
(!B)Hinweis:(!b) zum Zeitpunkt der Ankunft der Nachricht kann sich der
Fensterstapel bereits wieder ver„ndert haben. Die Nachricht wird nur
verschickt, wenn die Applikation nicht mit einem Aufruf das Fenster selbst
in den Vordergrund gesetzt hat.

Nachrichten dieses Typs werden im AES-Messagepuffer verschmolzen. Daraus
folgt, da immer die letzte Nachricht dieser Art empfangen wird; es k”nnen
sich also nicht mehrere dieser Nachrichten im Puffer befinden.

!label WM_REDRAW
!item [WM_REDRAW (20)]
ein Fensterbereich mu neu gezeichnet werden
!begin_xlist
!item [ev_mgpbuff[3!]]
Handle des neuzuzeichnenden Fensters
!item [ev_mgpbuff[4!]]
x-Koordinate des Bereichs
!item [ev_mgpbuff[5!]]
y-Koordinate des Bereichs
!item [ev_mgpbuff[6!]]
Breite des Bereichs
!item [ev_mgpbuff[7!]]
H”he des Bereichs
!end_xlist

!label WM_SIZED
!item [WM_SIZED (27)]
die Fenstergr”e wurde ver„ndert
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
neue x-Koordinate (unver„ndert)
!item [ev_mgpbuff[5!]]
neue y_Koordinate (unver„ndert)
!item [ev_mgpbuff[6!]]
neue Fensterbreite
!item [ev_mgpbuff[7!]]
neue Fensterh”he 
!end_xlist

!label WM_TOOLBAR
!item [WM_TOOLBAR (37)]
behandelt Mausklicks in ein Toolbar-Objekt; es gilt:
!begin_xlist
!item [ev_mgpbuff[3!]]
Kennung des Fensters
!item [ev_mgpbuff[4!]]
angeklicktes Objekt
!item [ev_mgpbuff[5!]]
Anzahl der Mausklicks
!item [ev_mgpbuff[6!]]
Tastatur-Status von Shift, Alternate und Control
!end_xlist
(!B)Hinweis:(!b) Bei allen Objekten der Toolbox sollte das Flag TOUCHEXIT
gesetzt werden.

!label WM_TOPPED
!item [WM_TOPPED (21)]
ein Fenster soll zum oben liegenden Fenster werden.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des nach oben zu holenden Fensters
!end_xlist

!label WM_UNICONIFY
!item [WM_UNICONIFY (35)]
ein oder mehrere Fenster der Applikation sollen unikonifiziert werden. Falls
mehrere Fenster betroffen sind (WM_ALLICONIFY) ist die Applikation auf sich
allein gestellt, da das AES keine Informationen ber die betroffenen Fenster
sowie deren Positionen/Ausmae bereitstellt.
!begin_xlist [ev_mgpbuff___]
!item [ev_mgpbuff[3!]]
Kennung des betreffenden Fensters
!item [ev_mgpbuff[4!]]
X-Koordinate
!item [ev_mgpbuff[5!]]
Y-Koordinate
!item [ev_mgpbuff[6!]]
Breite
!item [ev_mgpbuff[7!]]
H”he des unikonifizierten Fensters
!end_xlist

!label WM_UNTOPPED
!item [WM_UNTOPPED (30)]
ein Fenster wird gerade inaktiv.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des betreffenden Fensters
!end_xlist
(!B)Hinweis:(!b) zum Zeitpunkt der Ankunft der Nachricht kann sich der
Fensterstapel bereits wieder ver„ndert haben. Die Nachricht wird nur
verschickt, wenn die Applikation nicht mit einem Aufruf das Fenster selbst
in den Hintergrund gelegt hat.

!label WM_VSLID
!item [WM_VSLID (26)]
der vertikale Rollbalken wurde verschoben
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
die neue Sliderposition:
!begin_table [c c l]
0000 !! = !! ganz oben
1000 !! = !! ganz unten
!end_table
!end_xlist
!end_xlist
Die Untersttzung der neuen Nachrichtentypen kann per (!link [appl_getinfo][%apgi_12]) (Opcode
12) erfragt werden. Fr benutzerdefinierte Mitteilungen hat (!I)Digital
Research(!i) brigens Message-Nummern jenseits von 1024 vorgeschlagen.

Zur Gr”e des Nachrichtenpuffers:

Eine einzelne Applikation sollte unter MagiC 2.0 nicht mehr als 16 Fenster
nutzen, da sonst der Nachrichtenpuffer des Systems berlaufen kann und
evtl. Redraws nicht mehr ausgefhrt werden k”nnen.

Querverweis: evnt_multi  ~   evnt_mesag ~ AV-Protokoll ~ OLGA-Protokoll ~
             (!link [Drag&Drop][Drag&Drop-Protokoll])
!end_node



!begin_node Die Objekt-Struktur

Die Datenstruktur des Objektbaums ist zwar kein Baum im Sinne eines
Bin„rbaums, besitzt jedoch innerhalb eines Zeigers die logischen
Verkettungen eines Baums, mit Vorg„ngern und Nachfolgern. Die Spezifikation
von Vorg„ngern und Nachfolgern wird durch Indizes auf ein Array vorgenommen.
Die Baumstruktur der einzelnen Objekte kann man sich am leichtesten an Hand
eines einfachen Beispiels veranschaulichen: Ein Men setzt sich zun„chst aus
der Menleiste zusammen. Diese enth„lt wiederum mehrere Titeltexte. Die
Titeltexte sind also direkt in der Menleiste enthalten, sie sind beide
Nachfolger des Objekts 'Menleiste', bewegen sich also auf der selben
hierarchischen Ebene. Das Objekt Menleiste verweist mit (!I)ob_head(!i) auf
den ersten Mentitel und mit (!I)ob_tail(!i) auf den letzten Mentitel. Im
ersten Mentitel dient der Zeiger (!I)ob_next(!i) zur Adressierung des
n„chsten Mentitels. Die Verkettung weist also folgende Struktur auf:
!begin_verbatim
      Menleiste:
   +---------+---------+--------+
   | ob_head | ob_tail | ...    |
   |    o    |    o    |        |
   +----|----+----|----+--------+
        |         +-------------------------+
        V                                   V
   +---------+---------+--------+       +---------+---------+--------+
   | ...     | ob_next | ...    |  ...  | ...     | ...     | ...    |
   |         |    o    |        |       |         |         |        |
   +---------+----|----+--------+       +---------+---------+--------+
      1.Mentitel |                         n-ter Mentitel
                  +-----> 2.Mentitel
!end_verbatim
Welche Aktionen mit einem Objekt durchgefhrt werden drfen, wird in
(!I)ob_flags(!i) festgelegt. Der Zustand eines Objekts wird im Eintrag
(!I)ob_state(!i) festgehalten. Der Eintrag (!I)ob_type(!i) legt den
Objekttyp fest. Manche Objekte ben”tigen zur exakten Festlegung eine
zus„tzliche Datenstruktur, wie TEDINFO oder BITBLK. In ob_spec wird dann
ein Zeiger auf diese zus„tzliche Struktur abgelegt. Zusammenfassend
nochmals der Gesamtaufbau der Datenstruktur fr Objekte OBJECT:
!begin_verbatim
         +-------------+
         |  ob_next    |   Index fr das n„chste Objekt
         +-------------+
         |  ob_head    |   Index des ersten Kindes
         +-------------+
         |  ob_tail    |   Index des letzten Kindes
         +-------------+
         |  ob_type    |   Objektart
         +-------------+
         |  ob_flags   |   Manipulationsflags
         +-------------+
         |  ob_state   |   Objektstatus
         +-------------+
         |  ob_spec    |   siehe unter Objektart
         +-------------+
         |  ob_x       |   relative x-Koordiante zum Eltern-Objekt
         +-------------+
         |  ob_y       |   relative y-Koordinate zum Eltern-Objekt
         +-------------+
         |  ob_width   |   Breite des Objekts
         +-------------+
         |  ob_height  |   H”he des Objekts
         +-------------+
!end_verbatim
Querverweis: Objektfarben des AES ~ (!link [Objektart][Objektarten des AES]) ~
(!link [Manipulationsflags][Objektflags des AES]) ~ (!link [Objektstatus][Objektstati des AES])



!begin_node Objektarten des AES
!label Objekttypen des AES

Folgende Objektarten stehen zur Auswahl:


!begin_xlist [G_WINTITLE (36)]
!item [Art]
Bedeutung

!label G_BOX
!item [G_BOX      (20)]
Rechteckiger Kasten. ob_spec enth„lt verschiedene Informationen ber
Rahmenst„rke, Farbe und „hnliches.

!label G_TEXT
!item [G_TEXT     (21)]
Grafiktext, ob_spec zeigt auf TEDINFO-Struktur.

!label G_BOXTEXT
!item [G_BOXTEXT  (22)]
rechteckiger Kasten mit Grafiktext, ob_spec zeigt auf (!nolink [TEDINFO])-Struktur.

!label G_IMAGE
!item [G_IMAGE    (23)]
Bild, ob_spec zeigt auf BITBLK-Struktur.

!label USERDEF
!label G_USERDEF
!item [G_USERDEF  (24)]
Benutzerdefinierte Funktion zum Zeichnen eines eigenen Objekts. ob_spec
verweist auf eine USERBLK Struktur.

!label G_IBOX
!item [G_IBOX     (25)]
Transparentes Rechteck, das nur gesehen werden kann, wenn die Umrandung
nicht die Dicke Null hat. ob_spec enth„lt weitere Informationen ber das
Aussehen.

!label G_BUTTON
!item [G_BUTTON   (26)]
Text mit Rahmen fr Optionsauswahl. ob_spec zeigt auf eine Zeichenkette mit
dem Text, der in dem Knopf erscheinen soll. (!B)Neu ab MagiC-Version 3.0:(!b)
Ist das Objektflag WHITEBAK gesetzt, und Bit-15 im Objektstatus = 0, so wird
der Button unterstrichen; dabei gilt: (Highbyte&0xf) von ob_state ist die
gewnschte Unterstreichposition. Falls hingegen Bit-15 = 1 ist, so handelt
es sich um einen Sonderbutton (Radio-Button oder Checkbox).

Weitere Besonderheiten: WHITEBAK=1, Bit-15 = 1 und in ob_state
!begin_xlist !short
!item [Highbyte = -2]
==> Gruppenrahmen
!item [Highbyte = -1]
==> Sonderbutton, nicht unterstr.
!item [Highbyte != -1,-2]
==> Sonderbutton, unterstr.
!end_xlist
(dabei ist wieder (Highbyte&0xf) von ob_state die Unterstreichposition). Das
Vorhandensein dieser Features sollte am besten ber die Funktion
(!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label G_BOXCHAR
!item [G_BOXCHAR  (27)]
Rechteck, mit einem Zeichen. In ob_spec wird nicht nur das Aussehen der
Umrandung, sondern auch das Zeichen definiert.

!label G_STRING
!item [G_STRING   (28)]
Zeichenkette, ob_spec zeigt auf den String. (!B)Neu ab MagiC-Version 3.0:(!b)
Ist das Objektflag WHITEBAK gesetzt, und das Highbyte von ob_state != -1, so
wird der String unterstrichen; die Unterstreich-Position wird dabei durch
(Highbyte & 0xf) von ob_state geregelt.

Bei gesetztem (!nolink [WHITEBAK])-Flag und Highbyte von ob_state = -1, wird der
komplette String unterstrichen. Das Vorhandensein dieser Features sollte am
besten per (!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label G_FTEXT
!item [G_FTEXT    (29)]
Formatierter Grafiktext, ob_spec zeigt auf TEDINFO-Struktur

!label G_FBOXTEXT
!item [G_FBOXTEXT (30)]
Rechteck mit formatiertem Grafiktext, ob_spec zeigt auf (!nolink [TEDINFO])-Struktur.

!label G_ICON
!item [G_ICON     (31)]
Icon-Symbol, ob_spec zeigt auf die ICONBLK-Struktur.

!label G_TITLE
!item [G_TITLE    (32)]
Titel eines Drop-Down-Mens, ob_spec zeigt auf den String. Ab MagiC-2 kann
dabei auch ein Buchstabe unterstrichen werden. Dies geht wie folgt:

WHITEBAK in ob_state setzen
!begin_xlist !short
!item [(ob_state >> 8) & 0xf]
= Position des Unterstrichs
!item [(ob_state >> 8) & 0xf0]
ist 0
!end_xlist

!label G_CICON
!item [G_CICON    (33)]
Farb-Icon, ob_spec zeigt auf die CICONBLK-Struktur.

!label G_SWBUTTON
!item [G_SWBUTTON (34)]
Cycle-Button (d.h. ein Button, der beim Anklicken seinen Text zyklisch
„ndert), ob_spec zeigt auf eine SWINFO-Struktur. Das Vorhandensein dieses
Objekttyps sollte per (!link [appl_getinfo][%apgi_13]) (Opcode 13) erfragt werden.

!label G_POPUP
!item [G_POPUP    (35)]
PopUp-Men, ob_spec zeigt auf eine POPINFO-Struktur. Falls das Men mehr als
16 Eintr„ge umfat, so ist dieses scrollbar. Das Vorhandensein dieses
Objekttyps sollte per (!nolink [appl_getinfo]) (Opcode 13) erfragt werden. Hinweis:
G_POPUP sieht wie G_BUTTON aus, die Zeichenkette wird jedoch nicht
zentriert, um m”glichst mit den Zeichenketten im Men auf einer Linie zu
liegen.

!label G_WINTITLE
!item [G_WINTITLE (36)]
Diese Objektnummer wird von MagiC intern dazu verwendet, Fenstertitel
darzustellen. Der Aufbau dieses Objekttyps kann sich jederzeit „ndern und
wird daher nicht dokumentiert.

!label G_EDIT
!item [G_EDIT     (37)]
Ab MagiC 5.20 steht ein in einer Shared-Library implementiertes Editobjekt
zur Verfgung. ob_spec verweist auf das Objekt. Achtung: Dieser Typ wird von
den Funktionen (!nolink [form_do]), (!nolink [form_xdo]), (!nolink [form_button]),
(!nolink [form_keybd]), (!nolink [objc_edit]),
(!nolink [wdlg_evnt]) und wdlg_do z.Zt. noch (!I)nicht(!i) untersttzt, d.h. die
entsprechenden Ereignisse mssen selbst (per edit_evnt) an das Objekt
weitergeleitet werden.

!label G_SHORTCUT
!item [G_SHORTCUT (38)]
Dieser Typ wird „hnlich wie G_STRING behandelt, ein vorhandenes
Tastaturkrzel wird jedoch abgespalten und rechtsbndig ausgegeben. Das
Vorhandensein dieses Objekttyps sollte per (!nolink [appl_getinfo]) (Opcode 13) erfragt
werden.
                    
Die Einfhrung proportionaler AES-Zeichens„tze machte eine
neue Strategie fr die Ausrichtung der Meneintr„ge erforderlich. Um
Tastaturkrzel rechtsbndig ausrichten zu k”nnen, werden Objekte vom Typ
G_STRING innerhalb eines Mens entsprechend in Kommando und Krzel
aufgespalten. Diese Strategie versagt jedoch bei Mens, die vom Programm
selbst, z.B. innerhalb eines Fensters oder eines Popup-Mens, verwaltet
werden. Um auch hier eine brauchbare Ausrichtung zu erreichen, mute dieser
neue Objekttyp eingefhrt werden.
!end_xlist
(!B)Hinweis:(!b) Fr G_BOX, G_IBOX und G_BOXCHAR zeigt die Komponente
(!I)ob_spec(!i) der OBJECT-Struktur (!I)nicht(!i) auf eine andere
Datenstruktur, sondern enth„lt weitere Informationen zum Aussehen des
Objektes. Dabei gilt:

!begin_xlist !short
!item [Bits]
Bedeutung
!item [~]
~
!item [24..31]
darzustellendes Zeichen (nur bei G_BOXCHAR)
!item [16..23]
!begin_xlist [-1..127] !short
!item [0]
= Rahmendicke
!item [1..128]
= Rahmen liegt 1..128 Pixel im inneren des Objekts
!item [-1..-127]
= Rahmen liegt 1..127 Pixel auerhalb des Objekts
!end_xlist
!item [12..15]
Rahmenfarbe (0..15)
!item [08..11]
Textfarbe   (0..15)
!item [7]
Text transparent (0) oder deckend (1)
!item [04..06]
!begin_xlist !short
!item [0]
= hohl
!item [1]
= ansteigende Intensit„t
!item [2]
~
!item [.]
~
!item [.]
~
!item [7]
= solide Fl„che
!end_xlist
!item [00..03]
Innenfarbe (0..15)
!end_xlist
Das Hibyte wird vom AES nur fr Submens verwendet. Ist das h”chste Bit von
ob_type 0x8000, sowie das Bit SUBMENU in ob_flags gesetzt, so geben die Bits
8..14 an, welches Submen mit dem Meneintrag gekoppelt ist. Jede
Applikation kann daher maximal 128 Submens haben. MagiC liest aus ob_type
stets nur das Lowbyte aus, auer fr die Submen-Behandlung. TOS reagiert
auf unbekannte Objekttypen (z.B. die reinen (!nolink [MagiC])-Typen G_SWBUTTON usw.)
sauber, d.h. die Objekte werden nicht gezeichnet.

Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~  Objektfarben des AES
!end_node



!begin_node Objektfarben des AES

Die folgende Tabelle enth„lt die vordefinierten Objektfarben. Einzelheiten
h„ngen natrlich von der gew„hlten Bildaufl”sung, sowie den Einstellungen
des Benutzers ab.

!begin_table [l|l|r]
Nummer !! Farbe !! Standard RGB-Werte
!hline
WHITE    (00) !! Wei          !! 1000, 1000, 1000
BLACK    (01) !! Schwarz       !!    0,    0,    0
RED      (02) !! Rot           !! 1000,    0,    0
GREEN    (03) !! Grn          !!    0, 1000,    0
BLUE     (04) !! Blau          !!    0,    0, 1000
CYAN     (05) !! Cyan          !!    0, 1000, 1000
YELLOW   (06) !! Gelb          !! 1000, 1000,    0
MAGENTA  (07) !! Magenta       !! 1000,    0, 1000
DWHITE   (08) !! Hellgrau      !!  752,  752,  752
DBLACK   (09) !! Dunkelgrau    !!  501,  501,  501
DRED     (10) !! Dunkelrot     !!  713,    0,    0
DGREEN   (11) !! Dunkelgrn    !!    0,  713,    0
DBLUE    (12) !! Dunkelblau    !!    0,    0,  713
DCYAN    (13) !! Dunkelcyan    !!    0,  713,  713
DYELLOW  (14) !! Dunkelgelb    !!  713,  713,    0
DMAGENTA (15) !! Dunkelmagenta !!  713,    0,  713
!end_table
(!B)Hinweis:(!b) Diese Farben entsprechen auch weitestgehend den unter
Windows und OS/2 verwendeten Iconfarben. šber ein geeignetes CPX-Modul
k”nnen die richtigen RGB-Werte fr die ersten 16 Farben eingestellt werden.

Querverweis: (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node



!begin_node Objektflags des AES

Die Manipulationsflags eines Objektes bestimmen seine Eigenschaften.
Folgende M”glichkeiten stehen zu Auswahl:

!begin_xlist [TOUCHEXIT  (0x0040)]
!item [Flag]
Bedeutung

!item [NONE       (0x0000)]
Keine Eigenschaften.

!label SELECTABLE
!item [SELECTABLE (0x0001)]
Das Objekt ist selektierbar.

!label DEFAULT
!item [DEFAULT    (0x0002)]
Wenn der Benutzer die 'Return' oder 'Enter' Taste drckt, wird dieses Objekt
automatisch selektiert. Diese Flag ist pro Baum nur einmal zugelassen.

!label EXIT
!item [EXIT       (0x0004)]
Beim Anklicken eines solchen Objektes wird der Dialog beendet (siehe auch
form_do).

!label EDITABLE
!item [EDITABLE   (0x0008)]
Dieses Objekt kann vom Benutzer mittels der Tastatur editiert werden.

!label RBUTTON
!item [RBUTTON    (0x0010)]
Haben im selben Objektbaum mehrere Objekte die eigenschaft RBUTTON, so kann
immer nur eines dieser Objekte selektiert sein. Diese Objekte sollten alle
Kinder eines Elternobjekts mit der Objektart G_IBOX sein. Wird ein anderes
Objekt dieser Gruppe ausgew„hlt, wird das zuvor selektierte automatisch
deselektiert.

!label LASTOB
!item [LASTOB     (0x0020)]
Hierbei handelt es sich um das letzte Objekt innerhalb eines Objektbaumes.

!label TOUCHEXIT
!item [TOUCHEXIT  (0x0040)]
Der Dialog (siehe auch form_do) wird beendet, sobald sich der Mauszeiger
ber diesem Objekt befindet, und der linke Mausknopf gedrckt wird.

!label HIDETREE
!label HIDDEN
!item [HIDETREE   (0x0080)]
Das Objekt und seine Kinder werden von objc_draw und objc_find nicht mehr
bemerkt, sobald dieses Flag gesetzt ist. Weiterhin wird das Flag ab MagiC
5.20 auch von form_keybd ausgewertet, wenn Objekte zu Tastenkrzeln gesucht
werden. Eine Eingabe in versteckte Objekte ist jedoch immer noch m”glich.
Um dies zu verhindern, mu das Flag EDITABLE gel”scht werden.

!label INDIRECT
!item [INDIRECT   (0x0100)]
ob_spec zeigt nun auf einen weiteren Zeiger, der dann auf den eigentlichen
Wert von ob_spec zeigt (siehe auch OBJECT). Auf diese Weise lassen sich die
Standarddatenstrukturen wie TEDINFO etc. auf einfache Art erweitern.

!label FL3DIND
!item [FL3DIND    (0x0200)]
Dieses Objekt erzeugt unter MultiTOS ein dreidimensionales Objekt (unter
MagiC (ab Version 3.0) erst ab 16 Farben, und wenn der 3D-Effekt nicht
abgeschaltet wurde). Im 3D-Betrieb wird dies als Indikator aufgefat. Bei
diesen Objekten handelt es sich i.d.R. um Buttons, die einen Status
anzeigen, beispielsweise Radio-Buttons.

!label ESCCANCEL
!item [ESCCANCEL (0x0200)]
Das Drcken der ESC Taste entspricht einem Anw„hlen des Objekts mit
diesem Flag. Deshalb darf es nur ein Default Objekt in einem Dialog
geben. Dieses Flag wurde mit ViewMAX beta eingefhrt.

!label FL3DBAK
!item [FL3DBAK    (0x0400)]
Dieses Objekt wird im 3D-Betrieb als Hintergrund aufgefat, und entsprechend
gezeichnet. Es empfiehlt sich in Dialogen mit 3D-Buttons das ROOT Objekt mit
diesem Flag zu belegen. Gleiches gilt fr Eingabefelder und Textobjekte,
denn nur so wird eine einheitliche Hintergrundfarbe erhalten.

!label BITBUTTON
!item [BITBUTTON (0x0400)]
Dieses Flag wurde mit ViewMAX beta eingefhrt, wird dort aber nicht
benutzt. Vermutlich enth„lt ein Button mit diesem Flag eine Bitmap
anstelle eines Textes.

!label FL3DACT
!item [FL3DACT    (0x0600)]
Dieses Objekt wird im 3D-Betrieb als Aktivator aufgefat. Bei diesen
Objekten handelt es sich i.d.R. um Buttons, mit denen man Dialoge verlassen,
oder sonstwie eine Aktion hervorrufen kann.

!label SUBMENU
!item [SUBMENU    (0x0800)]
Wird in MultiTOS und ab MagiC 5.10 verwendet, um Submens zu kennzeichnen.
menu_attach setzt dieses Bit in einem Meneintrag, um zu kennzeichnen, da
hier ein Submen angeh„ngt ist. Das Hibyte von ob_type enth„lt dann die
Submen-Nummer (128..255) d.h. Bit 15 von ob_type ist immer gleichzeitig mit
SUBMENU gesetzt.

!label SCROLLER
!item [SCROLLER (0x0800)]
Das Drcken der PAGEUP Taste entspricht einem Anw„hlen des ersten
Objekts mit diesem Flag in dem Dialog. Das Drcken der PAGEDOWN Taste
entspricht einem Anw„hlen des letzten Objekts mit diesem Flag. Dieses
Flag wurde mit ViewMAX beta eingefhrt.

!label FLAG3D
!item [FLAG3D (0x1000)]
Ein Objekt mit dieserm Flag wird mit einem 3D Rahmen gezeichnet. Ab
ViewMAX/2 wird jeder Button automatisch mit einem 3D Rahmen gezeichnet.
Dazu wird die Color Categorie (siehe USECOLOURCAT) benutzt. Dieses Flag
wurde mit ViewMAX beta eingefhrt.

!label USECOLOURCAT
!item [USECOLOURCAT (0x2000)]
Die Farbe des Objekts ist kein Farbindex des VDI sondern ein Eintrag
in einer Tabelle mit Farben fr bestimmte Kategorien. Diese Tabellle
hat 16 Eintr„ge. ViewMAX benutzt die folgenden Kategorien:

 #define CC_NAME       8 /* Inactive title bar */ (!nl)
 #define CC_SLIDER     9 /* Scroll bar background */ (!nl)
 #define CC_DESKTOP   10 /* The desktop */ (!nl)
 #define CC_BUTTON    11 /* Buttons and other 3D gadgets */ (!nl)
 #define CC_INFO      12 /* Window information line */ (!nl)
 #define CC_ALERT     13 /* Alert boxes (not used in ViewMAX or FreeGEM) */ (!nl)
 #define CC_SLCTDNAME 14 /* Active titlebar */ (!nl)

CC_NAME      - Inaktive Titlezeile eine Fensters (!nl)
CC_SLIDER    - Hintergrund einer Scrollbar (!nl)
CC_DESKTOP   - Der Desktop (!nl)
CC_BUTTON    - Buttons und andere 3D Gadgets  (!nl)
CC_INFO      - Infozeile eines Fensters (!nl)
CC_ALERT     - Alertboxen (wird in ViewMAX und FreeGEM nicht benutzt) (!nl)
CC_SLCTDNAME - Aktive Titelzeile eines Fensters (!nl)

Wahrscheinlich ist beabsichtigt, die Kategorien 0 bis 7 durch die
Applikation definieren zu lassen, w„hrend 8 bis 15 fr das System
reserviert sind. Die Einstellung wird in ViewMAX.INI (GEM.CFG in
FreeGEM) gespeichert und bsteht aus jeweils einen Vordergrund,
Hintergrund, Fllstil und Fllindex. Dieses Flag wurde mit ViewMAX
beta eingefhrt.
!end_xlist


Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node



!begin_node Objektstati des AES

Vom Objektstatus h„ngt es ab, wie ein Objekt sp„ter auf dem Bildschirm
dargestellt wird. Ein Objektstatus kann von folgendem Typ sein:

!begin_xlist [UNDERLINE (0x0f00)]
!item [Status]
Bedeutung
!item [~]
~

!item [NORMAL    (0x0000)]
Normale Darstellung.

!label SELECTED
!item [SELECTED  (0x0001)]
Inverse Darstellung, dh. das Objekt ist selektiert.

!label CROSSED
!item [CROSSED   (0x0002)]
Falls die Objektart BOX ist, wird das Objekt mit durchgestrichen gezeichnet.

!label CHECKED
!item [CHECKED   (0x0004)]
Am linken Objektrand befindet sich ein H„kchen.

!label DISABLED
!item [DISABLED  (0x0008)]
Das Objekt wird grau dargestellt und ist nicht mehr selektierbar.

!label OUTLINED
!item [OUTLINED  (0x0010)]
Das Objekt bekommt einen Rahmen.

!label SHADOWED
!item [SHADOWED  (0x0020)]
Ein Schatten wird unter das Objekt gezeichnet.

!label WHITEBAK
!item [WHITEBAK  (0x0040)]
Auf PC-(!nolink [GEM]) bewirkt dies, da die Icon-Maske nicht mitgezeichnet wird, was
u.U. die Ausgabe beschleunigen kann. (!nl) Ab MagiC-3 wird hiermit das
Unterstreichen von Zeichenketten gesteuert. Dieses Feature kann ber
(!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label DRAW3D
!item [DRAW3D    (0x0080)]
Ein Objekt soll mit 3D-Effekt gezeichnet werden. Dieses Flag ist nur fr
PC-GEM interessant, und wird vom Atari-AES (so z.B. auch in (!nolink [MagiC])) ignoriert.

!label HIGHLIGHTED
!item [HIGHLIGHTED (0x0100)]
Ein Objekt mit diesem State wird mit einer gestrichelten Line, die mit
MD_XOR gezeichnet wird, umrandet. Dieser State wurde mit ViewMAX beta
eingefhrt.

!label UNHIGHLIGHTED
!item [UNHIGHLIGHTED (0x0200)]
Bei einem Objekt mit diesem State wird beim Zeichnen explizit eine
durch den State HIGHLIGHTED gezeichnete Umrandung entfernt. Dazu mu
wie folgt vorgegangen werden: Zuerst mu der State HIGHLIGHTED gel”scht
werden, dann der State UNHIGHLIGHTED gesetzt werden und anschlieend
das Objekt mit der Funktion objc_draw neu gezeichnet werden. Ein
Neuzeichnen des Objekts ohne den State UNHIGHLIGHTED wrde die Umrandung
nicht l”schen, da sie auerhalb des Bereichs liegt, den das Objekt
belegt. Nach dem Neuzeichnen sollte der State UNHIGHLIGHTED wieder
gel”scht werden. Dieser State wurde mit ViewMAX beta eingefhrt.

!label UNDERLINE
!item [UNDERLINE (0x0f00)]
Dieser Opcode steht unter MagiC ab Version 2.0 zur Verfgung, und legt die
Position und Gr”e des Unterstriches bei Objekten vom Typ G_STRING, G_TITLE
und G_BUTTON fest.

!label XSTATE
!item [XSTATE    (0xf000)]
Dieser Opcode steht unter MagiC ab Versio 2.0 zur Verfgung, und sorgt fr
das Umschalten bei den verschiedenen Button-Typen ((!nolink [G_STRING]),
(!nolink [G_TITLE]) und (!nolink [G_BUTTON])).
!end_xlist

Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node
!end_node


!begin_node Der Quarter-Screen-Buffer

Der Quarter-Screen-Buffer wird vom Screen-Manager ben”tigt, um beim
Herunterklappen von Drop-Down-Mens den Inhalt des Menhintergrundes zu
retten. Auch bei der Anzeige von Alarmboxen kommt der 'QSB' (so die
gebr„uchliche Abkrzung) zum Einsatz. Normalerweise sollte seine Gr”e von
der Anzahl  der Farbebenen und der Gr”e des Systemzeichensatzes,
(!I)nicht(!i) aber von der Gesamtgr”e des Bildschirms abh„ngen.

(!B)Eine gute Formel w„re:(!b) 500(Zeichen)*Platzbedarf eines
Zeichens*Farbebenen

Damit k„me man in der Aufl”sung 'ST-Hoch' genau auf den Wert 8000 (also
ein Viertel des Bildspeichers). Leider ist das AES in vielen F„llen jedoch
nicht so clever; die folgende Tabelle enth„lt eine šbersicht ber die
benutzten Algorithmen einiger (!nolink [GEM])-Versionen:

!begin_xlist !short
!item [(!nolink [GEM])-Version]
Methode zum Setzen des QSB
!item [~]
~
!item [1.0 und 1.2]
statisch, 8000 Bytes
!item [1.4]
dynamisch, ein Viertel des Bildspeichers
!item [3.0]
dynamisch, die H„lfte des Bildspeichers
!end_xlist

(!B)Hinweis:(!b) Die (!nolink [GEM])-Versionen 1.0 und 1.2 (also bis einschlielich
TOS-Version 1.02) sind mithin (!I)nicht(!i) fr Farbgrafikkarten vorbereitet
- einer unter mehreren Grnden, warum man selbst bei Benutzung eines
speziellen VDI-Treibers unter diesen (!nolink [GEM])-Versionen Farbgrafikkarten
(!I)nicht(!i) einsetzen kann.

Querverweis: GEM
!end_node


!begin_node Die Rechteckliste eines Fensters
!label Fensters, Rechteckliste eines

Um dem Problem sich berlappender Fenster zu begegnen, unterh„lt das AES
fr jedes Fenster die sogenannte (!I)Rechteckliste(!i); alle Elemente dieser
Liste ergeben gerade den komplett sichtbaren Arbeitsbereich des
entsprechenden Fensters. 

Um ein Fenster (bzw. dessen Inhalt) neu zu zeichnen erfragt man zun„chst
per wind_get(WF_FIRSTXYWH) das erste Rechteck der o.g. Liste. Dann stellt
man fest, ob sich dieses Rechteck mit dem neu zu zeichnenden
Bildschirmbereich berschneidet; dann und nur dann zeichnet man diesen
Bereich unter Ausnutzung von vs_clip neu.

Diese Methode wird mit allen brigen Elementen der Rechteckliste
fortgesetzt, bis die H”he (!I)und(!i) Breite eines Rechtecks den Wert Null
besitzen.

Querverweis: Clipping ~  WM_REDRAW ~  wind_get ~  wind_update
!end_node



!begin_node Der Screen-Manager

Der Screen-Manager ist immer aktiv und berwacht die Position des
Mauszeigers, wenn dieser den Arbeitsbereich der Fenster anderer
Applikationen verl„t. Die hier in Frage kommenden Fl„chen sind die
Rahmen der Fenster, die Drop-Down-Mens und die Menleiste.

Beim Berhren des Menbereichs sorgt der Screen-Manager selbstt„tig dafr
da der vom Men belegte Bildschirmausschnitt gesichert und anschlieend
wiederhergestellt wird (dazu wird der Quarter-Screen-Buffer benutzt).

Auch Manipulationen an den Fensterkontrollen fhren nicht zu dauerhaften
Ver„nderungen des Bildspeichers; Resultat der Interaktionen mit dem
Screen-Manager sind die sogenannten Mitteilungsereignisse, die die
zust„ndige Applikation ber die Aktion des Benutzers informieren.

!label Screen-Manager, Name des
!label Screen-Manager, ID des
(!B)Hinweis:(!b) Die ID des Screen-Managers kann brigens leicht durch einen
Aufruf von appl_find("SCRENMGR") ermittelt werden.

Querverweis: AES ~  GEM ~  Nachrichten
!end_node


!begin_node Startupcode fr Accessories
!label Accessories, Startupcode fr

Um zu testen, ob eine Applikation als Programm oder als Accessorie gestartet
worden ist, kann man wie folgt vorgehen:

!begin_itemize
!item wenn beim Programmstart das Register a0 den Wert Null hat, dann
      handelt es sich um einen normalen Programmstart
!item anderenfalls handelt es sich um ein Accessorie, und Register a0
      enth„lt einen Zeiger auf die (unvollst„ndig) ausgefllte BASEPAGE. Die
      TPA ist bereits passend geschrumpft (auf die Summe von Basepagegr”e
      und der L„nge der drei Programmsegmente), ein Stack mu erst noch
      angelegt werden.
!end_itemize

(!B)Hinweis:(!b) Mit diesen Informationen ist es kein Problem, den
Startupcode fr ein Programm so zu gestalten, da es selbst„ndig erkennt,
wie das Programm gestartet worden ist, und entsprechend die Initialisierung
fortzusetzen. Bei den meisten C-Compilern wird im Startupcode automatisch
die externe Variable (!I)_app(!i) initialisiert, die genau dann gleich Null
ist, wenn das Programm als Accessorie gestartet worden ist. Damit kann man
Programme so entwickeln, da sie sowohl als Accessorie als auch als normales
Programm eingesetzt werden k”nnen.

Querverweis: AES ~  Accessories in MagiC ~  Programmstart und TPA
!end_node



!begin_node Toolbar-Support
!label Toolbars, Redraw und Update von

Ab AES-Version 4.1 untersttzt das Betriebssystem sogenannte Toolbars. Es
handelt sich dabei um einen OBJECT-Baum, der unterhalb der Info-Zeile eines
Fensters (und ber dem Arbeitsbereich) plaziert wird, und die Darstellung
von Buttons, Icons etc. im Fenster erm”glicht.

Wie bereits von den Fensterroutinen bekannt, wird die Verwaltung einer
Toolbar zwischen dem (!nolink [AES]) und der Applikation aufgeteilt. (!B)Dabei ist das
(!nolink [AES]) fr die folgenden Aktionen verantwortlich:(!b)

!begin_itemize
!item Anpassung der x- und y-Koordinaten der Toolbar, wenn das Fenster
      bewegt oder in der Gr”e ver„ndert wird.
!item Sicherstellung, da das Fenster auf die fr die Fenster-Komponenten
      und die Toolbar notwendige Gr”e konfiguriert wird.
!item Anpassung der Breite der Toolbar an die Breite des Fensters.
!item Neuzeichnung der Toolbar beim Eintreffen einer WM_REDRAW-Nachricht.
!item Verschicken von (!nolink [AES])-Nachrichten, wenn der Benutzer ein Objekt der
      Toolbar aktiviert.
!end_itemize

(!B)Die Applikation hingegen muss sich um die folgenden Dinge kmmern:(!b)

!begin_itemize
!item Aufbau eines OBJECT-Baumes fr die Toolbar (insbesondere muss darauf
      geachtet werden, da alle anw„hlbaren Elemente der Toolbox den Status
      TOUCHEXIT besitzen).
!item Anpassung der Breite eines Objektes der Toolbar, falls dieses von der
      Breite des Fensters abh„ngig ist (wird evtl. beim Ver„ndern der Gr”e
      des Fensters notwendig sein).
!item Behandlung von USERDEF-Objekten.
!item Neuzeichnung alle Objekte, deren optische Erscheinung ge„ndert werden
      soll. In diesem Fall muss unbedingt die Rechteckliste der Toolbar
      abgefragt bzw. bercksichtigt werden.
!item Probleme die im Zusammenhang mit der Bildschirmaufl”sung stehen,
      mssen gel”st werden. So kann z.B. die H”he eines Icons in der
      mittleren ST-Aufl”sung von der H”he des Icons in der mittleren
      TT-Aufl”sung abweichen.
!end_itemize

(!B)Bei der Untersttzung von Toolbars in eigenen Programmen sollten die
folgenden Punkte beachtet werden:(!b)

!begin_itemize
!item Kommunikation mit dem (!nolink [AES])-Window-Manager
!item Probleme bei wind_calc
!item Redraw und Updating von Toolbars
!end_itemize

Querverweis: (!nl)
WF_TOOLBAR ~  WF_FTOOLBAR  ~ WF_NTOOLBAR ~  WM_TOOLBAR ~
             wind_get  ~   wind_set



!begin_node Redraw und Updating von Toolbars

Bei der Neuzeichnung (von Teilen) der Toolbar ist, wie blich, die
Rechteckliste zu beachten. Da die bisherigen wind_get Opcodes WF_FIRSTXYWH
und WF_NEXTXYWH jedoch (!I)nur den Arbeitsbereich(!i) eines Fensters
bercksichtigen, wurden zwei neue Parameter (WF_FTOOLBAR und WF_NTOOLBAR)
eingefhrt, mit deren Hilfe die Rechteckliste fr eine Toolbar abgefragt
werden kann.

(!B)Ein Redraw (von Teilen) der Toolbar kann in den folgenden Situationen
notwendig sein:(!b)

!begin_itemize
!item die Toolbar enth„lt benutzerdefinierte Objekte (USERDEF's).
!item der Status eines Objektes der Toolbar wurde ver„ndert. Der neu zu
      zeichnende Bereich besteht dabei aus der Gr”e des Objektes zzgl. des
      Platzes, welcher fr Spezialeffekte (3D, Shadowing, Outline etc.)
      beansprucht wird.
!end_itemize

(!B)Nicht notwendig ist ein Neuzeichnen z.B. in folgenden F„llen:(!b)

!begin_itemize
!item das entsprechende Fenster ist ikonifiziert. Die Applikation braucht
      sich um keinerlei Verwaltung der Toolbar zu kmmern; dies ist erst
      wieder nach der Aufhebung des Iconify, dem sogenannten Uniconify,
      notwendig.
!item die im Fenster vorhandene Toolbar soll durch eine andere ersetzt
      werden. In diesem Fall reicht ein Aufruf von wind_set mit dem Opcode
      WF_TOOLBAR und der Adresse des neuen OBJECT-Baumes aus.
!item die im Fenster vorhandene Toolbar soll entfernt werden. In diesem Fall
      reicht ein Aufruf von wind_set mit dem Opcode WF_TOOLBAR und
      NULL-Parametern aus.
!end_itemize

Querverweis:
(!link [Rechteckliste eines Fensters][Die Rechteckliste eines Fensters]) ~
Toolbar-Support
!end_node



!begin_node Toolbars und der Window-Manager

Zur Handhabung von Toolbars kann eine Applikation auf den Window-Manager
des (!nolink [AES]) zurckgreifen. Im einzelnen:

!label Toolbar, Anheften einer
(!B)Um eine Toolbar an ein Fenster anzuheften(!b), gengt ein Aufruf von
wind_set(handle, WF_TOOLBAR, ...) mit der Adresse des
Toolbar-Objektbaumes. Falls dieser Aufruf durchgefhrt wird w„hrend das
Fenster ge”ffnet ist, so ist dieses selbst fr die korrekte Berechnung der
H”he der Toolbar verantwortlich.

!label Toolbar, Austauschen einer
(!B)Um eine Toolbar gegen eine andere auszutauschen(!b), kann auf einen
Aufruf von (!nolink [wind_set])(handle, (!nolink [WF_TOOLBAR]), ...) mit der Adresse der neuen
Toolbar zurckgegriffen werden. Falls dieser Aufruf durchgefhrt wird
w„hrend das Fenster ge”ffnet ist, so ist dieses selbst fr die korrekte
Berechnung der H”he der (neuen) Toolbar verantwortlich.

!label Toolbar, Entfernen einer
(!B)Um eine Toolbar aus einem Fenster zu l”sen(!b), ist ein Aufruf von
(!nolink [wind_set])(handle, (!nolink [WF_TOOLBAR]), ...) mit NULL Parametern erforderlich. Falls
dieser Aufruf durchgefhrt wird w„hrend das Fenster ge”ffnet ist, so ist
dieses selbst fr die korrekte weitere Bearbeitung verantwortlich.

(!B)Darber hinaus sind die folgenden Punkte zu beachten:(!b)

!begin_itemize
!item Wird ein Fenster per wind_close geschlossen, so wird eine evtl.
      vorhandene Toolbar (!I)nicht(!i) entfernt. Bei einem sp„teren ™ffnen
      ist die Toolbar also weiterhin vorhanden.
!item Wird ein Fenster per wind_delete entfernt, so wird auch die Verbindung
      zur Toolbar aufgel”st.
!item Um Mausklicks auf Toolbar-Objekte erkennen zu k”nnen, mssen diese den
      Status TOUCHEXIT besitzen. Bei einem Klick auf ein solches Objekt wird
      vom (!nolink [AES]) eine (!nolink [WM_TOOLBAR])-Nachricht erzeugt, und an die betreffende
      Applikation geschickt.
!end_itemize

Querverweis: AES  ~ GEM ~  Toolbar-Support
!end_node



!begin_node Probleme bei wind_calc in Toolbar-Fenstern
!label wind_calc, Probleme bei

Beim Einsatz der Funktion wind_calc auf Fenster, die eine Toolbar
beinhalten, sind einige Probleme zu bercksichtigen:

Da dieser Funktion (!I)keine(!i) Fenster-Kennung (Window-Handle) bergeben
wird, k”nnen die gewnschten Gr”en nicht korrekt berechnet werden, wenn
sich eine Toolbar im Fenster befindet. Der Grund liegt ganz einfach darin,
da das AES in diesem Fall (!I)keine(!i) Informationen ber die Toolbar, und
speziell ber deren Gr”e besitzt.

Daher mssen in diesem Fall die von wind_calc gelieferten Werte von der
Applikation weiter aufbereitet werden. Da das Programm auf den
entsprechenden OBJECT-Baum (und damit auch auf die H”he der Toolbar)
zugreifen kann, ist dies problemlos m”glich. (!B)Konkret:(!b)

!begin_itemize
!item Bei der Ermittlung des (!I)Randbereiches(!i) des Fensters, mu die
      H”he der Toolbar auf die von der Funktion gelieferte H”he addiert
      werden.
!item Bei der Ermittlung des (!I)Arbeitsbereiches(!i) des Fensters, mu die
      H”he der Toolbar auf den von der Funktion gelieferten y-Wert (couty)
      addiert werden.
!end_itemize

(!B)Hinweis:(!b) Die H”he der Toolbar sollte neben der H”he des eigentlichen
Objektes den Platzbedarf fr Spezialeffekte (3D, Shadowing, etc.) beinhalten.

Querverweis: WF_FTOOLBAR ~  WF_NTOOLBAR ~  WM_TOOLBAR ~  objc_sysvar
!end_node
!end_node



!begin_node AES-Bindings
!label Bindings des AES

Das AES wird ber ein einziges Unterprogramm aufgerufen, dem 6 Parameter
bergeben werden; es handelt sich dabei um (!nolink [Adressen]) verschiedener Arrays,
die zur Ein-/Ausgabe-Kommunikation benutzt werden. Um eine AES-Funktion
aufzurufen, mu der folgende Parameterblock mit den (!nolink [Adressen]) der unten
beschriebenen Arrays bestckt werden:

!label AES-Parameterblock
!label Parameterblock des AES
!begin_verbatim
typedef struct
{
    WORD *cb_pcontrol;  /* Zeiger auf control-Array */
    WORD *cb_pglobal;   /* Zeiger auf global-Array  */
    WORD *cb_pintin;    /* Zeiger auf int_in-Array  */
    WORD *cb_pintout;   /* Zeiger auf int_out-Array */
    WORD *cb_padrin;    /* Zeiger auf adr_in-Array  */
    WORD *cb_padrout;   /* Zeiger auf adr_out-Array */
} AESPB;
!end_verbatim

Die Adresse dieses Parameterblocks (der sich auf dem Stack befindet), mu
dann im Register d1 vermerkt, und zus„tzlich Register d0.w mit dem Wert
0xc8 (200) gefllt werden. Durch einen TRAP#2 Systemaufruf kann dann das
(!nolink [AES]) direkt aufgerufen werden. Fr den (!B)(!I)Pure-Assembler(!b)(!i) k”nnte
das z.B. so aussehen:

!label aes
!begin_verbatim
                .EXPORT aes         ; Funktion exportieren
                .CODE               ; Beginn des Code-Segments

        aes:     MOVE.L 4(sp),D1    ; Adresse des Parameterblocks
                 MOVE.W #200,D0     ; Opcode des AES
                 TRAP   #2          ; GEM aufrufen
                 RTS                ; raus hier

                .END                ; Ende des Moduls
!end_verbatim

Darber, welche Register ver„ndert werden drfen, gibt es keine klaren
Informationen. Tatsache ist jedoch, da die entsprechenden Routinen im
ROM (!I)alle(!i) Register retten.

Nun zu den einzelnen Arrays. šber jedes Feld k”nnen bestimmte Ein- bzw.
Ausgaben get„tigt werden; es gilt:

!label control
!begin_xlist [WORD control[5!]] !short
!item [(!B)WORD control[5!](!b)]
šber dieses Feld werden Informationen ber die aufgerufene Funktion und ihre
Parameter festgelegt. Es gilt:
!begin_xlist
!item [control[0!]]
= Funktionsnummer
!item [control[1!]]
= Anzahl der Werte im int_in-Array
!item [control[2!]]
= Anzahl der Werte im int_out-Array
!item [control[3!]]
= Anzahl der Werte im addr_in-Array
1item [control[4!]]
= Anzahl der Werte im addr_out-Array
!end_xlist
Darber, welche Informationen vor einem AES-Aufruf gesetzt werden mssen,
gibt es keine klaren Informationen. N”tig ist es auf jeden Fall fr die
Elemente [0],[1] und [3]. Wenig sinnvoll erscheint es fr die Elemente [2]
und [4] zu sein - schlielich wissen die (!nolink [AES])-Funktionen ja selbst, wie viele
Werte sie in den Ausgabefeldern zurckliefern.

!label Globalfeld des AES
!label global
!item [(!B)WORD global[15!](!b)]
Dieses Feld enth„lt globale Daten fr die Applikation und wird teils von
appl_init, teils von anderen (!nolink [AES])-Funktionen benutzt, und automatisch
gefllt. Es gilt:
!begin_xlist [global[11,12]] !short
!label AES-Versionsnummer
!label Versionsnummer des AES
!item [global[0!]]
Versionsnummer der (!nolink [AES])
!label Multitasking vorhanden ?"                     
!item [global[1!]]
Anzahl der Applikationen, die gleichzeitig laufen k”nnen. Bei einem Wert
von -1 gibt es keine Beschr„nkung.
!item [global[2!]]
Kennung (ID) der Applikation
!item [global[3,4!]]
Beliebige Information, die nur fr die Applikation von Bedeutung ist und
von dieser gesetzt und gelesen werden kann.
!item [global[5,6!]]
Zeiger auf eine Liste von Zeigern auf die Objektb„ume der Applikation
(wird von rsrc_load gesetzt).
!item [global[7,8!]]
Adresse des fr die Resource-Datei reservierten Speichers. Nur von Digital
Research und (!I)nicht(!i) von Atari dokumentiert.
!item [global[9!]]
L„nge des reservierten Speichers. Nur von Digital Research und
(!I)nicht(!i) von Atari dokumentiert.
!item [global[10!]]
Anzahl der Farbebenen. Nur von Digital Research und (!I)nicht(!i) von
Atari dokumentiert.
!item [global[11,12!]]
reserviert
!item [global[13!]]
Maximale H”he eines Zeichens, die vom (!nolink [AES]) fr den vst_height-Aufruf
benutzt wird. Dieser Eintrag ist erst ab (!nolink [AES])-Version 4.0, und auch nur von
Atari dokumentiert. (!nl)
Ab PC-GEM Version 2.0 wird dieser Wert als Bitvektor mit
den auf dem Desktop angemeldeten Laufwerken interpretiert (Bit-15 =
Laufwerk-A).
!item [global[14!]]
Minimale H”he eines Zeichens, die vom (!nolink [AES]) fr den vst_height-Aufruf
benutzt wird. Dieser Eintrag ist erst ab (!nolink [AES])-Version 4.0, und auch nur von
Atari dokumentiert. (!nl)
Ab PC-GEM Version 2.0 wird dieser Wert als Bitvektor
interpretiert, der angibt, welche der in global[13] angegebenen Laufwerke
als Festplatten betrachtet werden k”nnen.
!end_xlist

!label int_in
!item [(!B)WORD int_in[16!](!b)]
šber dieses Feld werden alle 16-Bit groen Eingabeparameter bergeben.

!label int_out
!item [(!B)WORD int_out[10!](!b)]
šber dieses Feld liefert das (!nolink [AES]) alle 16-Bit groen Rckgabewerte.

!label addr_in
!item [(!B)LONG addr_in[8!](!b)]
Dieses Feld dient zur šbermittlung von Zeigern (z.B. Zeiger auf
Zeichenketten) an (!nolink [AES]) Funktionen.

!label addr_out
!item [(!B)LONG addr_out[2!](!b)]
šber dieses Feld werden 32-Bit groe Werte vom (!nolink [AES]) zurckgeliefert.
!end_xlist

(!B)Achtung:(!b) Wenn das Betriebssystem Threads untersttzt, muss unbedingt
darauf geachtet werden, eine Multithread-sichere Bibliothek zu verwenden.
Insbesondere muss sichergestellt werden, da jeder Thread sein
(!I)eigenes(!i) global-Feld (s.o) erh„lt.

Querverweis: (!link [Beispiel-Binding][Beispiel-Binding fr AES-Funktionen]) ~ VDI-Bindings ~
TOS Liste


!begin_node Beispiel-Binding fr AES-Funktionen

Die Funktion 'crys_if' (Crystal Interface) sorgt fr die Besetzung des
(!nolink [control])-Arrays, und macht den eigentlichen (!nolink [AES])-Aufruf.
Dazu bedient sie sich einer Tabelle, in der fr jede einzelne (!nolink [AES])-Funktion die
Werte fr
(!nolink [control])[1], (!nolink [control])[2] und (!nolink [control])[3] vermerkt sind.
!label crys_if

!begin_verbatim
AESPB c;

WORD crys_if (WORD opcode)
{
	WORD i, *paesb;
	
	control[0] = opcode;
	paespb = &ctrl_cnts[ (opcode-10)*3 ];
	
	for (i = 1; i < 4; i++)
		control[i] = *paespb++;
		
	aes (c);
	return (int_out[0]);
		
} /* crys_if */
!end_verbatim

Die dabei verwendete Tabelle k”nnte beispielsweise folgendermaen aufgebaut
sein:

!begin_verbatim
.GLOBAL ctrl_cnts
.DATA

ctrl_cnts: .dc.b     0,  1,  0       ; appl_init
           .dc.b     2,  1,  1       ; appl_read
           .dc.b     2,  1,  1       ; appl_write
            ...
            ...
            ...
          
.END
!end_verbatim

Querverweis: AES-Bindings  ~ GEM
!end_node
!end_node
!end_node



!end_node



###
### Beschreibung der AES-Funktionen
###

