## Hypertext zum TOS-Betriebssystem
## entwickelt fÅr den ST-Guide
##
## Last Edit: 29.08.1998
##
## Kapitel 4: AES-Funktionsaufrufe


!begin_node Das AES

Das AES (Application Environment (!nolink [Services])) ist der Teil des GEM, der die
direkte (grafische) Schnittstelle zum Benutzer realisiert. Mit Hilfe des
(!nolink [AES]) lassen sich verschiedene Konzepte wie Bildschirmfenster, MenÅzeilen,
Drop-Down oder Pop-Up MenÅs, Dialogboxen usw. komfortabel handhaben.
Dazu dienen die folgenden Bibliotheken:

!begin_xlist [˘ Applikationsverwaltung ] !short
!item [˘ (!link [Applikationsverwaltung][Applikationsfunktionen])] (appl_...)
!item [˘ Dateiauswahl]           (fsel_...)
!item [˘ Druckdialoge]           (pdlg_...)
!item [˘ Editobjekt-Funktionen]  (edit_...)
!item [˘ Ereignisverwaltung]     (evnt_...)
!item [˘ Fensterdialoge]         (wdlg_...)
!item [˘ Fensterverwaltung]      (wind_...)
!item [˘ Fileselektoren]         (fslx_...)
!item [˘ (!link [Formulare][Formularfunktionen])]              (form_...)
!item [˘ Grafikfunktionen]       (graf_...)
!item [˘ Listboxen]              (lbox_...)
!item [˘ (!link [MenÅs][MenÅfunktionen])]                  (menu_...)
!item [˘ (!link [Objekte][Objektfunktionen])]                (objc_...)
!item [˘ (!link [Resourceorganisation][Resourcefunktionen])]   (rsrc_...)
!item [˘ (!link [Shell-Kommunikation][Shellfunktionen])]    (shel_...)
!item [˘ (!link [X-Grafikfunktionen][Erweiterte Grafikfunktionen])]     (xgrf_...)
!item [˘ Zeichensatzauswahl]     (fnts_...)
!item [˘ (!link [Zwischenspeicher][Klemmbrett-Funktionen])]       (scrp_...)
!end_xlist

!label AES, Entstehung des
!label Entstehung des AES
Die Entwicklung des (!nolink [AES]) reicht bis in das Jahr 1984 zurÅck, als es von
(!I)Digital Research(!i) zunÑchst fÅr MS-DOS-Rechner entwickelt, und spÑter
auf die Apple Lisa (unter CP/M 68K) portiert wurde. Diese Version wurde dann
anschlieûend auf den Atari-ST (unter GEMDOS) portiert.

In der Version 4.0 wurde das (!nolink [AES]) stark Åberarbeitet, und stellt nun viele
neue und erweiterte Routinen zur VerfÅgung. öber die Funktion appl_getinfo
kann leicht festgestellt werden, ob (bzw. welche) neue(n) Mîglichkeiten zur
VerfÅgung stehen.

Querverweis: Grundlagen des AES ~ Bindings des AES ~ VDI
!end_node


!begin_node Grundlagen des AES
!label AES, Grundlagen des

(!nolink [Das AES]) (Application Environment (!nolink [Services])) bildet die obere Schicht des
GEM. Es befasst sich mit all jenen GEM-Bestandteilen, die Åber elementare
Grafikausgaben und -eingaben hinausgehen. Da das AES ausschlieûlich VDI-
und GEMDOS-Aufrufe tÑtigt, ist es sowohl von der Grafikhardware, vom
EingabegerÑt als auch vom Dateisystem unabhÑngig. In diesem Abschnitt
werden die folgenden Punkte behandelt:

!begin_itemize !short
!item Accessories in MagiC
!item (!link [Bindings des AES][AES-Bindings])
!item Das Desktop-Fenster
!item (!link [Datenaustausch per Klemmbrett][Der Datenaustausch Åber das GEM-Klemmbrett])
!item Nachrichten
!item (!link [Objektstruktur im AES][Die Objekt-Struktur])
!item (!link [Quarter-Screen-Buffer][Der Quarter-Screen-Buffer])
!item (!link [Rechteckliste eines Fensters][Die Rechteckliste eines Fensters])
!item (!link [Screen-Manager][Der Screen-Manager])
!item Startupcode fÅr Accessories
!item Toolbar-Support
!end_itemize
!label AES-Clones
!label Clones, AES-
!label NAES
!label MinA
!label AES im Quelltext?
!label Quelltext, AES im

Auch beim (!nolink [AES]) gibt es eine interessante Entwicklung, denn verschiedene
Programmierer haben mittlerweile eigene (!B)AES-Clones(!b) angekÅndigt; zur
Zeit sind hier die Projekte (!I)N.AES(!i) und (!I)XAAES(!i) zu nennen. Neben
einer stetigen Weiterentwicklung darf man wohl auch auf eine
Quelltext-Version dieser GEM Komponente hoffen.

Querverweis: Style-Guidelines


!begin_node Accessories in MagiC
!label MagiC, Accessories in

Unter MagiC sind Accessories den Programmen fast gleichgestellt. Ihre
Fenster bleiben beim Programmwechsel erhalten. Sie dÅrfen MenÅ und
Desktophintergrund besitzen, Programme nachladen, Speicher anfordern,
Dateien îffnen, schlieûen, lîschen, kopieren usw.

Da kein Grund mehr besteht, beim Programmwechsel Fenster zu schlieûen,
gibt es keine AC_CLOSE Meldung mehr. Accessories werden vom System nicht
von Programmen unterschieden, abgesehen davon, daû sie sich keinesfalls
beenden dÅrfen. ACCs dÅrfen sich wie unter (!nolink [GEM])/2 auch wieder im MenÅ
abmelden, und zwar mit dem (!nolink [AES])-Aufruf menu_unregister(). Anstelle von
ACCs sind unter (!nolink [MagiC]) Applikationen sinnvoll, die einfach nur eine
MenÅleiste mit einem MenÅ anmelden und im APP- Autostart- Ordner liegen.
Diese Applikationen kann man dann bei Bedarf nachladen und auch wieder
entfernen.

(!B)Hinweis:(!b) Ab (!nolink [MagiC])-4 kînnen Accessories zur Laufzeit nachgestartet
werden. Ferner ist es mîglich, bei einem Klick auf einen Accessory-Eintrag
(und gedrÅckter Control-Taste) das entsprechende Accessory zu entfernen. Ein
Nachteil ist, daû Accessories z.Zt. noch kein Pexec mit Modus 104 ausfÅhren
dÅrfen.

Querverweis: AES ~  GEM ~  Startupcode fÅr Accessories ~  shel_write
!end_node



!begin_node Das Desktop-Fenster
!label Fenster, Desktop-

Unter den verfÅgbaren Fenstern nimmt das Desktop- oder Hintergrundfenster
eine besondere Rolle ein. Es besitzt die Kennung 0, nimmt die gesamte
BildschirmflÑche in Anspruch, ist immer geîffnet und kann auch nicht
geschlossen werden. Der (!I)Arbeitsbereich(!i) ist die FlÑche unter der
MenÅleiste. Nur in diesem Arbeitsbereich dÅrfen andere Programme
Bildschirmausgaben machen oder eigene Fenster îffnen.

Normalerweise erscheint der Arbeitsbereich des Desktop als solide grÅne
FlÑche (im Farbbetrieb) bzw. als graues Raster (im Monochrombetrieb). Der
Screen-Manager kÅmmert sich vîllig selbsttÑtig um den Redraw; Åber einen
Aufruf von (!I)wind_set(!i) kînnen Anwendungsprogramme einen beliebigen
anderen Objektbaum als Hintergrund verankern. Auch dann kÅmmert sich der
Screen-Manager um das fÑllige Neuzeichnen von Bildausschnitten. Obwohl diese
Mîglichkeit sehr verlockend ist, gibt es etliche GrÅnde, die (!I)gegen(!i)
eine Benutzung des Desktop-Fensters sprechen; der wichtigste:

!begin_itemize
!item auch unter einem multitaskingfÑhigen GEM (MagiC oder MultiTOS), kann
es (!I)nur einen(!i) Bildschirmhintergrund geben. Dieser sollte dem Programm
vorbehalten bleiben, das daraus den meisten Nutzen ziehen kann - in der
Regel ist dies das Desktop bzw. ein Desktop-Ersatz wie z.B. die Shell
Gemini.
!end_itemize

Fazit: Der Desktop-Hintergrund sollte nach Mîglichkeit in eigenen Programmen
(!I)nicht(!i) benutzt werden.

Querverweis: AES  ~ wind_set ~  WF_NEWDESK
!end_node



!begin_node Der Datenaustausch Åber das GEM-Klemmbrett
!label Datenaustausch per Clipboard
!label Klemmbrett, Datenaustausch per
!label Clipboard, Datenaustausch per

Um Dateien im Klemmbrett abzulegen, sollte man folgendermaûen vorgehen:

!begin_itemize
!item alle Klemmbrett-Dateien, die auf die Maske 'scrap.*' und 'SCRAP.*'
passen, lîschen. Anmerkung: Die Maske 'SCRAP.*' muss berÅcksichtigt werden,
da alte Programme noch nichts von alternativen und case-sensitiven
Dateisystemen wussten.
!item die abzulegenden Daten in einem oder mehreren Formaten sichern.
!item die Nachricht SC_CHANGED an (!I)alle(!i) Applikationen im System,
SH_WDRAW an die System-Shell schicken.
!end_itemize

Der Dateiname ist (!I)immer(!i) 'scrap.', die Namenserweiterung (Suffix)
hÑngt dabei vom gewÑhlten Format ab; nach Mîglichkeit sollte (!I)immer(!i)
eines der folgenden Standardformate unterstÅtzt werden:

!begin_xlist [Suffix] !short
!item [Suffix]
Bedeutung
!item [~]
~
!item [gem]
Vektorgrafiken im Metafile-Format
!item [img]
Pixelbilder im XIMG-Format
!item [txt]
ASCII-Textdatei, jede Zeile mit CR/LF abgeschlossen
!end_xlist

ZusÑtzlich kann man eines oder mehrere der folgenden Formate unterstÅtzen
(der EmpfÑnger hat dann die Mîglichkeit, das Format mit den meisten
Informationen zu benutzen):

!begin_xlist [Suffix] !short
!item [Suffix]
Bedeutung
!item [~]
~
!item [asc]
ASCII-Textdatei, jeder Absatz mit CR/LF abgeschlossen
!item [csv]
ASCII-Datei mit durch Kommata getrennten Zahlen
!item [cvg]
Calamus Vektorgrafik-Format
!item [dif]
Export-Datei von Tabellenkalkulationen
!item [eps]
Encapsulated PostScript
!item [iwp]
Wordplus-Format
!item [rtf]
Microsoft Rich Text Format
!item [tex]
TeX
!end_xlist

Das empfangende Programm sollte zunÑchst ÅberprÅfen, welche der vorhandenen
Dateien die meisten Informationen enthÑlt, und dann diese Datei nehmen.

(!B)Wichtig:(!b) Jede der Dateien im Klemmbrett enthÑlt prinzipiell die
gleichen Informationen, nur eben in einem anderen Format. Die
Textverarbeitung (!I)Papyrus(!i) z.B. importiert 'scrap.rtf' nur dann, wenn
das eigene Format 'scrap.pap' nicht gefunden werden konnte.

Aus den obigen ErklÑrungen wird ersichtlich, daû sich immer nur (!I)ein(!i)
Datenobjekt (allerdings in verschiedenen Formaten) auf einmal im Klemmbrett
befinden kann.

Querverweis: Klemmbrett-Funktionen ~  scrp_clear  ~ Style-Guidelines
!end_node



!begin_node Nachrichten
!label AES-Messages

(!B)Die Standardmessages des Screenmanagers sind wie folgt aufgebaut:(!b)

!begin_xlist [ev_mgpbuff___]
!item [ev_mgpbuff[0!]]
Art der Message
!item [ev_mgpbuff[1!]]
ID der Applikation, die die Nachricht abgeschickt hat
!item [ev_mgpbuff[2!]]
Anzahl der Bytes die Åber die StandardlÑnge von 16 Bytes hinausgehen, und
dann mit appl_read gelesen werden mÅssen
!end_xlist

(!B)Arten der Standardmessages:(!b)

!begin_xlist [RESCH_COMPLETED (61)]
!item [Nachricht]
Bedeutung
!item [~]
~

!label AC_CLOSE
!item [AC_CLOSE (41)]
wird an ein Accessory geschickt, wenn die aktuelle Applikation beendet, der
Bildschirm gelîscht und der Windowmanager neu initialisiert wird.
!begin_xlist !short
!item [ev_mgpbuff[4!]]
Identifikator des Accessories 
!end_xlist
(!B)Hinweis:(!b) Diese Nachricht spielt in Multitaskingsystemen praktisch
keine Rolle mehr, und ist in MagiC auch nicht mehr vorhanden!

!label AC_OPEN
!item [AC_OPEN (40)]
ein Accessory wurde aktiviert
!begin_xlist !short
!item [ev_mgpbuff[4!]]
Identifikator des Accessories
!end_xlist

!label AP_DRAGDROP
!item [AP_DRAGDROP (63)]
ist ein Teil des Drag&Drop-Protokolls und wird vom Sender an den EmpfÑnger
geschickt.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Kennung des Zielfensters
!item [ev_mgpbuff[4!]]
X-Position des Mauszeigers
!item [ev_mgpbuff[5!]]
Y-Position des Mauszeigers
!item [ev_mgpbuff[6!]]
Keyboard-Shift-Status
!item [ev_mgpbuff[7!]]
zwei Zeichen der Pipe-Extension
!end_xlist
(!B)Hinweis:(!b) Wird anstelle einer gÅltigen Fensterkennung der Wert -1
Åbergeben, so ist das Ziel der Drag&Drop Operation kein spezielles Fenster,
sondern die Applikation selbst. Es sollte dann normalerweise ein
zusÑtzliches Fenster fÅr die angegebenen Daten geîffnet werden.

!label AP_RESCHG
!item [AP_RESCHG (57)]
durch diese Nachricht wird die betreffende Applikation darÅber informiert,
daû ein (!nolink [Auflîsungswechsel]) stattfinden soll. Der EmpfÑnger dieser Nachricht
sollte sich dann sobald wie mîglich beenden.

!label AP_TERM
!item [AP_TERM (50)]
das Betriebssystem fordert die Applikation auf, sich zu beenden. Dies kann
z.B. beim Auflîsungswechsel notwendig sein, oder von einem allgemeinen
Shut-Down Utility ausgelîst werden.
!begin_xlist !short
!item [ev_mgpbuff[5!]]
Grund des Shut-Downs, also z.B.
!begin_xlist [AP_RESCHG]!short
!item [AP_TERM]
(generell beenden)
!item [AP_RESCHG]
((!nolink [Auflîsungswechsel]))
!end_xlist
!end_xlist
(!B)Achtung:(!b) Entgegen der Åblichen Konvention (!I)muss(!i) in
ev_mgpbuff[1] der Wert -1 eingetragen werden, da lt. MagiC-Dokumentation
sonst nicht garantiert ist, daû der Desktop von einer Shut-Down-Sequenz
(Alternate-Control-Delete) ausgeht.

!label AP_TFAIL
!item [AP_TFAIL (51)]
wird vom EmpfÑnger einer AC_CLOSE bzw. AP_TERM Nachricht verschickt, falls
dieser sich (!I)nicht(!i) beenden mîchte oder kann.

!label CH_EXIT
!item [CH_EXIT (90)]
wird an den Parent-Prozess geschickt, wenn ein Child terminiert.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Applikations-ID des Childs
!item [ev_mgpbuff[4!]] 
Exit-Code des Childs
!end_xlist

!label CT_KEY
!item [CT_KEY (53)]
wird vom modularen Kontrollfeld XCONTROL verschickt, um TastendrÅcke
auswerten zu kînnen, die keine Auswirkungen auf Editfelder haben kînnen,
also z.B. HELP oder UNDO.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Highbyte: Scancode der gedrÅckten Taste.
(!nl)
Lowbyte : ASCII-Code der Taste.
!end_xlist

!label FNT_CHANGED
!item [FNT_CHANGED (83)]
wird verschickt, wenn zur Laufzeit GDOS-Fonts an- bzw. abgemeldet wurden.
(!nl)
Auf den Empfang dieser Nachricht sollte mit vst_unload_fonts und direkt
anschlieûendem vst_load_fonts reagiert werden. Dadurch ist sichergestellt,
daû die Applikation mit den aktuellen ZeichensÑtzen arbeiten kann.

!label MN_SELECTED
!item [MN_SELECTED (10)]
ein MenÅeintrag wurde ausgewÑhlt
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Objektnummer des Titeleintrags
!item [ev_mgpbuff[4!]]
Objektnummer des Eintrags
!item [ev_mgpbuff[5!]]
Zeiger auf die OBJECT-Struktur des MenÅbaums, wie er auch an
!item [ev_mgpbuff[6!]]
menu_bar Åbergeben wurde.
!item [ev_mgpbuff[7!]]
Parent des angewÑhlten Eintrags, d.h. die Objektnummer der
'heruntergefallenen' Box, die den Eintrag enthÑlt.
!end_xlist
(!B)Hinweis:(!b) Das Vorhandensein der erweiterten Nachricht (ev_mgpbuff[5]
und folgende) sollte am besten per (!link [appl_getinfo][%apgi_9]) (Opcode 9) ermittelt werden.

!label PRN_CHANGED
!item [PRN_CHANGED (82)]
Diese Nachricht wird vom GDOS-Konfigurationsprogramm an alle erreichbaren
Applikationen verschickt, um diese Åber énderungen an GerÑtetreibern zu
informieren. Es gilt:
!begin_xlist !short
!item [ev_mgpbuff[3!]]
GerÑtenummer
!item [ev_mgpbuff[4!]]
Aktion
!begin_table [c c l]
0 !! = !! neu
1 !! = !! geÑndert
2 !! = !! entfernt
!end_table
!end_xlist
Eine Applikation kann nach dem Empfang dieser Nachricht z.B. die
entsprechende Workstation neu îffnen, die jetzt aktuellen Einstellungen
ermitteln, und einen evtl. Preview neu anbieten.

!label RESCH_COMPLETED
!item [RESCH_COMPLETED (61)]
diese Nachricht wird an diejenige Applikation geschickt, die einen
Auflîsungswechsel eingeleitet hat. Wenn kein Fehler aufgetreten ist, muû
diese sich nun auch beenden.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Status (0 = Fehler, 1 = 0k)
!end_xlist

!label SC_CHANGED
!item [SC_CHANGED (80)]
diese Nachricht sollte von einem Programm an alle anderen Applikationen im
System verschickt werden, wenn dieses den Inhalt des GEM-Klemmbrettes
verÑndert hat.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Beschreibung des File-Formats:
!begin_xlist !short
!item [0x0000 =]
keine genauere Spezifizierung
!item [0x0001 =]
Daten fÅr eine Datenbank
!item [0x0002 =]
Textdateien
!item [0x0004 =]
Vektor-Grafiken
!item [0x0008 =]
Raster-Grafiken
!item [0x0010 =]
Spreadsheet-Daten
!item [0x0020 =]
Samples, MIDI-Files, Sound
!item [0x0040 =]
Archivdateien (z.B. ".zip", ".lzh")
!item [0x8000 =]
Systemdateien (z.B. Farbpaletten)
!end_xlist
Dabei sollte das Format 0x0000 nach Mîglichkeit vermieden werden!
!item [ev_mgpbuff[4!]]
4 Zeichen, die das "beste" Format (mîglichst wenig Informationsverlust) fÅr
!item [ev_mgpbuff[5!]]
den Datenimport beschreiben. Beispiel: ".RTF" statt ".TXT"
!item [ev_mgpbuff[6!]]
reserviert, 0
!item [ev_mgpbuff[7!]]
reserviert, 0
!end_xlist

!label SH_WDRAW
!item [SH_WDRAW (72)]
diese Nachricht sollte von einer Applikation an die System-Shell versandt
werden, wenn der Inhalt eines Laufwerkes verÑndert worden ist. Die Shell
kann daraufhin die entsprechenden Fenster aktualisieren.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Laufwerk (0 = A, 1 = B, usw).
!end_xlist
(!B)Hinweis:(!b) Ein Wert von -1 bedeutet, daû die Shell alle Fenster
aktualisieren soll.

!label SHUT_COMPLETED
!item [SHUT_COMPLETED (60)]
wird vom Betriebssystem an den Initiator eines Shut-Down geschickt, wenn
alle anderen Applikationen davon bereits informiert wurden, und diese
positiv reagiert haben.

!label SM_M_SPECIAL
!label Applikation, Einfrieren einer
!label Prozesses, Einfrieren eines
!label Einfrieren einer Applikation
!label Applikation, Auftauen einer
!label Prozesses, Auftauen eines
!label Auftauen einer Applikation
!label Applikation, Umschalten auf
!label Prozess, Umschalten auf einen
!label Umschalten auf eine Applikation
!item [SM_M_SPECIAL (101)]
diese Nachricht steht nur unter (!nolink [MagiC]) (ab Version 2.0) zur
VerfÅgung, und muû an den Screen-Manager geschickt werden.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
0
!item [ev_mgpbuff[4!]]
'MA'
!item [ev_mgpbuff[5!]]
'GX'
!item [ev_mgpbuff[6!]]
gewÅnschte Aktion; es gilt:
!begin_xlist !short
!item [0 =]
Redraw ausfÅhren
!item [1 =]
Applikation beenden
!item [2 =]
auf Applikation umschalten
!item [3 =]
Applikation einfrieren
!item [4 =]
Applikation wieder auftauen
!item [5 =]
z.Zt. keine Information bekannt
!item [6 =]
alle Applikationen einblenden
!item [7 =]
andere Applikationen ausblenden
!item [8 =]
aktuelle Applikation ausblenden
!end_xlist
!item [ev_mgpbuff[7!]]
ID der zu behandelnden Applikation
!end_xlist
(!B)Hinweis:(!b) Die Codes 6..8 von ev_mgpbuff[6] stehen dabei erst ab
MagiC-Version 3.1 zur VerfÅgung.

!label THR_EXIT
!item [THR_EXIT (88)]
Diese Nachricht wird an den Thread bzw. die Applikation geschickt, der bzw.
die den beendeten Thread erzeugt hat. Es gilt:
!begin_xlist !short
!item [ev_mgpbuff[3!]]
AES ID des beendeten Threads
!item [ev_mgpbuff[4!]]
RÅckgabe- bzw. Fehlercode als
!item [ev_mgpbuff[5!]]
LONG-Wert
!end_xlist

!label WM_ALLICONIFY
!item [WM_ALLICONIFY (36)]
alle Fenster der Applikation sollen zu einem ikonifizierten Fenster
zusammengefaût werden.
!begin_xlist !short
!item [ev_mgpbuff[4!]]
X-Koordinate
!item [ev_mgpbuff[5!]]
Y-Koordinate
!item [ev_mgpbuff[6!]]
Breite
!item [ev_mgpbuff[7!]]
Hîhe des ikonifizierten Fensters
!end_xlist

!label WM_ARROWED
!label WA_UPPAGE
!label WA_DNPAGE
!label WA_UPLINE
!label WA_DNLINE
!label WA_LFPAGE
!label WA_RTPAGE
!label WA_LFLINE
!label WA_RTLINE
!item [WM_ARROWED (24)]
ein Pfeil oder Rollbalken wurde angeklickt.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
einer der folgenden Werte:
!begin_xlist !short
!item [WA_UPPAGE (0) =]
Seite nach oben
!item [WA_DNPAGE (1) =]
Seite nach unten
!item [WA_UPLINE (2) =]
Zeile nach oben
!item [WA_DNLINE (3) =]
Zeile nach unten
!item [WA_LFPAGE (4) =]
Seite nach links
!item [WA_RTPAGE (5) =]
Seite nach rechts
!item [WA_LFLINE (6) =]
Spalte nach links
!item [WA_RTLINE (7) =]
Spalte nach rechts  
!end_xlist
!end_xlist

!label WM_BOTTOMED
!item [WM_BOTTOMED (33)]
wird vom Screen-Manager benutzt um die Applikation aufzufordern, ein Fenster
in den Hintergrund zu legen.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des betreffenden Fensters
!end_xlist
(!B)Hinweis:(!b) das Fenster kann von der Applikation dann einfach per
wind_set (ev_mgpbuff[3], WF_BOTTOM, 0, 0 ,0, 0) in den Hintergrund gelegt
werden. Unter MagiC 2.0 heiût diese Meldung noch WM_M_BDROPPED.

!label WM_CLOSED
!item [WM_CLOSED (22)]
das oberste Fenster soll geschlossen werden
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des zu schlieûenden Fensters
!end_xlist

!label WM_FULLED
!item [WM_FULLED (23)]
der Fullsizeknopf des obersten Fensters wurde angeklickt.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters, das auf volle Grîûe gebracht werden soll
!end_xlist

!label WM_HSLID
!item [WM_HSLID (25)]
der horizontale Rollbalken wurde verschoben
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
die neue Sliderposition:
!begin_table [c c l]
0000 !! = !! ganz links
1000 !! = !! ganz rechts
!end_table
!end_xlist

!label WM_ICONIFY
!item [WM_ICONIFY (34)]
ein Fenster der Applikation soll ikonifiziert werden.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Kennung des betreffenden Fensters
!item [ev_mgpbuff[4!]]
X-Koordinate
!item [ev_mgpbuff[5!]]
Y-Koordinate
!item [ev_mgpbuff[6!]]
Breite
!item [ev_mgpbuff[7!]]
Hîhe des ikonifizierten Fensters
!end_xlist

!label WM_M_BDROPPED
!item [WM_M_BDROPPED (100)]
wird vom Screen-Manager benutzt um die Applikation aufzufordern, ein Fenster
in den Hintergrund zu legen. Ab MagiC-3 wird nicht mehr dieser Opcode,
sondern WM_BOTTOMED verschickt.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des betreffenden Fensters
!end_xlist

!label WM_MOVED
!item [WM_MOVED (28)]
das ganze Fenster wurde verschoben
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
neue x-Koordinate
!item [ev_mgpbuff[5!]]
neue y_Koordinate
!item [ev_mgpbuff[6!]]
neue Fensterbreite (unverÑndert)
!item [ev_mgpbuff[7!]]
neue Fensterhîhe (unverÑndert)
!end_xlist

!label WM_NEWTOP
!item [WM_NEWTOP (29)]
das Fenster wurde nach oben gebracht
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!end_xlist

!label WM_ONTOP
!item [WM_ONTOP (31)]
ein Fenster wird (nach dem Schlieûen oder Deaktivieren eines anderen
Fensters) zum aktuellen bzw. aktiven.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des betreffenden Fensters
!end_xlist
(!B)Hinweis:(!b) zum Zeitpunkt der Ankunft der Nachricht kann sich der
Fensterstapel bereits wieder verÑndert haben. Die Nachricht wird nur
verschickt, wenn die Applikation nicht mit einem Aufruf das Fenster selbst
in den Vordergrund gesetzt hat.

Nachrichten dieses Typs werden im AES-Messagepuffer verschmolzen. Daraus
folgt, daû immer die letzte Nachricht dieser Art empfangen wird; es kînnen
sich also nicht mehrere dieser Nachrichten im Puffer befinden.

!label WM_REDRAW
!item [WM_REDRAW (20)]
ein Fensterbereich muû neu gezeichnet werden
!begin_xlist
!item [ev_mgpbuff[3!]]
Handle des neuzuzeichnenden Fensters
!item [ev_mgpbuff[4!]]
x-Koordinate des Bereichs
!item [ev_mgpbuff[5!]]
y-Koordinate des Bereichs
!item [ev_mgpbuff[6!]]
Breite des Bereichs
!item [ev_mgpbuff[7!]]
Hîhe des Bereichs
!end_xlist

!label WM_SIZED
!item [WM_SIZED (27)]
die Fenstergrîûe wurde verÑndert
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
neue x-Koordinate (unverÑndert)
!item [ev_mgpbuff[5!]]
neue y_Koordinate (unverÑndert)
!item [ev_mgpbuff[6!]]
neue Fensterbreite
!item [ev_mgpbuff[7!]]
neue Fensterhîhe 
!end_xlist

!label WM_TOOLBAR
!item [WM_TOOLBAR (37)]
behandelt Mausklicks in ein Toolbar-Objekt; es gilt:
!begin_xlist [ev_mgpbuff___]
!item [ev_mgpbuff[3!]]
Kennung des Fensters
!item [ev_mgpbuff[4!]]
angeklicktes Objekt
!item [ev_mgpbuff[5!]]
Anzahl der Mausklicks
!item [ev_mgpbuff[6!]]
Tastatur-Status von Shift, Alternate und Control
!end_xlist
(!B)Hinweis:(!b) Bei allen Objekten der Toolbox sollte das Flag TOUCHEXIT
gesetzt werden.

!label WM_TOPPED
!item [WM_TOPPED (21)]
ein Fenster soll zum oben liegenden Fenster werden.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des nach oben zu holenden Fensters
!end_xlist

!label WM_UNICONIFY
!item [WM_UNICONIFY (35)]
ein oder mehrere Fenster der Applikation sollen unikonifiziert werden. Falls
mehrere Fenster betroffen sind (WM_ALLICONIFY) ist die Applikation auf sich
allein gestellt, da das AES keine Informationen Åber die betroffenen Fenster
sowie deren Positionen/Ausmaûe bereitstellt.
!begin_xlist [ev_mgpbuff___]
!item [ev_mgpbuff[3!]]
Kennung des betreffenden Fensters
!item [ev_mgpbuff[4!]]
X-Koordinate
!item [ev_mgpbuff[5!]]
Y-Koordinate
!item [ev_mgpbuff[6!]]
Breite
!item [ev_mgpbuff[7!]]
Hîhe des unikonifizierten Fensters
!end_xlist

!label WM_UNTOPPED
!item [WM_UNTOPPED (30)]
ein Fenster wird gerade inaktiv.
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des betreffenden Fensters
!end_xlist
(!B)Hinweis:(!b) zum Zeitpunkt der Ankunft der Nachricht kann sich der
Fensterstapel bereits wieder verÑndert haben. Die Nachricht wird nur
verschickt, wenn die Applikation nicht mit einem Aufruf das Fenster selbst
in den Hintergrund gelegt hat.

!label WM_VSLID
!item [WM_VSLID (26)]
der vertikale Rollbalken wurde verschoben
!begin_xlist !short
!item [ev_mgpbuff[3!]]
Handle des Fensters
!item [ev_mgpbuff[4!]]
die neue Sliderposition:
!begin_table [c c l]
0000 !! = !! ganz oben
1000 !! = !! ganz unten
!end_table
!end_xlist
!end_xlist
Die UnterstÅtzung der neuen Nachrichtentypen kann per (!link [appl_getinfo][%apgi_12]) (Opcode
12) erfragt werden. FÅr benutzerdefinierte Mitteilungen hat (!I)Digital
Research(!i) Åbrigens Message-Nummern jenseits von 1024 vorgeschlagen.

Zur Grîûe des Nachrichtenpuffers:

Eine einzelne Applikation sollte unter MagiC 2.0 nicht mehr als 16 Fenster
nutzen, da sonst der Nachrichtenpuffer des Systems Åberlaufen kann und
evtl. Redraws nicht mehr ausgefÅhrt werden kînnen.

Querverweis: evnt_multi  ~   evnt_mesag ~ AV-Protokoll ~ OLGA-Protokoll ~
             (!link [Drag&Drop][Drag&Drop-Protokoll])
!end_node



!begin_node Die Objekt-Struktur

Die Datenstruktur des Objektbaums ist zwar kein Baum im Sinne eines
BinÑrbaums, besitzt jedoch innerhalb eines Zeigers die logischen
Verkettungen eines Baums, mit VorgÑngern und Nachfolgern. Die Spezifikation
von VorgÑngern und Nachfolgern wird durch Indizes auf ein Array vorgenommen.
Die Baumstruktur der einzelnen Objekte kann man sich am leichtesten an Hand
eines einfachen Beispiels veranschaulichen: Ein MenÅ setzt sich zunÑchst aus
der MenÅleiste zusammen. Diese enthÑlt wiederum mehrere Titeltexte. Die
Titeltexte sind also direkt in der MenÅleiste enthalten, sie sind beide
Nachfolger des Objekts 'MenÅleiste', bewegen sich also auf der selben
hierarchischen Ebene. Das Objekt MenÅleiste verweist mit (!I)ob_head(!i) auf
den ersten MenÅtitel und mit (!I)ob_tail(!i) auf den letzten MenÅtitel. Im
ersten MenÅtitel dient der Zeiger (!I)ob_next(!i) zur Adressierung des
nÑchsten MenÅtitels. Die Verkettung weist also folgende Struktur auf:
!begin_verbatim
      MenÅleiste:
   +---------+---------+--------+
   | ob_head | ob_tail | ...    |
   |    o    |    o    |        |
   +----|----+----|----+--------+
        |         +-------------------------+
        V                                   V
   +---------+---------+--------+       +---------+---------+--------+
   | ...     | ob_next | ...    |  ...  | ...     | ...     | ...    |
   |         |    o    |        |       |         |         |        |
   +---------+----|----+--------+       +---------+---------+--------+
      1.MenÅtitel |                         n-ter MenÅtitel
                  +-----> 2.MenÅtitel
!end_verbatim
Welche Aktionen mit einem Objekt durchgefÅhrt werden dÅrfen, wird in
(!I)ob_flags(!i) festgelegt. Der Zustand eines Objekts wird im Eintrag
(!I)ob_state(!i) festgehalten. Der Eintrag (!I)ob_type(!i) legt den
Objekttyp fest. Manche Objekte benîtigen zur exakten Festlegung eine
zusÑtzliche Datenstruktur, wie TEDINFO oder BITBLK. In ob_spec wird dann
ein Zeiger auf diese zusÑtzliche Struktur abgelegt. Zusammenfassend
nochmals der Gesamtaufbau der Datenstruktur fÅr Objekte OBJECT:
!begin_verbatim
         +-------------+
         |  ob_next    |   Index fÅr das nÑchste Objekt
         +-------------+
         |  ob_head    |   Index des ersten Kindes
         +-------------+
         |  ob_tail    |   Index des letzten Kindes
         +-------------+
         |  ob_type    |   Objektart
         +-------------+
         |  ob_flags   |   Manipulationsflags
         +-------------+
         |  ob_state   |   Objektstatus
         +-------------+
         |  ob_spec    |   siehe unter Objektart
         +-------------+
         |  ob_x       |   relative x-Koordiante zum Eltern-Objekt
         +-------------+
         |  ob_y       |   relative y-Koordinate zum Eltern-Objekt
         +-------------+
         |  ob_width   |   Breite des Objekts
         +-------------+
         |  ob_height  |   Hîhe des Objekts
         +-------------+
!end_verbatim
Querverweis: Objektfarben des AES ~ (!link [Objektart][Objektarten des AES]) ~
(!link [Manipulationsflags][Objektflags des AES]) ~ (!link [Objektstatus][Objektstati des AES])



!begin_node Objektarten des AES
!label Objekttypen des AES

Folgende Objektarten stehen zur Auswahl:


!begin_xlist [G_WINTITLE (36)]
!item [Art]
Bedeutung

!label G_BOX
!item [G_BOX      (20)]
Rechteckiger Kasten. ob_spec enthÑlt verschiedene Informationen Åber
RahmenstÑrke, Farbe und Ñhnliches.

!label G_TEXT
!item [G_TEXT     (21)]
Grafiktext, ob_spec zeigt auf TEDINFO-Struktur.

!label G_BOXTEXT
!item [G_BOXTEXT  (22)]
rechteckiger Kasten mit Grafiktext, ob_spec zeigt auf (!nolink [TEDINFO])-Struktur.

!label G_IMAGE
!item [G_IMAGE    (23)]
Bild, ob_spec zeigt auf BITBLK-Struktur.

!label USERDEF
!label G_USERDEF
!item [G_USERDEF  (24)]
Benutzerdefinierte Funktion zum Zeichnen eines eigenen Objekts. ob_spec
verweist auf eine USERBLK Struktur.

!label G_IBOX
!item [G_IBOX     (25)]
Transparentes Rechteck, das nur gesehen werden kann, wenn die Umrandung
nicht die Dicke Null hat. ob_spec enthÑlt weitere Informationen Åber das
Aussehen.

!label G_BUTTON
!item [G_BUTTON   (26)]
Text mit Rahmen fÅr Optionsauswahl. ob_spec zeigt auf eine Zeichenkette mit
dem Text, der in dem Knopf erscheinen soll. (!B)Neu ab MagiC-Version 3.0:(!b)
Ist das Objektflag WHITEBAK gesetzt, und Bit-15 im Objektstatus = 0, so wird
der Button unterstrichen; dabei gilt: (Highbyte&0xf) von ob_state ist die
gewÅnschte Unterstreichposition. Falls hingegen Bit-15 = 1 ist, so handelt
es sich um einen Sonderbutton (Radio-Button oder Checkbox).

Weitere Besonderheiten: WHITEBAK=1, Bit-15 = 1 und in ob_state
!begin_xlist !short
!item [Highbyte = -2]
==> Gruppenrahmen
!item [Highbyte = -1]
==> Sonderbutton, nicht unterstr.
!item [Highbyte != -1,-2]
==> Sonderbutton, unterstr.
!end_xlist
(dabei ist wieder (Highbyte&0xf) von ob_state die Unterstreichposition). Das
Vorhandensein dieser Features sollte am besten Åber die Funktion
(!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label G_BOXCHAR
!item [G_BOXCHAR  (27)]
Rechteck, mit einem Zeichen. In ob_spec wird nicht nur das Aussehen der
Umrandung, sondern auch das Zeichen definiert.

!label G_STRING
!item [G_STRING   (28)]
Zeichenkette, ob_spec zeigt auf den String. (!B)Neu ab MagiC-Version 3.0:(!b)
Ist das Objektflag WHITEBAK gesetzt, und das Highbyte von ob_state != -1, so
wird der String unterstrichen; die Unterstreich-Position wird dabei durch
(Highbyte & 0xf) von ob_state geregelt.

Bei gesetztem (!nolink [WHITEBAK])-Flag und Highbyte von ob_state = -1, wird der
komplette String unterstrichen. Das Vorhandensein dieser Features sollte am
besten per (!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label G_FTEXT
!item [G_FTEXT    (29)]
Formatierter Grafiktext, ob_spec zeigt auf TEDINFO-Struktur

!label G_FBOXTEXT
!item [G_FBOXTEXT (30)]
Rechteck mit formatiertem Grafiktext, ob_spec zeigt auf (!nolink [TEDINFO])-Struktur.

!label G_ICON
!item [G_ICON     (31)]
Icon-Symbol, ob_spec zeigt auf die ICONBLK-Struktur.

!label G_TITLE
!item [G_TITLE    (32)]
Titel eines Drop-Down-MenÅs, ob_spec zeigt auf den String. Ab MagiC-2 kann
dabei auch ein Buchstabe unterstrichen werden. Dies geht wie folgt:

WHITEBAK in ob_state setzen
!begin_xlist !short
!item [(ob_state >> 8) & 0xf]
= Position des Unterstrichs
!item [(ob_state >> 8) & 0xf0]
ist 0
!end_xlist

!label G_CICON
!item [G_CICON    (33)]
Farb-Icon, ob_spec zeigt auf die CICONBLK-Struktur.

!label G_SWBUTTON
!item [G_SWBUTTON (34)]
Cycle-Button (d.h. ein Button, der beim Anklicken seinen Text zyklisch
Ñndert), ob_spec zeigt auf eine SWINFO-Struktur. Das Vorhandensein dieses
Objekttyps sollte per (!link [appl_getinfo][%apgi_13]) (Opcode 13) erfragt werden.

!label G_POPUP
!item [G_POPUP    (35)]
PopUp-MenÅ, ob_spec zeigt auf eine POPINFO-Struktur. Falls das MenÅ mehr als
16 EintrÑge umfaût, so ist dieses scrollbar. Das Vorhandensein dieses
Objekttyps sollte per (!nolink [appl_getinfo]) (Opcode 13) erfragt werden. Hinweis:
G_POPUP sieht wie G_BUTTON aus, die Zeichenkette wird jedoch nicht
zentriert, um mîglichst mit den Zeichenketten im MenÅ auf einer Linie zu
liegen.

!label G_WINTITLE
!item [G_WINTITLE (36)]
Diese Objektnummer wird von MagiC intern dazu verwendet, Fenstertitel
darzustellen. Der Aufbau dieses Objekttyps kann sich jederzeit Ñndern und
wird daher nicht dokumentiert.

!label G_EDIT
!item [G_EDIT     (37)]
Ab MagiC 5.20 steht ein in einer Shared-Library implementiertes Editobjekt
zur VerfÅgung. ob_spec verweist auf das Objekt. Achtung: Dieser Typ wird von
den Funktionen (!nolink [form_do]), (!nolink [form_xdo]), (!nolink [form_button]),
(!nolink [form_keybd]), (!nolink [objc_edit]),
(!nolink [wdlg_evnt]) und wdlg_do z.Zt. noch (!I)nicht(!i) unterstÅtzt, d.h. die
entsprechenden Ereignisse mÅssen selbst (per edit_evnt) an das Objekt
weitergeleitet werden.

!label G_SHORTCUT
!item [G_SHORTCUT (38)]
Dieser Typ wird Ñhnlich wie G_STRING behandelt, ein vorhandenes
TastaturkÅrzel wird jedoch abgespalten und rechtsbÅndig ausgegeben. Das
Vorhandensein dieses Objekttyps sollte per (!nolink [appl_getinfo]) (Opcode 13) erfragt
werden.
                    
Die EinfÅhrung proportionaler AES-ZeichensÑtze machte eine
neue Strategie fÅr die Ausrichtung der MenÅeintrÑge erforderlich. Um
TastaturkÅrzel rechtsbÅndig ausrichten zu kînnen, werden Objekte vom Typ
G_STRING innerhalb eines MenÅs entsprechend in Kommando und KÅrzel
aufgespalten. Diese Strategie versagt jedoch bei MenÅs, die vom Programm
selbst, z.B. innerhalb eines Fensters oder eines Popup-MenÅs, verwaltet
werden. Um auch hier eine brauchbare Ausrichtung zu erreichen, muûte dieser
neue Objekttyp eingefÅhrt werden.

!label G_SLIST
!item [G_SLIST (39)]
XaAES extended object - scrolling list



!end_xlist
(!B)Hinweis:(!b) FÅr G_BOX, G_IBOX und G_BOXCHAR zeigt die Komponente
(!I)ob_spec(!i) der OBJECT-Struktur (!I)nicht(!i) auf eine andere
Datenstruktur, sondern enthÑlt weitere Informationen zum Aussehen des
Objektes. Dabei gilt:

!begin_xlist !short
!item [Bits]
Bedeutung
!item [~]
~
!item [24..31]
darzustellendes Zeichen (nur bei G_BOXCHAR)
!item [16..23]
!begin_xlist [-1..127] !short
!item [0]
= Rahmendicke
!item [1..128]
= Rahmen liegt 1..128 Pixel im inneren des Objekts
!item [-1..-127]
= Rahmen liegt 1..127 Pixel auûerhalb des Objekts
!end_xlist
!item [12..15]
Rahmenfarbe (0..15)
!item [08..11]
Textfarbe   (0..15)
!item [7]
Text transparent (0) oder deckend (1)
!item [04..06]
!begin_xlist !short
!item [0]
= hohl
!item [1]
= ansteigende IntensitÑt
!item [2]
~
!item [.]
~
!item [.]
~
!item [7]
= solide FlÑche
!end_xlist
!item [00..03]
Innenfarbe (0..15)
!end_xlist
Das Hibyte wird vom AES nur fÅr SubmenÅs verwendet. Ist das hîchste Bit von
ob_type 0x8000, sowie das Bit SUBMENU in ob_flags gesetzt, so geben die Bits
8..14 an, welches SubmenÅ mit dem MenÅeintrag gekoppelt ist. Jede
Applikation kann daher maximal 128 SubmenÅs haben. MagiC liest aus ob_type
stets nur das Lowbyte aus, auûer fÅr die SubmenÅ-Behandlung. TOS reagiert
auf unbekannte Objekttypen (z.B. die reinen (!nolink [MagiC])-Typen G_SWBUTTON usw.)
sauber, d.h. die Objekte werden nicht gezeichnet.

Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~  Objektfarben des AES
!end_node



!begin_node Objektfarben des AES

Die folgende Tabelle enthÑlt die vordefinierten Objektfarben. Einzelheiten
hÑngen natÅrlich von der gewÑhlten Bildauflîsung, sowie den Einstellungen
des Benutzers ab.

!begin_table [l|l|r]
Nummer !! Farbe !! Standard RGB-Werte
!hline
WHITE    (00) !! Weiû          !! 1000, 1000, 1000
BLACK    (01) !! Schwarz       !!    0,    0,    0
RED      (02) !! Rot           !! 1000,    0,    0
GREEN    (03) !! GrÅn          !!    0, 1000,    0
BLUE     (04) !! Blau          !!    0,    0, 1000
CYAN     (05) !! Cyan          !!    0, 1000, 1000
YELLOW   (06) !! Gelb          !! 1000, 1000,    0
MAGENTA  (07) !! Magenta       !! 1000,    0, 1000
DWHITE   (08) !! Hellgrau      !!  752,  752,  752
DBLACK   (09) !! Dunkelgrau    !!  501,  501,  501
DRED     (10) !! Dunkelrot     !!  713,    0,    0
DGREEN   (11) !! DunkelgrÅn    !!    0,  713,    0
DBLUE    (12) !! Dunkelblau    !!    0,    0,  713
DCYAN    (13) !! Dunkelcyan    !!    0,  713,  713
DYELLOW  (14) !! Dunkelgelb    !!  713,  713,    0
DMAGENTA (15) !! Dunkelmagenta !!  713,    0,  713
!end_table
(!B)Hinweis:(!b) Diese Farben entsprechen auch weitestgehend den unter
Windows und OS/2 verwendeten Iconfarben. öber ein geeignetes CPX-Modul
kînnen die richtigen RGB-Werte fÅr die ersten 16 Farben eingestellt werden.

Querverweis: (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node



!begin_node Objektflags des AES

Die Manipulationsflags eines Objektes bestimmen seine Eigenschaften.
Folgende Mîglichkeiten stehen zu Auswahl:

!begin_xlist [TOUCHEXIT  (0x0040)]
!item [Flag]
Bedeutung

!item [NONE       (0x0000)]
Keine Eigenschaften.

!label SELECTABLE
!item [SELECTABLE (0x0001)]
Das Objekt ist selektierbar.

!label DEFAULT
!item [DEFAULT    (0x0002)]
Wenn der Benutzer die 'Return' oder 'Enter' Taste drÅckt, wird dieses Objekt
automatisch selektiert. Diese Flag ist pro Baum nur einmal zugelassen.

!label EXIT
!item [EXIT       (0x0004)]
Beim Anklicken eines solchen Objektes wird der Dialog beendet (siehe auch
form_do).

!label EDITABLE
!item [EDITABLE   (0x0008)]
Dieses Objekt kann vom Benutzer mittels der Tastatur editiert werden.

!label RBUTTON
!item [RBUTTON    (0x0010)]
Haben im selben Objektbaum mehrere Objekte die eigenschaft RBUTTON, so kann
immer nur eines dieser Objekte selektiert sein. Diese Objekte sollten alle
Kinder eines Elternobjekts mit der Objektart G_IBOX sein. Wird ein anderes
Objekt dieser Gruppe ausgewÑhlt, wird das zuvor selektierte automatisch
deselektiert.

!label LASTOB
!item [LASTOB     (0x0020)]
Hierbei handelt es sich um das letzte Objekt innerhalb eines Objektbaumes.

!label TOUCHEXIT
!item [TOUCHEXIT  (0x0040)]
Der Dialog (siehe auch form_do) wird beendet, sobald sich der Mauszeiger
Åber diesem Objekt befindet, und der linke Mausknopf gedrÅckt wird.

!label HIDETREE
!label HIDDEN
!item [HIDETREE   (0x0080)]
Das Objekt und seine Kinder werden von objc_draw und objc_find nicht mehr
bemerkt, sobald dieses Flag gesetzt ist. Weiterhin wird das Flag ab MagiC
5.20 auch von form_keybd ausgewertet, wenn Objekte zu TastenkÅrzeln gesucht
werden. Eine Eingabe in versteckte Objekte ist jedoch immer noch mîglich.
Um dies zu verhindern, muû das Flag EDITABLE gelîscht werden.

!label INDIRECT
!item [INDIRECT   (0x0100)]
ob_spec zeigt nun auf einen weiteren Zeiger, der dann auf den eigentlichen
Wert von ob_spec zeigt (siehe auch OBJECT). Auf diese Weise lassen sich die
Standarddatenstrukturen wie TEDINFO etc. auf einfache Art erweitern.

!label FL3DIND
!item [FL3DIND    (0x0200)]
Dieses Objekt erzeugt unter MultiTOS ein dreidimensionales Objekt (unter
MagiC (ab Version 3.0) erst ab 16 Farben, und wenn der 3D-Effekt nicht
abgeschaltet wurde). Im 3D-Betrieb wird dies als Indikator aufgefaût. Bei
diesen Objekten handelt es sich i.d.R. um Buttons, die einen Status
anzeigen, beispielsweise Radio-Buttons.

!label ESCCANCEL
!item [ESCCANCEL (0x0200)]
Das DrÅcken der ESC Taste entspricht einem AnwÑhlen des Objekts mit
diesem Flag. Deshalb darf es nur ein Default Objekt in einem Dialog
geben. Dieses Flag wurde mit ViewMAX beta eingefÅhrt.

!label FL3DBAK
!item [FL3DBAK    (0x0400)]
Dieses Objekt wird im 3D-Betrieb als Hintergrund aufgefaût, und entsprechend
gezeichnet. Es empfiehlt sich in Dialogen mit 3D-Buttons das ROOT Objekt mit
diesem Flag zu belegen. Gleiches gilt fÅr Eingabefelder und Textobjekte,
denn nur so wird eine einheitliche Hintergrundfarbe erhalten.

!label BITBUTTON
!item [BITBUTTON (0x0400)]
Dieses Flag wurde mit ViewMAX beta eingefÅhrt, wird dort aber nicht
benutzt. Vermutlich enthÑlt ein Button mit diesem Flag eine Bitmap
anstelle eines Textes.

!label FL3DACT
!item [FL3DACT    (0x0600)]
Dieses Objekt wird im 3D-Betrieb als Aktivator aufgefaût. Bei diesen
Objekten handelt es sich i.d.R. um Buttons, mit denen man Dialoge verlassen,
oder sonstwie eine Aktion hervorrufen kann.

!label SUBMENU
!item [SUBMENU    (0x0800)]
Wird in MultiTOS und ab MagiC 5.10 verwendet, um SubmenÅs zu kennzeichnen.
menu_attach setzt dieses Bit in einem MenÅeintrag, um zu kennzeichnen, daû
hier ein SubmenÅ angehÑngt ist. Das Hibyte von ob_type enthÑlt dann die
SubmenÅ-Nummer (128..255) d.h. Bit 15 von ob_type ist immer gleichzeitig mit
SUBMENU gesetzt.

!label SCROLLER
!item [SCROLLER (0x0800)]
Das DrÅcken der PAGEUP Taste entspricht einem AnwÑhlen des ersten
Objekts mit diesem Flag in dem Dialog. Das DrÅcken der PAGEDOWN Taste
entspricht einem AnwÑhlen des letzten Objekts mit diesem Flag. Dieses
Flag wurde mit ViewMAX beta eingefÅhrt.

!label FLAG3D
!item [FLAG3D (0x1000)]
Ein Objekt mit dieserm Flag wird mit einem 3D Rahmen gezeichnet. Ab
ViewMAX/2 wird jeder Button automatisch mit einem 3D Rahmen gezeichnet.
Dazu wird die Color Categorie (siehe USECOLOURCAT) benutzt. Dieses Flag
wurde mit ViewMAX beta eingefÅhrt.

!label USECOLOURCAT
!item [USECOLOURCAT (0x2000)]
Die Farbe des Objekts ist kein Farbindex des VDI sondern ein Eintrag
in einer Tabelle mit Farben fÅr bestimmte Kategorien. Diese Tabellle
hat 16 EintrÑge. ViewMAX benutzt die folgenden Kategorien:

 #define CC_NAME       8 /* Inactive title bar */ (!nl)
 #define CC_SLIDER     9 /* Scroll bar background */ (!nl)
 #define CC_DESKTOP   10 /* The desktop */ (!nl)
 #define CC_BUTTON    11 /* Buttons and other 3D gadgets */ (!nl)
 #define CC_INFO      12 /* Window information line */ (!nl)
 #define CC_ALERT     13 /* Alert boxes (not used in ViewMAX or FreeGEM) */ (!nl)
 #define CC_SLCTDNAME 14 /* Active titlebar */ (!nl)

CC_NAME      - Inaktive Titlezeile eine Fensters (!nl)
CC_SLIDER    - Hintergrund einer Scrollbar (!nl)
CC_DESKTOP   - Der Desktop (!nl)
CC_BUTTON    - Buttons und andere 3D Gadgets  (!nl)
CC_INFO      - Infozeile eines Fensters (!nl)
CC_ALERT     - Alertboxen (wird in ViewMAX und FreeGEM nicht benutzt) (!nl)
CC_SLCTDNAME - Aktive Titelzeile eines Fensters (!nl)

Wahrscheinlich ist beabsichtigt, die Kategorien 0 bis 7 durch die
Applikation definieren zu lassen, wÑhrend 8 bis 15 fÅr das System
reserviert sind. Die Einstellung wird in ViewMAX.INI (GEM.CFG in
FreeGEM) gespeichert und bsteht aus jeweils einen Vordergrund,
Hintergrund, FÅllstil und FÅllindex. Dieses Flag wurde mit ViewMAX
beta eingefÅhrt.
!end_xlist


Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node



!begin_node Objektstati des AES

Vom Objektstatus hÑngt es ab, wie ein Objekt spÑter auf dem Bildschirm
dargestellt wird. Ein Objektstatus kann von folgendem Typ sein:

!begin_xlist [UNDERLINE (0x0f00)]
!item [Status]
Bedeutung
!item [~]
~

!item [NORMAL    (0x0000)]
Normale Darstellung.

!label SELECTED
!item [SELECTED  (0x0001)]
Inverse Darstellung, dh. das Objekt ist selektiert.

!label CROSSED
!item [CROSSED   (0x0002)]
Falls die Objektart BOX ist, wird das Objekt mit durchgestrichen gezeichnet.

!label CHECKED
!item [CHECKED   (0x0004)]
Am linken Objektrand befindet sich ein HÑkchen.

!label DISABLED
!item [DISABLED  (0x0008)]
Das Objekt wird grau dargestellt und ist nicht mehr selektierbar.

!label OUTLINED
!item [OUTLINED  (0x0010)]
Das Objekt bekommt einen Rahmen.

!label SHADOWED
!item [SHADOWED  (0x0020)]
Ein Schatten wird unter das Objekt gezeichnet.

!label WHITEBAK
!item [WHITEBAK  (0x0040)]
Auf PC-(!nolink [GEM]) bewirkt dies, daû die Icon-Maske nicht mitgezeichnet wird, was
u.U. die Ausgabe beschleunigen kann. (!nl) Ab MagiC-3 wird hiermit das
Unterstreichen von Zeichenketten gesteuert. Dieses Feature kann Åber
(!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label DRAW3D
!item [DRAW3D    (0x0080)]
Ein Objekt soll mit 3D-Effekt gezeichnet werden. Dieses Flag ist nur fÅr
PC-GEM interessant, und wird vom Atari-AES (so z.B. auch in (!nolink [MagiC])) ignoriert.

!label HIGHLIGHTED
!item [HIGHLIGHTED (0x0100)]
Ein Objekt mit diesem State wird mit einer gestrichelten Line, die mit
MD_XOR gezeichnet wird, umrandet. Dieser State wurde mit ViewMAX beta
eingefÅhrt.

!label UNHIGHLIGHTED
!item [UNHIGHLIGHTED (0x0200)]
Bei einem Objekt mit diesem State wird beim Zeichnen explizit eine
durch den State HIGHLIGHTED gezeichnete Umrandung entfernt. Dazu muû
wie folgt vorgegangen werden: Zuerst muû der State HIGHLIGHTED gelîscht
werden, dann der State UNHIGHLIGHTED gesetzt werden und anschlieûend
das Objekt mit der Funktion objc_draw neu gezeichnet werden. Ein
Neuzeichnen des Objekts ohne den State UNHIGHLIGHTED wÅrde die Umrandung
nicht lîschen, da sie auûerhalb des Bereichs liegt, den das Objekt
belegt. Nach dem Neuzeichnen sollte der State UNHIGHLIGHTED wieder
gelîscht werden. Dieser State wurde mit ViewMAX beta eingefÅhrt.

!label UNDERLINE
!item [UNDERLINE (0x0f00)]
Dieser Opcode steht unter MagiC ab Version 2.0 zur VerfÅgung, und legt die
Position und Grîûe des Unterstriches bei Objekten vom Typ G_STRING, G_TITLE
und G_BUTTON fest.

!label XSTATE
!item [XSTATE    (0xf000)]
Dieser Opcode steht unter MagiC ab Versio 2.0 zur VerfÅgung, und sorgt fÅr
das Umschalten bei den verschiedenen Button-Typen ((!nolink [G_STRING]),
(!nolink [G_TITLE]) und (!nolink [G_BUTTON])).
!end_xlist

Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node
!end_node


!begin_node Der Quarter-Screen-Buffer

Der Quarter-Screen-Buffer wird vom Screen-Manager benîtigt, um beim
Herunterklappen von Drop-Down-MenÅs den Inhalt des MenÅhintergrundes zu
retten. Auch bei der Anzeige von Alarmboxen kommt der 'QSB' (so die
gebrÑuchliche AbkÅrzung) zum Einsatz. Normalerweise sollte seine Grîûe von
der Anzahl  der Farbebenen und der Grîûe des Systemzeichensatzes,
(!I)nicht(!i) aber von der Gesamtgrîûe des Bildschirms abhÑngen.

(!B)Eine gute Formel wÑre:(!b) 500(Zeichen)*Platzbedarf eines
Zeichens*Farbebenen

Damit kÑme man in der Auflîsung 'ST-Hoch' genau auf den Wert 8000 (also
ein Viertel des Bildspeichers). Leider ist das AES in vielen FÑllen jedoch
nicht so clever; die folgende Tabelle enthÑlt eine öbersicht Åber die
benutzten Algorithmen einiger (!nolink [GEM])-Versionen:

!begin_xlist !short
!item [(!nolink [GEM])-Version]
Methode zum Setzen des QSB
!item [~]
~
!item [1.0 und 1.2]
statisch, 8000 Bytes
!item [1.4]
dynamisch, ein Viertel des Bildspeichers
!item [3.0]
dynamisch, die HÑlfte des Bildspeichers
!end_xlist

(!B)Hinweis:(!b) Die (!nolink [GEM])-Versionen 1.0 und 1.2 (also bis einschlieûlich
TOS-Version 1.02) sind mithin (!I)nicht(!i) fÅr Farbgrafikkarten vorbereitet
- einer unter mehreren GrÅnden, warum man selbst bei Benutzung eines
speziellen VDI-Treibers unter diesen (!nolink [GEM])-Versionen Farbgrafikkarten
(!I)nicht(!i) einsetzen kann.

Querverweis: GEM
!end_node


!begin_node Die Rechteckliste eines Fensters
!label Fensters, Rechteckliste eines

Um dem Problem sich Åberlappender Fenster zu begegnen, unterhÑlt das AES
fÅr jedes Fenster die sogenannte (!I)Rechteckliste(!i); alle Elemente dieser
Liste ergeben gerade den komplett sichtbaren Arbeitsbereich des
entsprechenden Fensters. 

Um ein Fenster (bzw. dessen Inhalt) neu zu zeichnen erfragt man zunÑchst
per wind_get(WF_FIRSTXYWH) das erste Rechteck der o.g. Liste. Dann stellt
man fest, ob sich dieses Rechteck mit dem neu zu zeichnenden
Bildschirmbereich Åberschneidet; dann und nur dann zeichnet man diesen
Bereich unter Ausnutzung von vs_clip neu.

Diese Methode wird mit allen Åbrigen Elementen der Rechteckliste
fortgesetzt, bis die Hîhe (!I)und(!i) Breite eines Rechtecks den Wert Null
besitzen.

Querverweis: Clipping ~  WM_REDRAW ~  wind_get ~  wind_update
!end_node



!begin_node Der Screen-Manager

Der Screen-Manager ist immer aktiv und Åberwacht die Position des
Mauszeigers, wenn dieser den Arbeitsbereich der Fenster anderer
Applikationen verlÑût. Die hier in Frage kommenden FlÑchen sind die
Rahmen der Fenster, die Drop-Down-MenÅs und die MenÅleiste.

Beim BerÅhren des MenÅbereichs sorgt der Screen-Manager selbsttÑtig dafÅr
daû der vom MenÅ belegte Bildschirmausschnitt gesichert und anschlieûend
wiederhergestellt wird (dazu wird der Quarter-Screen-Buffer benutzt).

Auch Manipulationen an den Fensterkontrollen fÅhren nicht zu dauerhaften
VerÑnderungen des Bildspeichers; Resultat der Interaktionen mit dem
Screen-Manager sind die sogenannten Mitteilungsereignisse, die die
zustÑndige Applikation Åber die Aktion des Benutzers informieren.

!label Screen-Manager, Name des
!label Screen-Manager, ID des
(!B)Hinweis:(!b) Die ID des Screen-Managers kann Åbrigens leicht durch einen
Aufruf von appl_find("SCRENMGR") ermittelt werden.

Querverweis: AES ~  GEM ~  Nachrichten
!end_node


!begin_node Startupcode fÅr Accessories
!label Accessories, Startupcode fÅr

Um zu testen, ob eine Applikation als Programm oder als Accessorie gestartet
worden ist, kann man wie folgt vorgehen:

!begin_itemize
!item wenn beim Programmstart das Register a0 den Wert Null hat, dann
      handelt es sich um einen normalen Programmstart
!item anderenfalls handelt es sich um ein Accessorie, und Register a0
      enthÑlt einen Zeiger auf die (unvollstÑndig) ausgefÅllte BASEPAGE. Die
      TPA ist bereits passend geschrumpft (auf die Summe von Basepagegrîûe
      und der LÑnge der drei Programmsegmente), ein Stack muû erst noch
      angelegt werden.
!end_itemize

(!B)Hinweis:(!b) Mit diesen Informationen ist es kein Problem, den
Startupcode fÅr ein Programm so zu gestalten, daû es selbstÑndig erkennt,
wie das Programm gestartet worden ist, und entsprechend die Initialisierung
fortzusetzen. Bei den meisten C-Compilern wird im Startupcode automatisch
die externe Variable (!I)_app(!i) initialisiert, die genau dann gleich Null
ist, wenn das Programm als Accessorie gestartet worden ist. Damit kann man
Programme so entwickeln, daû sie sowohl als Accessorie als auch als normales
Programm eingesetzt werden kînnen.

Querverweis: AES ~  Accessories in MagiC ~  Programmstart und TPA
!end_node



!include gem\aes\toolbar.ui


!begin_node AES-Bindings
!label Bindings des AES

Das AES wird Åber ein einziges Unterprogramm aufgerufen, dem 6 Parameter
Åbergeben werden; es handelt sich dabei um (!nolink [Adressen]) verschiedener Arrays,
die zur Ein-/Ausgabe-Kommunikation benutzt werden. Um eine AES-Funktion
aufzurufen, muû der folgende Parameterblock mit den (!nolink [Adressen]) der unten
beschriebenen Arrays bestÅckt werden:

!label AES-Parameterblock
!label Parameterblock des AES
!begin_verbatim
typedef struct
{
    WORD *cb_pcontrol;  /* Zeiger auf control-Array */
    WORD *cb_pglobal;   /* Zeiger auf global-Array  */
    WORD *cb_pintin;    /* Zeiger auf int_in-Array  */
    WORD *cb_pintout;   /* Zeiger auf int_out-Array */
    WORD *cb_padrin;    /* Zeiger auf adr_in-Array  */
    WORD *cb_padrout;   /* Zeiger auf adr_out-Array */
} AESPB;
!end_verbatim

Die Adresse dieses Parameterblocks (der sich auf dem Stack befindet), muû
dann im Register d1 vermerkt, und zusÑtzlich Register d0.w mit dem Wert
0xc8 (200) gefÅllt werden. Durch einen TRAP#2 Systemaufruf kann dann das
(!nolink [AES]) direkt aufgerufen werden. FÅr den (!B)(!I)Pure-Assembler(!b)(!i) kînnte
das z.B. so aussehen:

!label aes
!begin_verbatim
                .EXPORT aes         ; Funktion exportieren
                .CODE               ; Beginn des Code-Segments

        aes:     MOVE.L 4(sp),D1    ; Adresse des Parameterblocks
                 MOVE.W #200,D0     ; Opcode des AES
                 TRAP   #2          ; GEM aufrufen
                 RTS                ; raus hier

                .END                ; Ende des Moduls
!end_verbatim

DarÅber, welche Register verÑndert werden dÅrfen, gibt es keine klaren
Informationen. Tatsache ist jedoch, daû die entsprechenden Routinen im
ROM (!I)alle(!i) Register retten.

Nun zu den einzelnen Arrays. öber jedes Feld kînnen bestimmte Ein- bzw.
Ausgaben getÑtigt werden; es gilt:

!label control
!begin_xlist [WORD control[5!]] !short
!item [(!B)WORD control[5!](!b)]
öber dieses Feld werden Informationen Åber die aufgerufene Funktion und ihre
Parameter festgelegt. Es gilt:
!begin_xlist
!item [control[0!]]
= Funktionsnummer
!item [control[1!]]
= Anzahl der Werte im int_in-Array
!item [control[2!]]
= Anzahl der Werte im int_out-Array
!item [control[3!]]
= Anzahl der Werte im addr_in-Array
1item [control[4!]]
= Anzahl der Werte im addr_out-Array
!end_xlist
DarÅber, welche Informationen vor einem AES-Aufruf gesetzt werden mÅssen,
gibt es keine klaren Informationen. Nîtig ist es auf jeden Fall fÅr die
Elemente [0],[1] und [3]. Wenig sinnvoll erscheint es fÅr die Elemente [2]
und [4] zu sein - schlieûlich wissen die (!nolink [AES])-Funktionen ja selbst, wie viele
Werte sie in den Ausgabefeldern zurÅckliefern.

!label Globalfeld des AES
!label global
!item [(!B)WORD global[15!](!b)]
Dieses Feld enthÑlt globale Daten fÅr die Applikation und wird teils von
appl_init, teils von anderen (!nolink [AES])-Funktionen benutzt, und automatisch
gefÅllt. Es gilt:
!begin_xlist [global[11,12]] !short

!label AES-Versionsnummer
!label Versionsnummer des AES
!item [global[0!]]
Versionsnummer der (!nolink [AES])

!label Multitasking vorhanden?
!item [global[1!]]
Anzahl der Applikationen, die gleichzeitig laufen kînnen. Bei einem Wert
von -1 gibt es keine BeschrÑnkung.
!item [global[2!]]
Kennung (ID) der Applikation
!item [global[3,4!]]
Beliebige Information, die nur fÅr die Applikation von Bedeutung ist und
von dieser gesetzt und gelesen werden kann.
!item [global[5,6!]]
Zeiger auf eine Liste von Zeigern auf die ObjektbÑume der Applikation
(wird von rsrc_load gesetzt).
!item [global[7,8!]]
Adresse des fÅr die Resource-Datei reservierten Speichers. Nur von Digital
Research und (!I)nicht(!i) von Atari dokumentiert.
!item [global[9!]]
LÑnge des reservierten Speichers. Nur von Digital Research und
(!I)nicht(!i) von Atari dokumentiert.
!item [global[10!]]
Anzahl der Farbebenen. Nur von Digital Research und (!I)nicht(!i) von
Atari dokumentiert.
!item [global[11,12!]]
reserviert
!item [global[13!]]
Maximale Hîhe eines Zeichens, die vom (!nolink [AES]) fÅr den vst_height-Aufruf
benutzt wird. Dieser Eintrag ist erst ab (!nolink [AES])-Version 4.0, und auch nur von
Atari dokumentiert. (!nl)
Ab PC-GEM Version 2.0 wird dieser Wert als Bitvektor mit
den auf dem Desktop angemeldeten Laufwerken interpretiert (Bit-15 =
Laufwerk-A).
!item [global[14!]]
Minimale Hîhe eines Zeichens, die vom (!nolink [AES]) fÅr den vst_height-Aufruf
benutzt wird. Dieser Eintrag ist erst ab (!nolink [AES])-Version 4.0, und auch nur von
Atari dokumentiert. (!nl)
Ab PC-GEM Version 2.0 wird dieser Wert als Bitvektor
interpretiert, der angibt, welche der in global[13] angegebenen Laufwerke
als Festplatten betrachtet werden kînnen.
!end_xlist

!label int_in
!item [(!B)WORD int_in[16!](!b)]
öber dieses Feld werden alle 16-Bit groûen Eingabeparameter Åbergeben.

!label int_out
!item [(!B)WORD int_out[10!](!b)]
öber dieses Feld liefert das (!nolink [AES]) alle 16-Bit groûen RÅckgabewerte.

!label addr_in
!item [(!B)LONG addr_in[8!](!b)]
Dieses Feld dient zur öbermittlung von Zeigern (z.B. Zeiger auf
Zeichenketten) an (!nolink [AES]) Funktionen.

!label addr_out
!item [(!B)LONG addr_out[2!](!b)]
öber dieses Feld werden 32-Bit groûe Werte vom (!nolink [AES]) zurÅckgeliefert.
!end_xlist

(!B)Achtung:(!b) Wenn das Betriebssystem Threads unterstÅtzt, muss unbedingt
darauf geachtet werden, eine Multithread-sichere Bibliothek zu verwenden.
Insbesondere muss sichergestellt werden, daû jeder Thread sein
(!I)eigenes(!i) global-Feld (s.o) erhÑlt.

Querverweis: (!link [Beispiel-Binding][Beispiel-Binding fÅr AES-Funktionen]) ~ VDI-Bindings ~
TOS Liste


!begin_node Beispiel-Binding fÅr AES-Funktionen

Die Funktion 'crys_if' (Crystal Interface) sorgt fÅr die Besetzung des
(!nolink [control])-Arrays, und macht den eigentlichen (!nolink [AES])-Aufruf.
Dazu bedient sie sich einer Tabelle, in der fÅr jede einzelne (!nolink [AES])-Funktion die
Werte fÅr
(!nolink [control])[1], (!nolink [control])[2] und (!nolink [control])[3] vermerkt sind.
!label crys_if

!begin_verbatim
AESPB c;

WORD crys_if (WORD opcode)
{
	WORD i, *paesb;
	
	control[0] = opcode;
	paespb = &ctrl_cnts[ (opcode-10)*3 ];
	
	for (i = 1; i < 4; i++)
		control[i] = *paespb++;
		
	aes (c);
	return (int_out[0]);
		
} /* crys_if */
!end_verbatim

Die dabei verwendete Tabelle kînnte beispielsweise folgendermaûen aufgebaut
sein:

!begin_verbatim
.GLOBAL ctrl_cnts
.DATA

ctrl_cnts: .dc.b     0,  1,  0       ; appl_init
           .dc.b     2,  1,  1       ; appl_read
           .dc.b     2,  1,  1       ; appl_write
            ...
            ...
            ...
          
.END
!end_verbatim

Querverweis: AES-Bindings  ~ GEM
!end_node
!end_node
!end_node

!include gem\aes\appl_\appl_.u
!include gem\aes\fsel_\fsel_.u
!include gem\aes\pdlg_\pdlg_.u
!include gem\aes\edit_\edit_.u
!include gem\aes\evnt_\evnt_.u
!include gem\aes\wdlg_\wdlg_.u
!include gem\aes\wind_\wind_.u
!include gem\aes\fslx_\fslx_.u
!include gem\aes\form_\form_.u
!include gem\aes\graf_\graf_.u
!include gem\aes\scrp_\scrp_.u
!include gem\aes\lbox_\lbox_.u
!include gem\aes\menu_\menu_.u
!include gem\aes\objc_\objc_.u
!include gem\aes\rsrc_\rsrc_.u
!include gem\aes\shel_\shel_.u
!include gem\aes\xgrf_\xgrf_.u
!include gem\aes\fnts_\fnts_.u

!include gem\aes\aes_f.u
!include gem\aes\struktur.ui


!end_node
