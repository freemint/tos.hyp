## Hypertext zum TOS-Betriebssystem
##
## Kapitel 4: AES-Funktionsaufrufe

!iflang [english]

!include gem\aes\aes_en.u

!else

!begin_node Das AES

Das AES (Application Environment (!nolink [Services])) ist der Teil des GEM, der die
direkte (grafische) Schnittstelle zum Benutzer realisiert. Mit Hilfe des
(!nolink [AES]) lassen sich verschiedene Konzepte wie Bildschirmfenster, MenÅzeilen,
Drop-Down oder Pop-Up MenÅs, Dialogboxen usw. komfortabel handhaben.
Dazu dienen die folgenden Bibliotheken:

!begin_xlist [˘ Applikationsverwaltung ] !compressed
!item [˘ (!link [Applikationsverwaltung][Applikationsfunktionen])] (appl_...)
!item [˘ Dateiauswahl]           (fsel_...)
!item [˘ Druckdialoge]           (pdlg_...)
!item [˘ Editobjekt-Funktionen]  (edit_...)
!item [˘ Ereignisverwaltung]     (evnt_...)
!item [˘ Fensterdialoge]         (wdlg_...)
!item [˘ Fensterverwaltung]      (wind_...)
!item [˘ Fileselektoren]         (fslx_...)
!item [˘ (!link [Formulare][Formularfunktionen])]              (form_...)
!item [˘ Grafikfunktionen]       (graf_...)
!item [˘ Listboxen]              (lbox_...)
!item [˘ (!link [MenÅs][MenÅfunktionen])]                  (menu_...)
!item [˘ (!link [Objekte][Objektfunktionen])]                (objc_...)
!item [˘ (!link [Resourceorganisation][Resourcefunktionen])]   (rsrc_...)
!item [˘ (!link [Shell-Kommunikation][Shellfunktionen])]    (shel_...)
!item [˘ (!link [X-Grafikfunktionen][Erweiterte Grafikfunktionen])]     (xgrf_...)
!item [˘ Zeichensatzauswahl]     (fnts_...)
!item [˘ (!link [Zwischenspeicher][Klemmbrett-Funktionen])]       (scrp_...)
!end_xlist

!label AES, Entstehung des
Die Entwicklung des (!nolink [AES]) reicht bis in das Jahr 1984 zurÅck, als es von
(!I)Digital Research(!i) zunÑchst fÅr MS-DOS-Rechner entwickelt, und spÑter
auf die Apple Lisa (unter CP/M 68K) portiert wurde. Diese Version wurde dann
anschlieûend auf den Atari-ST (unter GEMDOS) portiert.

In der Version 4.0 wurde das (!nolink [AES]) stark Åberarbeitet, und stellt nun viele
neue und erweiterte Routinen zur VerfÅgung. öber die Funktion appl_getinfo
kann leicht festgestellt werden, ob (bzw. welche) neue(n) Mîglichkeiten zur
VerfÅgung stehen.

Querverweis: Grundlagen des AES ~ Bindings des AES ~ VDI
!end_node


!begin_node Grundlagen des AES
!label AES, Grundlagen des

(!nolink [Das AES]) (Application Environment (!nolink [Services])) bildet die obere Schicht des
GEM. Es befasst sich mit all jenen GEM-Bestandteilen, die Åber elementare
Grafikausgaben und -eingaben hinausgehen. Da das AES ausschlieûlich VDI-
und GEMDOS-Aufrufe tÑtigt, ist es sowohl von der Grafikhardware, vom
EingabegerÑt als auch vom Dateisystem unabhÑngig. In diesem Abschnitt
werden die folgenden Punkte behandelt:

!begin_itemize !compressed
!item Accessories
!item (!link [Bindings des AES][AES-Bindings])
!item Das Desktop-Fenster
!item (!link [Datenaustausch per Klemmbrett][Der Datenaustausch Åber das GEM-Klemmbrett])
!item Nachrichten
!item (!link [Objektstruktur im AES][Die Objekt-Struktur])
!item (!link [Quarter-Screen-Buffer][Der Quarter-Screen-Buffer])
!item (!link [Rechteckliste eines Fensters][Die Rechteckliste eines Fensters])
!item (!link [Screen-Manager][Der Screen-Manager])
!item Toolbar-Support
!end_itemize
!label AES-Clones
!label Clones, AES-
!label N.AES
!label MinA
!label AES im Quelltext?
!label Quelltext, AES im

Auch beim (!nolink [AES]) gibt es eine interessante Entwicklung, denn verschiedene
Programmierer haben mittlerweile eigene (!B)AES-Clones(!b) angekÅndigt; zur
Zeit sind hier die Projekte (!I)N.AES(!i) und (!I)XaAES(!i) zu nennen. Neben
einer stetigen Weiterentwicklung darf man wohl auch auf eine
Quelltext-Version dieser GEM Komponente hoffen.

Querverweis: Style-Guidelines

!begin_node Accessories

!begin_itemize !compressed
!item Startupcode fÅr Accessories
!item Accessories in MagiC
!end_itemize

!begin_node Startupcode fÅr Accessories
!label Accessories, Startupcode fÅr

Um zu testen, ob eine Applikation als Programm oder als Accessorie gestartet
worden ist, kann man wie folgt vorgehen:

!begin_itemize
!item wenn beim Programmstart das Register a0 den Wert Null hat, dann
      handelt es sich um einen normalen Programmstart
!item anderenfalls handelt es sich um ein Accessorie, und Register a0
      enthÑlt einen Zeiger auf die (unvollstÑndig) ausgefÅllte BASEPAGE. Die
      TPA ist bereits passend geschrumpft (auf die Summe von Basepagegrîûe
      und der LÑnge der drei Programmsegmente), ein Stack muû erst noch
      angelegt werden.
!end_itemize

(!B)Hinweis:(!b) Mit diesen Informationen ist es kein Problem, den
Startupcode fÅr ein Programm so zu gestalten, daû es selbstÑndig erkennt,
wie das Programm gestartet worden ist, und entsprechend die Initialisierung
fortzusetzen. Bei den meisten C-Compilern wird im Startupcode automatisch
die externe Variable (!I)_app(!i) initialisiert, die genau dann gleich Null
ist, wenn das Programm als Accessorie gestartet worden ist. Damit kann man
Programme so entwickeln, daû sie sowohl als Accessorie als auch als normales
Programm eingesetzt werden kînnen.

Querverweis: AES ~  Accessories in MagiC ~  Programmstart und TPA
!end_node

!begin_node Accessories in MagiC
!label MagiC, Accessories in

Unter MagiC sind Accessories den Programmen fast gleichgestellt. Ihre
Fenster bleiben beim Programmwechsel erhalten. Sie dÅrfen MenÅ und
Desktophintergrund besitzen, Programme nachladen, Speicher anfordern,
Dateien îffnen, schlieûen, lîschen, kopieren usw.

Da kein Grund mehr besteht, beim Programmwechsel Fenster zu schlieûen,
gibt es keine AC_CLOSE Meldung mehr. Accessories werden vom System nicht
von Programmen unterschieden, abgesehen davon, daû sie sich keinesfalls
beenden dÅrfen. ACCs dÅrfen sich wie unter (!nolink [GEM])/2 auch wieder im MenÅ
abmelden, und zwar mit dem (!nolink [AES])-Aufruf menu_unregister(). Anstelle von
ACCs sind unter (!nolink [MagiC]) Applikationen sinnvoll, die einfach nur eine
MenÅleiste mit einem MenÅ anmelden und im APP- Autostart- Ordner liegen.
Diese Applikationen kann man dann bei Bedarf nachladen und auch wieder
entfernen.

(!B)Hinweis:(!b) Ab (!nolink [MagiC])-4 kînnen Accessories zur Laufzeit nachgestartet
werden. Ferner ist es mîglich, bei einem Klick auf einen Accessory-Eintrag
(und gedrÅckter Control-Taste) das entsprechende Accessory zu entfernen. Ein
Nachteil ist, daû Accessories z.Zt. noch kein Pexec mit Modus 104 ausfÅhren
dÅrfen.

Querverweis: AES ~  GEM ~  Startupcode fÅr Accessories ~  shel_write
!end_node

!end_node


!begin_node Das Desktop-Fenster
!label Fenster, Desktop-

Unter den verfÅgbaren Fenstern nimmt das Desktop- oder Hintergrundfenster
eine besondere Rolle ein. Es besitzt die Kennung 0, nimmt die gesamte
BildschirmflÑche in Anspruch, ist immer geîffnet und kann auch nicht
geschlossen werden. Der (!I)Arbeitsbereich(!i) ist die FlÑche unter der
MenÅleiste. Nur in diesem Arbeitsbereich dÅrfen andere Programme
Bildschirmausgaben machen oder eigene Fenster îffnen.

Normalerweise erscheint der Arbeitsbereich des Desktop als solide grÅne
FlÑche (im Farbbetrieb) bzw. als graues Raster (im Monochrombetrieb). Der
Screen-Manager kÅmmert sich vîllig selbsttÑtig um den Redraw; Åber einen
Aufruf von (!I)wind_set(!i) kînnen Anwendungsprogramme einen beliebigen
anderen Objektbaum als Hintergrund verankern. Auch dann kÅmmert sich der
Screen-Manager um das fÑllige Neuzeichnen von Bildausschnitten. Obwohl diese
Mîglichkeit sehr verlockend ist, gibt es etliche GrÅnde, die (!I)gegen(!i)
eine Benutzung des Desktop-Fensters sprechen; der wichtigste:

!begin_itemize
!item auch unter einem multitaskingfÑhigen GEM (MagiC oder MultiTOS), kann
es (!I)nur einen(!i) Bildschirmhintergrund geben. Dieser sollte dem Programm
vorbehalten bleiben, das daraus den meisten Nutzen ziehen kann - in der
Regel ist dies das Desktop bzw. ein Desktop-Ersatz wie z.B. die Shell
Gemini.
!end_itemize

Fazit: Der Desktop-Hintergrund sollte nach Mîglichkeit in eigenen Programmen
(!I)nicht(!i) benutzt werden.

Querverweis: AES  ~ wind_set ~  WF_NEWDESK
!end_node



!begin_node Der Datenaustausch Åber das GEM-Klemmbrett
!label Datenaustausch per Clipboard
!label Klemmbrett, Datenaustausch per

Um Dateien im Klemmbrett abzulegen, sollte man folgendermaûen vorgehen:

!begin_itemize !compressed
!item alle Klemmbrett-Dateien, die auf die Maske 'scrap.*' und 'SCRAP.*'
passen, lîschen. Anmerkung: Die Maske 'SCRAP.*' muss berÅcksichtigt werden,
da alte Programme noch nichts von alternativen und case-sensitiven
Dateisystemen wussten.
!item die abzulegenden Daten in einem oder mehreren Formaten sichern.
!item die Nachricht SC_CHANGED an (!I)alle(!i) Applikationen im System,
SH_WDRAW an die System-Shell schicken.
!end_itemize

Der Dateiname ist (!I)immer(!i) 'scrap.', die Namenserweiterung (Suffix)
hÑngt dabei vom gewÑhlten Format ab; nach Mîglichkeit sollte (!I)immer(!i)
eines der folgenden Standardformate unterstÅtzt werden:

!begin_table [ll]
Suffix !! Bedeutung
!hline
gem !! Vektorgrafiken im Metafile-Format
img !! Pixelbilder im (!link [XIMG-Format][Das XIMG-Format fÅr Pixelbilder])
txt !! ASCII-Textdatei, jede Zeile mit CR/LF abgeschlossen
!end_table

ZusÑtzlich kann man eines oder mehrere der folgenden Formate unterstÅtzen
(der EmpfÑnger hat dann die Mîglichkeit, das Format mit den meisten
Informationen zu benutzen):

!begin_table [ll]
Suffix !! Bedeutung
!hline
asc !! ASCII-Textdatei, jeder Absatz mit CR/LF abgeschlossen
csv !! ASCII-Datei mit durch Kommata getrennten Zahlen
cvg !! Calamus Vektorgrafik-Format
dif !! Export-Datei von Tabellenkalkulationen
eps !! Encapsulated PostScript
1wp !! Wordplus-Format
rtf !! Microsoft Rich Text Format
tex !! TeX
!end_table

Das empfangende Programm sollte zunÑchst ÅberprÅfen, welche der vorhandenen
Dateien die meisten Informationen enthÑlt, und dann diese Datei nehmen.

(!B)Wichtig:(!b) Jede der Dateien im Klemmbrett enthÑlt prinzipiell die
gleichen Informationen, nur eben in einem anderen Format. Die
Textverarbeitung (!I)Papyrus(!i) z.B. importiert 'scrap.rtf' nur dann, wenn
das eigene Format 'scrap.pap' nicht gefunden werden konnte.

Aus den obigen ErklÑrungen wird ersichtlich, daû sich immer nur (!I)ein(!i)
Datenobjekt (allerdings in verschiedenen Formaten) auf einmal im Klemmbrett
befinden kann.

Querverweis: Klemmbrett-Funktionen ~  scrp_clear  ~ Style-Guidelines
!end_node


!begin_node Die Objekt-Struktur

Die (!nolink [Datenstruktur]) des Objektbaums ist zwar kein Baum im Sinne eines
BinÑrbaums, besitzt jedoch innerhalb eines Zeigers die logischen
Verkettungen eines Baums, mit VorgÑngern und Nachfolgern. Die Spezifikation
von VorgÑngern und Nachfolgern wird durch Indizes auf ein Array vorgenommen.

Die Baumstruktur der einzelnen Objekte kann man sich am leichtesten an Hand
eines einfachen Beispiels veranschaulichen: Ein MenÅ setzt sich zunÑchst aus
der MenÅleiste zusammen. Diese enthÑlt wiederum mehrere Titeltexte. Die
Titeltexte sind also direkt in der MenÅleiste enthalten, sie sind beide
Nachfolger des Objekts 'MenÅleiste', bewegen sich also auf der selben
hierarchischen Ebene. Das Objekt MenÅleiste verweist mit (!I)ob_head(!i) auf
den ersten MenÅtitel und mit (!I)ob_tail(!i) auf den letzten MenÅtitel. Im
ersten MenÅtitel dient der Zeiger (!I)ob_next(!i) zur Adressierung des
nÑchsten MenÅtitels. Die Verkettung weist also folgende Struktur auf:
!begin_verbatim
      MenÅleiste:
   +---------+---------+--------+
   | ob_head | ob_tail | ...    |
   |    o    |    o    |        |
   +----|----+----|----+--------+
        |         +-------------------------+
        V                                   V
   +---------+---------+--------+       +---------+---------+--------+
   | ...     | ob_next | ...    |  ...  | ...     | ...     | ...    |
   |         |    o    |        |       |         |         |        |
   +---------+----|----+--------+       +---------+---------+--------+
      1.MenÅtitel |                         n-ter MenÅtitel
                  +-----> 2.MenÅtitel
!end_verbatim
Welche Aktionen mit einem Objekt durchgefÅhrt werden dÅrfen, wird in
(!I)ob_flags(!i) festgelegt. Der Zustand eines Objekts wird im Eintrag
(!I)ob_state(!i) festgehalten. Der Eintrag (!I)ob_type(!i) legt den
Objekttyp fest. Manche Objekte benîtigen zur exakten Festlegung eine
zusÑtzliche (!nolink [Datenstruktur]), wie TEDINFO oder BITBLK. In ob_spec wird dann
ein Zeiger auf diese zusÑtzliche Struktur abgelegt. Zusammenfassend
nochmals der Gesamtaufbau der Datenstruktur fÅr Objekte OBJECT:
!begin_verbatim
         +-------------+
         |  ob_next    |   Index fÅr das nÑchste Objekt
         +-------------+
         |  ob_head    |   Index des ersten Kindes
         +-------------+
         |  ob_tail    |   Index des letzten Kindes
         +-------------+
         |  ob_type    |   Objektart
         +-------------+
         |  ob_flags   |   Manipulationsflags
         +-------------+
         |  ob_state   |   Objektstatus
         +-------------+
         |  ob_spec    |   siehe unter Objektart
         +-------------+
         |  ob_x       |   relative x-Koordiante zum Eltern-Objekt
         +-------------+
         |  ob_y       |   relative y-Koordinate zum Eltern-Objekt
         +-------------+
         |  ob_width   |   Breite des Objekts
         +-------------+
         |  ob_height  |   Hîhe des Objekts
         +-------------+
!end_verbatim
Querverweis: Objektfarben des AES ~ (!link [Objektart][Objektarten des AES]) ~
(!link [Manipulationsflags][Objektflags des AES]) ~ (!link [Objektstatus][Objektstati des AES])



!begin_node Objektarten des AES
!label Objekttypen des AES

Folgende Objektarten stehen zur Auswahl:


!begin_xlist [G_WINTITLE (36)]
!item [Art]
Bedeutung

!label G_BOX
!item [G_BOX      (20)]
Rechteckiger Kasten. ob_spec enthÑlt verschiedene Informationen Åber
RahmenstÑrke, Farbe und Ñhnliches.

!label G_TEXT
!item [G_TEXT     (21)]
Grafiktext, ob_spec zeigt auf TEDINFO-Struktur.

!label G_BOXTEXT
!item [G_BOXTEXT  (22)]
rechteckiger Kasten mit Grafiktext, ob_spec zeigt auf (!nolink [TEDINFO])-Struktur.

!label G_IMAGE
!item [G_IMAGE    (23)]
Bild, ob_spec zeigt auf BITBLK-Struktur.

!label USERDEF
!label G_USERDEF
!item [G_USERDEF  (24)]
Benutzerdefinierte Funktion zum Zeichnen eines eigenen Objekts. ob_spec
verweist auf eine USERBLK Struktur.

!label G_IBOX
!item [G_IBOX     (25)]
Transparentes Rechteck, das nur gesehen werden kann, wenn die Umrandung
nicht die Dicke Null hat. ob_spec enthÑlt weitere Informationen Åber das
Aussehen.

!label G_BUTTON
!item [G_BUTTON   (26)]
Text mit Rahmen fÅr Optionsauswahl. ob_spec zeigt auf eine Zeichenkette mit
dem Text, der in dem Knopf erscheinen soll.

(!B)Neu ab MagiC-Version 3.0:(!b) (!nl)
Ist das Objektflag WHITEBAK gesetzt, und Bit-15 im Objektstatus = 0, so wird
der Button unterstrichen; dabei gilt: (Highbyte&0xf) von ob_state ist die
gewÅnschte Unterstreichposition. Falls hingegen Bit-15 = 1 ist, so handelt
es sich um einen Sonderbutton (Radio-Button oder Checkbox).

Weitere Besonderheiten: WHITEBAK=1, Bit-15 = 1 und in ob_state
!begin_xlist [Highbyte != -1,-2] !compressed
!item [Highbyte = -2]
Gruppenrahmen
!item [Highbyte = -1]
Sonderbutton, nicht unterstr.
!item [Highbyte != -1,-2]
Sonderbutton, unterstr.
!end_xlist
(dabei ist wieder (Highbyte&0xf) von ob_state die Unterstreichposition). Das
Vorhandensein dieser Features sollte am besten Åber die Funktion
(!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label G_BOXCHAR
!item [G_BOXCHAR  (27)]
Rechteck, mit einem Zeichen. In ob_spec wird nicht nur das Aussehen der
Umrandung, sondern auch das Zeichen definiert.

!label G_STRING
!item [G_STRING   (28)]
Zeichenkette, ob_spec zeigt auf den String.

(!B)Neu ab MagiC-Version 3.0:(!b) (!nl)
Ist das Objektflag WHITEBAK gesetzt, und das Highbyte von ob_state != -1, so
wird der String unterstrichen; die Unterstreich-Position wird dabei durch
(Highbyte & 0xf) von ob_state geregelt.

Bei gesetztem (!nolink [WHITEBAK])-Flag und Highbyte von ob_state = -1, wird der
komplette String unterstrichen. Das Vorhandensein dieser Features sollte am
besten per (!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label G_FTEXT
!item [G_FTEXT    (29)]
Formatierter Grafiktext, ob_spec zeigt auf TEDINFO-Struktur

!label G_FBOXTEXT
!item [G_FBOXTEXT (30)]
Rechteck mit formatiertem Grafiktext, ob_spec zeigt auf (!nolink [TEDINFO])-Struktur.

!label G_ICON
!item [G_ICON     (31)]
Icon-Symbol, ob_spec zeigt auf die ICONBLK-Struktur.

!label G_TITLE
!item [G_TITLE    (32)]
Titel eines Drop-Down-MenÅs, ob_spec zeigt auf den String.

Ab MagiC-2 kann
dabei auch ein Buchstabe unterstrichen werden. Dies geht wie folgt:

WHITEBAK in ob_state setzen
!begin_xlist !compressed
!item [(ob_state >> 8) & 0xf]
= Position des Unterstrichs
!item [(ob_state >> 8) & 0xf0]
ist 0
!end_xlist

!label G_CICON
!item [G_CICON    (33)]
Farb-Icon, ob_spec zeigt auf die CICONBLK-Struktur.

!label G_CLRICN
!item [G_CLRICN    (33)]
Colour icon, ob_spec zeigt auf die ICONBLK-Struktur.
Supported in the ViewMAX/3 beta and in FreeGEM

!label G_SWBUTTON
!item [G_SWBUTTON (34)]
Cycle-Button (d.h. ein Button, der beim Anklicken seinen Text zyklisch
Ñndert), ob_spec zeigt auf eine SWINFO-Struktur. Das Vorhandensein dieses
Objekttyps sollte per (!link [appl_getinfo][%apgi_13]) (Opcode 13) erfragt werden.

!label G_DTMFDB
!item [G_DTMFDB    (34)]
For internal AES use only: desktop image. The ob_spec is a pointer to a
MFDB structure.
Supported in the ViewMAX/3 beta and in FreeGEM.

!label G_POPUP
!item [G_POPUP    (35)]
PopUp-MenÅ, ob_spec zeigt auf eine POPINFO-Struktur. Falls das MenÅ mehr als
16 EintrÑge umfaût, so ist dieses scrollbar. Das Vorhandensein dieses
Objekttyps sollte per (!link [appl_getinfo][%apgi_13]) (Opcode 13) erfragt werden. Hinweis:
G_POPUP sieht wie G_BUTTON aus, die Zeichenkette wird jedoch nicht
zentriert, um mîglichst mit den Zeichenketten im MenÅ auf einer Linie zu
liegen.

!label G_WINTITLE
!item [G_WINTITLE (36)]
Diese Objektnummer wird von MagiC intern dazu verwendet, Fenstertitel
darzustellen. Der Aufbau dieses Objekttyps kann sich jederzeit Ñndern und
wird daher nicht dokumentiert.

!label G_EDIT
!item [G_EDIT     (37)]
Ab MagiC 5.20 steht ein in einer Shared-Library implementiertes Editobjekt
zur VerfÅgung. ob_spec verweist auf das Objekt. Achtung: Dieser Typ wird von
den Funktionen (!nolink [form_do]), (!nolink [form_xdo]), (!nolink [form_button]),
(!nolink [form_keybd]), (!nolink [objc_edit]),
(!nolink [wdlg_evnt]) und wdlg_do z.Zt. noch (!I)nicht(!i) unterstÅtzt, d.h. die
entsprechenden Ereignisse mÅssen selbst (per edit_evnt) an das Objekt
weitergeleitet werden.

!label G_SHORTCUT
!item [G_SHORTCUT (38)]
Dieser Typ wird Ñhnlich wie G_STRING behandelt, ein vorhandenes
TastaturkÅrzel wird jedoch abgespalten und rechtsbÅndig ausgegeben. Das
Vorhandensein dieses Objekttyps sollte per (!link [appl_getinfo][%apgi_13])
(Opcode 13) erfragt werden.

Die EinfÅhrung proportionaler AES-ZeichensÑtze machte eine
neue Strategie fÅr die Ausrichtung der MenÅeintrÑge erforderlich. Um
TastaturkÅrzel rechtsbÅndig ausrichten zu kînnen, werden Objekte vom Typ
G_STRING innerhalb eines MenÅs entsprechend in Kommando und KÅrzel
aufgespalten. Diese Strategie versagt jedoch bei MenÅs, die vom Programm
selbst, z.B. innerhalb eines Fensters oder eines Popup-MenÅs, verwaltet
werden. Um auch hier eine brauchbare Ausrichtung zu erreichen, muûte dieser
neue Objekttyp eingefÅhrt werden.

!label G_SLIST
!item [G_SLIST (39)]
XaAES extended object - scrolling list



!end_xlist
(!B)Hinweis:(!b) FÅr G_BOX, G_IBOX und G_BOXCHAR zeigt die Komponente
(!I)ob_spec(!i) der OBJECT-Struktur (!I)nicht(!i) auf eine andere
Datenstruktur, sondern enthÑlt weitere Informationen zum Aussehen des
Objektes. Dabei gilt:

!begin_xlist !compressed
!item [Bits]
Bedeutung
!item [~]
~
!item [24..31]
darzustellendes Zeichen (nur bei G_BOXCHAR)
!item [16..23]
!begin_xlist [-1..127] !compressed
!item [~0]
= Rahmendicke
!item [~1..128]
= Rahmen liegt 1..128 Pixel im inneren des Objekts
!item [-1..-127]
= Rahmen liegt 1..127 Pixel auûerhalb des Objekts
!end_xlist
!item [12..15]
Rahmenfarbe (0..15)
!item [08..11]
Textfarbe   (0..15)
!item [7]
Text transparent (0) oder deckend (1)
!item [04..06]
!begin_xlist !compressed
!item [0]
= hohl
!item [1]
= ansteigende IntensitÑt
!item [2]
~
!item [.]
~
!item [.]
~
!item [7]
= solide FlÑche
!end_xlist
!item [00..03]
Innenfarbe (0..15)
!end_xlist
Das Hibyte wird vom AES nur fÅr SubmenÅs verwendet. Ist das hîchste Bit von
ob_type 0x8000, sowie das Bit SUBMENU in ob_flags gesetzt, so geben die Bits
8..14 an, welches SubmenÅ mit dem MenÅeintrag gekoppelt ist. Jede
Applikation kann daher maximal 128 SubmenÅs haben. MagiC liest aus ob_type
stets nur das Lowbyte aus, auûer fÅr die SubmenÅ-Behandlung. TOS reagiert
auf unbekannte Objekttypen (z.B. die reinen (!nolink [MagiC])-Typen G_SWBUTTON usw.)
sauber, d.h. die Objekte werden nicht gezeichnet.

Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~  Objektfarben des AES
!end_node



!begin_node Objektfarben des AES

Die folgende Tabelle enthÑlt die vordefinierten Objektfarben. Einzelheiten
hÑngen natÅrlich von der gewÑhlten Bildauflîsung, sowie den Einstellungen
des Benutzers ab.

!begin_table [l|l|r]
Nummer !! Farbe !! Standard RGB-Werte
!hline
WHITE    (00) !! Weiû          !! 1000, 1000, 1000
BLACK    (01) !! Schwarz       !!    0,    0,    0
RED      (02) !! Rot           !! 1000,    0,    0
GREEN    (03) !! GrÅn          !!    0, 1000,    0
BLUE     (04) !! Blau          !!    0,    0, 1000
CYAN     (05) !! Cyan          !!    0, 1000, 1000
YELLOW   (06) !! Gelb          !! 1000, 1000,    0
MAGENTA  (07) !! Magenta       !! 1000,    0, 1000
DWHITE   (08) !! Hellgrau      !!  752,  752,  752
DBLACK   (09) !! Dunkelgrau    !!  501,  501,  501
DRED     (10) !! Dunkelrot     !!  713,    0,    0
DGREEN   (11) !! DunkelgrÅn    !!    0,  713,    0
DBLUE    (12) !! Dunkelblau    !!    0,    0,  713
DCYAN    (13) !! Dunkelcyan    !!    0,  713,  713
DYELLOW  (14) !! Dunkelgelb    !!  713,  713,    0
DMAGENTA (15) !! Dunkelmagenta !!  713,    0,  713
!end_table
(!B)Hinweis:(!b) Diese Farben entsprechen auch weitestgehend den unter
Windows und OS/2 verwendeten Iconfarben. öber ein geeignetes CPX-Modul
kînnen die richtigen RGB-Werte fÅr die ersten 16 Farben eingestellt werden.

Querverweis: (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node



!begin_node Objektflags des AES

Die Manipulationsflags eines Objektes bestimmen seine Eigenschaften.
Folgende Mîglichkeiten stehen zu Auswahl:

!begin_xlist [TOUCHEXIT  (0x0040)]
!item [Flag]
Bedeutung

!item [NONE       (0x0000)]
Keine Eigenschaften.

!label SELECTABLE
!item [SELECTABLE (0x0001)]
Das Objekt ist selektierbar.

!label DEFAULT
!item [DEFAULT    (0x0002)]
Wenn der Benutzer die 'Return' oder 'Enter' Taste drÅckt, wird dieses Objekt
automatisch selektiert. Diese Flag ist pro Baum nur einmal zugelassen.

!label EXIT
!item [EXIT       (0x0004)]
Beim Anklicken eines solchen Objektes wird der Dialog beendet (siehe auch
form_do).

!label EDITABLE
!item [EDITABLE   (0x0008)]
Dieses Objekt kann vom Benutzer mittels der Tastatur editiert werden.

!label RBUTTON
!item [RBUTTON    (0x0010)]
Haben im selben Objektbaum mehrere Objekte die eigenschaft RBUTTON, so kann
immer nur eines dieser Objekte selektiert sein. Diese Objekte sollten alle
Kinder eines Elternobjekts mit der Objektart G_IBOX sein. Wird ein anderes
Objekt dieser Gruppe ausgewÑhlt, wird das zuvor selektierte automatisch
deselektiert.

!label LASTOB
!item [LASTOB     (0x0020)]
Hierbei handelt es sich um das letzte Objekt innerhalb eines Objektbaumes.

!label TOUCHEXIT
!item [TOUCHEXIT  (0x0040)]
Der Dialog (siehe auch form_do) wird beendet, sobald sich der Mauszeiger
Åber diesem Objekt befindet, und der linke Mausknopf gedrÅckt wird.

!label HIDETREE
!label HIDDEN
!item [HIDETREE   (0x0080)]
Das Objekt und seine Kinder werden von objc_draw und objc_find nicht mehr
bemerkt, sobald dieses Flag gesetzt ist. Weiterhin wird das Flag ab MagiC
5.20 auch von form_keybd ausgewertet, wenn Objekte zu TastenkÅrzeln gesucht
werden. Eine Eingabe in versteckte Objekte ist jedoch immer noch mîglich.
Um dies zu verhindern, muû das Flag EDITABLE gelîscht werden.

!label INDIRECT
!item [INDIRECT   (0x0100)]
ob_spec zeigt nun auf einen weiteren Zeiger, der dann auf den eigentlichen
Wert von ob_spec zeigt (siehe auch OBJECT). Auf diese Weise lassen sich die
Standarddatenstrukturen wie TEDINFO etc. auf einfache Art erweitern.

!label FL3DIND
!item [FL3DIND    (0x0200)]
Dieses Objekt erzeugt unter MultiTOS ein dreidimensionales Objekt (unter
MagiC (ab Version 3.0) erst ab 16 Farben, und wenn der 3D-Effekt nicht
abgeschaltet wurde). Im 3D-Betrieb wird dies als Indikator aufgefaût. Bei
diesen Objekten handelt es sich i.d.R. um Buttons, die einen Status
anzeigen, beispielsweise Radio-Buttons.

!label ESCCANCEL
!item [ESCCANCEL (0x0200)]
Das DrÅcken der ESC Taste entspricht einem AnwÑhlen des Objekts mit
diesem Flag. Deshalb darf es nur ein Default Objekt in einem Dialog
geben. Only effective in ViewMAX/2 and later.

!label FL3DBAK
!item [FL3DBAK    (0x0400)]
Dieses Objekt wird im 3D-Betrieb als Hintergrund aufgefaût, und entsprechend
gezeichnet. Es empfiehlt sich in Dialogen mit 3D-Buttons das ROOT Objekt mit
diesem Flag zu belegen. Gleiches gilt fÅr Eingabefelder und Textobjekte,
denn nur so wird eine einheitliche Hintergrundfarbe erhalten.

Siehe auch (0x4000).

!label BITBUTTON
!item [BITBUTTON (0x0400)]
Dieses Flag wurde mit ViewMAX beta eingefÅhrt, wird dort aber nicht
benutzt. Vermutlich enthÑlt ein Button mit diesem Flag eine Bitmap
anstelle eines Textes.
Only effective in ViewMAX/2 and later.

!label FL3DACT
!item [FL3DACT    (0x0600)]
Dieses Objekt wird im 3D-Betrieb als Aktivator aufgefaût. Bei diesen
Objekten handelt es sich i.d.R. um Buttons, mit denen man Dialoge verlassen,
oder sonstwie eine Aktion hervorrufen kann.

!label SUBMENU
!item [SUBMENU    (0x0800)]
Wird in MultiTOS und ab MagiC 5.10 verwendet, um SubmenÅs zu kennzeichnen.
menu_attach setzt dieses Bit in einem MenÅeintrag, um zu kennzeichnen, daû
hier ein SubmenÅ angehÑngt ist. Das Hibyte von ob_type enthÑlt dann die
SubmenÅ-Nummer (128..255) d.h. Bit 15 von ob_type ist immer gleichzeitig mit
SUBMENU gesetzt.

!label SCROLLER
!item [SCROLLER (0x0800)]
Das DrÅcken der PAGEUP Taste entspricht einem AnwÑhlen des ersten
Objekts mit diesem Flag in dem Dialog. Das DrÅcken der PAGEDOWN Taste
entspricht einem AnwÑhlen des letzten Objekts mit diesem Flag.
Only effective in ViewMAX/2 and later.

!label FLAG3D
!item [FLAG3D (0x1000)]
Ein Objekt mit dieserm Flag wird mit einem 3D Rahmen gezeichnet. Ab
ViewMAX/2 wird jeder Button automatisch mit einem 3D Rahmen gezeichnet.
Dazu wird die Color Categorie (siehe USECOLOURCAT) benutzt.
Only effective in ViewMAX/2 and later.

!label USECOLOURCAT
!item [USECOLOURCAT (0x2000)]
Die Farbe des Objekts ist kein Farbindex des VDI sondern ein Eintrag
in einer Tabelle mit Farben fÅr bestimmte Kategorien. Diese Tabellle
hat 16 EintrÑge. ViewMAX benutzt die folgenden Kategorien:

!begin_xlist
!item [CC_NAME (8)]       Inaktive Titlezeile eine Fensters
!item [CC_SLIDER (8)]     Hintergrund einer Scrollbar
!item [CC_DESKTOP (10)]   Der Desktop
!item [CC_BUTTON (11)]    Buttons und andere 3D Gadgets
!item [CC_INFO (12)]      Infozeile eines Fensters
!item [CC_ALERT (13)]     Alertboxen (wird in ViewMAX und FreeGEM nicht benutzt)
!item [CC_SLCTDNAME (14)] Aktive Titelzeile eines Fensters
!end_xlist

Wahrscheinlich ist beabsichtigt, die Kategorien 0 bis 7 durch die
Applikation definieren zu lassen, wÑhrend 8 bis 15 fÅr das System
reserviert sind. Die Einstellung wird in ViewMAX.INI ((!nolink [GEM]).CFG in
FreeGEM) gespeichert und besteht aus jeweils einen Vordergrund,
Hintergrund, FÅllstil und FÅllindex.
Only effective in ViewMAX/2 and later.

!item [FL3DBAK (0x4000)]
3D background (sunken rather than raised). (!nl)
To check for this feature, use appl_init and 
check that bit 3 of xbuf.abilities is set.

!item [SUBMENU (0x8000)]
Not implemented in any known PC AES

!end_xlist


Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node



!begin_node Objektstati des AES

Vom Objektstatus hÑngt es ab, wie ein Objekt spÑter auf dem Bildschirm
dargestellt wird. Ein Objektstatus kann von folgendem Typ sein:

!begin_xlist [UNDERLINE (0x0f00)]
!item [Status]
Bedeutung
!item [~]
~

!item [NORMAL    (0x0000)]
Normale Darstellung.

!label SELECTED
!item [SELECTED  (0x0001)]
Inverse Darstellung, dh. das Objekt ist selektiert.

!label CROSSED
!item [CROSSED   (0x0002)]
Falls die Objektart BOX ist, wird das Objekt mit durchgestrichen gezeichnet.

!label CHECKED
!item [CHECKED   (0x0004)]
Am linken Objektrand befindet sich ein HÑkchen.

!label DISABLED
!item [DISABLED  (0x0008)]
Das Objekt wird grau dargestellt und ist nicht mehr selektierbar.

!label OUTLINED
!item [OUTLINED  (0x0010)]
Das Objekt bekommt einen Rahmen.

!label SHADOWED
!item [SHADOWED  (0x0020)]
Ein Schatten wird unter das Objekt gezeichnet.

!label WHITEBAK
!item [WHITEBAK  (0x0040)]
Auf PC-(!nolink [GEM]) bewirkt dies, daû die Icon-Maske nicht mitgezeichnet wird, was
u.U. die Ausgabe beschleunigen kann. (!nl) Ab MagiC-3 wird hiermit das
Unterstreichen von Zeichenketten gesteuert. Dieses Feature kann Åber
(!link [appl_getinfo][%apgi_13]) (Opcode 13) ermittelt werden.

!label DRAW3D
!item [DRAW3D    (0x0080)]
Ein Objekt soll mit 3D-Effekt gezeichnet werden. Dieses Flag ist nur fÅr
PC-GEM interessant, und wird vom Atari-AES (so z.B. auch in (!nolink [MagiC])) ignoriert.

!label HIGHLIGHTED
!item [HIGHLIGHTED (0x0100)]
Ein Objekt mit diesem State wird mit einer gestrichelten Line, die mit
MD_XOR gezeichnet wird, umrandet. Dieser State wurde mit ViewMAX beta
eingefÅhrt.

!label UNHIGHLIGHTED
!item [UNHIGHLIGHTED (0x0200)]
Bei einem Objekt mit diesem State wird beim Zeichnen explizit eine
durch den State HIGHLIGHTED gezeichnete Umrandung entfernt. Dazu muû
wie folgt vorgegangen werden: Zuerst muû der State HIGHLIGHTED gelîscht
werden, dann der State UNHIGHLIGHTED gesetzt werden und anschlieûend
das Objekt mit der Funktion objc_draw neu gezeichnet werden. Ein
Neuzeichnen des Objekts ohne den State UNHIGHLIGHTED wÅrde die Umrandung
nicht lîschen, da sie auûerhalb des Bereichs liegt, den das Objekt
belegt. Nach dem Neuzeichnen sollte der State UNHIGHLIGHTED wieder
gelîscht werden. Dieser State wurde mit ViewMAX beta eingefÅhrt.

!label UNDERLINE
!item [UNDERLINE (0x0f00)]
Dieser Opcode steht unter MagiC ab Version 2.0 zur VerfÅgung, und legt die
Position und Grîûe des Unterstriches bei Objekten vom Typ G_STRING, G_TITLE
und G_BUTTON fest.

!label XSTATE
!item [XSTATE    (0xf000)]
Dieser Opcode steht unter MagiC ab Versio 2.0 zur VerfÅgung, und sorgt fÅr
das Umschalten bei den verschiedenen Button-Typen ((!nolink [G_STRING]),
(!nolink [G_TITLE]) und (!nolink [G_BUTTON])).
!end_xlist

In (!nolink [GEM])/5, CROSSED makes the object draw in 3D:
!begin_itemize !compressed
!item If an object is both CROSSED and SELECTABLE, then it is drawn as a checkbox.
!item If it is CROSSED, SELECTABLE and an RBUTTON, it is drawn as a radio button.
!item If it is a button or a box and it is CROSSED, then it is drawn as a raised
3D shape, similar to Motif.
!item If a button is CROSSED and DEFAULT, a "Return key" symbol appears on it
   (rather like NEXTSTEP).
!item Boxes and text fields that are CROSSED and CHECKED appear sunken.
!end_itemize
(!nolink [GEM])/5 can be detected by calling vqt_name for font 1. If nothing is
returned, (!nolink [GEM])/5 is running.


Recent FreeGEM builds contain a system based on the (!nolink [GEM])/5 one, but
extended and backwards-compatible. The DRAW3D state is used instead
of CROSSED:

!begin_itemize !compressed
!item If an object is both DRAW3D and SELECTABLE, then it is drawn as a checkbox.
!item If it is DRAW3D, SELECTABLE and an RBUTTON, it is drawn as a radio button.
!item If a button is DRAW3D and DEFAULT, a "Return key" symbol will be on it.
!item If an object with a 3D border has the WHITEBAK state, then the 3D border
will not have a black edge.
!item If a radio button or checkbox has the WHITEBAK state, then it will be drawn
with a white background rather than in the colour used by 3D objects.
!end_itemize

To check for these abilities, use appl_init and check that bit 3 of
xbuf.abilities is set.

Querverweis:  (!link [Objektstruktur im AES][Die Objekt-Struktur]) ~ Objektarten des AES
!end_node
!end_node


!begin_node Der Quarter-Screen-Buffer

Der Quarter-Screen-Buffer wird vom Screen-Manager benîtigt, um beim
Herunterklappen von Drop-Down-MenÅs den Inhalt des MenÅhintergrundes zu
retten. Auch bei der Anzeige von Alarmboxen kommt der 'QSB' (so die
gebrÑuchliche AbkÅrzung) zum Einsatz. Normalerweise sollte seine Grîûe von
der Anzahl  der Farbebenen und der Grîûe des Systemzeichensatzes,
(!I)nicht(!i) aber von der Gesamtgrîûe des Bildschirms abhÑngen.

(!B)Eine gute Formel wÑre:(!b) (!nl)
~~ 500(Zeichen) * Platzbedarf eines Zeichens * Farbebenen

Damit kÑme man in der Auflîsung 'ST-Hoch' genau auf den Wert 8000 (also
ein Viertel des Bildspeichers). Leider ist das AES in vielen FÑllen jedoch
nicht so clever; die folgende Tabelle enthÑlt eine öbersicht Åber die
benutzten Algorithmen einiger (!nolink [GEM])-Versionen:

!begin_table [ll]
(!nolink [GEM])-Version !! Methode zum Setzen des QSB
!hline
1.0 und 1.2 !! statisch, 8000 Bytes
1.4 !! dynamisch, ein Viertel des Bildspeichers
3.0 !! dynamisch, die HÑlfte des Bildspeichers
!end_table

(!B)Hinweis:(!b) Die (!nolink [GEM])-Versionen 1.0 und 1.2 (also bis einschlieûlich
TOS-Version 1.02) sind mithin (!I)nicht(!i) fÅr Farbgrafikkarten vorbereitet
- einer unter mehreren GrÅnden, warum man selbst bei Benutzung eines
speziellen VDI-Treibers unter diesen (!nolink [GEM])-Versionen Farbgrafikkarten
(!I)nicht(!i) einsetzen kann.

Querverweis: GEM
!end_node


!begin_node Die Rechteckliste eines Fensters
!label Fensters, Rechteckliste eines

Um dem Problem sich Åberlappender Fenster zu begegnen, unterhÑlt das AES
fÅr jedes Fenster die sogenannte (!I)Rechteckliste(!i); alle Elemente dieser
Liste ergeben gerade den komplett sichtbaren Arbeitsbereich des
entsprechenden Fensters.

Um ein Fenster (bzw. dessen Inhalt) neu zu zeichnen erfragt man zunÑchst
per wind_get( (!link [WF_FIRSTXYWH][WF_FIRSTXYWH, wind_get])) das erste Rechteck
der o.g. Liste. Dann stellt
man fest, ob sich dieses Rechteck mit dem neu zu zeichnenden
Bildschirmbereich Åberschneidet; dann und nur dann zeichnet man diesen
Bereich unter Ausnutzung von vs_clip neu.

Diese Methode wird mit allen Åbrigen Elementen der Rechteckliste
fortgesetzt, bis die Hîhe (!I)und(!i) Breite eines Rechtecks den Wert Null
besitzen.

Querverweis: Clipping ~  WM_REDRAW ~  wind_get ~  wind_update
!end_node



!begin_node Der Screen-Manager

Der Screen-Manager ist immer aktiv und Åberwacht die Position des
Mauszeigers, wenn dieser den Arbeitsbereich der Fenster anderer
Applikationen verlÑût. Die hier in Frage kommenden FlÑchen sind die
Rahmen der Fenster, die Drop-Down-MenÅs und die MenÅleiste.

Beim BerÅhren des MenÅbereichs sorgt der Screen-Manager selbsttÑtig dafÅr
daû der vom MenÅ belegte Bildschirmausschnitt gesichert und anschlieûend
wiederhergestellt wird (dazu wird der Quarter-Screen-Buffer benutzt).

Auch Manipulationen an den Fensterkontrollen fÅhren nicht zu dauerhaften
VerÑnderungen des Bildspeichers; Resultat der Interaktionen mit dem
Screen-Manager sind die sogenannten Mitteilungsereignisse, die die
zustÑndige Applikation Åber die Aktion des Benutzers informieren.

!label Screen-Manager, Name des
!label Screen-Manager, ID des
(!B)Hinweis:(!b) Die ID des Screen-Managers kann Åbrigens leicht durch einen
Aufruf von appl_find("SCRENMGR") ermittelt werden.

Querverweis: AES ~  GEM ~  Nachrichten
!end_node


!include gem\aes\toolbar.ui


!begin_node AES-Bindings
!label Bindings des AES

Das AES wird Åber ein einziges Unterprogramm aufgerufen, dem 6 Parameter
Åbergeben werden; es handelt sich dabei um (!nolink [Adressen]) verschiedener Arrays,
die zur Ein-/Ausgabe-Kommunikation benutzt werden. Um eine AES-Funktion
aufzurufen, muû der folgende Parameterblock mit den (!nolink [Adressen]) der unten
beschriebenen Arrays bestÅckt werden:

!label AES-Parameterblock
!label Parameterblock des AES
!label AESPB
!begin_verbatim
typedef struct
{
    int16_t *cb_pcontrol;  /* Zeiger auf control-Array */
    int16_t *cb_pglobal;   /* Zeiger auf global-Array  */
    int16_t *cb_pintin;    /* Zeiger auf int_in-Array  */
    int16_t *cb_pintout;   /* Zeiger auf int_out-Array */
    int16_t *cb_padrin;    /* Zeiger auf adr_in-Array  */
    int16_t *cb_padrout;   /* Zeiger auf adr_out-Array */
} AESPB;
!end_verbatim

Die Adresse dieses Parameterblocks (der sich auf dem Stack befindet), muû
dann im Register d1 vermerkt, und zusÑtzlich Register d0.w mit dem Wert
0xc8 (200) gefÅllt werden. Durch einen TRAP #2 Systemaufruf kann dann das
(!nolink [AES]) direkt aufgerufen werden. FÅr den (!B)(!I)Pure-Assembler(!b)(!i) kînnte
das z.B. so aussehen:

!label aes
!begin_verbatim
                .EXPORT aes         ; Funktion exportieren
                .CODE               ; Beginn des Code-Segments

        aes:     MOVE.L 4(sp),D1    ; Adresse des Parameterblocks
                 MOVE.W #200,D0     ; Opcode des AES
                 TRAP   #2          ; GEM aufrufen
                 RTS                ; raus hier

                .END                ; Ende des Moduls
!end_verbatim

DarÅber, welche Register verÑndert werden dÅrfen, gibt es keine klaren
Informationen. Tatsache ist jedoch, daû die entsprechenden Routinen im
ROM (!I)alle(!i) Register retten.

Nun zu den einzelnen Arrays. öber jedes Feld kînnen bestimmte Ein- bzw.
Ausgaben getÑtigt werden; es gilt:

!label control
!begin_xlist [int16_t control[5!]] !compressed
!item [(!B)int16_t control[5!](!b)]
öber dieses Feld werden Informationen Åber die aufgerufene Funktion und ihre
Parameter festgelegt. Es gilt:
!begin_xlist
!item [control[0!]]
= Funktionsnummer
!item [control[1!]]
= Anzahl der Werte im int_in-Array
!item [control[2!]]
= Anzahl der Werte im int_out-Array
!item [control[3!]]
= Anzahl der Werte im addr_in-Array
!item [control[4!]]
= Anzahl der Werte im addr_out-Array
!end_xlist
DarÅber, welche Informationen vor einem AES-Aufruf gesetzt werden mÅssen,
gibt es keine klaren Informationen. Nîtig ist es auf jeden Fall fÅr die
Elemente [0],[1] und [3]. Wenig sinnvoll erscheint es fÅr die Elemente [2]
und [4] zu sein - schlieûlich wissen die (!nolink [AES])-Funktionen ja selbst, wie viele
Werte sie in den Ausgabefeldern zurÅckliefern.

!label Globalfeld des AES
!label global
!item [(!B)int16_t global[15!](!b)]
Dieses Feld enthÑlt globale Daten fÅr die Applikation und wird teils von
appl_init, teils von anderen (!nolink [AES])-Funktionen benutzt, und automatisch
gefÅllt. Es gilt:
!begin_xlist [global[11,12]] !compressed

!label AES-Versionsnummer
!label Versionsnummer des AES
!item [global[0!]]
Versionsnummer der (!nolink [AES])

!label Multitasking vorhanden?
!item [global[1!]]
Anzahl der Applikationen, die gleichzeitig laufen kînnen. Bei einem Wert
von -1 gibt es keine BeschrÑnkung.
!item [global[2!]]
Kennung (ID) der Applikation
!item [global[3,4!]]
Beliebige Information, die nur fÅr die Applikation von Bedeutung ist und
von dieser gesetzt und gelesen werden kann.
!item [global[5,6!]]
Zeiger auf eine Liste von Zeigern auf die ObjektbÑume der Applikation
(wird von rsrc_load gesetzt).
!item [global[7,8!]]
Adresse des fÅr die Resource-Datei reservierten Speichers. Nur von Digital
Research und (!I)nicht(!i) von Atari dokumentiert.
!item [global[9!]]
LÑnge des reservierten Speichers. Nur von Digital Research und
(!I)nicht(!i) von Atari dokumentiert.
!item [global[10!]]
Anzahl der Farbebenen. Nur von Digital Research und (!I)nicht(!i) von
Atari dokumentiert.
!item [global[11,12!]]
reserviert
!item [global[13!]]
Maximale Hîhe eines Zeichens, die vom (!nolink [AES]) fÅr den vst_height-Aufruf
benutzt wird. Dieser Eintrag ist erst ab (!nolink [AES])-Version 4.0, und auch nur von
Atari dokumentiert. (!nl)
Ab PC-GEM Version 2.0 wird dieser Wert als Bitvektor mit
den auf dem Desktop angemeldeten Laufwerken interpretiert (Bit-15 =
Laufwerk-A).
!item [global[14!]]
Minimale Hîhe eines Zeichens, die vom (!nolink [AES]) fÅr den vst_height-Aufruf
benutzt wird. Dieser Eintrag ist erst ab (!nolink [AES])-Version 4.0, und auch nur von
Atari dokumentiert. (!nl)
Ab PC-GEM Version 2.0 wird dieser Wert als Bitvektor
interpretiert, der angibt, welche der in global[13] angegebenen Laufwerke
als Festplatten betrachtet werden kînnen.
!end_xlist

!label int_in
!item [(!B)int16_t int_in[16!](!b)]
öber dieses Feld werden alle 16-Bit groûen Eingabeparameter Åbergeben.

!label int_out
!item [(!B)int16_t int_out[10!](!b)]
öber dieses Feld liefert das (!nolink [AES]) alle 16-Bit groûen RÅckgabewerte.

!label addr_in
!item [(!B)int32_t addr_in[8!](!b)]
Dieses Feld dient zur öbermittlung von Zeigern (z.B. Zeiger auf
Zeichenketten) an (!nolink [AES]) Funktionen.

!label addr_out
!item [(!B)int32_t addr_out[2!](!b)]
öber dieses Feld werden 32-Bit groûe Werte vom (!nolink [AES]) zurÅckgeliefert.
!end_xlist

(!B)Achtung:(!b) Wenn das Betriebssystem Threads unterstÅtzt, muss unbedingt
darauf geachtet werden, eine Multithread-sichere Bibliothek zu verwenden.
Insbesondere muss sichergestellt werden, daû jeder Thread sein
(!I)eigenes(!i) global-Feld (s.o) erhÑlt.

Querverweis: (!link [Beispiel-Binding][Beispiel-Binding fÅr AES-Funktionen]) ~ VDI-Bindings ~
TOS Liste


!begin_node Beispiel-Binding fÅr AES-Funktionen

Die Funktion 'crys_if' (Crystal Interface) sorgt fÅr die Besetzung des
(!nolink [control])-Arrays, und macht den eigentlichen (!nolink [AES])-Aufruf.
Dazu bedient sie sich einer Tabelle, in der fÅr jede einzelne (!nolink [AES])-Funktion die
Werte fÅr
(!nolink [control])[1], (!nolink [control])[2] und (!nolink [control])[3] vermerkt sind.
!label crys_if

!begin_verbatim
AESPB c;

int16_t crys_if (int16_t opcode)
{
  int16_t i, *paesb;

  control[0] = opcode;
  paespb = &ctrl_cnts[ (opcode-10)*3 ];

  for (i = 1; i < 4; i++)
    control[i] = *paespb++;

  aes (c);
  return (int_out[0]);

} /* crys_if */
!end_verbatim

Die dabei verwendete Tabelle kînnte beispielsweise folgendermaûen aufgebaut
sein:

!begin_verbatim
.GLOBAL ctrl_cnts
.DATA

ctrl_cnts: .dc.b     0,  1,  0       ; appl_init
           .dc.b     2,  1,  1       ; appl_read
           .dc.b     2,  1,  1       ; appl_write
            ...
            ...
            ...

.END
!end_verbatim

Querverweis: AES-Bindings  ~ GEM
!end_node
!end_node
!end_node

!endif


!include gem\aes\appl_\appl_.u
!include gem\aes\fsel_\fsel_.u
!include gem\aes\pdlg_\pdlg_.u
!include gem\aes\edit_\edit_.u
!include gem\aes\evnt_\evnt_.u
!include gem\aes\wdlg_\wdlg_.u
!include gem\aes\wind_\wind_.u
!include gem\aes\fslx_\fslx_.u
!include gem\aes\form_\form_.u
!include gem\aes\graf_\graf_.u
!include gem\aes\scrp_\scrp_.u
!include gem\aes\lbox_\lbox_.u
!include gem\aes\menu_\menu_.u
!include gem\aes\objc_\objc_.u
!include gem\aes\rsrc_\rsrc_.u
!include gem\aes\shel_\shel_.u
!include gem\aes\xgrf_\xgrf_.u
!include gem\aes\fnts_\fnts_.u

!include gem\aes\aes_f.u
!include gem\aes\structures\structures.u

!end_node
