## Hypertext zum TOS-Betriebssystem
##
## Kapitel 5: VDI-Funktionsaufrufe

!ifdest [html,hh]
!define almost &#x2248;
!define micro &#xb5;
!else
!define almost ÷
!define micro æ
!endif

!iflang [english]

!include gem/vdi/vdi_en.u

!else

!begin_node Das VDI
!html_name About_the_VDI

Das (!nolink [VDI]) (Virtual Device Interface) ist ein Teil von GEM, und in erster Linie
als standardisiertes Grafiksystem zu verstehen. Aus Sicht des Programmierers
stellt sich das (!nolink [VDI]) als eine sehr umfangreiche Grafikbibliothek dar, deren
Ausgabeformat (!uumlaut)ber mehrere Plattformen hinweg portabel ist. Das (!nolink [VDI]) kann in
die folgenden Funktionsgruppen unterteilt werden:

!begin_itemize !compressed
!item Attributfunktionen
!item Ausgabefunktionen 
!item Auskunftsfunktionen 
!item Eingabefunktionen
!item Escapefunktionen                                           
!item Farbtabellenfunktionen
!item Kontrollfunktionen
!item Rasterfunktionen
!end_itemize

Da das Original-(!nolink [VDI]) im TOS des Atari mit einigen Schw(!aumlaut)chen behaftet, und vor
allem nicht besonders schnell ist, hat sich NVDI bei vielen Benutzern als
(!I)der(!i) Ersatz f(!uumlaut)r das normale (!nolink [VDI]) erwiesen.

Einige der Funktionen des (!nolink [VDI]) ben(!oumlaut)tigen die Erweiterung GDOS, das
urspr(!uumlaut)nglich als Teil des Betriebssystems mitgeliefert werden sollte,
aufgrund von Speicherplatzproblemen in den ROM's der ersten ST's von Atari
jedoch ausgelagert wurde. Durch konsequente Nutzung der (!nolink [VDI]) Routinen kann
jeder Programmierer daf(!uumlaut)r sorgen, da(!sharps) seine Programme sauber auf
unterschiedlichen Rechnern und in nahezu beliebigen Aufl(!oumlaut)sungen arbeiten.

Querverweis:
Grundlagen des VDI ~ Bindings des VDI ~ AES
!end_node


!begin_node Grundlagen des VDI
!html_name VDI_fundamentals

!label VDI, Grundlagen des

Das (!nolink [VDI]) (Virtual Device Interface) bildet die untere H(!aumlaut)lfte des GEM; es ist
sozusagen die Grundlage aller AES-Funktionen.

Auch wenn man mit dem (!nolink [VDI]) normalerweise prim(!aumlaut)r Funktionen zur Grafikausgabe
verbindet, erstreckt sich der Aufgabenbereich auch auf (!I)Eingaben(!i) (wie
z.B. per Maus oder Grafiktablett). (!nolink [Das VDI]) ist also eine
Betriebssystemschicht zur Ansteuerung von (im weitesten Sinn)
grafikorientierten Aus- (!I)und(!i) Eingabeger(!aumlaut)ten. Dieser Abschnitt
beschreibt die Punkte:

!begin_itemize !compressed
!item Bindings des VDI
!item Clipping
!item (!link [GDOS][Das GDOS])
!item GDOS-Treiber
!item Koordinatensysteme des VDI
!item (!link [Line-A Routinen][Der Line-A-Emulator])
!item Metafile-Format
!item NVDI
!item Off-Screen-Bitmaps
!item (!link [OUT-Dateiformat][Das OUT-Dateiformat])
!item Rasterformate
!item SpeedoGDOS
!item (!link [Vektorfonts][Details zu Vektorschriften])
!item Workstations des VDI
!item (!link [XIMG-Format][XIMG-Format])
!end_itemize

Wie das W(!oumlaut)rtchen 'Virtual' bereits andeutet, k(!oumlaut)nnen dabei fast alle
Funktionsaufrufe auf jedes verf(!uumlaut)gbare Ausgabeger(!aumlaut)t (Bildschirm, Drucker,
Plotter, Diabelichter etc.) angewendet werden. Es spielt also keine Rolle,
ob man Kreise malen oder Texte ausgeben m(!oumlaut)chte: dies kann immer mit den
gleichen Betriebssystemfunktionen realisiert werden.

!label VDI, Entstehung des
Die Wurzeln des (!nolink [VDI]) liegen im CP/M-GSX-System, das Anfang der 80er Jahre
aus dem Bedarf f(!uumlaut)r eine portable Grafikschnittstelle f(!uumlaut)r die damals
dominierenden CP/M-Systeme entstand. (!Aumlaut)hnlichkeiten in Funktionen und
Bezeichnungen zum GKS (Grafisches Kern-System) sind daher keineswegs
zuf(!aumlaut)llig, sondern von den Entwicklern bei (!I)Digital Research(!i) voll
beabsichtigt gewesen.

(!nolink [Das VDI]) erf(!uumlaut)llt den ANSI-Standard X3H3.6CG-(!nolink [VDI]).

Querverweis: Style-Guidelines


!begin_node Clipping

Clipping ist ein Verfahren, das die Benutzung eines Fenstersystems
eigentlich erst m(!oumlaut)glich macht. Dabei gibt man mittels des Clipping-Rechtecks
an, auf welchen Bildschirmbereich sich alle Grafikausgaben der betreffenden
Workstation beziehen sollen; alles, was aus dem so spezifizierten
Bildausschnitt herausragt, wird bei der Bildschirmausgabe (!uumlaut)bergangen.

Eine zwar wenig effiziente, aber leicht zu programmierende
Fensterausgaberoutine w(!uumlaut)rde einfach f(!uumlaut)r jedes zu zeichnende Teilrechteck des
Fensters jeweils ein Clipping-Rechteck setzen und dann alle zum Aufbau des
Fensterinhaltes notwendigen Bildschirmausgaben wiederholen. Wer sich die
M(!uumlaut)he macht, zun(!aumlaut)chst anhand einer Plausibilit(!aumlaut)tsabfrage festzustellen, ob
das zu zeichnende Objekt (!uumlaut)berhaupt (!I)sichtbar(!i) ist, kann nat(!uumlaut)rlich
deutlich Zeit sparen.

(!B)Hinweis:(!b) Wie so vieles im Leben ist auch das Clipping nicht gratis
zu haben. Wer eine optimale Geschwindigkeit beim Bildschirmaufbau erreichen
will sollte das Clipping-Rechteck so oft wie nur m(!oumlaut)glich ausschalten.

Querverweis: Grundlagen des VDI ~  Style-Guidelines ~  vs_clip
!end_node



!begin_node Das GDOS
!label FontGDOS
!label FSM-GDOS
!label AMC-GDOS
!label GDOS, Font-
!label GDOS, FSM-
!label GDOS, AMC-

Einige Funktionen des VDI k(!oumlaut)nnen erst nach der Installation des GDOS aus
dem AUTO-Ordner heraus richtig benutzt werden. Grunds(!aumlaut)tzlich erm(!oumlaut)glicht
das GDOS (Graphics Device Operating System) beliebige Ger(!aumlaut)tetreiber und
Zeichens(!aumlaut)tze zu laden, und dann zu benutzen.

Es ist dabei v(!oumlaut)llig unabh(!aumlaut)ngig vom verwendeten Ger(!aumlaut)t. Ger(!aumlaut)tespezifisch sind
nur die nachzuladenden Treiber, die die (!nolink [VDI]) Funktionen auf dem
entsprechenden Ger(!aumlaut)t realisieren. Bei genauer Kenntnis des Treiberformats
ist es so m(!oumlaut)glich beliebige, und auch exotische Ausgabeger(!aumlaut)te als (!nolink [VDI])
Ausgabeger(!aumlaut)t zu betreiben.

Mit residentem GDOS erh(!oumlaut)ht sich die Zahl der Verf(!uumlaut)gung stehenden
(!nolink [VDI])-Funktionen, w(!aumlaut)hrend alle anderen Funktionen voll funktionsf(!aumlaut)hig bleiben
bzw. einen erweiterten Ausgabeumfang erhalten. Umgekehrt ist das aber nicht
so, Funktionen, die GDOS ben(!oumlaut)tigen, f(!uumlaut)hren ohne residentes GDOS zum Absturz
des Rechners. 
!label GDOS, Familie des

!image (!picture_path)gdos_ahn

!begin_center
Abb: Der Stammbaum der GDOS-Familie
!end_center

!label vq_gdos
(!B)Daher ist es in einigen F(!aumlaut)llen wichtig zu wissen, ob (!uumlaut)berhaupt ein
vollst(!aumlaut)ndiges GDOS installiert ist.(!b) Atari hat zu diesem Zweck das
folgende Verfahren dokumentiert: Der Trap-Dispatcher ver(!aumlaut)ndert den
Eingabewert -2 f(!uumlaut)r Register D0 genau dann, wenn ein GDOS installiert ist.
Viele Compiler stellen die Funktion (!B)vq_gdos(!b) zur Verf(!uumlaut)gung die genau
dann einen Wert von 0 zur(!uumlaut)ckliefert wenn (!I)kein(!i) GDOS installiert ist.
Diese Funktion basiert im wesentlichen auf dem folgenden Code:

!begin_verbatim
vq_gdos:
              move.w   #-2,d0
              trap     #2
              cmp.w    #-2,d0
              sne      d0
              ext.w    d0
              rts
!end_verbatim

(!B)Wichtiger Hinweis:(!b) vq_gdos liefert nur die Information, ob ein GDOS
vorhanden ist, oder nicht. Es wird (!I)nichts(!i) dar(!uumlaut)ber ausgesagt, um
welches GDOS es sich handelt bzw. welche F(!aumlaut)higkeiten das installierte GDOS
besitzt. So l(!aumlaut)(!sharps)t sich mit Hilfe dieser Funktion beispielsweise das AMC-GDOS
(!I)nicht(!i) von SpeedoGDOS oder NVDI unterscheiden.

!label ABC-GEM
(!B)Vorsicht:(!b) Die GEM-Versionen des niederl(!aumlaut)ndischen Softwarehauses "ABC"
(ABC-GEM 2.x) st(!uumlaut)rzen bei diesem Aufruf ab.

!label vq_vgdos
!label _vq_gdos
Alternativ gibt es noch vq_vgdos (_vq_gdos):

!begin_verbatim
vq_vgdos:
              move.w   #-2,d0
              trap     #2
              rts
!end_verbatim

!label GDOS_NONE
!label GDOS_ATARI
!label GDOS_AMC
!label GDOS_AMCLIGHT
!label GDOS_FNT
!label GDOS_FSM
Als R(!uumlaut)ckgabe erh(!aumlaut)lt man:
!begin_table [l|l|l]
Name !! Wert !! GDOS Type
!hline
GDOS_NONE    !! -2 !! GDOS not (!nolink [installed]).
-            !! Any other value.     !! GDOS 1.0  or 1.2
GDOS_ATARI   !! 0x0007E88A           !! GDOS 1.1 von Atari Corp.
GDOS_AMC     !! 0x0007E864           !! AMC-GDOS von Arnd Beissner
GDOS_AMCLIGHT !! 0x0007E8BA          !! GEMINI-Spezial-GDOS von Arnd Beissner 
-            !! 0x3e5d0957           !! ttf-gdos von Trevor Blight
GDOS_FNT     !! 0x5F464E54 ('_FNT')  !! FONTGDOS
GDOS_FSM     !! 0x5F46534D ('_FSM')  !! FSMGDOS
-            !! 0x66564449 ('fVDI')  !! fVDI
!end_table
# Quelle: ttf-gdos aus Archiv ttf-gdos.lzh auf meine Festplatte ;-) [GS]
# Quelle: GDOS_ATARI, GDOS_AMC und GDOS_AMCLIGHT aus der Headerdatei portvdi.h
#         von Maustausch-Fontend CAT

Die aktuellen (und leistungsf(!aumlaut)higsten) Versionen sind das (!nolink [SpeedoGDOS]) und
(!nolink [NVDI]) (ab Version 3.0), die es u.a. erlauben Vektorzeichens(!aumlaut)tze im TrueType,
Type-1 bzw. Speedo Format zu verarbeiten. (!nolink [NVDI]) liegt auch in einer
speziellen (!I)Macintosh-Version(!i) vor (NVDIMac), und erm(!oumlaut)glicht es jedem
Programm das (!uumlaut)ber GDOS ausgeben kann (in Verbindung mit MagiC Mac), seine
Ausgaben auch auf Apple-Druckern und im Netzwerk t(!aumlaut)tigen zu k(!oumlaut)nnen.

Querverweis:
(!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei]) ~
Grundlagen des VDI ~  Style-Guidelines
!end_node


!include gem/vdi/assign_sys.ui



!begin_node GDOS-Treiber
!label Treiber, GDOS-
!label Treiber, VDI-
!label VDI-Treiber

Ein GDOS-Treiber ist im wesentlichen eine normale Programmdatei ohne
Startup-Code, die als erste Routine einen Dispatcher f(!uumlaut)r die eingehenden
VDI-Aufrufe enth(!aumlaut)lt. Alle Treiber m(!uumlaut)ssen in der ASSIGN.SYS-Datei angemeldet
sein, die vom GDOS beim Start ausgewertet wird.

Die folgende Liste nennt die wichtigsten Treiber mit ihren jeweiligen
Ger(!aumlaut)tenummern:

!begin_xlist [Lade und Zeichnen Bit-Image Treiber] !compressed
!item [Bildschirm-Treiber]                   (01-10) 
!item [Plotter-Treiber]                      (11-20)              
!item [Drucker-Treiber]                      (21-30)               
!item [Metafile-Treiber]                     (31-40)               
!item [Kamera-Treiber]                       (41-50)               
!item [Grafiktablett-Treiber]                (51-60)
!item [Memory-Treiber]                       (61-70)
!item [Fax-Treiber]                          (81-90)
!item [Bit-Image Treiber]                    (91-100)
!item [Multimedia Treiber]                   (101-110)
!item [Sound Treiber]                        (111-120)
!item [Lade und Zeichnen Bit-Image Treiber]  (121-130)
!end_xlist

Bei der Implementierung des Dispatchers sollte folgendes beachtet werden:

!begin_itemize !compressed
!item die Adresse des (!nolink [VDI])-Parameterblocks wird im Register D1 (!uumlaut)bergeben
!item die Funktion selbst wird mit einer RTS-Anweisung abgeschlossen
!end_itemize

Ein GDOS-Treiber arbeitet immer im Rasterkoordinaten-System; die
Konvertierung der Werte im ptsin- und ptsout-Feld wird vom GDOS (!uumlaut)bernommen.
Dar(!uumlaut)ber hinaus mu(!sharps) beachtet werden, da(!sharps) nicht alle Funktionen den
eigentlichen Treiber exakt so erreichen, wie sie abgeschickt wurden, da sie
vom GDOS teilweise vorverarbeitet werden.

Querverweis: (!link [GDOS][Das GDOS]) ~ Grundlagen des VDI ~ Bindings des VDI



!begin_node Bildschirm-Treiber
!label GDOS-Treiber, Bildschirm
!label Treiber, Bildschirm-

Der Bildschirmtreiber des TOS kann durch einen eigenen Treiber ersetzt
werden, welcher vom GDOS nachgeladen werden muss.

Derartige Treiber gibt es bereits f(!uumlaut)r die unterschiedlichsten Grafikkarten
(z.B. (!I)NVDI-ET4000(!i) f(!uumlaut)r Grafikkarten mit dem Tseng ET-4000 Chip).

Bei der Anschaffung eines alternativen Bildschirmtreibers sollte darauf
geachtet werden, da(!sharps) der Treiber alle relevanten Funktionen des VDI
unterst(!uumlaut)tzt, und auch mit GEM-Zeichens(!aumlaut)tzen keine Probleme hat.

Querverweis:
GDOS-Treiber ~  (!link [Mindestfunktionsumfang] [Mindestfunktionsumfang f(!uumlaut)r Bildschirmtreiber])
!end_node



!begin_node Mindestfunktionsumfang f(!uumlaut)r Bildschirmtreiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Bildschirmtreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation aus dem
Atari (!I)"GEM Programmer's Guide"(!i).

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!    !! v_opnwk
  2 !!    !! v_clswk
  3 !!    !! v_clrwk
  4 !!    !! v_updwk
  5 !!    !! Escapefunktionen
    !!  1 !! vq_chcells
    !!  2 !! v_exit_cur
    !!  3 !! v_enter_cur
    !!  4 !! v_curup
    !!  5 !! v_curdown
    !!  6 !! v_curright
    !!  7 !! v_curleft
    !!  8 !! v_curhome
    !!  9 !! v_eeos
    !! 10 !! v_eeol
    !! 11 !! v_curaddress
    !! 12 !! v_curtext
    !! 15 !! vq_curaddress
    !! 18 !! v_dspcur
    !! 19 !! v_rmcur
  6 !!    !! v_pline
  7 !!    !! v_pmarker
  8 !!    !! v_gtext
  9 !!    !! v_fillarea
 11 !!    !! Ausgabefunktionen
    !!  1 !! v_bar
    !!  2 !! v_arc
    !!  3 !! v_pieslice
    !!  4 !! v_circle
    !!  5 !! v_ellipse
    !!  6 !! v_ellarc
    !!  7 !! v_ellpie
    !!  8 !! v_rbox
    !!  9 !! v_rfbox
    !! 10 !! v_justified
 12 !!    !! vst_height
 14 !!    !! vs_color
 15 !!    !! vsl_type
 17 !!    !! vsl_color
 18 !!    !! vsm_type
 20 !!    !! vsm_color
 21 !!    !! vst_font
 22 !!    !! vst_color
 23 !!    !! vsf_interior
 24 !!    !! vsf_style
 25 !!    !! vsf_color
 26 !!    !! vq_color
 28 !!    !! vrq_locator
 31 !!    !! vrq_string
 32 !!    !! vswr_mode
 33 !!    !! vsin_mode
 35 !!    !! vql_attributes
 36 !!    !! vqm_attributes
 37 !!    !! vqf_attributes
 38 !!    !! vqt_attributes
 39 !!    !! vst_alignment
100 !!    !! v_opnvwk
101 !!    !! v_clsvwk
102 !!    !! vq_extnd
104 !!    !! vsf_perimeter
106 !!    !! vst_effects
107 !!    !! vst_point
108 !!    !! vsl_ends
109 !!    !! vro_cpyfm
110 !!    !! vr_trnfm
111 !!    !! vsc_form
112 !!    !! vsf_udpat
113 !!    !! vsl_udsty
114 !!    !! vr_recfl
115 !!    !! vqin_mode
116 !!    !! vqt_extent
117 !!    !! vqt_width
118 !!    !! vex_timv
121 !!    !! vrt_cpyfm
122 !!    !! v_show_c
123 !!    !! v_hide_c
124 !!    !! vq_mouse
125 !!    !! vex_butv
126 !!    !! vex_motv
127 !!    !! vex_curv
128 !!    !! vq_key_s
129 !!    !! vs_clip
130 !!    !! vqt_name
131 !!    !! vqt_fontinfo
!end_table
!end_node



!begin_node Bit-Image Treiber
!label GDOS-Treiber, Bit-Image
!label Treiber, Bit-Image

Mit Hilfe eines Bit-Image Treibers k(!oumlaut)nnen alle Applikationen, die (!uumlaut)ber das
GDOS Ausgaben t(!aumlaut)tigen k(!oumlaut)nnen, direkt in eine Datei drucken.

Bei NVDI-Treibern kann bei v_opnwk das Seitenformat und der Name der
Bit-Image-Datei gesetzt werden. Der Dateiname kann (!uumlaut)brigens auch mit
Hilfe von vq_extnd (!uumlaut)bergeben werden:

!begin_verbatim
contrl[1]   = 4;
ptsin[2]    = 1157;
ptsin[3..4] = Zeiger auf den Dateinamen (BYTE *);
ptsin[5..6] = Zeiger auf Fehlervariable (int16_t *);
ptsin[7]    = 0;
!end_verbatim

(!B)Hinweis:(!b) (!Uumlaut)ber den Sinn und Unsinn dieses Features kann man sich
sicherlich streiten, da es sich bei vq_extnd eigentlich um eine reine
Auskunftsfunktion handelt!

Querverweis: GDOS-Treiber ~
(!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei])
!end_node



!begin_node Drucker-Treiber
!label GDOS-Treiber, Drucker
!label Treiber, Drucker-

Die Auswahl an Drucker-Treibern f(!uumlaut)r das GDOS ist inzwischen fast
unersch(!oumlaut)pflich; lediglich bei Farbdruckern scheint es noch einige Engp(!aumlaut)sse
zu geben.

Bei der Arbeit mit Drucker-Treibern sollte beachtet werden, da(!sharps) nicht alle
Treiber funktional v(!oumlaut)llig identisch sind. So gibt es etwa bei Einsatz eines
Laserdruckers nicht nur zus(!aumlaut)tzliche Funktionen, sondern einige bestehende
wurden auch teilweise erweitert.

Bei NVDI-Druckertreibern kann bei v_opnwk das Seitenformat und das GEMDOS
Ausgabeger(!aumlaut)t gesetzt werden. Zur Ausgabe von (Farb-) Bildern sollten die
Funktionen vrt_cpyfm bzw. vro_cpyfm benutzt werden. Sie lassen sich in (!nolink [NVDI])
f(!uumlaut)r Druckertreiber (und IMG, usw.) genauso wie die Funktionen des
Bildschirmtreibers ansprechen. Der einzige  Unterschied besteht darin, da(!sharps)
Raster nicht innerhalb der Druckerbitmap verschoben werden k(!oumlaut)nnen (Quell-
und Ziel-MFDB mit fd_addr == 0L), da die  Druckerbitmap i.a. aus mehreren
Scheiben besteht, die nacheinander aufbereitet werden. Da Kopieren innerhalb
der Ger(!aumlaut)tebitmap bei der Druckausgabe keinen Sinn macht, stellt dieser
Unterschied aber keine Einschr(!aumlaut)nkung dar.

Der Druckertreiber puffert die Bitmap ggf. in der Display-List falls nicht
gen(!uumlaut)gend Speicher vorhanden ist; es ist also nicht erforderlich, die Bitmap
bis zur Ausgabe mit v_updwk im Speicher zu halten.

Wenn die Bitmap skaliert werden mu(!sharps), sollte ein Programm wenn m(!oumlaut)glich nicht
selber die Bitmap vergr(!oumlaut)(!sharps)ern, sondern vrt/vro_cpyfm die Arbeit (!uumlaut)berlassen.
Dadurch steigt die Ausgabequalit(!aumlaut)t, es m(!uumlaut)ssen weniger Daten auf der
Festplatte gepuffert werden, und der Ausdruck wird beschleunigt. Ob der
Treiber skalieren kann, erf(!aumlaut)hrt man bei Aufruf von vq_extnd.

Bei Ausgabe von Farbbildern im 8-Farbmodus sollten Raster vor dem Dithern
mit einer Korrekturfunktion behandelt werden. Hier empfiehlt sich eine
Gamma-Korrektur mit Exponent von 0,3 bis 0,4, damit das Bild nicht
vollkommen matt und (!uumlaut)bers(!aumlaut)ttigt aussieht. Im Truecolor-Modus (!uumlaut)bernimmt der
Treiber Farbkorrektur, Schwarz-Separation und andere qualit(!aumlaut)tsverbessernde
Ma(!sharps)nahmen selber - Bitmaps sollten hier ohne vorhergehende Korrektur und
ohne Rasterung an den Treiber geschickt werden.

Querverweis:
GDOS-Treiber    ~  Bitmapformat bei Druckertreibern ~
(!link [Mindestfunktionsumfang] [Mindestfunktionsumfang f(!uumlaut)r Drucker-Treiber])
!end_node



!begin_node Mindestfunktionsumfang f(!uumlaut)r Drucker-Treiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Druckertreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation aus dem
Atari (!I)"GEM Programmer's Guide"(!i).

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!    !! v_opnwk
  2 !!    !! v_clswk
  3 !!    !! v_clrwk
  4 !!    !! v_updwk
  5 !!    !! Escapefunktionen
    !!  1 !! vq_chcells
    !! 20 !! v_form_adv
    !! 21 !! v_output_window
    !! 22 !! v_clear_disp_list
    !! 23 !! v_bit_image
  6 !!    !! v_pline
  7 !!    !! v_pmarker
  8 !!    !! v_gtext
  9 !!    !! v_fillarea
 11 !!    !! Ausgabefunktionen
    !!  1 !! v_bar
    !!  2 !! v_arc
    !!  3 !! v_pieslice
    !!  4 !! v_circle
    !!  5 !! v_ellipse
    !!  6 !! v_ellarc
    !!  7 !! v_ellpie
    !!  8 !! v_rbox
    !!  9 !! v_rfbox
    !! 10 !! v_justified  
 12 !!    !! vst_height
 15 !!    !! vsl_type
 17 !!    !! vsl_color
 18 !!    !! vsm_type
 20 !!    !! vsm_color
 21 !!    !! vst_font
 22 !!    !! vst_color
 23 !!    !! vsf_interior
 24 !!    !! vsf_style
 25 !!    !! vsf_color 
 26 !!    !! vq_color
 32 !!    !! vswr_mode
 35 !!    !! vql_attributes
 36 !!    !! vqm_attributes
 37 !!    !! vqf_attributes
 38 !!    !! vqt_attributes
 39 !!    !! vst_alignment 
102 !!    !! vq_extnd
104 !!    !! vsf_perimeter
106 !!    !! vst_effects
107 !!    !! vst_point 
108 !!    !! vsl_ends
112 !!    !! vsf_udpat
116 !!    !! vqt_extent
117 !!    !! vqt_width
129 !!    !! vs_clip
130 !!    !! vqt_name
131 !!    !! vqt_fontinfo
!end_table
!end_node



!begin_node Bitmapformat bei Druckertreibern
!label Druckertreiber, Bitmapformat

Genauso wie f(!uumlaut)r den Bildschirm liefert vq_scrninfo auch f(!uumlaut)r Drucker das
Format der Bitmap zur(!uumlaut)ck. In der Regel gibt es hier nur 3 verschiedene
Formate: 

!begin_itemize !compressed
!item monochrome Bitmap, wenn der Treiber 2 Farben hat.
!item drei hintereinanderliegende Ebenen, wenn der Treiber 8 Farben hat.
!item Packed Pixels mit 32 Bit, wenn der Treiber im Truecolor-Modus l(!aumlaut)uft.
!end_itemize

Da die Formate (1) und (3) wohl selbsterkl(!aumlaut)rend sind, sei hier nur noch auf
Format (2) eingegangen: Bei 8 Farben besteht eine farbige Bitmap aus 3
vollst(!aumlaut)ndigen, hintereinander im Speicher liegenden Ebenen (Planes). Das
ger(!aumlaut)tespezifische Rasterformat entspricht also dem Standardformat. Die
Zuordnung von VDI-Farbindex zum Pixelwert folgt der Standardeinteilung, die
f(!uumlaut)r alle VDI-Treiber gilt.

Querverweis: Drucker-Treiber ~  Rasterformate ~  vro_cpyfm ~  vrt_cpyfm
!end_node



!begin_node Fax-Treiber
!label GDOS-Treiber, Fax
!label Treiber, Fax-

Ein Fax-Treiber ist im Prinzip nichts anderes als ein einfacher
Drucker-Treiber. Mit Hilfe eines solchen Treibers k(!oumlaut)nnen alle Applikationen,
die (!uumlaut)ber das GDOS ausgeben, direkt Telefaxe verschicken.

Bei einem Fax-Treiber kann weder Seitenformat noch GEMDOS-Ger(!aumlaut)t angegeben
werden. Man sollte auch nicht versuchen, die Gr(!oumlaut)(!sharps)e der Bitmap zu ver(!aumlaut)ndern.

Querverweis: GDOS-Treiber ~  (!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei])
!end_node



!begin_node Grafiktablett-Treiber
!label GDOS-Treiber, Grafiktablett
!label Treiber, Grafiktablett-

Da z.Zt. noch keine Treiber f(!uumlaut)r Grafiktabletts existieren, k(!oumlaut)nnen an dieser
Stelle keine weitergehenden Informationen erteilt werden.

Querverweis: GDOS-Treiber ~  (!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei])
!end_node



!begin_node Kamera-Treiber
!label GDOS-Treiber, Kamera
!label Treiber, Kamera-

Da z.Zt. noch keine Treiber f(!uumlaut)r die (!I)Polaroid-Palette(!i) existieren,
k(!oumlaut)nnen an dieser Stelle keine weitergehenden Informationen erteilt werden.

Querverweis:
GDOS-Treiber ~ (!link [Mindestfunktionsumfang] [Mindestfunktionsumfang f(!uumlaut)r Kamera-Treiber])
!end_node



!begin_node Mindestfunktionsumfang f(!uumlaut)r Kamera-Treiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Kameratreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation von
(!I)Digital Research(!i) zu PC-GEM 2.0.

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!    !! v_opnwk
  2 !!    !! v_clswk
  3 !!    !! v_clrwk
  4 !!    !! v_updwk
  5 !!    !! Escapefunktionen
    !!  1 !! vq_chcells
    !! 23 !! v_bit_image     
    !! 91 !! vsp_film
    !! 92 !! vqp_filmname
  6 !!    !! v_pline
 11 !!    !! Ausgabefunktionen
    !!  1 !! v_bar
    !!  2 !! v_arc
    !!  3 !! v_pieslice
    !!  4 !! v_circle
    !!  5 !! v_ellipse
    !!  6 !! v_ellarc
    !!  7 !! v_ellpie
    !!  8 !! v_rbox
    !!  9 !! v_rfbox
    !! 10 !! v_justified 
 12 !!    !! vst_height
 13 !!    !! vst_rotation
 14 !!    !! vs_color
 15 !!    !! vsl_type
 16 !!    !! vsl_width
 17 !!    !! vsl_color
 18 !!    !! vsm_type
 19 !!    !! vsm_height
 20 !!    !! vsm_color
 21 !!    !! vst_font
 22 !!    !! vst_color
 23 !!    !! vsf_interior
 24 !!    !! vsf_style
 25 !!    !! vsf_color 
 26 !!    !! vq_color
 32 !!    !! vswr_mode
 35 !!    !! vql_attributes
 36 !!    !! vqm_attributes
 37 !!    !! vqf_attributes
 38 !!    !! vqt_attributes
 39 !!    !! vst_alignment 
102 !!    !! vq_extnd
104 !!    !! vsf_perimeter
106 !!    !! vst_effects
107 !!    !! vst_point 
108 !!    !! vsl_ends
112 !!    !! vsf_udpat
113 !!    !! vsl_udsty
116 !!    !! vqt_extent
117 !!    !! vqt_width
119 !!    !! vst_load_fonts
120 !!    !! vst_unload_fonts
129 !!    !! vs_clip
130 !!    !! vqt_name
131 !!    !! vqt_fontinfo
!end_table
!end_node



!begin_node Memory-Treiber
!label GDOS-Treiber, Memory
!label Treiber, Memory-

Ein Memory-Treiber ist im Prinzip ein Bildschirmtreiber, bei dem die 
Ausgaben nicht im Bildschirmspeicher, sondern in einem anderen
Speicherbereich landen, und dort dann weiterverarbeitet werden k(!oumlaut)nnen.

Die z.Zt. verf(!uumlaut)gbaren Treiber unterst(!uumlaut)tzen nur eine monochrome Bitmap, und
besitzen eine logische Aufl(!oumlaut)sung von 300dpi. Leider stimmt das Aspect-Ratio
Verh(!aumlaut)ltnis i.a. nicht mit der aktuellen Aufl(!oumlaut)sung des Bildschirms (!uumlaut)berein,
was zur Folge hat, da(!sharps) Kreise beispielsweise als Ellipsen dargestellt
werden.

Die Aufl(!oumlaut)sung der Bitmap kann per v_opnwk gesetzt werden, indem in
ptsin[0..1] die Breite-1 bzw. H(!oumlaut)he-1 sowie in contrl[1] der Wert 1
geschrieben werden. Nach dem Aufruf der Funktion wird die Adresse der Bitmap
in (!nolink [contrl])[0..1] zur(!uumlaut)ckgeliefert. Dar(!uumlaut)ber hinaus ist es auch m(!oumlaut)glich, die
Bitmap-Gr(!oumlaut)(!sharps)e per vq_extnd zu setzen. In diesem Fall ist es zus(!aumlaut)tzlich
m(!oumlaut)glich, einen eigenen Buffer zu (!uumlaut)bergeben. Dazu setzt man (!nolink [contrl])[3] auf den
Wert 3 und (!uumlaut)bergibt in intin[1..2] einen Zeiger auf den Buffer.

Aufgrund der gr(!oumlaut)(!sharps)eren Flexibilit(!aumlaut)t sollte Off-Screen-Bitmaps der Vorzug
gegen(!uumlaut)ber Memory-Treibern gegeben werden.

Querverweis: GDOS-Treiber ~  (!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei])
!end_node



!begin_node Metafile-Treiber
!label GDOS-Treiber, Metafile
!label Treiber, Metafile-

Ein Metafile-Treiber speichert alle an ihn gerichteten Aufrufe in einem
GEM-Metafile, welches sich im aktuellen Verzeichnis der Applikation befindet
und als Voreinstellung den Namen (!I)GEMFILE.(!nolink [GEM])(!i) tr(!aumlaut)gt.

M(!oumlaut)chte man den Namen (!aumlaut)ndern, so sollte direkt nach v_opnwk die Funktion
vm_filename aufgerufen werden, der man einen kompletten Dateinamen mit dem
gew(!uumlaut)nschten Pfad und Namen (!uumlaut)bergeben kann.

Damit andere Programme ein Metafile vern(!uumlaut)nftig darstellen k(!oumlaut)nnen, sollten
die Funktionen v_meta_extents, vm_pagesize und vm_coords aufgerufen werden.

Querverweis:
(!nl)
v_meta_extents ~  vm_pagesize ~  vm_coords ~
GDOS-Treiber ~    (!link [Mindestfunktionsumfang] [Mindestfunktionsumfang f(!uumlaut)r Metafile-Treiber])
!end_node



!begin_node Mindestfunktionsumfang f(!uumlaut)r Metafile-Treiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Metafiletreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation aus dem
Atari (!I)"GEM Programmer's Guide"(!i).

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!     !! v_opnwk
  2 !!     !! v_clswk
  3 !!     !! v_clrwk
  4 !!     !! v_updwk
  5 !!     !! Escapefunktionen
    !!   1 !! vq_chcells
    !!   2 !! v_exit_cur
    !!   3 !! v_enter_cur
    !!  20 !! v_form_adv
    !!  21 !! v_output_window
    !!  22 !! v_clear_disp_list
    !!  23 !! v_bit_image     
    !!  98 !! v_meta_extents
    !!  99 !! v_write_meta
    !! 100 !! vm_filename
  6 !!     !! v_pline
  7 !!     !! v_pmarker
  8 !!     !! v_gtext
  9 !!     !! v_fillarea
 11 !!     !! Ausgabefunktionen
    !!   1 !! v_bar
    !!   2 !! v_arc
    !!   3 !! v_pieslice
    !!   4 !! v_circle
    !!   5 !! v_ellipse
    !!   6 !! v_ellarc
    !!   7 !! v_ellpie
    !!   8 !! v_rbox
    !!   9 !! v_rfbox
    !!  10 !! v_justified 
 12 !!     !! vst_height
 13 !!     !! vst_rotation
 14 !!     !! vs_color
 15 !!     !! vsl_type
 16 !!     !! vsl_width
 17 !!     !! vsl_color
 18 !!     !! vsm_type
 19 !!     !! vsm_height
 20 !!     !! vsm_color
 21 !!     !! vst_font
 22 !!     !! vst_color
 23 !!     !! vsf_interior
 24 !!     !! vsf_style
 25 !!     !! vsf_color 
 26 !!     !! vq_color
 32 !!     !! vswr_mode
 35 !!     !! vql_attributes
 36 !!     !! vqm_attributes
 37 !!     !! vqf_attributes
 38 !!     !! vqt_attributes
 39 !!     !! vst_alignment 
102 !!     !! vq_extnd
103 !!     !! v_contourfill
104 !!     !! vsf_perimeter
106 !!     !! vst_effects
107 !!     !! vst_point 
108 !!     !! vsl_ends
112 !!     !! vsf_udpat
113 !!     !! vsl_udsty
114 !!     !! vr_recfl
117 !!     !! vqt_width
129 !!     !! vs_clip
131 !!     !! vqt_fontinfo
!end_table
!end_node



!begin_node Plotter-Treiber
!label GDOS-Treiber, Plotter
!label Treiber, Plotter-

Nach langer Durststrecke sind mittlerweile auch GDOS-Plottertreiber
verf(!uumlaut)gbar. So wird z.B. bei dem Programm (!I)DATA(!i) ein HPGL-Treiber
mitgeliefert, und auch auf der (!nolink [PD])-Diskette Nummer 458 der Zeitschrift
(!I)ST-Computer(!i) befindet sich ein solcher Treiber.

Genauere Informationen zu Plottertreibern sind z.Zt. jedoch noch nicht
bekannt.

Querverweis:
GDOS-Treiber ~  (!link [Mindestfunktionsumfang] [Mindestfunktionsumfang f(!uumlaut)r Plotter-Treiber])
!end_node



!begin_node Mindestfunktionsumfang f(!uumlaut)r Plotter-Treiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Plottertreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation aus dem
Atari (!I)"GEM Programmer's Guide"(!i).

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!    !! v_opnwk
  2 !!    !! v_clswk
  3 !!    !! v_clrwk
  4 !!    !! v_updwk
  5 !!    !! Escapefunktionen
    !!  1 !! vq_chcells
  6 !!    !! v_pline
  7 !!    !! v_pmarker
  8 !!    !! v_gtext
  9 !!    !! v_fillarea
 11 !!    !! Ausgabefunktionen
    !!  1 !! v_bar
    !!  2 !! v_arc
    !!  3 !! v_pieslice
    !!  4 !! v_circle
    !!  5 !! v_ellipse
    !!  6 !! v_ellarc
    !!  7 !! v_ellpie
    !!  8 !! v_rbox
    !!  9 !! v_rfbox
    !! 10 !! v_justified 
 12 !!    !! vst_height
 15 !!    !! vsl_type
 17 !!    !! vsl_color
 18 !!    !! vsm_type
 20 !!    !! vsm_color
 21 !!    !! vst_font
 22 !!    !! vst_color
 23 !!    !! vsf_interior
 24 !!    !! vsf_style
 25 !!    !! vsf_color 
 35 !!    !! vql_attributes
 36 !!    !! vqm_attributes
 37 !!    !! vqf_attributes
 38 !!    !! vqt_attributes
 39 !!    !! vst_alignment 
102 !!    !! vq_extnd
104 !!    !! vsf_perimeter
107 !!    !! vst_point 
108 !!    !! vsl_ends
116 !!    !! vqt_extent
117 !!    !! vqt_width
130 !!    !! vqt_name
131 !!    !! vqt_fontinfo
!end_table
!end_node
!end_node



!begin_node Koordinatensysteme des VDI

(!nolink [Das VDI]) unterscheidet zwei verschiedene Typen von Koordinatensystemen:

!begin_itemize
!label Rasterkoordinaten
!label Koordinaten, Raster-
!label Koordinaten, RC-
!label RC-Koordinaten
!item (!B)Rasterkoordinaten (RC):(!b) Bei Verwendung dieses Systems kann man
      exakt das dem Ausgabeger(!aumlaut)t eigene Koordinatensystem benutzen. Bei
      einem Bildschirm entspricht das den horizontal und vertikal
      verf(!uumlaut)gbaren Pixeln. Der Nullpunkt liegt in der linken (!I)oberen(!i)
      Ecke.
(!nl)
      Hauptvorteil der Rasterkoordinaten ist die absolut exakte
      Positionierung die die genaue Arbeit mit Bildschirmrastern (Fenster
      etc). erst m(!oumlaut)glicht macht.
!label normalisierte Koordinaten
!label Koordinaten, normalisierte
!label Koordinaten, NDC-
!label NDC-Koordinaten
!item (!B)normalisierte Koordinaten (NDC):(!b) Dieses System besitzt immer
      eine maximale Aufl(!oumlaut)sung von 32768*32768 Punkten. (!nolink [Das VDI]) rechnet beim
      Aufruf eines Ger(!aumlaut)tetreibers automatisch auf dessen physikalisches
      Koordinatensystem um. Der Nullpunkt liegt in der linken
      (!I)unteren(!i) Ecke. Zur Arbeit mit dem NDC-System mu(!sharps) ein GDOS
      installiert sein - der Bildschirmtreiber im ROM kann (!I)keine(!i)
      NDC-Koordinaten verarbeiten.
!end_itemize

Die folgende Abbildung macht den Unterschied zwischen RC- und
NDC-Koordinaten noch einmal besonders deutlich:

!image (!picture_path)koords

(!B)Hinweis:(!b) In der Praxis wird das NDC-System nur selten benutzt.
Programme, die exakte Bema(!sharps)ungen anbieten m(!uumlaut)ssen (Desktop-Publishing,
wissenschaftliche Grafik) m(!uumlaut)ssen intern sowieso eine eigene, feinere
Koordinatendarstellung benutzen.

Die Verwendung des NDC-Systems w(!uumlaut)rde dazu f(!uumlaut)hren, da(!sharps) Koordinaten gleich
zweimal konvertiert werden (einmal von der internen Darstellung in
NDC-Koordinaten, anschlie(!sharps)end in Rasterkoordinaten), was zu (!uumlaut)berfl(!uumlaut)ssigen
Geschwindigkeitsverlusten und Rundungsfehlern f(!uumlaut)hrt.

Querverweis: Grundlagen des VDI ~  Style-Guidelines
!end_node



!include gem/vdi/metafile.u



!begin_node NVDI
!label NVDIMac

NVDI (NewVDI) ist ein von den (!I)Behne-Br(!uumlaut)dern(!i) entwickeltes VDI,
welches das Original des Atari vollst(!aumlaut)ndig ersetzt. Dabei besticht neben der
sehr hohen Geschwindigkeit vor allem die M(!oumlaut)glichkeit, Vektorzeichens(!aumlaut)tze der
Formate Speedo und TrueType (mit einem speziellen Modul auch Type-1)
verwenden zu k(!oumlaut)nnen. NVDI liegt auch in einer speziellen
(!I)Macintosh-Version(!i) vor (NVDIMac), und erm(!oumlaut)glicht es jedem Programm
das (!uumlaut)ber GDOS ausgeben kann (in Verbindung mit MagiC Mac), seine Ausgaben
auch auf Apple-Druckern und im Netzwerk t(!aumlaut)tigen zu k(!oumlaut)nnen.

Um herauszufinden, welche NVDI-Version man vor sich hat und welchen
Funktionsumfang sie hat, mu(!sharps) der Cookie NVDI gesucht werden, der die
Versionsnummer im BCD-Format enth(!aumlaut)lt (z.B. 0x0410 f(!uumlaut)r Version 4.10).

!label EdDI
Wer die Offscreen-Bitmaps nutzen m(!oumlaut)chte, sollte nach dem (!link ['EdDI'-Cookie][ Cookie, EdDI])
suchen (z.B. per is_EdDI()). Das auf die Kennung folgende Langwort ist die
Adresse eines Dispatchers, der mit der Funktionsnummer in Register d0.w
aufgerufen wird. F(!uumlaut)r den Aufruf gelten die Pure C-Konventionen, d.h.
Register d0-d2/a0-a1 und der Stack werden zur Parameter(!uumlaut)bergabe benutzt,
d0-d2/a0-a1 k(!oumlaut)nnen ver(!aumlaut)ndert werden. Die Funktion 0 liefert die
EdDI-Versionsnummer im BCD-Format (z.B. 0x0110 f(!uumlaut)r Version 1.10).

Querverweis:
(!nl)
Off-Screen-Bitmaps ~  v_opnbm   ~    v_clsbm ~
Grundlagen des VDI ~  vq_scrninfo ~  GEM

# Version Datum
# 1.00    1991-02-27
# 2.01    1991-09-16
# 2.11    1992-09-17
# 2.50    1993-06-21  EdDI 1.00
# 3.01    1994-10-11  EdDI 1.00   FSMC 5.00
# 5.03    1999-08-30  EdDI 1.10   FSMC 5.00

!begin_node is_EdDI

(!B)(!nolink [Beispiel-Code]) f(!uumlaut)r Pure-C:(!b)

!begin_verbatim
GLOBAL BOOLEAN is_EdDI ()
{
    int16_t (*func)(int16_t);
    
    if (get_cookie ("EdDI", (LONG *) &func))
        return ((*func)(0));
        
    else return (FALSE);
    
} /* is_EdDI */
!end_verbatim
!end_node
!end_node



!begin_node Off-Screen-Bitmaps

F(!uumlaut)r viele Anwendungen ist es sehr n(!uumlaut)tzlich, wenn Zeichenfunktionen nicht 
direkt auf den Bildschirm, sondern auf einen nicht sichtbaren Bildschirm
angewendet werden k(!oumlaut)nnen. Einen derartigen "versteckten" Bildschirm nennt
man Off-Screen-Bitmap.

Zur Erzeugung von Off-Screen-Bitmaps dient die Funktion v_opnbm(). Man kann
ihr entweder die Gr(!oumlaut)(!sharps)e eines Bitmap angeben, die Sie allozieren soll, oder
ihr eine Bitmap (!uumlaut)bergeben. Die Bitmap wird im gleichen Format wie die des
Bildschirms verwaltet, wodurch schnelles Kopieren zwischen beiden m(!oumlaut)glich
ist. Die Funktion v_clsbm() schlie(!sharps)t eine mit v_opnbm() erzeugte Bitmap und
gibt gegebenenfalls deren Speicher zur(!uumlaut)ck.

Rasteroperationen zwischen Bildschirm und Off-Screen-Bitmap sollten
grunds(!aumlaut)tzlich im ger(!aumlaut)tespezifischen Format erfolgen. Wenn als Ziel einer
Rasteroperation eine Off-Screen-Bitmap mit ihrem MFDB angegeben wird und
wenn das zu dieser Bitmap geh(!oumlaut)rende Handle benutzt wird, so wird beim
Blitten anhand der (!uumlaut)ber vs_clip() auf dieser  Workstation eingestellten
Koordinaten geclippt. F(!uumlaut)r das Kopieren eines Rasters vom Bildschirm in eine
Off-Screen-Bitmap sollte man also das vdi_handle dieser Bitmap benutzen.

Ist die Bitmap dagegen Quelle und der Bildschirm Ziel, so sollte man das
Handle der Bildschirm-Workstation benutzen, da dann das Raster anhand der
Bildschirm-Koordinaten abgeclippt wird. Wenn man das von v_opnbm()
zur(!uumlaut)ckgelieferte Handle einer Bitmap benutzt und in (!I)fd_addr(!i) in einem
MFDB 0 enth(!aumlaut)lt, so werden die Daten der Bitmap statt dessen benutzt.

Querverweis: NVDI ~  (!link [GDOS][Das GDOS]) ~  Style-Guidelines
!end_node



!begin_node Das OUT-Dateiformat
!label OUTPUT-Format

Das OUT-Format wurde von (!I)Digital Research(!i) entwickelt und erm(!oumlaut)glicht
wie das XIMG oder Metafile-Format den Datenaustausch zwischen beliebigen
GEM-Applikationen. Genauer gesagt k(!oumlaut)nnen hiermit Steuerzeichen f(!uumlaut)r
Textattribute in eine Datei mit dem Suffix ".out" geschrieben werden, die
dann vom Ausgabetreiber erkannt, und ber(!uumlaut)cksichtigt werden.

Das OUT-Format ist somit besonders geeignet, um Textdateien mit Attributen
zwischen verschiedenen Applikationen auszutauschen. OUT-Dateien sind nicht
anderes als ASCII-Dateien, die zum Umschalten zwischen Textattributen den
Steuercode DC2 (ASCII-Wert 18) benutzen; anschlie(!sharps)end folgt ein Buchstabe,
der das Ein- oder Ausschalten des Attriutes beschreibt:

(!B)Folgende Steuerzeichen sind definiert:(!b)

!begin_table [l l]
Code !! Bedeutung
!hline
DC2 0 !! Fettschrift ein         
DC2 1 !! Fettschrift aus
DC2 2 !! Kursiv ein
DC2 3 !! Kursiv aus
DC2 4 !! Unterstrichen ein
DC2 5 !! Unterstrichen aus
DC2 6 !! Superscript ein
DC2 7 !! Superscript aus
DC2 8 !! Subscript ein
DC2 9 !! Subscript aus
DC2 A !! Briefqualit(!aumlaut)t-Modus ein
DC2 B !! Briefqualit(!aumlaut)t-Modus aus
DC2 C !! Breitschrift ein
DC2 D !! Breitschrift aus
DC2 E !! helle Schrift ein
DC2 F !! helle Schrift aus
DC2 G !! ~     
  :   !! ~
  :   !! ~
DC2 V !! reserviert, wird ignoriert
DC2 W !! Pica-Schrift (10 cpi)
DC2 X !! Elite-Schrift (12 cpi)
DC2 Y !! komprimierter Druck
DC2 Z !! Proportionalschrift
!end_table

(!B)Hinweis:(!b) Selbstverst(!aumlaut)ndlich k(!oumlaut)nnen auch Grafiken in die Ausgabedatei
mit eingebunden werden, die Syntax lautet in diesem Fall:

!begin_verbatim
(ESC)(ESC)GEM,x,y,w,h,C:\pathname\filename.img
!end_verbatim

Die Parameter x,y,w und h sind dabei in Zeicheneinheiten relativ zur
aktuellen Cursorposition anzugeben.

Querverweis:
GDOS-Treiber ~  v_alpha_text ~  (!link [XIMG-Format][XIMG-Format])   Metafile-Format
!end_node



!begin_node Rasterformate

Bei der Arbeit mit Bildschirmen spielen die Rasterfunktionen eine besondere
Rolle; sie sind f(!uumlaut)r all das zust(!aumlaut)ndig, was mit der Bewegung oder Ver(!aumlaut)nderung
von Bildschirmausschnitten zu tun hat. Beispiel: Scrolling innerhalb eines
Dokumentes oder das Darstellen von Icons.

Die Rasterfunktionen k(!oumlaut)nnen ihre Aufgabe nat(!uumlaut)rlich nur dann effizient
ausf(!uumlaut)hren, wenn als interne Darstellung das gleiche Format verwendet wird,
wie es auch im Bildspeicher benutzt wird; anderenfalls m(!uumlaut)(!sharps)ten die Daten bei
jedem einzelnen Aufruf einer Rasterfunktion konvertiert werden. Naturgem(!aumlaut)(!sharps)
ist jedoch der interne Aufbau des Bildspeichers von der Hardware des
benutzten Grafiksystems abh(!aumlaut)ngig - mal davon abgesehen, da(!sharps) der Bildspeicher
gar nicht unbedingt direkt f(!uumlaut)r den Prozessor zug(!aumlaut)nglich sein mu(!sharps).

Die Anzahl der pro Pixel ben(!oumlaut)tigten Bits h(!aumlaut)ngt nat(!uumlaut)rlich von der Anzahl der
gleichzeitig darstellbaren Farben ab; f(!uumlaut)r monochrome Pixel reicht 1 Bit, bei
16 Farben sind schon vier Bits notwendig. Abh(!aumlaut)ngig von der verwendeten
Videohardware k(!oumlaut)nnen diese Bits nat(!uumlaut)rlich v(!oumlaut)llig verschieden angeordnet
sein; daher verwundert es nicht, da(!sharps) f(!uumlaut)r diesen Zweck verschiedene Formate
zur Verf(!uumlaut)gung stehen:

!label Bildformat, pixelorientiertes
!label pixelorientiertes Bildformat
(!B)pixelorientiertes Format:(!b) In diesem Fall werden alle zu einem Pixel
geh(!oumlaut)renden Bits zusammen in ein oder mehrere Bytes kodiert. In einem System
mit 16 Farben w(!uumlaut)rden also jeweils zwei Pixel gemeinsam in einem Byte
abgespeichert; bei 256 Farben nimmt jeder Pixel ein Byte ein.

!label Bildformat, planeorientiertes
!label planeorientiertes Bildformat
(!B)planeorientiertes Format:(!b) In diesem Fall betrachtet man den
Bildspeicher als eine Sammlung monochromer (d.h. einfarbiger) Bildebenen
(Planes). Um zu einem Pixel die Farbe zu ermitteln, kombiniert man die
zust(!aumlaut)ndigen Bits aus den einzelnen Ebenen zu einem Farbwert. Damit ist
nat(!uumlaut)rlich noch nichts dar(!uumlaut)ber ausgesagt, wie die einzelnen Ebenen im
Bildspeicher angeordnet sind. Eine einfache (und im PC-Bereich durchaus
(!uumlaut)bliche) L(!oumlaut)sung ist es, eine Plane nach der anderen hintereinander im
Bildspeicher abzulegen.

Um nicht auf ein bestimmtes, Hardware-abh(!aumlaut)ngiges Format angewiesen zu sein,
unterscheidet das VDI zwischen dem (!I)ger(!aumlaut)teabh(!aumlaut)ngigen Format(!i) (welches
eben von der Hardware abh(!aumlaut)ngt), und dem sogenannten Standardformat. Das
Standardformat ist f(!uumlaut)r alle (!nolink [VDI])-Systeme gleich, und kann daher immer dann
benutzt werden, wenn Rastergrafiken von au(!sharps)en in das System eingebracht
werden sollen (Beispiel: Darstellung von Icons in einer Resource-Datei). Zur
Umwandlung zwischen beiden Formaten steht die Funktion vr_trnfm zur
Verf(!uumlaut)gung.

!label Standardformat des VDI
!label VDI, Standardformat des
!label Ger(!aumlaut)teunabh(!aumlaut)ngiges Format
!label Format, ger(!aumlaut)teunabh(!aumlaut)ngiges
(!B)(!nolink [Das VDI])-Standardformat ist wie folgt definiert:(!b)

!begin_itemize
!item das Format ist planeorientiert. Jede Bildebene belegt ein
      zusammenh(!aumlaut)ngendes St(!uumlaut)ck Speicher, und besitzt die gleiche Anzahl von
      Bildpunkten.
!item das h(!oumlaut)chste Bit eines 16-Bit Wortes steht f(!uumlaut)r den am weitesten links
      stehenden Pixel.
!item aufeinanderfolgende Worte im Bildspeicher bilden die einzelnen Zeilen.
      Das erste Wort einer solchen Zeile liegt am linken Bildrand; die erste
      Zeile der Plane kodiert die oberste Pixelzeile.
!end_itemize

Die folgende Abbildung zeigt ein Beispiel f(!uumlaut)r das ger(!aumlaut)teunabh(!aumlaut)ngige
Standardformat mit 3 Farbebenen (Planes):

!image (!picture_path)raster

(!B)Achtung:(!b) In den monochromen Grafikmodi von ST und TT entspricht das
ger(!aumlaut)teabh(!aumlaut)ngige Format (!I)zuf(!aumlaut)llig (!)(!i) dem ger(!aumlaut)teunabh(!aumlaut)ngigen d.h. dem
Standardformat. Das hei(!sharps)t nat(!uumlaut)rlich nicht, da(!sharps) man deshalb auf den Einsatz
der Funktion vr_trnfm verzichten darf. Da man (!uumlaut)ber das ger(!aumlaut)teabh(!aumlaut)ngige
Format im Normalfall keine Informationen besitzt, verbietet sich schon aus
diesem Grund jede direkte Manipulation am Bildspeicher.

!label Color-Lookup-Table
!label Lookup-Table
Das VDI arbeitet prinzipiell Farbregister-orientiert (Color-Lookup-Table).
Es geht also davon aus, da(!sharps) es eine Maximalzahl von gleichzeitig
darstellbaren Farben gibt, und da(!sharps) man diesen Farbregistern bestimmte
(relativ frei w(!aumlaut)hlbare) Farbt(!oumlaut)ne zuordnen kann. Da diese Eigenschaft jedoch
keinesfalls selbstverst(!aumlaut)ndlich ist, kann sie per vq_extnd erfragt werden. Im
folgenden zwei Beispiele f(!uumlaut)r Grafikmodi (!I)ohne(!i) Color-Lookup-Table:

!begin_itemize
!item Der TT-Grafikmodus 'TT-Hoch': es gibt nur zwei Farbregister und zwei
      Farbt(!oumlaut)ne (Schwarz und Wei(!sharps)), die auch nicht vertauscht werden k(!oumlaut)nnen.
!item Bei True-Color Grafikkarten wie der Crazy-Dots-II k(!oumlaut)nnen 'beliebig'
      viele Farben gleichzeitig dargestellt werden. Normalerweise werden 24
      Bits pro Pixel benutzt, so da(!sharps) etwa 16 Millionen Farben zur Verf(!uumlaut)gung
      stehen. Bei einer derartigen Anzahl von Farbnummern hat sich die Idee
      von Farbregistern erledigt: die Anzahl der prinzipiell gleichzeitig
      darstellbaren Farbt(!oumlaut)ne (!uumlaut)bersteigt die typische Zahl von Bildpunkten
      bei weitem.
!end_itemize

!label Pixelwert und VDI-Farbnummer
!label VDI-Farbnummer und Pixelwert
!label Farbnummer und Pixelwert, VDI-
(!B)Bleibt die Frage auf welche Weise die Pixelwerte im Bildspeicher mit den
VDI-Farbnummern zusammenh(!aumlaut)ngen. Antwort:(!b)

!begin_xlist
!item [(a)]
aus historischen Gr(!uumlaut)nden darf davon ausgegangen werden, da(!sharps) bei einem Pixel
in (!nolink [VDI])-Farbe 0 (normal Wei(!sharps)) alle Bits gel(!oumlaut)scht, und bei schwarzen
Bildpunkten ((!nolink [VDI])-Farbe 1) alle Bits gesetzt sind. Dies ist schon deshalb
logisch, da durch ein vollst(!aumlaut)ndiges Invertieren aller Bits der
Pixeldarstellung Wei(!sharps) und Schwarz vertauscht werden m(!uumlaut)ssen.
!item [(b)]
Mit Hilfe der Funktion v_get_pixel kann f(!uumlaut)r eine gegebene Bildkoordinate
sowohl die (!nolink [VDI])-Farbnummer, als auch der Pixelwert erfragt werden.
!end_xlist

(!B)Dar(!uumlaut)ber hinaus haben (!I)Atari(!i) und (!I)Digital Research(!i) f(!uumlaut)r 4,
8 und 16-Farbgrafikstufen die Standardzuordnungen dokumentiert:(!b)

!begin_itemize
!item bei vier Farben gilt

!begin_table [c c l l]
Pixelwert !! Farbindex !! Farbe !! Name
!hline
00 !! 0 !! wei(!sharps)    !! WHITE
01 !! 2 !! rot     !! RED
10 !! 3 !! gr(!uumlaut)n    !! GREEN
11 !! 1 !! schwarz !! BLACK
!end_table

!item bei acht Farben gilt

!begin_table [c c l l]
Pixelwert !! Farbindex !! Farbe !! Name
!hline
000 !! 0 !! wei(!sharps)    !! WHITE
001 !! 2 !! rot     !! RED
010 !! 3 !! gr(!uumlaut)n    !! GREEN
011 !! 6 !! gelb    !! YELLOW
100 !! 4 !! blau    !! BLUE
101 !! 7 !! magenta !! MAGENTA
110 !! 5 !! cyan    !! CYAN
111 !! 1 !! schwarz !! BLACK
!end_table

!item bei 16 Farben gilt

!begin_table [c c l l]
Pixelwert !! Farbindex !! Farbe !! Name
!hline
0000 !!  0 !! wei(!sharps)          !! WHITE
0001 !!  2 !! rot           !! RED
0010 !!  3 !! gr(!uumlaut)n          !! GREEN
0011 !!  6 !! gelb          !! YELLOW
0100 !!  4 !! blau          !! BLUE
0101 !!  7 !! magenta       !! MAGENTA
0110 !!  5 !! cyan          !! CYAN
0111 !!  8 !! hellgrau      !! LWHITE
1000 !!  9 !! dunkelgrau    !! LBLACK
1001 !! 10 !! dunkelrot     !! LRED
1010 !! 11 !! dunkelgr(!uumlaut)n    !! LGREEN
1011 !! 14 !! dunkelgelb    !! LYELLOW
1100 !! 12 !! dunkelblau    !! LBLUE
1101 !! 15 !! dunkelmagenta !! LMAGENTA
1110 !! 13 !! dunkelcyan    !! LCYAN
1111 !!  1 !! schwarz       !! BLACK
!end_table
!end_itemize

(!B)Hinweis:(!b) F(!uumlaut)r andere Farbtiefen existiert (!I)keine(!i) eindeutige
Zuordnung. Da es auch keine allgemeine Formel zur Umrechnung gibt, muss im
Bedarfsfall auf die Funktion v_get_pixel zur(!uumlaut)ckgegriffen werden.

Querverweis:
Objektfarben des AES ~  Rasterfunktionen ~  vq_scrninfo
!end_node



!begin_node SpeedoGDOS
!label GDOS, Speedo-

SpeedoGDOS geh(!oumlaut)rt zur j(!uumlaut)ngsten Generation der GDOS-Familie, und liegt
aktuell in der Version 5.0c vor. Neben den Eigenschaften eines 'normalen'
GDOS bestechen vor allem die folgenden M(!oumlaut)glichkeiten:

!begin_itemize !compressed
!item Unterst(!uumlaut)tzung von Vektorzeichens(!aumlaut)tzen der Formate:
!begin_itemize !compressed
!item Speedo
!item TrueType
!item Type1
!end_itemize
!item M(!oumlaut)glichkeiten f(!uumlaut)r Track/Pair-Kerning.
!end_itemize

Ob SpeedoGDOS installiert ist, l(!aumlaut)(!sharps)t sich am besten (!uumlaut)ber den Cookie-Jar
abfragen. Das Programm legt in der Bootphase einen Cookie mit der Kennung
FSMC an.

Querverweis:
(!link [GDOS][Das GDOS]) ~  NVDI ~  Style-Guidelines


# Version Datum
# 4.11    1993-06-14
# 5.0a    1994-08-03
!end_node



!begin_node Details zu Vektorschriften

Bei Verwendung der Programme NVDI oder SpeedoGDOS stehen auch unter GEM
hochqualitative Vektorschriften (in den Formaten Speedo, TrueType, und
Type-1) zur Verf(!uumlaut)gung. Da bei der Unterst(!uumlaut)tzung dieser Schrifttechnologien
einige Feinheiten zu beachten sind, werden in diesem Abschnitt die folgenden
Punkte behandelt:

!begin_itemize !compressed
!item (!Aumlaut)quidistante Fonts
!item Font-ID und Index 
!item Gr(!oumlaut)(!sharps)e von Vektorfonts
!item H(!oumlaut)he und Breite von Vektorfonts
!item Kerning
!item Positionierung von Vektortext
!item (!link [Unterscheidung von Vektor- und Bitmap-Font][Vektor- oder Bitmap-Font?])
!end_itemize

Querverweis:
vst_load_fonts ~  vst_unload_fonts



!begin_node (!Aumlaut)quidistante Fonts

F(!uumlaut)r manche Applikationen ist es sinnvoll, bei der Ausgabe nur (!aumlaut)quidistante
(d.h. monospaced) Fonts zu benutzen. In diesem Fall sollte man wie folgt
vorgehen:

!begin_itemize
!item wenn vqt_name in erweiterter Form (35 Eintr(!aumlaut)ge in intout) vorhanden
      ist, sollte einfach das entsprechende Bit in (!nolink [intout])[34] abgetestet
      werden.
!item wenn vqt_name nur die Information bietet, da(!sharps) es sich um einen
      Vektorfont handelt (34 Eintr(!aumlaut)ge in intout, (!nolink [intout[33!]]) != 0), sollte
      f(!uumlaut)r Vektorfonts vqt_fontheader aufgerufen, und Bit 1 von FH_CLFGS
      gepr(!uumlaut)ft werden.
!item wenn es sich nicht um einen Vektorfont handelt und die ersten beiden
      Punkte nicht zutreffen, m(!uumlaut)ssen die Zeichenbreiten einzeln mit
      vqt_width erfragt und miteinander verglichen werden.
!end_itemize

(!B)Hinweis:(!b) Wer (!aumlaut)quidistante Vektorfonts mit v_ftext ausgibt, darf als
Breite (!I)nicht(!i) mit den Ausgaben von vst_height oder vqt_width rechnen,
sondern mu(!sharps) sie bei vqt_advance erfragen, da bei v_ftext immer mit Breiten
in 1/65536 Pixeln positioniert wird. Bei Ausgabe (!uumlaut)ber v_gtext sind die
R(!uumlaut)ckgaben von vqt_width zutreffend.

Querverweis:
(!link [Vektorfonts][Details zu Vektorschriften]) ~
VDI ~ (!link [GDOS][Das GDOS])  ~ Style-Guidelines ~ fix31
!end_node



!begin_node Font-ID und Index
!label Zeichensatzes, Index eines

(!B)Der Index eines Fonts(!b) ist eine Zahl zwischen 1 und der verf(!uumlaut)gbaren
Fontanzahl. Je nach Anzahl der auf dem jeweiligen Rechner installierten
Fonts hat ein Font wie z.B. (!I)Swiss 721(!i) einen unterschiedlichen Index.

!label Zeichensatzes, Font-ID eines
(!B)Die Font-ID(!b) ist dagegen eine Kennung, die grunds(!aumlaut)tzlich f(!uumlaut)r einen
Font unabh(!aumlaut)ngig vom System immer gleich ist - f(!uumlaut)r (!I)Swiss 721(!i) z.B.
5003. Ausnahmen von dieser Regel sind aber bei Fonts m(!oumlaut)glich, die keine
verwendbare Font-ID haben. In diesem Fall wird versucht, eine eindeutige ID
zu erzeugen. Da es aber m(!oumlaut)glich ist, da(!sharps) eine derart erzeugte ID f(!uumlaut)r einen
Font nicht auf allen Systemen identisch ist, sollten Programme f(!uumlaut)r eine
eindeutige Zuordnung des Fonts au(!sharps)er der ID (!I)auch den Namen(!i)
abspeichern.

Querverweis:
(!link [Vektorfonts][Details zu Vektorschriften]) ~  VDI ~
(!link [GDOS][Das GDOS]) ~ Style-Guidelines
!end_node



!begin_node Gr(!oumlaut)(!sharps)e von Vektorfonts

Die meisten Bildschirmtreiber liefern eine Aufl(!oumlaut)sung von (!almost) 91 dpi zur(!uumlaut)ck,
nach der sich auch die Gr(!oumlaut)(!sharps)e der Vektorfonts richtet. Da nicht bei jedem
Schirm 91 dpi vorhanden sind, sollten Programme bei Textdarstellung auf dem
Bildschirm (!I)nicht(!i) fest mit diesem Wert rechnen, sondern die Ausgaben
von (!B)v_opnwk(!b), (!B)v_opnvwk(!b), (!B)vq_extnd(!b) und (!B)v_opnbm(!b)
beachten.

Andernfalls k(!oumlaut)nnen bei abweichenden Pixelgr(!oumlaut)(!sharps)en Darstellungsfehler
auftreten. Beim Ausdruck sollten die genaueren Pixelgr(!oumlaut)(!sharps)en bei
(!B)vq_extnd(!b) beachtet werden, damit die Textpositionierung m(!oumlaut)glichst
genau ist.
!end_node



!begin_node H(!oumlaut)he und Breite von Vektorfonts

Die H(!oumlaut)he und Breite eines Vektorfonts kann mit den Funktionen
(!B)vst_arbpt32(!b) und (!B)vst_setsize32(!b) in 1/65536 pt eingestellt werden
(1pt (!almost) 1/72 Zoll (!almost) 353 (!micro)m).

Bei negativer H(!oumlaut)he oder Breite wird der Text an der jeweiligen Achse
gespiegelt.
!end_node



!begin_node Kerning

Kerning ist ein Verfahren um Abst(!aumlaut)nde zwischen Zeichen zu manipulieren, und
damit ein einheitlicheres (besseres) Schriftbild zu erlangen. Man kann zwei
Varianten des Kernings unterscheiden:

!label Track-Kerning
!label Kerning, Track-
!begin_itemize
!item (!B)Track-Kerning:(!b) Diese Methode benutzt einen (!I)konstanten
      Offset(!i) f(!uumlaut)r alle Zeichen eines Zeichensatzes. Zeichens(!aumlaut)tze die
      Track-Kerning unterst(!uumlaut)tzen enthalten i.d.R. verschiedene Offsets um
      beispielsweise zwischen normalem, engen und sehr engen Kerning
      ausw(!aumlaut)hlen zu k(!oumlaut)nnen.
!label Pair-Kerning
!label Kerning, Pair-
!item (!B)Pair-Kerning:(!b) Beruht auf der Erkenntnis, da(!sharps) (!I)ein(!i)
      Offset nicht f(!uumlaut)r alle Zeichen eines Zeichensatzes sinnvoll ist; in
      vielen F(!aumlaut)llen l(!aumlaut)(!sharps)t sich n(!aumlaut)mlich ein wesentlich besseres Schriftbild
      erreichen, wenn der Abstand (!I)f(!uumlaut)r ein Paar von Zeichen
      individuell(!i) festgelegt werden kann. Zeichens(!aumlaut)tze die Pair-Kerning
      unterst(!uumlaut)tzen enthalten daher eine Tabelle, in der f(!uumlaut)r jede Kombination
      (genauer: f(!uumlaut)r die wichtigsten) von zwei Zeichen der f(!uumlaut)r sie optimale
      Offset vermerkt ist.
!end_itemize

(!B)Hinweis:(!b) Sowohl Track-, als auch Pair-Kerning sind nach dem (!Oumlaut)ffnen
einer Workstation ausgeschaltet. Um eine bessere Textdarstellung zu
erhalten, sollte daher das Pair-Kerning per vst_kern eingeschaltet werden.

Querverweis:
vst_kern ~ vqt_pairkern ~ vqt_trackkern ~ vst_track_offset
!end_node



!begin_node Positionierung von Vektortext

Bei der Ausgabe von Vektorfonts wird innerhalb des VDI mit Schrittweiten
von 1/65536 Pixel Aufl(!oumlaut)sung gerechnet, um unabh(!aumlaut)ngig vom verwendeten
Ausgabeger(!aumlaut)t und dessen tats(!aumlaut)chlicher Aufl(!oumlaut)sung eine gleichbleibende
Zeichenpositionierung zu gew(!aumlaut)hrleisten.

Um die Bitmaps f(!uumlaut)r die einzelnen Zeichen auszugeben, werden diese
Festkommawerte in Pixel umgerechnet, indem 32768 hinzuaddiert und
anschlie(!sharps)end durch 65536 geteilt wird.

!begin_itemize
!item wenn das Track-Kerning eingeschaltet ist, wird zu jeder
      Zeichenposition der bei vqt_trackkern zu erfragende Offset addiert.
!item bei eingeschaltetem Pair-Kerning wird zu jeder Zeichenposition der von
      vqt_pairkern zur(!uumlaut)ckgelieferte Offset addiert.
!end_itemize

(!B)Achtung:(!b) Pair- und Track-Kerning und die Positionierung in 1/65536
Pixeln werden nur eingesetzt, wenn v_ftext aufgerufen wird! Bei v_gtext
verhalten sich Vektorfonts weitgehend wie Bitmap-Fonts und weder Kerning
noch genaue Positionierung werden benutzt.

Querverweis:
Pair-Kerning ~ Track-Kerning ~ (!link [fix31-Format][fix31])
!end_node



!begin_node Vektor- oder Bitmap-Font?

Wenn es sich bei einem eingestellten Font um einen Vektorfont handelt,
liefert (!B)vqt_name(!b) 34 Eintr(!aumlaut)ge in intout zur(!uumlaut)ck und intout[33] enth(!aumlaut)lt
einen Wert ungleich Null.

Ist hingegen (!nolink [intout])[33] gleich Null (oder werden nur 33 Eintr(!aumlaut)ge
zur(!uumlaut)ckgeliefert), so handelt es sich um Bitmap-Font.
!end_node
!end_node



!begin_node Workstations des VDI

Eine (!I)Workstation(!i) ist ein allgemeiner Begriff f(!uumlaut)r ein Ein- oder
Ausgabeger(!aumlaut)t; dies k(!oumlaut)nnen Bildschirme, Drucker, Plotter, Kameras,
Grafiktabletts und viele andere Ger(!aumlaut)te sein.

Um auf ein bestimmtes VDI-Ger(!aumlaut)t zugreifen zu k(!oumlaut)nnen, mu(!sharps) daher zun(!aumlaut)chst die
Workstation (!I)ge(!oumlaut)ffnet(!i) werden. Je nach Sachlage erh(!aumlaut)lt man als
Resultat entweder eine Fehlermeldung oder die Workstation-Kennung (Handle)
des betreffenden Ger(!aumlaut)tes.

Zu jeder Workstation geh(!oumlaut)rt eine Menge von (!I)Merkmalen(!i), die
unver(!aumlaut)nderlich sind und (!uumlaut)ber die F(!aumlaut)higkeiten des Ger(!aumlaut)tes Auskunft geben.
Dazu geh(!oumlaut)ren u.a. Ger(!aumlaut)tetyp, Koordinatensystem und Farbf(!aumlaut)higkeit. Neben den
beim (!Oumlaut)ffnen der Workstation zur(!uumlaut)ckgelieferten Daten ist es (!uumlaut)ber eine
erweiterte Auskunftsfunktion m(!oumlaut)glich, noch mehr Daten (!uumlaut)ber ein Ger(!aumlaut)t zu
ermitteln. Dies erlaubt es einem Anwendungsprogramm, die F(!aumlaut)higkeiten des
Ger(!aumlaut)tes optimal auszunutzen (z.B. dadurch, da(!sharps) sie ihren Bildschirmaufbau an
die Anzahl der darstellbaren Bildschirmpunkte anpassen).

Neben den unver(!aumlaut)nderlichen besitzt eine Workstation auch noch ver(!aumlaut)nderliche
Merkmale; man spricht in diesem Zusammenhang von (!I)Attributen(!i). Sie
beschreiben den (!I)aktuellen Zustand(!i) des Ger(!aumlaut)tes. Ein gutes Beispiel
ist die Linienfarbe, die man nur ein einziges mal (und nicht etwa bei jedem
einzelnen Aufruf von Zeichenfunktionen) setzen mu(!sharps). Die aktuellen Attribute
werden vom (!nolink [VDI]) in internen Strukturen f(!uumlaut)r jede einzelne Workstation getrennt
gespeichert; so kann eine Applikation beispielsweise f(!uumlaut)r den Bildschirm und
den Drucker unbesorgt verschiedene Linienfarben einstellen. (!nolink [Das VDI])
erkennt am Workstation-Handle, welches Ausgabeger(!aumlaut)t gemeint ist.

(!B)Die folgende Tabelle nennt einige Attribute mit ihren
Standardwerten:(!b)

!begin_table [l l l]
Attribut !! Standardwert !! einzustellen per
!hline
Basislinienwinkel  !! 0 Grad                 !! vst_rotation
Clipping           !! ausgeschaltet          !! vs_clip
Cursor             !! versteckt              !! v_show_c, v_hide_c
Eingabemodus       !! Request                !! vsin_mode
F(!uumlaut)llmuster, frei   !! Logo des Herstellers   !! vsf_udpat
Kerning            !! ausgeschaltet          !! vst_kern
Linienenden        !! rechteckig             !! vsl_ends
Linienmuster, frei !! durchgehend            !! vsl_udsty
Linienst(!aumlaut)rke       !! nominelle Linienst(!aumlaut)rke !! vst_width
Markergr(!oumlaut)(!sharps)e        !! nominelle Markergr(!oumlaut)(!sharps)e  !! vsm_height
Schreibmodus       !! Replace                !! vswr_mode
Textausrichtung    !! links, Basislinie      !! vst_alignment
Texteffekt         !! normal                 !! vst_effects
Umrahmung          !! sichtbar               !! vsf_perimeter
Zeichenh(!oumlaut)he        !! nominelle Zeichenh(!oumlaut)he  !! vst_height
!end_table

!label Workstations, virtuelle
!label virtuelle Workstations
Eine Sonderstellung nimmt dabei der Bildschirm ein, da dieser f(!uumlaut)r mehrere
Prozesse gleichzeitig zur Verf(!uumlaut)gung stehen mu(!sharps). Aus diesem Grund bietet das
VDI sogenannte virtuelle Workstations an, die immer nur im Zusammenhang mit
einer bereits ge(!oumlaut)ffneten (!I)physikalischen(!i) Bildschirm-Workstation
benutzt werden k(!oumlaut)nnen. Jede virtuelle Workstation verf(!uumlaut)gt nat(!uumlaut)rlich (!uumlaut)ber
einen eigenen Satz von Attributen, damit sich die Progamme bei der
Bildschirmausgabe nicht gegenseitig in die Quere kommen.

(!B)Achtung:(!b) Nicht alle Eigenschaften der physikalischen
Bildschirm-Workstation sind auf die virtuellen Workstations (!uumlaut)bertragbar.
Tastatur und Maus k(!oumlaut)nnen auch weiterhin immer nur von einem Programm
gleichzeitig benutzt werden. Die Eingabefunktionen d(!uumlaut)rfen daher (!I)nur(!i)
von dem Programm benutzt werden, welches die physikalische
Bildschirm-Workstation ge(!oumlaut)ffnet hat (dies sind im Normalfall die AES).

Ein letzter Hinweis: Da die Verwaltung der Workstation-Attribute
Speicherplatz erfordert, der i.d.R. dynamisch angefordert wird, sollte man
nie davon ausgehen, da(!sharps) das (!Oumlaut)ffnen einer Workstation immer klappen mu(!sharps)!

Querverweis:
GDOS-Treiber ~  v_opnwk ~  v_opnvwk ~  vq_extnd
!end_node



!begin_node Das XIMG-Format f(!uumlaut)r Pixelbilder
!alias XIMG-Format

Pixelbilder werden unter GEM in einem Standardformat, dem sogenannten
Bit-Image (bzw. XIMG) Format abgelegt. Grafiken dieses Typs werden dabei
komprimiert gespeichert, und besitzen immer das Suffix (!I)'.IMG'(!i).

Der Hauptvorteil dieses Formats liegt in der Tatsache begr(!uumlaut)ndet, da(!sharps) es sich
um ein (!nolink [GEM])-(!I)Standardformat(!i) handelt, welches daher von nahezu allen
Applikationen unterst(!uumlaut)tzt wird. Eine Bit-Image-Datei besteht aus einem
Header, sowie den reinen Pixeldaten. Der Header ist dabei in C-Notation wie
folgt definiert:

!label XIMG-Header
!begin_preformatted !inside
typedef struct
{
  int16_t version;           /* Versionsnummer (meist 1)                 */
  int16_t headlen;           /* L(!aumlaut)nge des Kopfes in 16-Bit Worten        */
  int16_t planes;            /* Anzahl der Farbebenen der Grafik         */
  int16_t pat_run;           /* Musterl(!aumlaut)nge in Bytes                     */
  int16_t pix_width;         /* Pixelbreite des Quellger(!aumlaut)tes in 1/1000mm */
  int16_t pix_height;        /* Pixelh(!oumlaut)he des Quellger(!aumlaut)tes in 1/1000mm   */
  int16_t sl_width;          /* Breite einer Scan-Zeile in Pixeln        */
  int16_t sl_height;         /* H(!oumlaut)he einer Scan-Zeile in Pixeln          */
  int8_t  x_id[4];           /* muss 'XIMG' sein                         */
  int16_t color_model;       /* Farbmodell: 0=RGB, 1=CYM, 2=Pantone      */
  RGB_LIST color_table[]; /* Farbtabelle */
} XIMG;
!end_preformatted

Der gesamte Header liegt dabei im (!B)Motorola-68000-Format(!b) vor, so da(!sharps)
er auf einem Rechnern mit Intel-CPU wort- bzw. langwortweise gedreht werden
muss. Die reinen Pixeldaten beginnen immer bei (!I)headlen * 2(!i) und sind
(wie bereits erw(!aumlaut)hnt) komprimiert abgelegt.

Die L(!aumlaut)nge der Muster liegt zwischen 1 und 8, und betr(!aumlaut)gt bei den meisten
Bildschirmen 2 Bytes. Jede Scan-Zeilen-Information setzt sich aus zwei
Komponenten zusammen:

!begin_itemize
!item einem Wiederholungsteil folgender Struktur (in C-Notation):

!begin_verbatim
typedef struct
{
  int16_t sc_zero;    /* immer Null */
  int8_t  sc_ff;      /* immer 255  */
  int8_t  sc_cnt;     /* Anzahl der codierten Bildzeilen */
} SCANLINE;
!end_verbatim

!item der eigentlichen Bildinformation. Diese wird in drei verschiedenen
      Kategorien zeilenweise abgespeichert.

!begin_xlist
!label Solid-Runs
!item [(a)]
(!B)einfarbige Pixelfolgen (Solid-Runs)(!b) werden als einfaches Byte
gespeichert, wobei das oberste Bit den Status des Punktes bestimmt (also
'an' oder 'aus'). Die restlichen sieben Bits teilen mit, wie viele Bytes
ausgegeben werden m(!uumlaut)ssen.
!label Pattern-Runs
!item [(b)]
(!B)Musterfolgen (Pattern-Runs)(!b) haben als erstes Byte die 0, und als
zweites die Anzahl der Musterwiederholungen. Die Musterl(!aumlaut)nge steht im Header
unter (!I)pat_run(!i). Es folgen den ersten beiden Bytes also genau so viele
Bytes, wie ben(!oumlaut)tigt werden, um das Muster darzustellen.
!begin_verbatim
typedef struct
{                        
  int8_t pr_zero;        /* immer Null       */
  int8_t pr_cnt;         /* Anzahl der Bytes */
  int8_t pr_data[...];   /* Musterdaten      */
} PATTERNRUN;
!end_verbatim
!label Bit-Strings
!item [c)]
(!B)Schlecht, oder nicht verk(!uumlaut)rzbare Bildinformation (Bit-Strings)(!b) wird
unver(!aumlaut)ndert abgespeichert. Hier steht als erstes Byte eine 0x80 und als
zweites die Anzahl der Bytes. Danach folgen dann die entsprechenden Bytes
mit der unkomprimierten Bildinformation.
!begin_verbatim
typedef struct
{
  int8_t bs_first;       /* immer 0x80       */
  int8_t bs_cnt;         /* Anzahl der Bytes */
  int8_t bs_data[...];   /* Bilddaten        */
} BITSTRING;
!end_verbatim
!end_xlist
!end_itemize

Es folgen jeweils die Bildinformationen f(!uumlaut)r jede codierte Farbebene direkt
hintereinander. Man sollte auch darauf achten, da(!sharps) immer eine Zeile mit
voller Bytezahl codiert wird, auch wenn das Bild effektiv schmaler ist. Es
k(!oumlaut)nnen also bis zu sieben Bits (!uumlaut)berfl(!uumlaut)ssiger Information vorliegen. Die
Pixelbreite des Bildes steht im Header unter (!I)sl_width(!i).

Querverweis:
Metafile-Format ~  v_bit_image ~
(!link [OUT-Dateiformat][Das OUT-Dateiformat])
!end_node
!end_node



!begin_node VDI-Bindings
!label Bindings des VDI
!html_name vdi_bindings

(!nolink [Das VDI]) wird (!uumlaut)ber ein einziges Unterprogramm aufgerufen, dem 5 Parameter
(!uumlaut)bergeben werden; es handelt sich dabei um (!nolink [Adressen]) verschiedener Arrays,
die zur Ein-/Ausgabe-Kommunikation benutzt werden. Um eine VDI-Funktion
aufzurufen, mu(!sharps) der folgende Parameterblock mit den (!nolink [Adressen]) der unten
beschriebenen Arrays best(!uumlaut)ckt werden:

!label VDI-Parameterblock
!label Parameterblock des VDI
!begin_verbatim
typedef struct
{
   int16_t  *contrl;    /* Zeiger auf contrl-Array */
   int16_t  *intin;     /* Zeiger auf intin-Array  */
   int16_t  *ptsin;     /* Zeiger auf ptsin-Array  */
   int16_t  *intout;    /* Zeiger auf intout-Array */
   int16_t  *ptsout;    /* Zeiger auf ptsout-Array */
} VDIPB;
!end_verbatim

Die Adresse dieses Parameterblocks mu(!sharps) dann im Register d1 vermerkt, und
zus(!aumlaut)tzlich Register d0.w mit dem Wert 0x73 (115) gef(!uumlaut)llt werden. Durch
einen TRAP#2 Systemaufruf kann dann das (!nolink [VDI]) direkt aufgerufen werden. F(!uumlaut)r
den (!B)(!I)Pure-Assembler(!i)(!b) k(!oumlaut)nnte das z.B. so aussehen:

!begin_verbatim
        .EXPORT vdi         ; Funktion exportieren

        .IMPORT contrl      ; contrl-Feld importieren
        .IMPORT intin       ; intin-Feld  importieren
        .IMPORT ptsin       ; ptsin-Feld  importieren
        .IMPORT intout      ; intout-Feld importieren
        .IMPORT ptsout      ; ptsout-Feld importieren

        .DATA               ; Beginn des Daten-Segments

pblock: .DC.L contrl        ; Adresse des contrl-Arrays
        .DC.L intin         ; Adresse des intin-Arrays
        .DC.L ptsin         ; Adresse des ptsin-Arrays
        .DC.L intout        ; Adresse des intout-Arrays
        .DC.L ptsout        ; Adresse des ptsout-Arrays

        .CODE               ; Beginn des Code-Segments
!end_verbatim
!label vdi
!begin_verbatim
vdi:     MOVE.L #pblock,D1  ; Adresse des Parameterblocks
         MOVE.W #$73,D0     ; Opcode des VDI
         TRAP   #2          ; GEM aufrufen
         RTS                ; raus hier

       .END                 ; Ende des Moduls
!end_verbatim

Dar(!uumlaut)ber, welche Register ver(!aumlaut)ndert werden d(!uumlaut)rfen, gibt es keine klaren
Informationen. Tatsache ist jedoch, da(!sharps) die entsprechenden Routinen im
ROM (!I)alle(!i) Register retten.

Im Gegensatz zum GEMDOS kennt das VDI leider keinen dokumentierten
R(!uumlaut)ckgabewert f(!uumlaut)r 'unbekannte Funktionsnummer'. Daher muss man sich im
Zweifelsfall wie folgt behelfen:

!begin_itemize
!item Viele Eigenschaften eines Treibers k(!oumlaut)nnen bereits (!uumlaut)ber die Funktion
      vq_extnd ermittelt werden.
!item Ansonsten sollte man den entsprechenden (!nolink [VDI])-Aufruf einfach
      ausprobieren, und die R(!uumlaut)ckgabewerte analysieren. Viele Funktionen
      liefern n(!aumlaut)mlich als Resultat den eingestellten Wert zur(!uumlaut)ck. Dar(!uumlaut)ber
      hinaus kann man auch noch die Felder contrl[2] und contrl[4] (s.u.)
      untersuchen, und kontrollieren, ob sie die korrekten Zahlen enthalten.
!end_itemize

Nun zu den einzelnen Arrays. (!Uumlaut)ber jedes Feld k(!oumlaut)nnen bestimmte Ein- bzw.
Ausgaben get(!aumlaut)tigt werden; es gilt:

!begin_blist

!label contrl
!item [int16_t contrl[12!]]
(!Uumlaut)ber dieses Feld werden die Funktionsnummer, die Anzahl der Eingaben, die
Kennung der Workstation sowie funktionsabh(!aumlaut)ngige Parameter (!uumlaut)bergeben.
Eingaben an das VDI werden dabei wie folgt eingetragen:
!begin_xlist !compressed [contrl-7..n- =]
!item [contrl[0!] =]
Funktionsnummer
!item [contrl[1!] =]
Anzahl der Werte im ptsin-Array
!item [contrl[3!] =]
Anzahl der Werte im intin-Array
!item [contrl[5!] =]
Unterfunktionsnummer
!item [contrl[6!] =]
Kennung der Workstation
!item [contrl[7..n!] =]
abh(!aumlaut)ngig von der Funktion
!end_xlist
Ausgaben des (!nolink [VDI]) werden (!uumlaut)ber die folgenden Felder gemacht:
!begin_xlist !compressed
!item [contrl[2!] =]
Anzahl der Werte im ptsout-Array
!item [contrl[4!] =]
Anzahl der Werte im intout-Array
!item [contrl[6!] =]
Kennung der Workstation
!end_xlist
                      
!label ptsin
!item [int16_t ptsin[1024!]]
~
!label ptsout
!item [int16_t ptsout[256!]]
Diese beiden Felder werden benutzt, um Paare von Koordinaten oder Ma(!sharps)e in
Pixeln (wie z.B. die Breite einer Linie, oder die H(!oumlaut)he eines Zeichens) zu
(!uumlaut)bergeben. Die Gr(!oumlaut)(!sharps)e dieser Felder h(!aumlaut)ngt von der aufgerufenen Funktion ab.

!label intin
!item [int16_t intin[1024!]]
~
!label intout
!item [int16_t intout[512!]]
Diese Felder werden ben(!oumlaut)tigt, um Werte wie den Index eines Zeichens oder
einer Farbe zu (!uumlaut)bergeben. Die Gr(!oumlaut)(!sharps)e dieser Felder h(!aumlaut)ngt von der aufgerufenen
Funktion ab.

!end_blist

(!B)Bei der (!Uumlaut)bergabe von Strings an das (!nolink [VDI]) sind einige Besonderheiten zu
beachten:(!b) Diese werden grunds(!aumlaut)tzlich (!uumlaut)ber die Felder intin und intout
(!uumlaut)bergeben, wobei pro Zeichen ein Wort benutzt wird. Das hat den Vorteil, da(!sharps)
auch andere Codierungen als ASCII genutzt, und mehr als 256 Zeichen eines
Zeichensatzes verwendet werden k(!oumlaut)nnen.

Die Bindings arbeiten i.d.R. mit normalen C-Strings, und wandeln sie f(!uumlaut)r
das (!nolink [VDI]) um. Dabei wird die L(!aumlaut)nge des Strings in contrl[3] bzw. contrl[4]
vermerkt, wobei kein abschlie(!sharps)endes Null-Byte oder -wort vorhanden ist. Um
z.B. eine in intout liegende Zeichenkette in einen C-String zu verwandeln,
m(!uumlaut)ssen contrl[4] Elemente kopiert (dabei die oberen 8 Bit abschneiden !) und
anschlie(!sharps)end ein Null-Byte angeh(!aumlaut)ngt werden.

(!B)Achtung:(!b) Wenn das Betriebssystem Threads unterst(!uumlaut)tzt, muss unbedingt
darauf geachtet werden, eine Multithread-sichere Bibliothek zu verwenden.

Querverweis:
(!link [C-String nach VDI-String][Wandel C-String nach VDI-String]) ~
(!link [VDI-String nach C-String][Wandel VDI-String nach C-String]) ~
AES-Bindings



!begin_node Wandel VDI-String nach C-String

!begin_preformatted !inside
VOID vdi_str_to_c( UWORD *src, UBYTE *des, int16_t len )
{
   while ( len > 0 )
   {
      *des++ = (UBYTE)*src++;  /* nur Low-Byte kopieren */
      len(--);
   }
   *des++ = 0;  /* Ende des Strings */
}
!end_preformatted
!end_node



!begin_node Wandel C-String nach VDI-String

!begin_preformatted !inside
int16_t c_str_to_vdi( UBYTE *src, UWORD *des )
{
   int16_t  len;

   while (( *des++ = *src++ ) != 0 )
      len++;
   return (len); /* Stringl(!aumlaut)nge ohne Null-Byte */
}
!end_preformatted
!end_node
!end_node

!endif

!include gem/vdi/attribut/attribut.u
!include gem/vdi/output/output.u
!include gem/vdi/inquire/inquire.u
!include gem/vdi/input/input.u
!include gem/vdi/escape/escape.u
!include gem/vdi/colortable/colortable.u
!include gem/vdi/control/control.u
!include gem/vdi/raster/raster.u

!include gem/vdi/vdi_f.u

!include gem/vdi/structures/structures.u
