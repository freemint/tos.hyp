## Hypertext zum TOS-Betriebssystem
##
## Kapitel 5: VDI-Funktionsaufrufe

!iflang [english]

!include gem\vdi\vdi_en.u

!else

!begin_node Das VDI
!html_name About_the_VDI

Das (!nolink [VDI]) (Virtual Device Interface) ist ein Teil von GEM, und in erster Linie
als standardisiertes Grafiksystem zu verstehen. Aus Sicht des Programmierers
stellt sich das (!nolink [VDI]) als eine sehr umfangreiche Grafikbibliothek dar, deren
Ausgabeformat Åber mehrere Plattformen hinweg portabel ist. Das (!nolink [VDI]) kann in
die folgenden Funktionsgruppen unterteilt werden:

!begin_itemize !compressed
!item Attributfunktionen
!item Ausgabefunktionen 
!item Auskunftsfunktionen 
!item Eingabefunktionen
!item Escapefunktionen                                           
!item Farbtabellenfunktionen
!item Kontrollfunktionen
!item Rasterfunktionen
!end_itemize

Da das Original-(!nolink [VDI]) im TOS des Atari mit einigen SchwÑchen behaftet, und vor
allem nicht besonders schnell ist, hat sich NVDI bei vielen Benutzern als
(!I)der(!i) Ersatz fÅr das normale (!nolink [VDI]) erwiesen.

Einige der Funktionen des (!nolink [VDI]) benîtigen die Erweiterung GDOS, das
ursprÅnglich als Teil des Betriebssystems mitgeliefert werden sollte,
aufgrund von Speicherplatzproblemen in den ROM's der ersten ST's von Atari
jedoch ausgelagert wurde. Durch konsequente Nutzung der (!nolink [VDI]) Routinen kann
jeder Programmierer dafÅr sorgen, daû seine Programme sauber auf
unterschiedlichen Rechnern und in nahezu beliebigen Auflîsungen arbeiten.

Querverweis:
Grundlagen des VDI ~ Bindings des VDI ~ AES
!end_node


!begin_node Grundlagen des VDI
!html_name VDI_fundamentals

!label VDI, Grundlagen des

Das (!nolink [VDI]) (Virtual Device Interface) bildet die untere HÑlfte des GEM; es ist
sozusagen die Grundlage aller AES-Funktionen.

Auch wenn man mit dem (!nolink [VDI]) normalerweise primÑr Funktionen zur Grafikausgabe
verbindet, erstreckt sich der Aufgabenbereich auch auf (!I)Eingaben(!i) (wie
z.B. per Maus oder Grafiktablett). (!nolink [Das VDI]) ist also eine
Betriebssystemschicht zur Ansteuerung von (im weitesten Sinn)
grafikorientierten Aus- (!I)und(!i) EingabegerÑten. Dieser Abschnitt
beschreibt die Punkte:

!begin_itemize !compressed
!item Bindings des VDI
!item Clipping
!item (!link [GDOS][Das GDOS])
!item GDOS-Treiber
!item Koordinatensysteme des VDI
!item (!link [Line-A Routinen][Der Line-A-Emulator])
!item Metafile-Format
!item NVDI
!item Off-Screen-Bitmaps
!item (!link [OUT-Dateiformat][Das OUT-Dateiformat])
!item Rasterformate
!item SpeedoGDOS
!item (!link [Vektorfonts][Details zu Vektorschriften])
!item Workstations des VDI
!item (!link [XIMG-Format][Das XIMG-Format fÅr Pixelbilder])
!end_itemize

Wie das Wîrtchen 'Virtual' bereits andeutet, kînnen dabei fast alle
Funktionsaufrufe auf jedes verfÅgbare AusgabegerÑt (Bildschirm, Drucker,
Plotter, Diabelichter etc.) angewendet werden. Es spielt also keine Rolle,
ob man Kreise malen oder Texte ausgeben mîchte: dies kann immer mit den
gleichen Betriebssystemfunktionen realisiert werden.

!label VDI, Entstehung des
Die Wurzeln des (!nolink [VDI]) liegen im CP/M-GSX-System, das Anfang der 80er Jahre
aus dem Bedarf fÅr eine portable Grafikschnittstelle fÅr die damals
dominierenden CP/M-Systeme entstand. éhnlichkeiten in Funktionen und
Bezeichnungen zum GKS (Grafisches Kern-System) sind daher keineswegs
zufÑllig, sondern von den Entwicklern bei (!I)Digital Research(!i) voll
beabsichtigt gewesen.

(!nolink [Das VDI]) erfÅllt den ANSI-Standard X3H3.6CG-(!nolink [VDI]).

Querverweis: Style-Guidelines


!begin_node Clipping

Clipping ist ein Verfahren, das die Benutzung eines Fenstersystems
eigentlich erst mîglich macht. Dabei gibt man mittels des Clipping-Rechtecks
an, auf welchen Bildschirmbereich sich alle Grafikausgaben der betreffenden
Workstation beziehen sollen; alles, was aus dem so spezifizierten
Bildausschnitt herausragt, wird bei der Bildschirmausgabe Åbergangen.

Eine zwar wenig effiziente, aber leicht zu programmierende
Fensterausgaberoutine wÅrde einfach fÅr jedes zu zeichnende Teilrechteck des
Fensters jeweils ein Clipping-Rechteck setzen und dann alle zum Aufbau des
Fensterinhaltes notwendigen Bildschirmausgaben wiederholen. Wer sich die
MÅhe macht, zunÑchst anhand einer PlausibilitÑtsabfrage festzustellen, ob
das zu zeichnende Objekt Åberhaupt (!I)sichtbar(!i) ist, kann natÅrlich
deutlich Zeit sparen.

(!B)Hinweis:(!b) Wie so vieles im Leben ist auch das Clipping nicht gratis
zu haben. Wer eine optimale Geschwindigkeit beim Bildschirmaufbau erreichen
will sollte das Clipping-Rechteck so oft wie nur mîglich ausschalten.

Querverweis: Grundlagen des VDI ~  Style-Guidelines ~  vs_clip
!end_node



!begin_node Das GDOS
!label FontGDOS
!label FSM-GDOS
!label AMC-GDOS
!label GDOS, Font-
!label GDOS, FSM-
!label GDOS, AMC-

Einige Funktionen des VDI kînnen erst nach der Installation des GDOS aus
dem AUTO-Ordner heraus richtig benutzt werden. GrundsÑtzlich ermîglicht
das GDOS (Graphics Device Operating System) beliebige GerÑtetreiber und
ZeichensÑtze zu laden, und dann zu benutzen.

Es ist dabei vîllig unabhÑngig vom verwendeten GerÑt. GerÑtespezifisch sind
nur die nachzuladenden Treiber, die die (!nolink [VDI]) Funktionen auf dem
entsprechenden GerÑt realisieren. Bei genauer Kenntnis des Treiberformats
ist es so mîglich beliebige, und auch exotische AusgabegerÑte als (!nolink [VDI])
AusgabegerÑt zu betreiben.

Mit residentem GDOS erhîht sich die Zahl der VerfÅgung stehenden
(!nolink [VDI])-Funktionen, wÑhrend alle anderen Funktionen voll funktionsfÑhig bleiben
bzw. einen erweiterten Ausgabeumfang erhalten. Umgekehrt ist das aber nicht
so, Funktionen, die GDOS benîtigen, fÅhren ohne residentes GDOS zum Absturz
des Rechners. 
!label GDOS, Familie des

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image gdos_ahn
!else
!image (!picture_path)\gdos_ahn
!endif
!else
!image (!picture_path)\gdos_ahn
!endif

!begin_center
Abb: Der Stammbaum der GDOS-Familie
!end_center

!label vq_gdos
(!B)Daher ist es in einigen FÑllen wichtig zu wissen, ob Åberhaupt ein
vollstÑndiges GDOS installiert ist.(!b) Atari hat zu diesem Zweck das
folgende Verfahren dokumentiert: Der Trap-Dispatcher verÑndert den
Eingabewert -2 fÅr Register D0 genau dann, wenn ein GDOS installiert ist.
Viele Compiler stellen die Funktion (!B)vq_gdos(!b) zur VerfÅgung die genau
dann einen Wert von 0 zurÅckliefert wenn (!I)kein(!i) GDOS installiert ist.
Diese Funktion basiert im wesentlichen auf dem folgenden Code:

!begin_verbatim
vq_gdos:
              move.w   #-2,d0
              trap     #2
              cmp.w    #-2,d0
              sne      d0
              ext.w    d0
              rts
!end_verbatim

(!B)Wichtiger Hinweis:(!b) vq_gdos liefert nur die Information, ob ein GDOS
vorhanden ist, oder nicht. Es wird (!I)nichts(!i) darÅber ausgesagt, um
welches GDOS es sich handelt bzw. welche FÑhigkeiten das installierte GDOS
besitzt. So lÑût sich mit Hilfe dieser Funktion beispielsweise das AMC-GDOS
(!I)nicht(!i) von SpeedoGDOS oder NVDI unterscheiden.

!label ABC-GEM
(!B)Vorsicht:(!b) Die GEM-Versionen des niederlÑndischen Softwarehauses "ABC"
(ABC-GEM 2.x) stÅrzen bei diesem Aufruf ab.

!label vq_vgdos
!label _vq_gdos
Allernativ gibt es noch vq_vgdos (_vq_gdos):

!begin_verbatim
vq_vgdos:
              move.w   #-2,d0
              trap     #2
              rts
!end_verbatim

!label GDOS_NONE
!label GDOS_ATARI
!label GDOS_AMC
!label GDOS_AMCLIGHT
!label GDOS_FNT
!label GDOS_FSM
Als RÅckgabe erhÑlt man:
!begin_table [l|l|l]
Name !! Wert !! GDOS Type
!hline
GDOS_NONE    !! -2 !! GDOS not (!nolink [installed]).
-            !! Any other value.     !! GDOS 1.0  or 1.2
GDOS_ATARI   !! 0x0007E88A           !! GDOS 1.1 von Atari Corp.
GDOS_AMC     !! 0x0007E864           !! AMC-GDOS von Arnd Beissner
GDOS_AMCLIGHT !! 0x0007E8BA          !! GEMINI-Spezial-GDOS von Arnd Beissner 
-            !! 0x3e5d0957           !! ttf-gdos von Trevor Blight
GDOS_FNT     !! 0x5F464E54 ('_FNT')  !! FONTGDOS
GDOS_FSM     !! 0x5F46534D ('_FSM')  !! FSMGDOS
-            !! 0x66564449 ('fVDI')  !! fVDI
!end_table
# Quelle: ttf-gdos aus Archiv ttf-gdos.lzh auf meine Festplatte ;-) [GS]
# Quelle: GDOS_ATARI, GDOS_AMC und GDOS_AMCLIGHT aus der Headerdatei portvdi.h
#         von Maustausch-Fontend CAT

Die aktuellen (und leistungsfÑhigsten) Versionen sind das (!nolink [SpeedoGDOS]) und
(!nolink [NVDI]) (ab Version 3.0), die es u.a. erlauben VektorzeichensÑtze im TrueType,
Type-1 bzw. Speedo Format zu verarbeiten. (!nolink [NVDI]) liegt auch in einer
speziellen (!I)Macintosh-Version(!i) vor (NVDIMac), und ermîglicht es jedem
Programm das Åber GDOS ausgeben kann (in Verbindung mit MagiC Mac), seine
Ausgaben auch auf Apple-Druckern und im Netzwerk tÑtigen zu kînnen.

Querverweis:
(!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei]) ~
Grundlagen des VDI ~  Style-Guidelines
!end_node


!include gem\vdi\assign_sys.ui



!begin_node GDOS-Treiber
!label Treiber, GDOS-
!label Treiber, VDI-
!label VDI-Treiber

Ein GDOS-Treiber ist im wesentlichen eine normale Programmdatei ohne
Startup-Code, die als erste Routine einen Dispatcher fÅr die eingehenden
VDI-Aufrufe enthÑlt. Alle Treiber mÅssen in der ASSIGN.SYS-Datei angemeldet
sein, die vom GDOS beim Start ausgewertet wird.

Die folgende Liste nennt die wichtigsten Treiber mit ihren jeweiligen
GerÑtenummern:

!begin_xlist [Lade und Zeichnen Bit-Image Treiber] !compressed
!item [Bildschirm-Treiber]                   (01-10) 
!item [Plotter-Treiber]                      (11-20)              
!item [Drucker-Treiber]                      (21-30)               
!item [Metafile-Treiber]                     (31-40)               
!item [Kamera-Treiber]                       (41-50)               
!item [Grafiktablett-Treiber]                (51-60)
!item [Memory-Treiber]                       (61-70)
!item [Fax-Treiber]                          (81-90)
!item [Bit-Image Treiber]                    (91-100)
!item [Multimedia Treiber]                   (101-110)
!item [Sound Treiber]                        (111-120)
!item [Lade und Zeichnen Bit-Image Treiber]  (121-130)
!end_xlist

Bei der Implementierung des Dispatchers sollte folgendes beachtet werden:

!begin_itemize !compressed
!item die Adresse des (!nolink [VDI])-Parameterblocks wird im Register D1 Åbergeben
!item die Funktion selbst wird mit einer RTS-Anweisung abgeschlossen
!end_itemize

Ein GDOS-Treiber arbeitet immer im Rasterkoordinaten-System; die
Konvertierung der Werte im ptsin- und ptsout-Feld wird vom GDOS Åbernommen.
DarÅber hinaus muû beachtet werden, daû nicht alle Funktionen den
eigentlichen Treiber exakt so erreichen, wie sie abgeschickt wurden, da sie
vom GDOS teilweise vorverarbeitet werden.

Querverweis: (!link [GDOS][Das GDOS]) ~ Grundlagen des VDI ~ Bindings des VDI



!begin_node Bildschirm-Treiber
!label GDOS-Treiber, Bildschirm
!label Treiber, Bildschirm-

Der Bildschirmtreiber des TOS kann durch einen eigenen Treiber ersetzt
werden, welcher vom GDOS nachgeladen werden muss.

Derartige Treiber gibt es bereits fÅr die unterschiedlichsten Grafikkarten
(z.B. (!I)NVDI-ET4000(!i) fÅr Grafikkarten mit dem Tseng ET-4000 Chip).

Bei der Anschaffung eines alternativen Bildschirmtreibers sollte darauf
geachtet werden, daû der Treiber alle relevanten Funktionen des VDI
unterstÅtzt, und auch mit GEM-ZeichensÑtzen keine Probleme hat.

Querverweis:
GDOS-Treiber ~  (!link [Mindestfunktionsumfang] [Mindestfunktionsumfang fÅr Bildschirmtreiber])
!end_node



!begin_node Mindestfunktionsumfang fÅr Bildschirmtreiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Bildschirmtreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation aus dem
Atari (!I)"GEM Programmer's Guide"(!i).

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!    !! v_opnwk
  2 !!    !! v_clswk
  3 !!    !! v_clrwk
  4 !!    !! v_updwk
  5 !!    !! Escapefunktionen
    !!  1 !! vq_chcells
    !!  2 !! v_exit_cur
    !!  3 !! v_enter_cur
    !!  4 !! v_curup
    !!  5 !! v_curdown
    !!  6 !! v_curright
    !!  7 !! v_curleft
    !!  8 !! v_curhome
    !!  9 !! v_eeos
    !! 10 !! v_eeol
    !! 11 !! v_curaddress
    !! 12 !! v_curtext
    !! 15 !! vq_curaddress
    !! 18 !! v_dspcur
    !! 19 !! v_rmcur
  6 !!    !! v_pline
  7 !!    !! v_pmarker
  8 !!    !! v_gtext
  9 !!    !! v_fillarea
 11 !!    !! Ausgabefunktionen
    !!  1 !! v_bar
    !!  2 !! v_arc
    !!  3 !! v_pieslice
    !!  4 !! v_circle
    !!  5 !! v_ellipse
    !!  6 !! v_ellarc
    !!  7 !! v_ellpie
    !!  8 !! v_rbox
    !!  9 !! v_rfbox
    !! 10 !! v_justified
 12 !!    !! vst_height
 14 !!    !! vs_color
 15 !!    !! vsl_type
 17 !!    !! vsl_color
 18 !!    !! vsm_type
 20 !!    !! vsm_color
 21 !!    !! vst_font
 22 !!    !! vst_color
 23 !!    !! vsf_interior
 24 !!    !! vsf_style
 25 !!    !! vsf_color
 26 !!    !! vq_color
 28 !!    !! vrq_locator
 31 !!    !! vrq_string
 32 !!    !! vswr_mode
 33 !!    !! vsin_mode
 35 !!    !! vql_attributes
 36 !!    !! vqm_attributes
 37 !!    !! vqf_attributes
 38 !!    !! vqt_attributes
 39 !!    !! vst_alignment
100 !!    !! v_opnvwk
101 !!    !! v_clsvwk
102 !!    !! vq_extnd
104 !!    !! vsf_perimeter
106 !!    !! vst_effects
107 !!    !! vst_point
108 !!    !! vsl_ends
109 !!    !! vro_cpyfm
110 !!    !! vr_trnfm
111 !!    !! vsc_form
112 !!    !! vsf_udpat
113 !!    !! vsl_udsty
114 !!    !! vr_recfl
115 !!    !! vqin_mode
116 !!    !! vqt_extent
117 !!    !! vqt_width
118 !!    !! vex_timv
121 !!    !! vrt_cpyfm
122 !!    !! v_show_c
123 !!    !! v_hide_c
124 !!    !! vq_mouse
125 !!    !! vex_butv
126 !!    !! vex_motv
127 !!    !! vex_curv
128 !!    !! vq_key_s
129 !!    !! vs_clip
130 !!    !! vqt_name
131 !!    !! vqt_fontinfo
!end_table
!end_node



!begin_node Bit-Image Treiber
!label GDOS-Treiber, Bit-Image
!label Treiber, Bit-Image

Mit Hilfe eines Bit-Image Treibers kînnen alle Applikationen, die Åber das
GDOS Ausgaben tÑtigen kînnen, direkt in eine Datei drucken.

Bei NVDI-Treibern kann bei v_opnwk das Seitenformat und der Name der
Bit-Image-Datei gesetzt werden. Der Dateiname kann Åbrigens auch mit
Hilfe von vq_extnd Åbergeben werden:

!begin_verbatim
contrl[1]   = 4;
ptsin[2]    = 1157;
ptsin[3..4] = Zeiger auf den Dateinamen (BYTE *);
ptsin[5..6] = Zeiger auf Fehlervariable (int16_t *);
ptsin[7]    = 0;
!end_verbatim

(!B)Hinweis:(!b) öber den Sinn und Unsinn dieses Features kann man sich
sicherlich streiten, da es sich bei vq_extnd eigentlich um eine reine
Auskunftsfunktion handelt!

Querverweis: GDOS-Treiber ~
(!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei])
!end_node



!begin_node Drucker-Treiber
!label GDOS-Treiber, Drucker
!label Treiber, Drucker-

Die Auswahl an Drucker-Treibern fÅr das GDOS ist inzwischen fast
unerschîpflich; lediglich bei Farbdruckern scheint es noch einige EngpÑsse
zu geben.

Bei der Arbeit mit Drucker-Treibern sollte beachtet werden, daû nicht alle
Treiber funktional vîllig identisch sind. So gibt es etwa bei Einsatz eines
Laserdruckers nicht nur zusÑtzliche Funktionen, sondern einige bestehende
wurden auch teilweise erweitert.

Bei NVDI-Druckertreibern kann bei v_opnwk das Seitenformat und das GEMDOS
AusgabegerÑt gesetzt werden. Zur Ausgabe von (Farb-) Bildern sollten die
Funktionen vrt_cpyfm bzw. vro_cpyfm benutzt werden. Sie lassen sich in (!nolink [NVDI])
fÅr Druckertreiber (und IMG, usw.) genauso wie die Funktionen des
Bildschirmtreibers ansprechen. Der einzige  Unterschied besteht darin, daû
Raster nicht innerhalb der Druckerbitmap verschoben werden kînnen (Quell-
und Ziel-MFDB mit fd_addr == 0L), da die  Druckerbitmap i.a. aus mehreren
Scheiben besteht, die nacheinander aufbereitet werden. Da Kopieren innerhalb
der GerÑtebitmap bei der Druckausgabe keinen Sinn macht, stellt dieser
Unterschied aber keine EinschrÑnkung dar.

Der Druckertreiber puffert die Bitmap ggf. in der Display-List falls nicht
genÅgend Speicher vorhanden ist; es ist also nicht erforderlich, die Bitmap
bis zur Ausgabe mit v_updwk im Speicher zu halten.

Wenn die Bitmap skaliert werden muû, sollte ein Programm wenn mîglich nicht
selber die Bitmap vergrîûern, sondern vrt/vro_cpyfm die Arbeit Åberlassen.
Dadurch steigt die AusgabequalitÑt, es mÅssen weniger Daten auf der
Festplatte gepuffert werden, und der Ausdruck wird beschleunigt. Ob der
Treiber skalieren kann, erfÑhrt man bei Aufruf von vq_extnd.

Bei Ausgabe von Farbbildern im 8-Farbmodus sollten Raster vor dem Dithern
mit einer Korrekturfunktion behandelt werden. Hier empfiehlt sich eine
Gamma-Korrektur mit Exponent von 0,3 bis 0,4, damit das Bild nicht
vollkommen matt und ÅbersÑttigt aussieht. Im Truecolor-Modus Åbernimmt der
Treiber Farbkorrektur, Schwarz-Separation und andere qualitÑtsverbessernde
Maûnahmen selber - Bitmaps sollten hier ohne vorhergehende Korrektur und
ohne Rasterung an den Treiber geschickt werden.

Querverweis:
GDOS-Treiber    ~  Bitmapformat bei Druckertreibern ~
(!link [Mindestfunktionsumfang] [Mindestfunktionsumfang fÅr Drucker-Treiber])
!end_node



!begin_node Mindestfunktionsumfang fÅr Drucker-Treiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Druckertreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation aus dem
Atari (!I)"GEM Programmer's Guide"(!i).

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!    !! v_opnwk
  2 !!    !! v_clswk
  3 !!    !! v_clrwk
  4 !!    !! v_updwk
  5 !!    !! Escapefunktionen
    !!  1 !! vq_chcells
    !! 20 !! v_form_adv
    !! 21 !! v_output_window
    !! 22 !! v_clear_disp_list
    !! 23 !! v_bit_image
  6 !!    !! v_pline
  7 !!    !! v_pmarker
  8 !!    !! v_gtext
  9 !!    !! v_fillarea
 11 !!    !! Ausgabefunktionen
    !!  1 !! v_bar
    !!  2 !! v_arc
    !!  3 !! v_pieslice
    !!  4 !! v_circle
    !!  5 !! v_ellipse
    !!  6 !! v_ellarc
    !!  7 !! v_ellpie
    !!  8 !! v_rbox
    !!  9 !! v_rfbox
    !! 10 !! v_justified  
 12 !!    !! vst_height
 15 !!    !! vsl_type
 17 !!    !! vsl_color
 18 !!    !! vsm_type
 20 !!    !! vsm_color
 21 !!    !! vst_font
 22 !!    !! vst_color
 23 !!    !! vsf_interior
 24 !!    !! vsf_style
 25 !!    !! vsf_color 
 26 !!    !! vq_color
 32 !!    !! vswr_mode
 35 !!    !! vql_attributes
 36 !!    !! vqm_attributes
 37 !!    !! vqf_attributes
 38 !!    !! vqt_attributes
 39 !!    !! vst_alignment 
102 !!    !! vq_extnd
104 !!    !! vsf_perimeter
106 !!    !! vst_effects
107 !!    !! vst_point 
108 !!    !! vsl_ends
112 !!    !! vsf_udpat
116 !!    !! vqt_extent
117 !!    !! vqt_width
129 !!    !! vs_clip
130 !!    !! vqt_name
131 !!    !! vqt_fontinfo
!end_table
!end_node



!begin_node Bitmapformat bei Druckertreibern
!label Druckertreiber, Bitmapformat

Genauso wie fÅr den Bildschirm liefert vq_scrninfo auch fÅr Drucker das
Format der Bitmap zurÅck. In der Regel gibt es hier nur 3 verschiedene
Formate: 

!begin_itemize !compressed
!item monochrome Bitmap, wenn der Treiber 2 Farben hat.
!item drei hintereinanderliegende Ebenen, wenn der Treiber 8 Farben hat.
!item Packed Pixels mit 32 Bit, wenn der Treiber im Truecolor-Modus lÑuft.
!end_itemize

Da die Formate (1) und (3) wohl selbsterklÑrend sind, sei hier nur noch auf
Format (2) eingegangen: Bei 8 Farben besteht eine farbige Bitmap aus 3
vollstÑndigen, hintereinander im Speicher liegenden Ebenen (Planes). Das
gerÑtespezifische Rasterformat entspricht also dem Standardformat. Die
Zuordnung von VDI-Farbindex zum Pixelwert folgt der Standardeinteilung, die
fÅr alle VDI-Treiber gilt.

Querverweis: Drucker-Treiber ~  Rasterformate ~  vro_cpyfm ~  vrt_cpyfm
!end_node



!begin_node Fax-Treiber
!label GDOS-Treiber, Fax
!label Treiber, Fax-

Ein Fax-Treiber ist im Prinzip nichts anderes als ein einfacher
Drucker-Treiber. Mit Hilfe eines solchen Treibers kînnen alle Applikationen,
die Åber das GDOS ausgeben, direkt Telefaxe verschicken.

Bei einem Fax-Treiber kann weder Seitenformat noch GEMDOS-GerÑt angegeben
werden. Man sollte auch nicht versuchen, die Grîûe der Bitmap zu verÑndern.

Querverweis: GDOS-Treiber ~  (!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei])
!end_node



!begin_node Grafiktablett-Treiber
!label GDOS-Treiber, Grafiktablett
!label Treiber, Grafiktablett-

Da z.Zt. noch keine Treiber fÅr Grafiktabletts existieren, kînnen an dieser
Stelle keine weitergehenden Informationen erteilt werden.

Querverweis: GDOS-Treiber ~  (!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei])
!end_node



!begin_node Kamera-Treiber
!label GDOS-Treiber, Kamera
!label Treiber, Kamera-

Da z.Zt. noch keine Treiber fÅr die (!I)Polaroid-Palette(!i) existieren,
kînnen an dieser Stelle keine weitergehenden Informationen erteilt werden.

Querverweis:
GDOS-Treiber ~ (!link [Mindestfunktionsumfang] [Mindestfunktionsumfang fÅr Kamera-Treiber])
!end_node



!begin_node Mindestfunktionsumfang fÅr Kamera-Treiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Kameratreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation von
(!I)Digital Research(!i) zu PC-GEM 2.0.

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!    !! v_opnwk
  2 !!    !! v_clswk
  3 !!    !! v_clrwk
  4 !!    !! v_updwk
  5 !!    !! Escapefunktionen
    !!  1 !! vq_chcells
    !! 23 !! v_bit_image     
    !! 91 !! vsp_film
    !! 92 !! vqp_filmname
  6 !!    !! v_pline
 11 !!    !! Ausgabefunktionen
    !!  1 !! v_bar
    !!  2 !! v_arc
    !!  3 !! v_pieslice
    !!  4 !! v_circle
    !!  5 !! v_ellipse
    !!  6 !! v_ellarc
    !!  7 !! v_ellpie
    !!  8 !! v_rbox
    !!  9 !! v_rfbox
    !! 10 !! v_justified 
 12 !!    !! vst_height
 13 !!    !! vst_rotation
 14 !!    !! vs_color
 15 !!    !! vsl_type
 16 !!    !! vsl_width
 17 !!    !! vsl_color
 18 !!    !! vsm_type
 19 !!    !! vsm_height
 20 !!    !! vsm_color
 21 !!    !! vst_font
 22 !!    !! vst_color
 23 !!    !! vsf_interior
 24 !!    !! vsf_style
 25 !!    !! vsf_color 
 26 !!    !! vq_color
 32 !!    !! vswr_mode
 35 !!    !! vql_attributes
 36 !!    !! vqm_attributes
 37 !!    !! vqf_attributes
 38 !!    !! vqt_attributes
 39 !!    !! vst_alignment 
102 !!    !! vq_extnd
104 !!    !! vsf_perimeter
106 !!    !! vst_effects
107 !!    !! vst_point 
108 !!    !! vsl_ends
112 !!    !! vsf_udpat
113 !!    !! vsl_udsty
116 !!    !! vqt_extent
117 !!    !! vqt_width
119 !!    !! vst_load_fonts
120 !!    !! vst_unload_fonts
129 !!    !! vs_clip
130 !!    !! vqt_name
131 !!    !! vqt_fontinfo
!end_table
!end_node



!begin_node Memory-Treiber
!label GDOS-Treiber, Memory
!label Treiber, Memory-

Ein Memory-Treiber ist im Prinzip ein Bildschirmtreiber, bei dem die 
Ausgaben nicht im Bildschirmspeicher, sondern in einem anderen
Speicherbereich landen, und dort dann weiterverarbeitet werden kînnen.

Die z.Zt. verfÅgbaren Treiber unterstÅtzen nur eine monochrome Bitmap, und
besitzen eine logische Auflîsung von 300dpi. Leider stimmt das Aspect-Ratio
VerhÑltnis i.a. nicht mit der aktuellen Auflîsung des Bildschirms Åberein,
was zur Folge hat, daû Kreise beispielsweise als Ellipsen dargestellt
werden.

Die Auflîsung der Bitmap kann per v_opnwk gesetzt werden, indem in
ptsin[0..1] die Breite-1 bzw. Hîhe-1 sowie in contrl[1] der Wert 1
geschrieben werden. Nach dem Aufruf der Funktion wird die Adresse der Bitmap
in (!nolink [contrl])[0..1] zurÅckgeliefert. DarÅber hinaus ist es auch mîglich, die
Bitmap-Grîûe per vq_extnd zu setzen. In diesem Fall ist es zusÑtzlich
mîglich, einen eigenen Buffer zu Åbergeben. Dazu setzt man (!nolink [contrl])[3] auf den
Wert 3 und Åbergibt in intin[1..2] einen Zeiger auf den Buffer.

Aufgrund der grîûeren FlexibilitÑt sollte Off-Screen-Bitmaps der Vorzug
gegenÅber Memory-Treibern gegeben werden.

Querverweis: GDOS-Treiber ~  (!link [ASSIGN.SYS-Datei][Der Aufbau der ASSIGN.SYS-Datei])
!end_node



!begin_node Metafile-Treiber
!label GDOS-Treiber, Metafile
!label Treiber, Metafile-

Ein Metafile-Treiber speichert alle an ihn gerichteten Aufrufe in einem
GEM-Metafile, welches sich im aktuellen Verzeichnis der Applikation befindet
und als Voreinstellung den Namen (!I)GEMFILE.(!nolink [GEM])(!i) trÑgt.

Mîchte man den Namen Ñndern, so sollte direkt nach v_opnwk die Funktion
vm_filename aufgerufen werden, der man einen kompletten Dateinamen mit dem
gewÅnschten Pfad und Namen Åbergeben kann.

Damit andere Programme ein Metafile vernÅnftig darstellen kînnen, sollten
die Funktionen v_meta_extents, vm_pagesize und vm_coords aufgerufen werden.

Querverweis:
(!nl)
v_meta_extents ~  vm_pagesize ~  vm_coords ~
GDOS-Treiber ~    (!link [Mindestfunktionsumfang] [Mindestfunktionsumfang fÅr Metafile-Treiber])
!end_node



!begin_node Mindestfunktionsumfang fÅr Metafile-Treiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Metafiletreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation aus dem
Atari (!I)"GEM Programmer's Guide"(!i).

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!     !! v_opnwk
  2 !!     !! v_clswk
  3 !!     !! v_clrwk
  4 !!     !! v_updwk
  5 !!     !! Escapefunktionen
    !!   1 !! vq_chcells
    !!   2 !! v_exit_cur
    !!   3 !! v_enter_cur
    !!  20 !! v_form_adv
    !!  21 !! v_output_window
    !!  22 !! v_clear_disp_list
    !!  23 !! v_bit_image     
    !!  98 !! v_meta_extents
    !!  99 !! v_write_meta
    !! 100 !! vm_filename
  6 !!     !! v_pline
  7 !!     !! v_pmarker
  8 !!     !! v_gtext
  9 !!     !! v_fillarea
 11 !!     !! Ausgabefunktionen
    !!   1 !! v_bar
    !!   2 !! v_arc
    !!   3 !! v_pieslice
    !!   4 !! v_circle
    !!   5 !! v_ellipse
    !!   6 !! v_ellarc
    !!   7 !! v_ellpie
    !!   8 !! v_rbox
    !!   9 !! v_rfbox
    !!  10 !! v_justified 
 12 !!     !! vst_height
 13 !!     !! vst_rotation
 14 !!     !! vs_color
 15 !!     !! vsl_type
 16 !!     !! vsl_width
 17 !!     !! vsl_color
 18 !!     !! vsm_type
 19 !!     !! vsm_height
 20 !!     !! vsm_color
 21 !!     !! vst_font
 22 !!     !! vst_color
 23 !!     !! vsf_interior
 24 !!     !! vsf_style
 25 !!     !! vsf_color 
 26 !!     !! vq_color
 32 !!     !! vswr_mode
 35 !!     !! vql_attributes
 36 !!     !! vqm_attributes
 37 !!     !! vqf_attributes
 38 !!     !! vqt_attributes
 39 !!     !! vst_alignment 
102 !!     !! vq_extnd
103 !!     !! v_contourfill
104 !!     !! vsf_perimeter
106 !!     !! vst_effects
107 !!     !! vst_point 
108 !!     !! vsl_ends
112 !!     !! vsf_udpat
113 !!     !! vsl_udsty
114 !!     !! vr_recfl
117 !!     !! vqt_width
129 !!     !! vs_clip
131 !!     !! vqt_fontinfo
!end_table
!end_node



!begin_node Plotter-Treiber
!label GDOS-Treiber, Plotter
!label Treiber, Plotter-

Nach langer Durststrecke sind mittlerweile auch GDOS-Plottertreiber
verfÅgbar. So wird z.B. bei dem Programm (!I)DATA(!i) ein HPGL-Treiber
mitgeliefert, und auch auf der (!nolink [PD])-Diskette Nummer 458 der Zeitschrift
(!I)ST-Computer(!i) befindet sich ein solcher Treiber.

Genauere Informationen zu Plottertreibern sind z.Zt. jedoch noch nicht
bekannt.

Querverweis:
GDOS-Treiber ~  (!link [Mindestfunktionsumfang] [Mindestfunktionsumfang fÅr Plotter-Treiber])
!end_node



!begin_node Mindestfunktionsumfang fÅr Plotter-Treiber

Die folgende Liste beschreibt den Funktionsumfang, den ein Plottertreiber
mindestens bieten sollte; es handelt sich um eine Spezifikation aus dem
Atari (!I)"GEM Programmer's Guide"(!i).

!begin_table [c c l]
Opcode !! ~ !! Funktion
!hline
  1 !!    !! v_opnwk
  2 !!    !! v_clswk
  3 !!    !! v_clrwk
  4 !!    !! v_updwk
  5 !!    !! Escapefunktionen
    !!  1 !! vq_chcells
  6 !!    !! v_pline
  7 !!    !! v_pmarker
  8 !!    !! v_gtext
  9 !!    !! v_fillarea
 11 !!    !! Ausgabefunktionen
    !!  1 !! v_bar
    !!  2 !! v_arc
    !!  3 !! v_pieslice
    !!  4 !! v_circle
    !!  5 !! v_ellipse
    !!  6 !! v_ellarc
    !!  7 !! v_ellpie
    !!  8 !! v_rbox
    !!  9 !! v_rfbox
    !! 10 !! v_justified 
 12 !!    !! vst_height
 15 !!    !! vsl_type
 17 !!    !! vsl_color
 18 !!    !! vsm_type
 20 !!    !! vsm_color
 21 !!    !! vst_font
 22 !!    !! vst_color
 23 !!    !! vsf_interior
 24 !!    !! vsf_style
 25 !!    !! vsf_color 
 35 !!    !! vql_attributes
 36 !!    !! vqm_attributes
 37 !!    !! vqf_attributes
 38 !!    !! vqt_attributes
 39 !!    !! vst_alignment 
102 !!    !! vq_extnd
104 !!    !! vsf_perimeter
107 !!    !! vst_point 
108 !!    !! vsl_ends
116 !!    !! vqt_extent
117 !!    !! vqt_width
130 !!    !! vqt_name
131 !!    !! vqt_fontinfo
!end_table
!end_node
!end_node



!begin_node Koordinatensysteme des VDI

(!nolink [Das VDI]) unterscheidet zwei verschiedene Typen von Koordinatensystemen:

!begin_itemize
!label Rasterkoordinaten
!label Koordinaten, Raster-
!label Koordinaten, RC-
!label RC-Koordinaten
!item (!B)Rasterkoordinaten (RC):(!b) Bei Verwendung dieses Systems kann man
      exakt das dem AusgabegerÑt eigene Koordinatensystem benutzen. Bei
      einem Bildschirm entspricht das den horizontal und vertikal
      verfÅgbaren Pixeln. Der Nullpunkt liegt in der linken (!I)oberen(!i)
      Ecke.
(!nl)
      Hauptvorteil der Rasterkoordinaten ist die absolut exakte
      Positionierung die die genaue Arbeit mit Bildschirmrastern (Fenster
      etc). erst mîglicht macht.
!label normalisierte Koordinaten
!label Koordinaten, normalisierte
!label Koordinaten, NDC-
!label NDC-Koordinaten
!item (!B)normalisierte Koordinaten (NDC):(!b) Dieses System besitzt immer
      eine maximale Auflîsung von 32768*32768 Punkten. (!nolink [Das VDI]) rechnet beim
      Aufruf eines GerÑtetreibers automatisch auf dessen physikalisches
      Koordinatensystem um. Der Nullpunkt liegt in der linken
      (!I)unteren(!i) Ecke. Zur Arbeit mit dem NDC-System muû ein GDOS
      installiert sein - der Bildschirmtreiber im ROM kann (!I)keine(!i)
      NDC-Koordinaten verarbeiten.
!end_itemize

Die folgende Abbildung macht den Unterschied zwischen RC- und
NDC-Koordinaten noch einmal besonders deutlich:

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image koords
!else
!image (!picture_path)\koords
!endif
!else
!image (!picture_path)\koords
!endif

(!B)Hinweis:(!b) In der Praxis wird das NDC-System nur selten benutzt.
Programme, die exakte Bemaûungen anbieten mÅssen (Desktop-Publishing,
wissenschaftliche Grafik) mÅssen intern sowieso eine eigene, feinere
Koordinatendarstellung benutzen.

Die Verwendung des NDC-Systems wÅrde dazu fÅhren, daû Koordinaten gleich
zweimal konvertiert werden (einmal von der internen Darstellung in
NDC-Koordinaten, anschlieûend in Rasterkoordinaten), was zu ÅberflÅssigen
Geschwindigkeitsverlusten und Rundungsfehlern fÅhrt.

Querverweis: Grundlagen des VDI ~  Style-Guidelines
!end_node



!include gem\vdi\metafile.u



!begin_node NVDI
!label NVDIMac

NVDI (NewVDI) ist ein von den (!I)Behne-BrÅdern(!i) entwickeltes VDI,
welches das Original des Atari vollstÑndig ersetzt. Dabei besticht neben der
sehr hohen Geschwindigkeit vor allem die Mîglichkeit, VektorzeichensÑtze der
Formate Speedo und TrueType (mit einem speziellen Modul auch Type-1)
verwenden zu kînnen. NVDI liegt auch in einer speziellen
(!I)Macintosh-Version(!i) vor (NVDIMac), und ermîglicht es jedem Programm
das Åber GDOS ausgeben kann (in Verbindung mit MagiC Mac), seine Ausgaben
auch auf Apple-Druckern und im Netzwerk tÑtigen zu kînnen.

Um herauszufinden, welche NVDI-Version man vor sich hat und welchen
Funktionsumfang sie hat, muû der Cookie NVDI gesucht werden, der die
Versionsnummer im BCD-Format enthÑlt (z.B. 0x0410 fÅr Version 4.10).

!label EdDI
Wer die Offscreen-Bitmaps nutzen mîchte, sollte nach dem (!link ['EdDI'-Cookie][ Cookie, EdDI])
suchen (z.B. per is_EdDI()). Das auf die Kennung folgende Langwort ist die
Adresse eines Dispatchers, der mit der Funktionsnummer in Register d0.w
aufgerufen wird. FÅr den Aufruf gelten die Pure C-Konventionen, d.h.
Register d0-d2/a0-a1 und der Stack werden zur ParameterÅbergabe benutzt,
d0-d2/a0-a1 kînnen verÑndert werden. Die Funktion 0 liefert die
EdDI-Versionsnummer im BCD-Format (z.B. 0x0110 fÅr Version 1.10).

Querverweis:
(!nl)
Off-Screen-Bitmaps ~  v_opnbm   ~    v_clsbm ~
Grundlagen des VDI ~  vq_scrninfo ~  GEM

# Version Datum
# 1.00    1991-02-27
# 2.01    1991-09-16
# 2.11    1992-09-17
# 2.50    1993-06-21  EdDI 1.00
# 3.01    1994-10-11  EdDI 1.00   FSMC 5.00
# 5.03    1999-08-30  EdDI 1.10   FSMC 5.00

!begin_node is_EdDI

(!B)(!nolink [Beispiel-Code]) fÅr Pure-C:(!b)

!begin_verbatim
GLOBAL BOOLEAN is_EdDI ()
{
    int16_t (*func)(int16_t);
    
    if (get_cookie ("EdDI", (LONG *) &func))
        return ((*func)(0));
        
    else return (FALSE);
    
} /* is_EdDI */
!end_verbatim
!end_node
!end_node



!begin_node Off-Screen-Bitmaps

FÅr viele Anwendungen ist es sehr nÅtzlich, wenn Zeichenfunktionen nicht 
direkt auf den Bildschirm, sondern auf einen nicht sichtbaren Bildschirm
angewendet werden kînnen. Einen derartigen "versteckten" Bildschirm nennt
man Off-Screen-Bitmap.

Zur Erzeugung von Off-Screen-Bitmaps dient die Funktion v_opnbm(). Man kann
ihr entweder die Grîûe eines Bitmap angeben, die Sie allozieren soll, oder
ihr eine Bitmap Åbergeben. Die Bitmap wird im gleichen Format wie die des
Bildschirms verwaltet, wodurch schnelles Kopieren zwischen beiden mîglich
ist. Die Funktion v_clsbm() schlieût eine mit (!nolink [v_opnbm])() erzeugte Bitmap und
gibt gegebenenfalls deren Speicher zurÅck.

Rasteroperationen zwischen Bildschirm und Off-Screen-Bitmap sollten
grundsÑtzlich im gerÑtespezifischen Format erfolgen. Wenn als Ziel einer
Rasteroperation eine Off-Screen-Bitmap mit ihrem MFDB angegeben wird und
wenn das zu dieser Bitmap gehîrende Handle benutzt wird, so wird beim
Blitten anhand der Åber vs_clip() auf dieser  Workstation eingestellten
Koordinaten geclippt. FÅr das Kopieren eines Rasters vom Bildschirm in eine
Off-Screen-Bitmap sollte man also das vdi_handle dieser Bitmap benutzen.

Ist die Bitmap dagegen Quelle und der Bildschirm Ziel, so sollte man das
Handle der Bildschirm-Workstation benutzen, da dann das Raster anhand der
Bildschirm-Koordinaten abgeclippt wird. Wenn man das von (!nolink [v_opnbm])()
zurÅckgelieferte Handle einer Bitmap benutzt und in (!I)fd_addr(!i) in einem
MFDB 0 enthÑlt, so werden die Daten der Bitmap statt dessen benutzt.

Querverweis: NVDI ~  (!link [GDOS][Das GDOS]) ~  Style-Guidelines
!end_node



!begin_node Das OUT-Dateiformat
!label OUTPUT-Format

Das OUT-Format wurde von (!I)Digital Research(!i) entwickelt und ermîglicht
wie das XIMG oder Metafile-Format den Datenaustausch zwischen beliebigen
GEM-Applikationen. Genauer gesagt kînnen hiermit Steuerzeichen fÅr
Textattribute in eine Datei mit dem Suffix ".out" geschrieben werden, die
dann vom Ausgabetreiber erkannt, und berÅcksichtigt werden.

Das OUT-Format ist somit besonders geeignet, um Textdateien mit Attributen
zwischen verschiedenen Applikationen auszutauschen. OUT-Dateien sind nicht
anderes als ASCII-Dateien, die zum Umschalten zwischen Textattributen den
Steuercode DC2 (ASCII-Wert 18) benutzen; anschlieûend folgt ein Buchstabe,
der das Ein- oder Ausschalten des Attriutes beschreibt:

(!B)Folgende Steuerzeichen sind definiert:(!b)

!begin_table [l l]
Code !! Bedeutung
!hline
DC2 0 !! Fettschrift ein         
DC2 1 !! Fettschrift aus
DC2 2 !! Kursiv ein
DC2 3 !! Kursiv aus
DC2 4 !! Unterstrichen ein
DC2 5 !! Unterstrichen aus
DC2 6 !! Superscript ein
DC2 7 !! Superscript aus
DC2 8 !! Subscript ein
DC2 9 !! Subscript aus
DC2 A !! BriefqualitÑt-Modus ein
DC2 B !! BriefqualitÑt-Modus aus
DC2 C !! Breitschrift ein
DC2 D !! Breitschrift aus
DC2 E !! helle Schrift ein
DC2 F !! helle Schrift aus
DC2 G !! ~     
  :   !! ~
  :   !! ~
DC2 V !! reserviert, wird ignoriert
DC2 W !! Pica-Schrift (10 cpi)
DC2 X !! Elite-Schrift (12 cpi)
DC2 Y !! komprimierter Druck
DC2 Z !! Proportionalschrift
!end_table

(!B)Hinweis:(!b) SelbstverstÑndlich kînnen auch Grafiken in die Ausgabedatei
mit eingebunden werden, die Syntax lautet in diesem Fall:

!begin_verbatim
(ESC)(ESC)GEM,x,y,w,h,C:\pathname\filename.img
!end_verbatim

Die Parameter x,y,w und h sind dabei in Zeicheneinheiten relativ zur
aktuellen Cursorposition anzugeben.

Querverweis:
GDOS-Treiber ~  v_alpha_text ~  (!link [XIMG-Format][Das XIMG-Format fÅr Pixelbilder])   Metafile-Format
!end_node



!begin_node Rasterformate

Bei der Arbeit mit Bildschirmen spielen die Rasterfunktionen eine besondere
Rolle; sie sind fÅr all das zustÑndig, was mit der Bewegung oder VerÑnderung
von Bildschirmausschnitten zu tun hat. Beispiel: Scrolling innerhalb eines
Dokumentes oder das Darstellen von Icons.

Die (!nolink [Rasterfunktionen]) kînnen ihre Aufgabe natÅrlich nur dann effizient
ausfÅhren, wenn als interne Darstellung das gleiche Format verwendet wird,
wie es auch im Bildspeicher benutzt wird; anderenfalls mÅûten die Daten bei
jedem einzelnen Aufruf einer Rasterfunktion konvertiert werden. NaturgemÑû
ist jedoch der interne Aufbau des Bildspeichers von der Hardware des
benutzten Grafiksystems abhÑngig - mal davon abgesehen, daû der Bildspeicher
gar nicht unbedingt direkt fÅr den Prozessor zugÑnglich sein muû.

Die Anzahl der pro Pixel benîtigten Bits hÑngt natÅrlich von der Anzahl der
gleichzeitig darstellbaren Farben ab; fÅr monochrome Pixel reicht 1 Bit, bei
16 Farben sind schon vier Bits notwendig. AbhÑngig von der verwendeten
Videohardware kînnen diese Bits natÅrlich vîllig verschieden angeordnet
sein; daher verwundert es nicht, daû fÅr diesen Zweck verschiedene Formate
zur VerfÅgung stehen:

!label Bildformat, pixelorientiertes
!label pixelorientiertes Bildformat
(!B)pixelorientiertes Format:(!b) In diesem Fall werden alle zu einem Pixel
gehîrenden Bits zusammen in ein oder mehrere Bytes kodiert. In einem System
mit 16 Farben wÅrden also jeweils zwei Pixel gemeinsam in einem Byte
abgespeichert; bei 256 Farben nimmt jeder Pixel ein Byte ein.

!label Bildformat, planeorientiertes
!label planeorientiertes Bildformat
(!B)planeorientiertes Format:(!b) In diesem Fall betrachtet man den
Bildspeicher als eine Sammlung monochromer (d.h. einfarbiger) Bildebenen
(Planes). Um zu einem Pixel die Farbe zu ermitteln, kombiniert man die
zustÑndigen Bits aus den einzelnen Ebenen zu einem Farbwert. Damit ist
natÅrlich noch nichts darÅber ausgesagt, wie die einzelnen Ebenen im
Bildspeicher angeordnet sind. Eine einfache (und im PC-Bereich durchaus
Åbliche) Lîsung ist es, eine Plane nach der anderen hintereinander im
Bildspeicher abzulegen.

Um nicht auf ein bestimmtes, Hardware-abhÑngiges Format angewiesen zu sein,
unterscheidet das VDI zwischen dem (!I)gerÑteabhÑngigen Format(!i) (welches
eben von der Hardware abhÑngt), und dem sogenannten Standardformat. Das
Standardformat ist fÅr alle (!nolink [VDI])-Systeme gleich, und kann daher immer dann
benutzt werden, wenn Rastergrafiken von auûen in das System eingebracht
werden sollen (Beispiel: Darstellung von Icons in einer Resource-Datei). Zur
Umwandlung zwischen beiden Formaten steht die Funktion vr_trnfm zur
VerfÅgung.

!label Standardformat des VDI
!label VDI, Standardformat des
!label GerÑteunabhÑngiges Format
!label Format, gerÑteunabhÑngiges
(!B)(!nolink [Das VDI])-Standardformat ist wie folgt definiert:(!b)

!begin_itemize
!item das Format ist planeorientiert. Jede Bildebene belegt ein
      zusammenhÑngendes StÅck Speicher, und besitzt die gleiche Anzahl von
      Bildpunkten.
!item das hîchste Bit eines 16-Bit Wortes steht fÅr den am weitesten links
      stehenden Pixel.
!item aufeinanderfolgende Worte im Bildspeicher bilden die einzelnen Zeilen.
      Das erste Wort einer solchen Zeile liegt am linken Bildrand; die erste
      Zeile der Plane kodiert die oberste Pixelzeile.
!end_itemize

Die folgende Abbildung zeigt ein Beispiel fÅr das gerÑteunabhÑngige
Standardformat mit 3 Farbebenen (Planes):

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image raster
!else
!image (!picture_path)\raster
!endif
!else
!image (!picture_path)\raster
!endif

(!B)Achtung:(!b) In den monochromen Grafikmodi von ST und TT entspricht das
gerÑteabhÑngige Format (!I)zufÑllig (!)(!i) dem gerÑteunabhÑngigen d.h. dem
Standardformat. Das heiût natÅrlich nicht, daû man deshalb auf den Einsatz
der Funktion vr_trnfm verzichten darf. Da man Åber das gerÑteabhÑngige
Format im Normalfall keine Informationen besitzt, verbietet sich schon aus
diesem Grund jede direkte Manipulation am Bildspeicher.

!label Color-Lookup-Table
!label Lookup-Table
Das VDI arbeitet prinzipiell Farbregister-orientiert (Color-Lookup-Table).
Es geht also davon aus, daû es eine Maximalzahl von gleichzeitig
darstellbaren Farben gibt, und daû man diesen Farbregistern bestimmte
(relativ frei wÑhlbare) Farbtîne zuordnen kann. Da diese Eigenschaft jedoch
keinesfalls selbstverstÑndlich ist, kann sie per vq_extnd erfragt werden. Im
folgenden zwei Beispiele fÅr Grafikmodi (!I)ohne(!i) Color-Lookup-Table:

!begin_itemize
!item Der TT-Grafikmodus 'TT-Hoch': es gibt nur zwei Farbregister und zwei
      Farbtîne (Schwarz und Weiû), die auch nicht vertauscht werden kînnen.
!item Bei True-Color Grafikkarten wie der Crazy-Dots-II kînnen 'beliebig'
      viele Farben gleichzeitig dargestellt werden. Normalerweise werden 24
      Bits pro Pixel benutzt, so daû etwa 16 Millionen Farben zur VerfÅgung
      stehen. Bei einer derartigen Anzahl von Farbnummern hat sich die Idee
      von Farbregistern erledigt: die Anzahl der prinzipiell gleichzeitig
      darstellbaren Farbtîne Åbersteigt die typische Zahl von Bildpunkten
      bei weitem.
!end_itemize

!label Pixelwert und VDI-Farbnummer
!label VDI-Farbnummer und Pixelwert
!label Farbnummer und Pixelwert, VDI-
(!B)Bleibt die Frage auf welche Weise die Pixelwerte im Bildspeicher mit den
VDI-Farbnummern zusammenhÑngen. Antwort:(!b)

!begin_xlist
!item [(a)]
aus historischen GrÅnden darf davon ausgegangen werden, daû bei einem Pixel
in (!nolink [VDI])-Farbe 0 (normal Weiû) alle Bits gelîscht, und bei schwarzen
Bildpunkten ((!nolink [VDI])-Farbe 1) alle Bits gesetzt sind. Dies ist schon deshalb
logisch, da durch ein vollstÑndiges Invertieren aller Bits der
Pixeldarstellung Weiû und Schwarz vertauscht werden mÅssen.
!item [(b)]
Mit Hilfe der Funktion v_get_pixel kann fÅr eine gegebene Bildkoordinate
sowohl die (!nolink [VDI])-Farbnummer, als auch der Pixelwert erfragt werden.
!end_xlist

(!B)DarÅber hinaus haben (!I)Atari(!i) und (!I)Digital Research(!i) fÅr 4,
8 und 16-Farbgrafikstufen die Standardzuordnungen dokumentiert:(!b)

!begin_itemize
!item bei vier Farben gilt

!begin_table [c c l l]
Pixelwert !! Farbindex !! Farbe !! Name
!hline
00 !! 0 !! weiû    !! WHITE
01 !! 2 !! rot     !! RED
10 !! 3 !! grÅn    !! GREEN
11 !! 1 !! schwarz !! BLACK
!end_table

!item bei acht Farben gilt

!begin_table [c c l l]
Pixelwert !! Farbindex !! Farbe !! Name
!hline
000 !! 0 !! weiû    !! WHITE
001 !! 2 !! rot     !! RED
010 !! 3 !! grÅn    !! GREEN
011 !! 6 !! gelb    !! YELLOW
100 !! 4 !! blau    !! BLUE
101 !! 7 !! magenta !! MAGENTA
110 !! 5 !! cyan    !! CYAN
111 !! 1 !! schwarz !! BLACK
!end_table

!item bei 16 Farben gilt

!begin_table [c c l l]
Pixelwert !! Farbindex !! Farbe !! Name
!hline
0000 !!  0 !! weiû          !! WHITE
0001 !!  2 !! rot           !! RED
0010 !!  3 !! grÅn          !! GREEN
0011 !!  6 !! gelb          !! YELLOW
0100 !!  4 !! blau          !! BLUE
0101 !!  7 !! magenta       !! MAGENTA
0110 !!  5 !! cyan          !! CYAN
0111 !!  8 !! hellgrau      !! LWHITE
1000 !!  9 !! dunkelgrau    !! LBLACK
1001 !! 10 !! dunkelrot     !! LRED
1010 !! 11 !! dunkelgrÅn    !! LGREEN
1011 !! 14 !! dunkelgelb    !! LYELLOW
1100 !! 12 !! dunkelblau    !! LBLUE
1101 !! 15 !! dunkelmagenta !! LMAGENTA
1110 !! 13 !! dunkelcyan    !! LCYAN
1111 !!  1 !! schwarz       !! BLACK
!end_table
!end_itemize

(!B)Hinweis:(!b) FÅr andere Farbtiefen existiert (!I)keine(!i) eindeutige
Zuordnung. Da es auch keine allgemeine Formel zur Umrechnung gibt, muss im
Bedarfsfall auf die Funktion v_get_pixel zurÅckgegriffen werden.

Querverweis:
Objektfarben des AES ~  Rasterfunktionen ~  vq_scrninfo
!end_node



!begin_node SpeedoGDOS
!label GDOS, Speedo-

SpeedoGDOS gehîrt zur jÅngsten Generation der GDOS-Familie, und liegt
aktuell in der Version 5.0c vor. Neben den Eigenschaften eines 'normalen'
GDOS bestechen vor allem die folgenden Mîglichkeiten:

!begin_itemize !compressed
!item UnterstÅtzung von VektorzeichensÑtzen der Formate:
!begin_itemize !compressed
!item Speedo
!item TrueType
!item Type1
!end_itemize
!item Mîglichkeiten fÅr Track/Pair-Kerning.
!end_itemize

Ob SpeedoGDOS installiert ist, lÑût sich am besten Åber den Cookie-Jar
abfragen. Das Programm legt in der Bootphase einen Cookie mit der Kennung
FSMC an.

Querverweis:
(!link [GDOS][Das GDOS]) ~  NVDI ~  Style-Guidelines


# Version Datum
# 4.11    1993-06-14
# 5.0a    1994-08-03
!end_node



!begin_node Details zu Vektorschriften

Bei Verwendung der Programme NVDI oder SpeedoGDOS stehen auch unter GEM
hochqualitative Vektorschriften (in den Formaten Speedo, TrueType, und
Type-1) zur VerfÅgung. Da bei der UnterstÅtzung dieser Schrifttechnologien
einige Feinheiten zu beachten sind, werden in diesem Abschnitt die folgenden
Punkte behandelt:

!begin_itemize !compressed
!item équidistante Fonts
!item Font-ID und Index 
!item Grîûe von Vektorfonts
!item Hîhe und Breite von Vektorfonts
!item Kerning
!item Positionierung von Vektortext
!item (!link [Unterscheidung von Vektor- und Bitmap-Font][Vektor- oder Bitmap-Font?])
!end_itemize

Querverweis:
vst_load_fonts ~  vst_unload_fonts



!begin_node équidistante Fonts

FÅr manche Applikationen ist es sinnvoll, bei der Ausgabe nur Ñquidistante
(d.h. monospaced) Fonts zu benutzen. In diesem Fall sollte man wie folgt
vorgehen:

!begin_itemize
!item wenn vqt_name in erweiterter Form (35 EintrÑge in intout) vorhanden
      ist, sollte einfach das entsprechende Bit in (!nolink [intout])[34] abgetestet
      werden.
!item wenn (!nolink [vqt_name]) nur die Information bietet, daû es sich um einen
      Vektorfont handelt (34 EintrÑge in intout, (!nolink [intout[33!]]) != 0), sollte
      fÅr Vektorfonts vqt_fontheader aufgerufen, und Bit 1 von FH_CLFGS
      geprÅft werden.
!item wenn es sich nicht um einen Vektorfont handelt und die ersten beiden
      Punkte nicht zutreffen, mÅssen die Zeichenbreiten einzeln mit
      vqt_width erfragt und miteinander verglichen werden.
!end_itemize

(!B)Hinweis:(!b) Wer Ñquidistante Vektorfonts mit v_ftext ausgibt, darf als
Breite (!I)nicht(!i) mit den Ausgaben von vst_height oder (!nolink [vqt_width]) rechnen,
sondern muû sie bei vqt_advance erfragen, da bei (!nolink [v_ftext]) immer mit Breiten
in 1/65536 Pixeln positioniert wird. Bei Ausgabe Åber v_gtext sind die
RÅckgaben von (!nolink [vqt_width]) zutreffend.

Querverweis:
(!link [Vektorfonts][Details zu Vektorschriften]) ~
VDI ~ (!link [GDOS][Das GDOS])  ~ Style-Guidelines ~ fix31
!end_node



!begin_node Font-ID und Index
!label Zeichensatzes, Index eines

(!B)Der Index eines Fonts(!b) ist eine Zahl zwischen 1 und der verfÅgbaren
Fontanzahl. Je nach Anzahl der auf dem jeweiligen Rechner installierten
Fonts hat ein Font wie z.B. (!I)Swiss 721(!i) einen unterschiedlichen Index.

!label Zeichensatzes, Font-ID eines
(!B)Die Font-ID(!b) ist dagegen eine Kennung, die grundsÑtzlich fÅr einen
Font unabhÑngig vom System immer gleich ist - fÅr (!I)Swiss 721(!i) z.B.
5003. Ausnahmen von dieser Regel sind aber bei Fonts mîglich, die keine
verwendbare Font-ID haben. In diesem Fall wird versucht, eine eindeutige ID
zu erzeugen. Da es aber mîglich ist, daû eine derart erzeugte ID fÅr einen
Font nicht auf allen Systemen identisch ist, sollten Programme fÅr eine
eindeutige Zuordnung des Fonts auûer der ID (!I)auch den Namen(!i)
abspeichern.

Querverweis:
(!link [Vektorfonts][Details zu Vektorschriften]) ~  VDI ~
(!link [GDOS][Das GDOS]) ~ Style-Guidelines
!end_node



!begin_node Grîûe von Vektorfonts

Die meisten Bildschirmtreiber liefern eine Auflîsung von ˜ 91 dpi zurÅck,
nach der sich auch die Grîûe der Vektorfonts richtet. Da nicht bei jedem
Schirm 91 dpi vorhanden sind, sollten Programme bei Textdarstellung auf dem
Bildschirm (!I)nicht(!i) fest mit diesem Wert rechnen, sondern die Ausgaben
von (!B)v_opnwk(!b), (!B)v_opnvwk(!b), (!B)vq_extnd(!b) und (!B)v_opnbm(!b)
beachten.

Andernfalls kînnen bei abweichenden Pixelgrîûen Darstellungsfehler
auftreten. Beim Ausdruck sollten die genaueren Pixelgrîûen bei
(!B)(!nolink [vq_extnd])(!b) beachtet werden, damit die Textpositionierung mîglichst
genau ist.
!end_node



!begin_node Hîhe und Breite von Vektorfonts

Die Hîhe und Breite eines Vektorfonts kann mit den Funktionen
(!B)vst_arbpt32(!b) und (!B)vst_setsize32(!b) in 1/65536 pt eingestellt werden
(1pt ˜ 1/72 Zoll ˜ 353 Êm).

Bei negativer Hîhe oder Breite wird der Text an der jeweiligen Achse
gespiegelt.
!end_node



!begin_node Kerning

Kerning ist ein Verfahren um AbstÑnde zwischen Zeichen zu manipulieren, und
damit ein einheitlicheres (besseres) Schriftbild zu erlangen. Man kann zwei
Varianten des Kernings unterscheiden:

!label Track-Kerning
!label Kerning, Track-
!begin_itemize
!item (!B)Track-Kerning:(!b) Diese Methode benutzt einen (!I)konstanten
      Offset(!i) fÅr alle Zeichen eines Zeichensatzes. ZeichensÑtze die
      Track-Kerning unterstÅtzen enthalten i.d.R. verschiedene Offsets um
      beispielsweise zwischen normalem, engen und sehr engen Kerning
      auswÑhlen zu kînnen.
!label Pair-Kerning
!label Kerning, Pair-
!item (!B)Pair-Kerning:(!b) Beruht auf der Erkenntnis, daû (!I)ein(!i)
      Offset nicht fÅr alle Zeichen eines Zeichensatzes sinnvoll ist; in
      vielen FÑllen lÑût sich nÑmlich ein wesentlich besseres Schriftbild
      erreichen, wenn der Abstand (!I)fÅr ein Paar von Zeichen
      individuell(!i) festgelegt werden kann. ZeichensÑtze die Pair-Kerning
      unterstÅtzen enthalten daher eine Tabelle, in der fÅr jede Kombination
      (genauer: fÅr die wichtigsten) von zwei Zeichen der fÅr sie optimale
      Offset vermerkt ist.
!end_itemize

(!B)Hinweis:(!b) Sowohl Track-, als auch Pair-Kerning sind nach dem ôffnen
einer Workstation ausgeschaltet. Um eine bessere Textdarstellung zu
erhalten, sollte daher das Pair-Kerning per vst_kern eingeschaltet werden.

Querverweis:
vst_kern ~ vqt_pairkern ~ vqt_trackkern ~ vst_track_offset
!end_node



!begin_node Positionierung von Vektortext

Bei der Ausgabe von Vektorfonts wird innerhalb des VDI mit Schrittweiten
von 1/65536 Pixel Auflîsung gerechnet, um unabhÑngig vom verwendeten
AusgabegerÑt und dessen tatsÑchlicher Auflîsung eine gleichbleibende
Zeichenpositionierung zu gewÑhrleisten.

Um die Bitmaps fÅr die einzelnen Zeichen auszugeben, werden diese
Festkommawerte in Pixel umgerechnet, indem 32768 hinzuaddiert und
anschlieûend durch 65536 geteilt wird.

!begin_itemize
!item wenn das Track-Kerning eingeschaltet ist, wird zu jeder
      Zeichenposition der bei vqt_trackkern zu erfragende Offset addiert.
!item bei eingeschaltetem Pair-Kerning wird zu jeder Zeichenposition der von
      vqt_pairkern zurÅckgelieferte Offset addiert.
!end_itemize

(!B)Achtung:(!b) Pair- und Track-Kerning und die Positionierung in 1/65536
Pixeln werden nur eingesetzt, wenn v_ftext aufgerufen wird! Bei v_gtext
verhalten sich Vektorfonts weitgehend wie Bitmap-Fonts und weder Kerning
noch genaue Positionierung werden benutzt.

Querverweis:
Pair-Kerning ~ Track-Kerning ~ (!link [fix31-Format][fix31])
!end_node



!begin_node Vektor- oder Bitmap-Font?

Wenn es sich bei einem eingestellten Font um einen Vektorfont handelt,
liefert (!B)vqt_name(!b) 34 EintrÑge in intout zurÅck und intout[33] enthÑlt
einen Wert ungleich Null.

Ist hingegen (!nolink [intout])[33] gleich Null (oder werden nur 33 EintrÑge
zurÅckgeliefert), so handelt es sich um Bitmap-Font.
!end_node
!end_node



!begin_node Workstations des VDI

Eine (!I)Workstation(!i) ist ein allgemeiner Begriff fÅr ein Ein- oder
AusgabegerÑt; dies kînnen Bildschirme, Drucker, Plotter, Kameras,
Grafiktabletts und viele andere GerÑte sein.

Um auf ein bestimmtes VDI-GerÑt zugreifen zu kînnen, muû daher zunÑchst die
Workstation (!I)geîffnet(!i) werden. Je nach Sachlage erhÑlt man als
Resultat entweder eine Fehlermeldung oder die Workstation-Kennung (Handle)
des betreffenden GerÑtes.

Zu jeder Workstation gehîrt eine Menge von (!I)Merkmalen(!i), die
unverÑnderlich sind und Åber die FÑhigkeiten des GerÑtes Auskunft geben.
Dazu gehîren u.a. GerÑtetyp, Koordinatensystem und FarbfÑhigkeit. Neben den
beim ôffnen der Workstation zurÅckgelieferten Daten ist es Åber eine
erweiterte Auskunftsfunktion mîglich, noch mehr Daten Åber ein GerÑt zu
ermitteln. Dies erlaubt es einem Anwendungsprogramm, die FÑhigkeiten des
GerÑtes optimal auszunutzen (z.B. dadurch, daû sie ihren Bildschirmaufbau an
die Anzahl der darstellbaren Bildschirmpunkte anpassen).

Neben den unverÑnderlichen besitzt eine Workstation auch noch verÑnderliche
Merkmale; man spricht in diesem Zusammenhang von (!I)Attributen(!i). Sie
beschreiben den (!I)aktuellen Zustand(!i) des GerÑtes. Ein gutes Beispiel
ist die Linienfarbe, die man nur ein einziges mal (und nicht etwa bei jedem
einzelnen Aufruf von Zeichenfunktionen) setzen muû. Die aktuellen Attribute
werden vom (!nolink [VDI]) in internen Strukturen fÅr jede einzelne Workstation getrennt
gespeichert; so kann eine Applikation beispielsweise fÅr den Bildschirm und
den Drucker unbesorgt verschiedene Linienfarben einstellen. (!nolink [Das VDI])
erkennt am Workstation-Handle, welches AusgabegerÑt gemeint ist.

(!B)Die folgende Tabelle nennt einige Attribute mit ihren
Standardwerten:(!b)

!begin_table [l l l]
Attribut !! Standardwert !! einzustellen per
!hline
Basislinienwinkel  !! 0 Grad                 !! vst_rotation
Clipping           !! ausgeschaltet          !! vs_clip
Cursor             !! versteckt              !! v_show_c, v_hide_c
Eingabemodus       !! Request                !! vsin_mode
FÅllmuster, frei   !! Logo des Herstellers   !! vsf_udpat
Kerning            !! ausgeschaltet          !! vst_kern
Linienenden        !! rechteckig             !! vsl_ends
Linienmuster, frei !! durchgehend            !! vsl_udsty
LinienstÑrke       !! nominelle LinienstÑrke !! vst_width
Markergrîûe        !! nominelle Markergrîûe  !! vsm_height
Schreibmodus       !! Replace                !! vswr_mode
Textausrichtung    !! links, Basislinie      !! vst_alignment
Texteffekt         !! normal                 !! vst_effects
Umrahmung          !! sichtbar               !! vsf_perimeter
Zeichenhîhe        !! nominelle Zeichenhîhe  !! vst_height
!end_table

!label Workstations, virtuelle
!label virtuelle Workstations
Eine Sonderstellung nimmt dabei der Bildschirm ein, da dieser fÅr mehrere
Prozesse gleichzeitig zur VerfÅgung stehen muû. Aus diesem Grund bietet das
VDI sogenannte virtuelle Workstations an, die immer nur im Zusammenhang mit
einer bereits geîffneten (!I)physikalischen(!i) Bildschirm-Workstation
benutzt werden kînnen. Jede virtuelle Workstation verfÅgt natÅrlich Åber
einen eigenen Satz von Attributen, damit sich die Progamme bei der
Bildschirmausgabe nicht gegenseitig in die Quere kommen.

(!B)Achtung:(!b) Nicht alle Eigenschaften der physikalischen
Bildschirm-Workstation sind auf die virtuellen Workstations Åbertragbar.
Tastatur und Maus kînnen auch weiterhin immer nur von einem Programm
gleichzeitig benutzt werden. Die Eingabefunktionen dÅrfen daher (!I)nur(!i)
von dem Programm benutzt werden, welches die physikalische
Bildschirm-Workstation geîffnet hat (dies sind im Normalfall die AES).

Ein letzter Hinweis: Da die Verwaltung der Workstation-Attribute
Speicherplatz erfordert, der i.d.R. dynamisch angefordert wird, sollte man
nie davon ausgehen, daû das ôffnen einer Workstation immer klappen muû!

Querverweis:
GDOS-Treiber ~  v_opnwk ~  v_opnvwk ~  vq_extnd
!end_node



!begin_node Das XIMG-Format fÅr Pixelbilder

Pixelbilder werden unter GEM in einem Standardformat, dem sogenannten
Bit-Image (bzw. XIMG) Format abgelegt. Grafiken dieses Typs werden dabei
komprimiert gespeichert, und besitzen immer das Suffix (!I)'.IMG'(!i).

Der Hauptvorteil dieses Formats liegt in der Tatsache begrÅndet, daû es sich
um ein (!nolink [GEM])-(!I)Standardformat(!i) handelt, welches daher von nahezu allen
Applikationen unterstÅtzt wird. Eine Bit-Image-Datei besteht aus einem
Header, sowie den reinen Pixeldaten. Der Header ist dabei in C-Notation wie
folgt definiert:

!label XIMG-Header
!begin_verbatim
typedef struct
{
  int16_t version;           /* Versionsnummer (meist 1)                 */
  int16_t headlen;           /* LÑnge des Kopfes in 16-Bit Worten        */
  int16_t planes;            /* Anzahl der Farbebenen der Grafik         */
  int16_t pat_run;           /* MusterlÑnge in Bytes                     */
  int16_t pix_width;         /* Pixelbreite des QuellgerÑtes in 1/1000mm */
  int16_t pix_height;        /* Pixelhîhe des QuellgerÑtes in 1/1000mm   */
  int16_t sl_width;          /* Breite einer Scan-Zeile in Pixeln        */
  int16_t sl_height;         /* Hîhe einer Scan-Zeile in Pixeln          */
  int8_t  x_id[4];           /* muss 'XIMG' sein                         */
  int16_t color_model;       /* Farbmodell: 0=RGB, 1=CYM, 2=Pantone      */
  RGB_LIST color_table[]; /* Farbtabelle */
} XIMG;
!end_verbatim

Der gesamte Header liegt dabei im (!B)Motorola-68000-Format(!b) vor, so daû
er auf einem Rechnern mit Intel-CPU wort- bzw. langwortweise gedreht werden
muss. Die reinen Pixeldaten beginnen immer bei (!I)headlen * 2(!i) und sind
(wie bereits erwÑhnt) komprimiert abgelegt.

Die LÑnge der Muster liegt zwischen 1 und 8, und betrÑgt bei den meisten
Bildschirmen 2 Bytes. Jede Scan-Zeilen-Information setzt sich aus zwei
Komponenten zusammen:

!begin_itemize
!item einem Wiederholungsteil folgender Struktur (in C-Notation):

!begin_verbatim
typedef struct
{
  int16_t sc_zero;    /* immer Null */
  int8_t  sc_ff;      /* immer 255  */
  int8_t  sc_cnt;     /* Anzahl der codierten Bildzeilen */
} SCANLINE;
!end_verbatim

!item der eigentlichen Bildinformation. Diese wird in drei verschiedenen
      Kategorien zeilenweise abgespeichert.

!begin_xlist
!label Solid-Runs
!item [(a)]
(!B)einfarbige Pixelfolgen (Solid-Runs)(!b) werden als einfaches Byte
gespeichert, wobei das oberste Bit den Status des Punktes bestimmt (also
'an' oder 'aus'). Die restlichen sieben Bits teilen mit, wie viele Bytes
ausgegeben werden mÅssen.
!label Pattern-Runs
!item [(b)]
(!B)Musterfolgen (Pattern-Runs)(!b) haben als erstes Byte die 0, und als
zweites die Anzahl der Musterwiederholungen. Die MusterlÑnge steht im Header
unter (!I)pat_run(!i). Es folgen den ersten beiden Bytes also genau so viele
Bytes, wie benîtigt werden, um das Muster darzustellen.
!begin_verbatim
typedef struct
{                        
  int8_t pr_zero;        /* immer Null       */
  int8_t pr_cnt;         /* Anzahl der Bytes */
  int8_t pr_data[...];   /* Musterdaten      */
} PATTERNRUN;
!end_verbatim
!label Bit-Strings
!item [c)]
(!B)Schlecht, oder nicht verkÅrzbare Bildinformation (Bit-Strings)(!b) wird
unverÑndert abgespeichert. Hier steht als erstes Byte eine 0x80 und als
zweites die Anzahl der Bytes. Danach folgen dann die entsprechenden Bytes
mit der unkomprimierten Bildinformation.
!begin_verbatim
typedef struct
{
  int8_t bs_first;       /* immer 0x80       */
  int8_t bs_cnt;         /* Anzahl der Bytes */
  int8_t bs_data[...];   /* Bilddaten        */
} BITSTRING;
!end_verbatim
!end_xlist
!end_itemize

Es folgen jeweils die Bildinformationen fÅr jede codierte Farbebene direkt
hintereinander. Man sollte auch darauf achten, daû immer eine Zeile mit
voller Bytezahl codiert wird, auch wenn das Bild effektiv schmaler ist. Es
kînnen also bis zu sieben Bits ÅberflÅssiger Information vorliegen. Die
Pixelbreite des Bildes steht im Header unter (!I)sl_width(!i).

Querverweis:
Metafile-Format ~  v_bit_image ~
(!link [OUT-Dateiformat][Das OUT-Dateiformat])
!end_node
!end_node



!begin_node VDI-Bindings
!label Bindings des VDI

(!nolink [Das VDI]) wird Åber ein einziges Unterprogramm aufgerufen, dem 5 Parameter
Åbergeben werden; es handelt sich dabei um (!nolink [Adressen]) verschiedener Arrays,
die zur Ein-/Ausgabe-Kommunikation benutzt werden. Um eine VDI-Funktion
aufzurufen, muû der folgende Parameterblock mit den (!nolink [Adressen]) der unten
beschriebenen Arrays bestÅckt werden:

!label VDI-Parameterblock
!label Parameterblock des VDI
!begin_verbatim
typedef struct
{
   int16_t  *contrl;    /* Zeiger auf contrl-Array */
   int16_t  *intin;     /* Zeiger auf intin-Array  */
   int16_t  *ptsin;     /* Zeiger auf ptsin-Array  */
   int16_t  *intout;    /* Zeiger auf intout-Array */
   int16_t  *ptsout;    /* Zeiger auf ptsout-Array */
} VDIPB;
!end_verbatim

Die Adresse dieses Parameterblocks muû dann im Register d1 vermerkt, und
zusÑtzlich Register d0.w mit dem Wert 0x73 (115) gefÅllt werden. Durch
einen TRAP#2 Systemaufruf kann dann das (!nolink [VDI]) direkt aufgerufen werden. FÅr
den (!B)(!I)Pure-Assembler(!i)(!b) kînnte das z.B. so aussehen:

!begin_verbatim
        .EXPORT vdi         ; Funktion exportieren

        .IMPORT contrl      ; contrl-Feld importieren
        .IMPORT intin       ; intin-Feld  importieren
        .IMPORT ptsin       ; ptsin-Feld  importieren
        .IMPORT intout      ; intout-Feld importieren
        .IMPORT ptsout      ; ptsout-Feld importieren

        .DATA               ; Beginn des Daten-Segments

pblock: .DC.L contrl        ; Adresse des contrl-Arrays
        .DC.L intin         ; Adresse des intin-Arrays
        .DC.L ptsin         ; Adresse des ptsin-Arrays
        .DC.L intout        ; Adresse des intout-Arrays
        .DC.L ptsout        ; Adresse des ptsout-Arrays

        .CODE               ; Beginn des Code-Segments
!end_verbatim
!label vdi
!begin_verbatim
vdi:     MOVE.L #pblock,D1  ; Adresse des Parameterblocks
         MOVE.W #$73,D0     ; Opcode des VDI
         TRAP   #2          ; GEM aufrufen
         RTS                ; raus hier

       .END                 ; Ende des Moduls
!end_verbatim

DarÅber, welche Register verÑndert werden dÅrfen, gibt es keine klaren
Informationen. Tatsache ist jedoch, daû die entsprechenden Routinen im
ROM (!I)alle(!i) Register retten.

Im Gegensatz zum GEMDOS kennt das VDI leider keinen dokumentierten
RÅckgabewert fÅr 'unbekannte Funktionsnummer'. Daher muss man sich im
Zweifelsfall wie folgt behelfen:

!begin_itemize
!item Viele Eigenschaften eines Treibers kînnen bereits Åber die Funktion
      vq_extnd ermittelt werden.
!item Ansonsten sollte man den entsprechenden (!nolink [VDI])-Aufruf einfach
      ausprobieren, und die RÅckgabewerte analysieren. Viele Funktionen
      liefern nÑmlich als Resultat den eingestellten Wert zurÅck. DarÅber
      hinaus kann man auch noch die Felder contrl[2] und contrl[4] (s.u.)
      untersuchen, und kontrollieren, ob sie die korrekten Zahlen enthalten.
!end_itemize

Nun zu den einzelnen Arrays. öber jedes Feld kînnen bestimmte Ein- bzw.
Ausgaben getÑtigt werden; es gilt:

!begin_blist

!label contrl
!item [int16_t contrl[12!]]
öber dieses Feld werden die Funktionsnummer, die Anzahl der Eingaben, die
Kennung der Workstation sowie funktionsabhÑngige Parameter Åbergeben.
Eingaben an das VDI werden dabei wie folgt eingetragen:
!begin_xlist !compressed [contrl-7..n- =]
!item [contrl[0!] =]
Funktionsnummer
!item [contrl[1!] =]
Anzahl der Werte im ptsin-Array
!item [contrl[3!] =]
Anzahl der Werte im intin-Array
!item [contrl[5!] =]
Unterfunktionsnummer
!item [contrl[6!] =]
Kennung der Workstation
!item [contrl[7..n!] =]
abhÑngig von der Funktion
!end_xlist
Ausgaben des (!nolink [VDI]) werden Åber die folgenden Felder gemacht:
!begin_xlist !compressed
!item [contrl[2!] =]
Anzahl der Werte im ptsout-Array
!item [contrl[4!] =]
Anzahl der Werte im intout-Array
!item [contrl[6!] =]
Kennung der Workstation
!end_xlist
                      
!label ptsin
!item [int16_t ptsin[1024!]]
~
!label ptsout
!item [int16_t ptsout[256!]]
Diese beiden Felder werden benutzt, um Paare von Koordinaten oder Maûe in
Pixeln (wie z.B. die Breite einer Linie, oder die Hîhe eines Zeichens) zu
Åbergeben. Die Grîûe dieser Felder hÑngt von der aufgerufenen Funktion ab.

!label intin
!item [int16_t intin[1024!]]
~
!label intout
!item [int16_t intout[512!]]
Diese Felder werden benîtigt, um Werte wie den Index eines Zeichens oder
einer Farbe zu Åbergeben. Die Grîûe dieser Felder hÑngt von der aufgerufenen
Funktion ab.

!end_blist

(!B)Bei der öbergabe von Strings an das (!nolink [VDI]) sind einige Besonderheiten zu
beachten:(!b) Diese werden grundsÑtzlich Åber die Felder intin und intout
Åbergeben, wobei pro Zeichen ein Wort benutzt wird. Das hat den Vorteil, daû
auch andere Codierungen als ASCII genutzt, und mehr als 256 Zeichen eines
Zeichensatzes verwendet werden kînnen.

Die Bindings arbeiten i.d.R. mit normalen C-Strings, und wandeln sie fÅr
das (!nolink [VDI]) um. Dabei wird die LÑnge des Strings in contrl[3] bzw. contrl[4]
vermerkt, wobei kein abschlieûendes Null-Byte oder -wort vorhanden ist. Um
z.B. eine in intout liegende Zeichenkette in einen C-String zu verwandeln,
mÅssen contrl[4] Elemente kopiert (dabei die oberen 8 Bit abschneiden !) und
anschlieûend ein Null-Byte angehÑngt werden.

(!B)Achtung:(!b) Wenn das Betriebssystem Threads unterstÅtzt, muss unbedingt
darauf geachtet werden, eine Multithread-sichere Bibliothek zu verwenden.

Querverweis:
(!link [C-String nach VDI-String][Wandel C-String nach VDI-String]) ~
(!link [VDI-String nach C-String][Wandel VDI-String nach C-String]) ~
AES-Bindings



!begin_node Wandel VDI-String nach C-String

!begin_verbatim
VOID vdi_str_to_c( UWORD *src, UBYTE *des, int16_t len )
{
   while ( len > 0 )
   {
      *des++ = (UBYTE)*src++;  /* nur Low-Byte kopieren */
      len--;
   }
   *des++ = 0;  /* Ende des Strings */
}
!end_verbatim
!end_node



!begin_node Wandel C-String nach VDI-String

!begin_verbatim
int16_t c_str_to_vdi( UBYTE *src, UWORD *des )
{
   int16_t  len;

   while (( *des++ = *src++ ) != 0 )
      len++;
   return (len); /* StringlÑnge ohne Null-Byte */
}
!end_verbatim
!end_node
!end_node

!endif

!include gem\vdi\attribut\attribut.u
!include gem\vdi\output\output.u
!include gem\vdi\inquire\inquire.u
!include gem\vdi\input\input.u
!include gem\vdi\escape\escape.u
!include gem\vdi\colortable\colortable.u
!include gem\vdi\control\control.u
!include gem\vdi\raster\raster.u

!include gem\vdi\vdi_f.u

!include gem\vdi\structures\structures.u
