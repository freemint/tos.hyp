## Hypertext zum TOS-Betriebssystem
## entwickelt fr den ST-Guide
##
## Last Edit: 08.11.1997
##
## Kapitel 5: VDI-Eingabefunktionen



!begin_node v_hide_c

(!begin_liste) [Beschreibung]

!item [Name:]
¯Hide Cursor® - schaltet den Grafikcursor aus.

!item [VDI-Nummer:]
123

!item [Deklaration:]
void v_hide_c ( int16_t handle );

!item [Beschreibung:]
Die Funktion schaltet den Grafikcursor auf dem Ger„t mit der Kennung
(!I)handle(!i) aus.

Zum  Ein-/Ausschalten der Maus sollte in GEM-Programmen unbedingt die
AES-Funktion graf_mouse verwendet werden.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den (!nolink [AES]) benutzt
wird. Deshalb sollte man besser auf (!nolink [graf_mouse]) zurckgreifen.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all screen drivers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr v_hide_c])  ~ v_show_c

(!ende_liste)
!end_node



!begin_node Bindings fr v_hide_c
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void v_hide_c ( int16_t handle );

!item [Implementierung:]
!begin_verbatim
void v_hide_c (int16_t handle)
{
   contrl[0] = 123;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;

   vdi ();
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 123   Opcode der Funktion
contrl+2  !! contrl[1] !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4] !! 0     # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
!end_table

(!ende_liste)
!end_node


!begin_node v_show_c

(!begin_liste) [Beschreibung]

!item [Name:]
¯Show Cursor® - schaltet den Grafikcursor ein.

!item [VDI-Nummer:]
122

!item [Deklaration:]
void v_show_c ( int16_t handle, int16_t reset );

!item [Beschreibung:]
Die Funktion zeigt den Grafikcursor, bzw. storniert einen Aufruf der
Funktion v_hide_c. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [reset]
Flag
!begin_xlist !short [<>0 =]
!item [0 =]
Anzahl der Hide-Cursor-Aufrufe ignorieren
!item [<>0 =]
normale Anwendung, d.h. ein Hide-Cursor-Aufruf wird storniert
!end_xlist
!end_xlist

Zum  Ein-/Ausschalten der Maus sollte in GEM Programmen unbedingt die
AES-Funktion graf_mouse verwendet werden.

(!B)Hinweis:(!b) Die Eingabefunktionen des (!nolink [VDI]) arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den (!nolink [AES]) benutzt
wird. Deshalb sollte man besser auf (!nolink [graf_mouse]) zurckgreifen.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all screen drivers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr v_show_c]) ~  v_hide_c ~  graf_mouse

(!ende_liste)
!end_node



!begin_node Bindings fr v_show_c
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void v_show_c ( int16_t handle, int16_t reset );

!item [Implementierung:]
!begin_verbatim
void v_show_c (int16_t handle, int16_t reset)
{
   intin[0] = reset;

   contrl[0] = 122;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[6] = handle;

   vdi ();
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 122   Opcode der Funktion
contrl+2  !! contrl[1] !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 1     # Eintr„ge in intin
contrl+8  !! contrl[4] !! 0     # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
intin     !! intin[0]  !! reset
!end_table

(!ende_liste)
!end_node



!begin_node vex_butv

(!begin_liste) [Beschreibung]

!item [Name:]
¯Exchange Button Change Vector® - stellt den Interruptvektor fr einen
Maustastendruck um.

!item [VDI-Nummer:]
125

!item [Deklaration:]
void vex_butv ( int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)() );

!item [Beschreibung:]
Die Funktion erlaubt es, eine eigene Routine in den Maustasten-Vektor zu
h„ngen. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [pusrcode]
Adresse der neuen Routine
!item [psavcode]
Adresse der alten Routine
!end_xlist

Die neue Routine mu alle ver„nderten Register wiederherstellen und die alte
Maustasten-Status Routine aufrufen.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all screen drivers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vex_butv])  ~ vex_timv ~  vex_motv ~  vex_curv

(!ende_liste)
!end_node



!begin_node Bindings fr vex_butv
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vex_butv ( int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)() );

!item [Implementierung:]
!begin_verbatim
void vex_butv (int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)())
{
   contrl[0] = 125;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;
   contrl[7..8] = pusrcode;

   vdi ();

   *psavcode = contrl[9..10];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 125   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2]    !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3]    !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4]    !! 0     # Eintr„ge in intout
contrl+12 !! contrl[6]    !! handle
contrl+14 !! contrl[7,8]  !! pusrcode
contrl+18 !! contrl[9,10] !! psavcode
!end_table

(!ende_liste)
!end_node



!begin_node vex_curv

(!begin_liste) [Beschreibung]

!item [Name:]
¯Exchange Cursor Change Vector® - stellt den Interruptvector fr
Cursorbewegungen um.

!item [VDI-Nummer:]
127

!item [Deklaration:]
void vex_curv ( int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)() );

!item [Beschreibung:]
Die Funktion erlaubt es, eine eigene Routine in den Cursor-Change-Vektor zu
h„ngen. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [pusrcode]
Adresse der neuen Routine
!item [psavcode]
Adresse der alten Routine
!end_xlist

Der Aufruf dieser Routine erfolgt, nachdem die ber vex_motv eingetragene
Routine aufgerufen und die Mauszeiger-Koordinaten, die man in d0.w und d1.w
erh„lt, geclippt wurden. Alle ver„nderten Register mssen wiederhergestellt
werden. Anschlieend sollte die alte Routine aufgerufen werden.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all screen drivers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vex_curv]) ~  vex_timv ~  vex_butv  ~ vex_motv

(!ende_liste)
!end_node



!begin_node Bindings fr vex_curv
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vex_curv ( int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)() );

!item [Implementierung:]
!begin_verbatim
void vex_curv (int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)())
{
   contrl[0] = 127;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;
   contrl[7..8] = pusrcode;

   vdi ();

   *psavcode = contrl[9..10];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]     !! 127   Opcode der Funktion
contrl+2  !! contrl[1]     !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2]     !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3]     !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4]     !! 0     # Eintr„ge in intout
contrl+12 !! contrl[6]     !! handle
contrl+14 !! contrl[7..8]  !! pusrcode
contrl+18 !! contrl[9..10] !! psavcode
!end_table

(!ende_liste)
!end_node



!begin_node vex_motv

(!begin_liste) [Beschreibung]

!item [Name:]
¯Exchange Mouse Movement Vector® - stellt den Interruptvektor fr
Mausbewegungen um.

!item [VDI-Nummer:]
126

!item [Deklaration:]
void vex_motv ( int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)() );

!item [Beschreibung:]
Die Funktion erlaubt es, eine eigene Routine in den Maus-Movement-Vektor zu
h„ngen. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [pusrcode]
Adresse der neuen Routine
!item [psavcode]
Adresse der alten Routine
!end_xlist

Die neue Routine mu alle ver„nderten Register wiederherstellen und die alte
Maus-Movement Routine aufrufen.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all screen drivers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vex_motv]) ~  vex_timv ~  vex_butv ~  vex_curv

(!ende_liste)
!end_node



!begin_node Bindings fr vex_motv
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vex_motv ( int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)() );

!item [Implementierung:]
!begin_verbatim
void vex_motv (int16_t handle, int16_t (*pusrcode)(), int16_t (**psavcode)())
{
   contrl[0] = 126;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;
   contrl[7..8] = pusrcode;

   vdi ();

   *psavcode = contrl[9..10];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]     !! 126   Opcode der Funktion
contrl+2  !! contrl[1]     !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2]     !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3]     !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4]     !! 0     # Eintr„ge in intout
contrl+12 !! contrl[6]     !! handle
contrl+14 !! contrl[7..8]  !! pusrcode
contrl+18 !! contrl[9..10] !! psavcode
!end_table

(!ende_liste)
!end_node



!begin_node vex_timv

(!begin_liste) [Beschreibung]

!item [Name:]
¯Exchange Timer Interrupt Vector® - stellt den Interruptvektor fr den
Zeitgeber um.

!item [VDI-Nummer:]
118

!item [Deklaration:]
void vex_timv ( int16_t handle, int16_t (*tim_addr)(),
                int16_t (**otim_addr)(), int16_t *tim_conv );

!item [Beschreibung:]
Die Funktion erm”glicht es, eine eigene Routine in den Timer-Interrupt zu
h„ngen. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [tim_addr]
Adresse der neuen Routine
!item [otim_addr]
Adresse der alten Routine
!item [tim_conv]
Intervall des Interrupts (msec).
!end_xlist

Die neue Routine mu an ihrem Ende alle ver„nderten Register restaurieren
und die alte Timerinterrupt-Routine anspringen.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all screen drivers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vex_timv]) ~  vex_butv ~  vex_motv ~  vex_curv

(!ende_liste)
!end_node



!begin_node Bindings fr vex_timv
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vex_timv ( int16_t handle, int16_t (*tim_addr)(),
                int16_t (**otim_addr)(), int16_t *tim_conv );

!item [Implementierung:]
!begin_verbatim
void vex_timv (int16_t handle, int16_t (*tim_addr)(), int16_t (**otim_addr)(),
               int16_t *tim_conv)
{
   contrl[0] = 118;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;
   contrl[7..8] = tim_addr;

   vdi ();

   *otim_addr = contrl[9..10];
   *tim_conv  = intout[0];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]     !! 118   Opcode der Funktion
contrl+2  !! contrl[1]     !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2]     !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3]     !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4]     !! 1     # Eintr„ge in intout
contrl+12 !! contrl[6]     !! handle
contrl+14 !! contrl[7..8]  !! tim_addr
contrl+18 !! contrl[9..10] !! otim_addr
intout    !! intout[0]     !! tim_conv
!end_table

(!ende_liste)
!end_node



!begin_node vex_wheelv

(!begin_liste) [Beschreibung]

!item [Name:]
¯Exchange Timer Interrupt Vector® - stellt den Interruptvektor fr den
Zeitgeber um.

!item [VDI-Nummer:]
134

!item [Deklaration:]
void vex_wheelv ( int16_t handle, void *new, void **old );

!item [Beschreibung:]
This call installs a routine which is called by the VDI every time a
mouse wheel event occurs.  d0.w contain the wheel_number,
d1.w contain the wheel_amount of the wheel from the mouse.
The subroutine must save and restore modified registers and call the old
interrupt routine. 

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [new]
Adresse der neuen Routine
!item [old]
Adresse der alten Routine
!end_xlist

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Seit dem MilanTOS 4.08 Release 5.10.2002,  not yet documented, internals may
still change.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vex_wheelv])  ~ vex_butv ~  vex_motv ~  vex_curv ~ vex_timv

(!ende_liste)
!end_node



!begin_node Bindings fr vex_wheelv
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vex_wheelv ( int16_t handle, void *new, void **old );

!item [Implementierung:]
!begin_verbatim
void vex_wheelv ( int16_t handle, void *new, void **old )
{
   contrl[0] = 134;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;
   contrl[7..8] = new;

   vdi ();

   *old = contrl[9..10];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]     !! 134   Opcode der Funktion
contrl+2  !! contrl[1]     !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2]     !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3]     !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4]     !! 0     # Eintr„ge in intout
contrl+12 !! contrl[6]     !! handle
contrl+14 !! contrl[7..8]  !! new
contrl+18 !! contrl[9..10] !! old
!end_table

(!ende_liste)
!end_node





!begin_node vq_key_s

(!begin_liste) [Beschreibung]

!item [Name:]
¯Sample Keyboard State Information® - ermittelt den Status der
Kontrolltasten.

!item [VDI-Nummer:]
128

!item [Deklaration:]
void vq_key_s ( int16_t handle, int16_t *pstatus );

!item [Beschreibung:]
Die Funktion berprft den Status der Tastatur. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [pstatus]
Status der Tastatur als Bitvektor:
!begin_xlist !short [Shift-rechts]
!item [Shift-rechts]
= 0x0001
!item [Shift-links]
= 0x0002
!item [Control]
= 0x0004
!item [Alternate]
= 0x0008
!end_xlist
!end_xlist

In GEM-Programmen sollten die AES Event-Funktionen verwendet werden, um nur
die fr die eigene Applikation bestimmten Informationen ber den
Tastaturstatus zu erhalten.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den (!nolink [AES]) benutzt
wird. Deshalb sollte man besser auf graf_mkstate oder die Eventfunktionen
zurckgreifen.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all Atari computers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vq_key_s]) ~  evnt_button

(!ende_liste)
!end_node



!begin_node Bindings fr vq_key_s
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vq_key_s ( int16_t handle, int16_t *pstatus );

!item [Implementierung:]
!begin_verbatim
void vq_key_s (int16_t handle, int16_t *pstatus)
{
   contrl[0] = 128;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;

   vdi ();

   *pstatus = intout[0];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 128   Opcode der Funktion
contrl+2  !! contrl[1] !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4] !! 1     # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
intout    !! intout[0] !! pstatus
!end_table

(!ende_liste)
!end_node



!begin_node vq_mouse

(!begin_liste) [Beschreibung]

!item [Name:]
¯Sample Mouse Button State® - ermittelt Position und Status der Maustasten.

!item [VDI-Nummer:]
124

!item [Deklaration:]
void vq_mouse ( int16_t handle, int16_t *pstatus, int16_t *x, int16_t *y );

!item [Beschreibung:]
Die Funktion ermittelt die Position und den Status der Maustasten. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [pstatus]
Status der Maustasten
!begin_xlist !short
!item [Bit-0 =]
linke Taste
!item [Bit-1 =]
Taste rechts daneben (etc.)
!end_xlist
!item [x]
x-Koordinate
!item [y]
y-Koordinate des Grafikcursors
!end_xlist

In GEM-Programmen sollte die AES-Funktion graf_mkstate verwendet werden, um
nur die fr die eigene Applikation bestimmten Informationen ber Position
und Status der Maustastenstatus zu erhalten.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den (!nolink [AES]) benutzt
wird. Deshalb sollte man besser auf (!nolink [graf_mkstate]) oder die Eventfunktionen
zurckgreifen.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all screen drivers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vq_mouse]) ~  graf_mkstate

(!ende_liste)
!end_node



!begin_node Bindings fr vq_mouse
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vq_mouse ( int16_t handle, int16_t *pstatus, int16_t *x, int16_t *y );

!item [Implementierung:]
!begin_verbatim
void vq_mouse (int16_t handle, int16_t *pstatus, int16_t *x, int16_t *y)
{
   contrl[0] = 124;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;

   vdi ();

   *pstatus = intout[0];
   *x = ptsout[0];
   *y = ptsout[1];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 124   Opcode der Funktion
contrl+2  !! contrl[1] !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 1     # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4] !! 1     # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
intout    !! intout[0] !! pstatus
ptsout    !! ptsout[0] !! x
ptsout+2  !! ptsout[1] !! y
!end_table

(!ende_liste)
!end_node



!begin_node vrq_choice

(!begin_liste) [Beschreibung]

!item [Name:]
¯Input Choise, Request Mode® - liefert den Status der Funktionstasten, wenn
eine gedrckt wurde.

!item [VDI-Nummer:]
30

!item [Deklaration:]
void vrq_choice ( int16_t handle, int16_t ch_in, int16_t *ch_out );

!item [Beschreibung:]
Die Funktion ermittelt die Bet„tigung einer Auswahltaste (z.B.
Funktionstaste). Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [ch_in]
initialisierende Auswahltaste
!item [ch_out]
ausgew„hlte Taste bzw. Codenummer
!end_xlist

Die Anzahl der Funktionstasten ist abh„ngig vom jeweiligen Ger„t. Falls eine
andere Taste gedrckt wird, wird die entsprechende Codenummer
zurckgeliefert.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Die Funktion ist zwar im ROM implementiert, scheint aber in
keiner Weise zu funktionieren. Die Funktion wird (!I)nicht(!i) von allen
Ger„tetreibern untersttzt. Die Eingabefunktionen des VDI arbeiten nur auf
der (!I)physikalischen(!i) Workstation, die im Normalfall von den AES
benutzt wird.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vrq_choice]) ~  vsm_choice ~  vsin_mode

(!ende_liste)

!end_node


!begin_node Bindings fr vrq_choice
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vrq_choice ( int16_t handle, int16_t ch_in, int16_t *ch_out );

!item [Implementierung:]
!begin_verbatim
void vrq_choice (int16_t handle, int16_t ch_in, int16_t *ch_out)
{
   intin[0] = ch_in;

   contrl[0] = 30;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[6] = handle;

   vdi ();

   *ch_out = intout[0];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 30    Opcode der Funktion
contrl+2  !! contrl[1] !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 1     # Eintr„ge in intin
contrl+8  !! contrl[4] !! 1     # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
intin     !! intin[0]  !! ch_in
intout    !! intout[0] !! ch_out
!end_table

(!ende_liste)
!end_node



!begin_node vrq_locator

(!begin_liste) [Beschreibung]

!item [Name:]
¯Input Locator, Request Mode® - ermittel die Mausposition, wenn eine Taste
gedrckt wurde.

!item [VDI-Nummer:]
28

!item [Deklaration:]
void vrq_locator ( int16_t handle, int16_t x, int16_t y, int16_t *xout,
                   int16_t *yout, int16_t *term );

!item [Beschreibung:]
Die Funktion ermittelt bzw. setzt die Position des Grafik-Cursors. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [x]
x-Koordinate
!item [y]
y-Koordinate des Grafikcursors
!item [xout]
x-Koordinate
!item [yout]
y-Koordinate des Grafikcursors bei der Rckgabe
!item [term]
im Low-Byte wird der Code der Abbruch-Taste eingetragen. Dies ist
normalerweise der ASCII-Code. Spezielle Werte wie z.B. die Maustasten
erhalten jedoch Werte ab 32 und k”nnen so nicht direkt von Tasten der
Tastatur unterschieden werden.
!end_xlist

Das Ergebnis erh„lt der Benutzer erst, wenn eine Taste gedrckt wird. Der
Grafikcursor wird stets an der angegebenen Position in der aktuellen Form
auf dem Bildschirm sichtbar. Zu beachten ist, da jede beliebige Taste (also
auch die Maustasten) gedrckt werden darf.

Normalerweise erfolgt eine Bewegung des Grafikcursors in groen Schritten,
wenn die Cursortasten gedrckt werden, bzw. in kleinen Schritten, wenn
diese in Verbindung mit der Shift-Taste gedrckt werden. Auf dem Atari wird
jedoch zus„tzlich die Alternate-Taste ben”tigt.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Die Funktion wird nicht von allen Ger„tetreibern
untersttzt. Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vrq_locator]) ~  vsm_locator ~  vsin_mode

(!ende_liste)
!end_node



!begin_node Bindings fr vrq_locator
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vrq_locator ( int16_t handle, int16_t x, int16_t y, int16_t *xout,
                   int16_t *yout, int16_t *term );

!item [Implementierung:]
!begin_verbatim
void vrq_locator (int16_t handle, int16_t x, int16_t y, int16_t *xout,
                  int16_t *yout, int16_t *term)
{
   ptsin[0] = x;
   ptsin[1] = y;

   contrl[0] = 28;
   contrl[1] = 1;
   contrl[3] = 0;
   contrl[6] = handle;

   vdi ();

   *xout = ptsout[0];
   *yout = ptsout[1];
   *term = intout[0];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 28    Opcode der Funktion
contrl+2  !! contrl[1] !! 1     # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 1     # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 0     # Eintr„ge in intin
contrl+8  !! contrl[4] !! 1     # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
ptsin     !! ptsin[0]  !! x
ptsin+2   !! ptsin[1]  !! y
intout    !! intout[0] !! term
ptsout    !! ptsout[0] !! xout
ptsout+2  !! ptsout[1] !! yout
!end_table

(!ende_liste)
!end_node



!begin_node vrq_string

(!begin_liste) [Beschreibung]

!item [Name:]
¯Input String, Request Mode® - liest einen String im REQUEST-Modus ein.

!item [VDI-Nummer:]
31

!item [Deklaration:]
void vrq_string ( int16_t handle, int16_t max_length, int16_t echo_mode,
                  int16_t *echo_xy, int8_t *string );

!item [Beschreibung:]
Die Funktion liest einen String von der Tastatur ein, wobei optional ein
Echo auf dem Bildschirm erfolgen kann. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [max_length]
maximale L„nge des Strings
!item [echo_mode]
Modus
!begin_xlist !short
!item [0 =]
kein Echo
!item [1 =]
Echo benutzen
!end_xlist
!item [echo_xy[0!]]
x-Koordinate
!item [echo_xy[1!]]
y-Koordinate fr den Startpunkt der Echoausgabe
!item [string]
Adresse der Zeichenkette
!end_xlist

Die Echoausgabe ist nicht auf allen Ger„ten verfbar; im Falle eines Echos
werden die Text-Attribute jedoch bercksichtigt.

Ist (!I)max_length(!i) negativ, so wird der Absolutbetrag als L„nge
betrachtet, und statt der ASCII-Codes werden Scan-Codes bergeben.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
This call is not guaranteed to be available with any driver
              and its use should therefore be restricted.
              
!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vrq_string])  ~   vswr_mode  ~  vs_color  ~    vst_alignment ~
vst_height ~  vst_point  ~  vst_rotation ~ vst_font ~
vst_color ~  vst_effects ~ vsm_string
               
(!ende_liste)
!end_node



!begin_node Bindings fr vrq_string
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vrq_string ( int16_t handle, int16_t max_length, int16_t echo_mode,
                  int16_t *echo_xy, int8_t *string );

!item [Implementierung:]
!begin_verbatim
void vrq_string (int16_t handle, int16_t max_length, int16_t echo_mode,
                 int16_t *echo_xy, int8_t *string)
{
   int16_t tmp;

   intin[0] = max_length;
   intin[1] = echo_mode;
   ptsin[0..1] = echo_xy[0..1];

   contrl[0] = 31;
   contrl[1] = 1;
   contrl[3] = 2;
   contrl[6] = handle;

   vdi ();

   for (tmp = 0; tmp < contrl[4]; tmp++)
      *string++ = intout[tmp];

   *string = 0;
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]      !! 31    Opcode der Funktion
contrl+2  !! contrl[1]      !! 1     # Eintr„ge in ptsin
contrl+4  !! contrl[2]      !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3]      !! 2     # Eintr„ge in intin
contrl+8  !! contrl[4]      !! n     # Eintr„ge in intout
contrl+12 !! contrl[6]      !! handle
intin     !! intin[0]       !! max_length
intin+2   !! intin[1]       !! echo_mode
ptsin     !! ptsin[0..1]    !! echo_xy[0..1]
intout    !! intout[0..n-1] !! string[0..n-1]
!end_table

(!ende_liste)
!end_node



!begin_node vrq_valuator

(!begin_liste) [Beschreibung]

!item [Name:]
¯Input Valuator, Request Mode® - stellt Wertver„nderungen im REQUEST-Modus
fest.

!item [VDI-Nummer:]
29

!item [Deklaration:]
void vrq_valuator ( int16_t handle, int16_t valuator_in,
                    int16_t *valuator_out, int16_t *terminator );

!item [Beschreibung:]
Die Funktion ermittelt eine Wertver„nderung, die sich aus verschiedenen
Tastenbet„tigungen ergibt. Es gilt:

!begin_xlist !short [Parameter]
!item [valuator_out]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [valuator_in]
Anfangswert
!item [valuator_out]
Ausgabewert
!item [terminator]
bet„tigte Taste
!end_xlist

Es werden immer Werte zwischen 1 und 100 zurckgegeben. Typische Tasten fr
Wertver„nderung sind Cursor-hoch bzw. Cursor-runter. Hier erh„lt man
folgende Wertver„nderung zum jeweils aktuellen Wert:

!begin_xlist !short [Shift + Cursor runter]
!item [Tastendruck]
Wert
!item [~]
~
!item [Cursor hoch]
+ 10
!item [Cursor runter]
- 10
!item [Shift + Cursor hoch]
+ 01
!item [Shift + Cursor runter]
- 01
!end_xlist

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Die Funktion wird (!I)nicht(!i) von allen Ger„tetreibern
(auch nicht dem im ROM) untersttzt. Die Eingabefunktionen des VDI arbeiten
nur auf der (!I)physikalischen(!i) Workstation, die im Normalfall von den
AES benutzt wird.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vrq_valuator])  ~ vsm_valuator ~  vsin_mode

(!ende_liste)
!end_node



!begin_node Bindings fr vrq_valuator
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vrq_valuator ( int16_t handle, int16_t valuator_in,
                    int16_t *valuator_out, int16_t *terminator );

!item [Implementierung:]
!begin_verbatim
void vrq_valuator (int16_t handle, int16_t valuator_in, int16_t *valuator_out,
                   int16_t *terminator)
{
   intin[0] = valuator_in;

   contrl[0] = 29;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[6] = handle;

   vdi ();

   *valuator_out = intout[0];
   *terminator   = intout[1];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 29    Opcode der Funktion
contrl+2  !! contrl[1] !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 1     # Eintr„ge in intin
contrl+8  !! contrl[4] !! 2     # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
intin     !! intin[0]  !! valuator_in
intout    !! intout[0] !! valuator_out
intout+2  !! intout[1] !! terminator
!end_table

(!ende_liste)
!end_node



!begin_node vsc_form

(!begin_liste) [Beschreibung]

!item [Name:]
¯Set Mouse Form® - setzt die Mauszeigerform.

!item [VDI-Nummer:]
111

!item [Deklaration:]
void vsc_form ( int16_t handle, int16_t *pcur_form );

!item [Beschreibung:]
Die Funktion erlaubt die Definition der Form des Mauszeigers. Es gilt:

!begin_xlist !short [pcur_form+21..36+]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [pcur_form[0!]]
x-Koordinate
!item [pcur_form[1!]]
y-Koordinate des Hot-Spot
!item [pcur_form[2!]]
reserviert, sollte 1 sein
!item [pcur_form[3!]]
Farbindex der Hintergrundmaske
!item [pcur_form[4!]]
Farbindex der Vordergrundmaske
!item [pcur_form[05..20!]]
Definition der Hintergrundmaske
!item [pcur_form[21..36!]]
Definition der Vordergrundmaske
!end_xlist

Jede Maske wird als Feld mit 16 W”rtern zu je 16 Bit festgelegt. Bit-15 des
ersten Wortes ist hierbei die obere linke Ecke der Maske, und Bit 0 von Wort
16 ist ist die rechte untere Ecke.

!label Hot-Spot
Unter dem (!B)Hot-Spot(!b) versteht man die exakte Position des
Grafikcursors. Bei einem Pfeil wrde dies der Pfeilspitze, bei einem Kreuz
der Mitte entsprechen. Die Koordinaten werden relativ zur oberen linken
Ecke der Maske angegeben.

Zum Setzen der Mausform sollte in GEM-Programmen unbedingt die AES-Funktion
graf_mouse verwendet werden. Andernfalls wird die Mausform-Verwaltung des
(!nolink [AES]) nachhaltig verwirrt.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den (!nolink [AES]) benutzt
wird. Deshalb sollte man besser auf (!nolink [graf_mouse]) zurckgreifen.

Unter NVDI ist es auch m”glich, die aktuelle Form der Maus zu ermitteln
(vgl. Binding).

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Supported by all screen drivers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vsc_form]) ~  graf_mouse

(!ende_liste)
!end_node



!begin_node Bindings fr vsc_form
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vsc_form ( int16_t handle, int16_t *pcur_form );

!item [Implementierung:]
!begin_verbatim
void vsc_form (int16_t handle, int16_t *pcur_form)
{
   intin[0..36] = pcur_form[0..36];

   contrl[0] = 111;
   contrl[1] = 0;
   contrl[3] = 37;
   contrl[6] = handle;

   vdi ();
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 111   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2]    !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3]    !! 37    # Eintr„ge in intin
contrl+8  !! contrl[4]    !! 0     # Eintr„ge in intout
contrl+12 !! contrl[6]    !! handle
intin     !! intin[0..36] !! pcur_form[0..36]
!end_table

(!B)Hinweis:(!b) Unter NVDI ist auch m”glich, die aktuelle Mausform zu
ermitteln. Die dazu n”tigen Belegungen der Ein-/Ausgabefelder lauten wie
folgt:

!begin_xlist !short [intout+0..36+ =]
!item [contrl[0!] =]
111;
!item [contrl[1!] =]
0;
!item [contrl[2!] =]
0;
!item [contrl[3!] =]
0;
!item [contrl[4!] =]
37;
!item [contrl[6!] =]
handle;
!item [intout[0..36!] =]
pcur_form[0..36];
!end_xlist

(!ende_liste)
!end_node



!begin_node vsin_mode

(!begin_liste) [Beschreibung]

!item [Name:]
¯Set Input Mode® - setzt den Eingabemodus

!item [VDI-Nummer:]
33

!item [Deklaration:]
int16_t vsin_mode ( int16_t handle, int16_t dev_type, int16_t mode );

!item [Beschreibung:]
Die Funktion setzt den Eingabemodus auf Request oder Sample. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [dev_type]
Art des Eingabeger„ts
!begin_xlist !short
!item [1 =]
Positionseingabe (Maus)
!item [2 =]
wert„ndernde Einheiten (Cursor)
!item [3 =]
ausw„hlende Einheiten (Funktionstasten)
!item [4 =]
alphanumerische Ger„te (Tastatur)
!end_xlist
!item [mode]
gewnschter Modus
!begin_xlist !short
!item [1 =]
Request
!item [2 =]
Sample
!end_xlist
!end_xlist

Im Request-Modus wartet das Eingabeger„t auf eine Eingabe, im Sample-Modus
wird lediglich der Zustand oder die Position der Eingabeeinheit
zurckgegeben.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Ergebnis:]
Die Funktion liefert den ausgew„hlten Eingabemodus zurck.

!item [Verfgbar:]
Supported in ROM by all Atari computers.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vsin_mode])

(!ende_liste)
!end_node



!begin_node Bindings fr vsin_mode
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
int16_t vsin_mode ( int16_t handle, int16_t dev_type, int16_t mode );

!item [Implementierung:]
!begin_verbatim
int16_t vsin_mode (int16_t handle, int16_t dev_type, int16_t mode)
{
   intin[0] = dev_type;
   intin[1] = mode;

   contrl[0] = 33;
   contrl[1] = 2;
   contrl[3] = 2;
   contrl[6] = handle;

   vdi ();

   /* Vorsicht: Nicht alle Bindings liefern einen
      Return-Wert !!! */

   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 33    Opcode der Funktion
contrl+2  !! contrl[1] !! 0     # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0     # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 2     # Eintr„ge in intin
contrl+8  !! contrl[4] !! 1     # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
intin     !! intin[0]  !! dev_type
intin+2   !! intin[1]  !! mode
intout    !! intout[0] !! Return-Wert
!end_table

(!ende_liste)
!end_node



!begin_node vsm_choice

(!begin_liste) [Beschreibung]

!item [Name:]
¯Input Choise, Sample Mode® - ermittelt welche Funktionstaste zuletzt
gedrckt wurde.

!item [VDI-Nummer:]
30

!item [Deklaration:]
int16_t vsm_choice ( int16_t handle, int16_t *choice );

!item [Beschreibung:]
Die Funktion ermittelt die Nummer der zuletzt bet„tigten Auswahltaste. Es
gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [choice]
bet„tigte Auswahltaste oder 0, falls keine solche gedrckt worden ist
!end_xlist

Die Anzahl der Funktionstasten ist vom jeweiligen Ger„t abh„ngig. Falls eine
andere Taste bet„tigt worden ist, wird die zugeh”rige Codenummer
zurckgeliefert.

!item [Ergebnis:]
Die Funktion liefert den Auswahlstatus (0 = keine Taste bet„tigt, 1 = Taste
bet„tigt) zurck.

!item [Verfgbar:]
Die Funktion ist zwar im ROM implementiert, scheint aber
nicht richtig zu funktionieren. Die Funktion wird (!I)nicht(!i) von allen
Ger„tetreibern untersttzt. Die Eingabefunktionen des VDI arbeiten nur auf
der (!I)physikalischen(!i) Workstation, die im Normalfall von den AES
benutzt wird.

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vsm_choice]) ~  vrq_choice ~  vsin_mode

(!ende_liste)
!end_node



!begin_node Bindings fr vsm_choice
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
int16_t vsm_choice ( int16_t handle, int16_t *choice );

!item [Implementierung:]
!begin_verbatim
int16_t vsm_choice ( int16_t handle, int16_t *choice )
{
   contrl[0] = 30;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;

   vdi ();
 
   *choice = intout[0];
   return ( contrl[4] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 30     Opcode der Funktion
contrl+2  !! contrl[1] !! 0      # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0      # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 0      # Eintr„ge in intin
contrl+8  !! contrl[4] !! status # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
intout    !! intout[0] !! choice
!end_table

(!ende_liste)
!end_node



!begin_node vsm_locator

(!begin_liste) [Beschreibung]

!item [Name:]
¯Input Locator, Sample Mode® - bestimmt die Position des Grafikcursors.

!item [VDI-Nummer:]
28

!item [Deklaration:]
int16_t vsm_locator ( int16_t handle, int16_t x, int16_t y, int16_t *xout,
                   int16_t *yout, int16_t *term );

!item [Beschreibung:]
Die Funktion setzt bzw. ermittelt die Position des Grafikcursors. Es gilt:

!begin_xlist !short [Parameter]
!item [Position]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [x]
x-Koordinate
!item [y]
y-Koordinate des Grafikcursors
!item [xout]
x-Koordinate
!item [yout]
y-Koordinate des Grafikcursors bei Rckgabe
!item [term]
im Low-Byte wird der Code der Abbruch-Taste eingegeben. Spezielle Tasten
(Maustasten etc.) erhalten Werte ab 32 aufw„rts, und k”nnen daher nicht
direkt von Tasten der Tastatur unterschieden werden.
!end_xlist

Der Grafikcursor wird durch diese Funktion (!I)nicht(!i) sichtbar;
Tastenbet„tigungen oder Cursorbewegungen werden nur dann gemeldet, wenn
diese tats„chlich erfolgt sind.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Ergebnis:]
Die Funktion liefert kodiert Informationen darber, ob sich die Position
ver„ndert hat (Bit 0 gesetzt) und ob eine Taste gedrckt wurde (Bit 1
gesetzt).

!item [Verfgbar:]
Die Funktion wird nicht von allen Ger„tetreibern
untersttzt. 

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vsm_locator]) ~  vrq_locator ~  vsin_mode

(!ende_liste)
!end_node



!begin_node Bindings fr vsm_locator
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
int16_t vsm_locator ( int16_t handle, int16_t x, int16_t y, int16_t *xout,
                   int16_t *yout, int16_t *term );

!item [Implementierung:]
!begin_verbatim
int16_t vsm_locator (int16_t handle, int16_t x, int16_t y, int16_t *xout,
                  int16_t *yout, int16_t *term)
{
   ptsin[0] = x;
   ptsin[1] = y;

   contrl[0] = 28;
   contrl[1] = 1;
   contrl[3] = 0;
   contrl[6] = handle;

   vdi ();

   *xout = ptsout[0];
   *yout = ptsout[1];
   *term = intout[0];

   return ( (contrl[4] << 1) | (contrl[2]) );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 28        Opcode der Funktion
contrl+2  !! contrl[1] !! 1         # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0 oder 1  # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 0         # Eintr„ge in intin
contrl+8  !! contrl[4] !! 0 oder 1  # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
ptsin     !! ptsin[0]  !! x
ptsin+2   !! ptsin[1]  !! y
intout    !! intout[0] !! term
ptsout    !! ptsout[0] !! xout
ptsout+2  !! ptsout[1] !! yout
!end_table

(!ende_liste)
!end_node



!begin_node vsm_string

(!begin_liste) [Beschreibung]

!item [Name:]
¯Input String, Sample Mode® - liest einen String im SAMPLE-Modus ein.

!item [VDI-Nummer:]
31

!item [Deklaration:]
int16_t vsm_string ( int16_t handle, int16_t max_length, int16_t echo_mode,
                  int16_t *echo_xy, int8_t *string );

!item [Beschreibung:]
Die Funktion gibt einen String von der Tastatur zurck. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [max_length]
maximale L„nge des Strings
!item [echo_mode]
Modus
!begin_xlist !short
!item [0 =]
kein Echo
!item [1 =]
Echo benutzen
!end_xlist
!item [echo_xy[0!]]
x-Koordinate
!item [echo_xy[1!]]
y-Koordinate fr den Startpunkt der Echoausgabe
!item [string]
Adresse der Zeichenkette
!end_xlist

Die Echoausgabe ist nicht auf allen Ger„ten verfbar; im Falle eines Echos
werden die Text-Attribute jedoch bercksichtigt.

Ist (!I)max_length(!i) negativ, so wird der Absolut-Betrag als L„nge benutzt
und statt der ASCII-Codes werden Scan-Codes bergeben.

(!B)Die Eingabe der Zeichenkette wird abgebrochen durch:(!b)

!begin_itemize !short
!item Return
!item erreichen der maximalen Eingabel„nge
!item nicht verfgbare Datenwerte
!end_itemize

Falls die Zeichenkette grunds„tzlich mit (!nolink [Return]) abgeschlossen werden soll,
ist der Request-Modus per vrq_string zu w„hlen.

(!B)Hinweis:(!b) Die Eingabefunktionen des VDI arbeiten nur auf der
(!I)physikalischen(!i) Workstation, die im Normalfall von den AES benutzt
wird.

!item [Ergebnis:]
Die Funktion liefert entweder die Anzahl der gelesen Zeichen oder Null,
falls die Eingabe durch eine ungltige Taste  abgebrochen wurde. Der
eingegebene Text steht in string.

!item [Verfgbar:]
Die Funktion wird nicht von allen Ger„tetreibern
untersttzt. 

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vsm_string])    ~  vswr_mode ~   vs_color  ~  vst_alignment ~
vst_height  ~ vst_point  ~  vst_rotation ~ vst_font ~
vst_color   ~ vst_effects ~  vrq_string
               
(!ende_liste)
!end_node



!begin_node Bindings fr vsm_string
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
int16_t vsm_string ( int16_t handle, int16_t max_length, int16_t echo_mode,
                  int16_t *echo_xy, int8_t *string );

!item [Implementierung:]
!begin_verbatim
int16_t vsm_string (int16_t handle, int16_t max_length, int16_t echo_mode,
                 int16_t *echo_xy, int8_t *string)
{
   int16_t tmp;

   intin[0] = max_length;
   intin[1] = echo_mode;
   ptsin[0..1] = echo_xy[0..1];

   contrl[0] = 31;
   contrl[1] = 1;
   contrl[3] = 2;
   contrl[6] = handle;

   vdi ();

   for (tmp = 0; tmp < contrl[4]; tmp++)
      *string++ = intout[tmp];

   *string = 0;
   return ( contrl[4] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]      !! 31         Opcode der Funktion
contrl+2  !! contrl[1]      !! 1          # Eintr„ge in ptsin
contrl+4  !! contrl[2]      !! 0          # Eintr„ge in ptsout
contrl+6  !! contrl[3]      !! 2          # Eintr„ge in intin
contrl+8  !! contrl[4]      !! max_length # Eintr„ge in intout
contrl+12 !! contrl[6]      !! handle
intin     !! intin[0]       !! max_length
intin+2   !! intin[1]       !! echo_mode
ptsin     !! ptsin[0..1]    !! echo_xy[0..1]
intout    !! intout[0..n-1] !! string[0..n-1]
!end_table

(!ende_liste)
!end_node



!begin_node vsm_valuator

(!begin_liste) [Beschreibung]

!item [Name:]
¯Input Valuator, Sample Mode® - stellt Wertver„nderungen im SAMPLE-Modus
fest.

!item [VDI-Nummer:]
29

!item [Deklaration:]
void vsm_valuator ( int16_t handle, int16_t val_in, int16_t *val_out, int16_t *term,
                    int16_t *status );

!item [Beschreibung:]
Die Funktion ermittelt Wertver„nderungen im Sample-Modus. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstatoin
!item [val_in]
Anfangswert
!item [val_out]
Ausgabewert
!item [term]
ASCII-Code der gedrckten Taste
!item [status]
Auswertung
!begin_xlist !short
!item [0 =]
keine Ver„nderung
!item [1 =]
Wert ver„ndert
!item [2 =]
Taste bet„tigt
!end_xlist
!end_xlist

Es werden Werte zwischen 1 und 100 zurckgegeben, falls ein entsprechendes
Ereignis aufgetreten ist; anderenfalls wird kein Wert zurckgeliefert.

(!B)Hinweis:(!b) Die Funktion wird (!I)nicht(!i) von allen Ger„tetreibern
(auch nicht dem im ROM) untersttzt. Die Eingabefunktionen des VDI arbeiten
nur auf der (!I)physikalischen(!i) Workstation, die im Normalfall von den
AES benutzt wird.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Verfgbar:]
Die Funktion wird nicht von allen Ger„tetreibern
untersttzt. 

!item [Gruppe:]
Eingabefunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fr vsm_valuator]) ~  vrq_valuator ~  vsin_mode

(!ende_liste)
!end_node



!begin_node Bindings fr vsm_valuator
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
void vsm_valuator ( int16_t handle, int16_t val_in, int16_t *val_out, int16_t *term,
                    int16_t *status );

!item [Implementierung:]
!begin_verbatim
void vsm_valuator (int16_t handle, int16_t val_in, int16_t *val_out,
                   int16_t *term, int16_t *status)
{
   intin[0] = val_in;

   contrl[0] = 29;
   contrl[1] = 0;
   contrl[3] = 1;
   contrl[6] = handle;

   vdi ();

   *val_out = intout[0];
   *term    = intout[1];
   *status  = contrl[4];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 29     Opcode der Funktion
contrl+2  !! contrl[1] !! 0      # Eintr„ge in ptsin
contrl+4  !! contrl[2] !! 0      # Eintr„ge in ptsout
contrl+6  !! contrl[3] !! 1      # Eintr„ge in intin
contrl+8  !! contrl[4] !! status # Eintr„ge in intout
contrl+12 !! contrl[6] !! handle
intin     !! intin[0]  !! val_in
intout    !! intout[0] !! val_out
intout+2  !! intout[1] !! term
!end_table

(!ende_liste)
!end_node
