########################################
# @(#) TOS - das Betriebssystem
# @(#) Rolf Kotzian
########################################

!begin_node Das XCONTROL

XControl ist ein modulares (erweiterbares) Kontrollfeld, das von Atari
zuerst mit den Computern der TT und Mega-STE Serie ausgeliefert wurde.

!ifdest [html]
!ifset [No_Bilder_Pfad]
!image xcontrol
!else
!image (!picture_path)\xcontrol
!endif
!else
!image (!picture_path)\xcontrol
!endif

Die einzelnen Module sind Dateien mit der Namenserweiterung '.CPX'
(Control-Panel eXtension), und XControl selbst kann als Steuerungsprogramm
fÅr diese Module angesehen werden.

(!B)Wichtig:(!b) XControl sollte nur als Tool fÅr Konfigurationsdialoge
angesehen werden, und (!I)nicht(!i) fÅr andere Zwecke miûbraucht werden.

Die Kommunikation zwischen XControl und seinen Modulen erfolgt Åber zwei
Strukturen, die mit XCPB und CPXINFO bezeichnet werden. öber erstere werden
einige Flags sowie eine ganze Reihe von Hilfsfunktionen zugÑnglich gemacht.

!label XControl, Start von
Beim Start lÑdt XControl alle verfÅgbaren CPX-Header; sofern im Header
ein entsprechendes Flag gesetzt ist, werden alle CPX-Dateien einmal zum
initialisieren aufgerufen. FÅr jedes einzelne Modul kann angegeben
werden, ob es resident geladen werden soll (dies kann auch Åber das
mitgelieferte Konfigurations-CPX verÑndert werden). DarÅber hinaus ist es
mîglich, CPX-Module zu schreiben, die nur bestimmte Werte setzen. Man
spricht in diesem Zusammenhang von 'Set-Only'-Modulen, die nur beim
Booten bzw. erneuten Laden der CPX-Module durch XControl aufgerufen
werden, und bei der Initialisierung einfach einen Nullzeiger zurÅckliefern.

!label CPX-Moduls, Aktivierung eines
Sobald ein CPX-Modul vom Anwender ausgewÑhlt wird, lÑdt XControl dieses
in den Speicher, und ruft die Funktion cpx_init auf. Anschlieûend wird
noch cpx_call aufgerufen, wobei im wesentlichen nun das Modul selbst die
Steuerung Åbernimmt.

!label CPX, Form-
!label CPX, Event-
!label Form-CPX
!label Event-CPX
(!B)Man unterscheidet zwischen Form-CPX und Event-CPX(!b). Erstere sind
relativ einfach zu programmieren, bieten jedoch nur eine eingeschrÑnkte
FlexibilitÑt. Letztere sind flexibler, da sie die AES-Events direkt
auswerten. Alle mit XControl 1.0 ausgelieferten CPX-Module sind Form-CPX
Dateien, woraus geschlossen werden kann, daû Form-CPX in den meisten
FÑllen ausreichen.

!label CPX, Suffix eines
FÅr die Dateinamen von CPX-Modulen gilt die folgende Terminologie:

!begin_table [l l]
Suffix !! Bedeutung
!hline
*.CP !! Standard-CPX ohne Header
*.CPX !! Standard-CPX, fertig zum Gebrauch
*.CPZ !! inaktive CPX (von XControl deaktiviert)
*.HDR !! Header fÅr die CPX-Datei
*_R.CPX !! residente CPX-Datei
*_S.CPX !! Set-Only CPX-Datei
!end_table

!label CPX-Datei, Aufbau einer
!label CPX-Datei, Header einer
Der Aufbau einer CPX-Datei ist einem normalen Programm sehr Ñhnlich. Sie
besteht aus einem 512 Byte groûen Header und dem Åbrigen Dateiinhalt, bei
dem es sich fast um eine normale GEMDOS-Programmdatei handelt. Der Header
ist dabei wie folgt definiert:

!label CPXHEAD
!begin_verbatim
typedef struct
{
    UWORD magic;                 /* Magic-Konstante = 100   */
 
    struct
    {
        unsigned reserved : 13;  /* reserviert              */
        unsigned resident :  1;  /* RAM-resident            */
        unsigned bootinit :  1;  /* Boot-Initialisierung    */
        unsigned setonly  :  1;  /* Set-Only                */
 
    } flags;
 
    LONG  cpx_id;                /* eindeutige CPX-ID       */
    UWORD cpx_version;           /* CPX-Versionsnummer      */
    BYTE  i_text[14];            /* Icontext                */
    UWORD sm_icon[48];           /* Bitmap (32*24 Pixel)    */
    UWORD i_color;               /* Iconfarbe               */
    BYTE  title_text[18];        /* Name des CPX            */
    UWORD t_color;               /* Textfarbe               */
    BYTE  buffer[64];            /* nicht-flÅchtiger Puffer */
    BYTE  reserved[306];         /* reserviert              */
 
} CPXHEAD;
!end_verbatim

(!B)Zum Header noch einige (!nolink [Anmerkungen]):(!b)

!begin_itemize !short
!item die erste Funktion im TEXT-Segment muû die Initialisierungsroutine
fÅr die CPX sein
!item zur Konstruktion eines CPX-Headers gibt es mehrere Toolkits
!item Header und gelinkte Programmdatei kînnen in den meisten UNIX-Ñhnlichen
Shells (z.B. der Mupfel aus Gemini) mit dem Kommando 'cat' zusammengefÅgt
werden.
!item bei der CPX-Entwicklung ist es sehr praktisch, daû man XControl auch
als Programm starten kann (Suffix Ñndern !). Dies erlaubt es, ohne
permanentes Neu-Booten des Rechners zu arbeiten.
!item CPX-ID und -Versionsnummer sorgen dafÅr, daû jede CPX nur ein einziges
mal (und auch nur die neueste Version) erscheint.
!end_itemize
 
Bei der Programmierung eines CPX-Moduls sind einige Feinheiten zu beachten.
Da ein solches Modul (mit Ausnahme von 64 Byte) Åber keinen
nichtvergÑnglichen Speicher verfÅgt, ist nichts erlaubt, was Speicher in
irgendeiner Form fest reserviert. Insbesondere gehen Variableninhalte mit
dem Verlassen der CPX in aller Regel verloren ! (!B)Daher sollte man(!b):

!begin_itemize !short
!item Resourcen statisch einbinden
!item Speicheranforderungen nur kurzzeitig erlauben
!item virtuelle VDI-Workstations nicht dauerhaft anlegen
!end_itemize

Bei der Programmierung eines CPX-Moduls kann auf Funktionen der beiden
folgenden Kategorien zurÅckgegriffen werden:

!begin_itemize
!item CPX-Funktionen
!item XCONTROL-Funktionen
!end_itemize

!label COPS
(!B)Hinweis:(!b) Als Alternative zu (!nolink [XCONTROL]), welches von Atari nicht mehr
weiterentwickelt wird, bieten sich verschiedene Programme an. Besonders
empfehlenswert ist dabei COPS ((!B)COntrol Panel Server(!b), mit dessen
Hilfe sich nicht nur beliebig viele CPX-Module gleichzeitig îffnen lassen,
sondern das auch Kontrollfelder mit grîûerer ArbeitsflÑche als (!nolink [XCONTROL])
erlaubt.


!begin_node CPX-Programmierrichtlinien
!label Richtlinien fÅr CPX-Module

Bei der Programmierung eines CPX-Moduls sollte man tunlichst die
folgenden Regeln beachten:

!begin_itemize !short
!item reservierter Speicher ist mîglichst schnell wieder freizugeben
!item XControl-Funktionen sind immer auszunutzen, wenn dies mîglich ist
!item die Benutzerschnittstelle ist einfach und in Anlehnung an die anderen
CPX-Module zu gestalten

!item grafische Elemente sind MenÅkommandos vorzuziehen
!item 'OK' und 'Abbruch' sind (wenn mîglich) immer zu implementieren
!item Popup-MenÅs sind als Text mit schattiertem Rechteck darzustellen
!item AC_CLOSE (Verlassen des Hauptprogramms) wird als 'Abbruch' gewertet
!item WM_CLOSE (Schlieûen des XControl-Fensters) wird als 'OK' gewertet
!item 'Save'/'Sichern' ist als 'OK' ohne Verlassen des Dialogs zu werten
!item das Wurzelobjekt der CPX hat immer eine Grîûe von 256*176 Pixeln.
(!B)Ausnahme:(!b) Unter COPS darf der Objektbaum eine Grîûe von bis zu
512*384 Pixeln besitzen.

!item Interrupt-Vektoren dÅrfen nicht verÑndert werden
!item Xform_do darf nicht mit Funktionen fÅr Event-CPX vermischt werden
!item reservierter Speicher darf beim Verlassen der CPX nicht vergessen
werden, da es sonst zu einer Fragmentierung des Speichers kommt

!item bereits von anderen CPX verwandte ID's dÅrfen nicht benutzt werden
!item geîffnete Dateien mÅssen wieder geschlossen werden
!item geîffnete (!nolink [VDI])-Workstations sind auf jedenfall wieder zu schlieûen
(spÑtestens bei einer (!nolink [AC_CLOSE]) bzw. WM_CLOSE Meldung), wenn sie nicht mehr
benîtigt werden
!end_itemize
!end_node

!begin_node CPX-Funktionen

!begin_xlist [˘ cpx_button] !short 
!item [˘ cpx_button]    Maustasten-Ereignis
!item [˘ cpx_call  ]    Aktivierungsroutine
!item [˘ cpx_close ]    Close-Ereignis
!item [˘ cpx_draw  ]    Redraw-Ereignis
!item [˘ cpx_hook  ]    Preemption Hook
!item [˘ cpx_init  ]    Initialisierung
!item [˘ cpx_m1    ]    Mausrechteck-Ereignis
!item [˘ cpx_m2    ]    Mausrechteck-Ereignis
!item [˘ cpx_key   ]    Keyboard-Ereignis
!item [˘ cpx_timer ]    Timer-Ereignis
!item [˘ cpx_wmove ]    Fensterverschiebung
!end_xlist


!begin_node cpx_button

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_buttonÆ - Ereignis fÅr die Maustasten
!item [Deklaration]
VOID cdecl (*cpx_button) (MRETS *mrets, WORD nclicks, WORD *event);
!item [Beschreibung]
Die Funktion wird bei einem aufgetretenen Maustastenereignis aufgerufen. Es
gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [mrets]
Maus-Paramter zum Event
!item [nclicks]
Anzahl der Mausklicks
!item [event]
auf den Wert 1 setzen, falls das CPX verlassen werden soll
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_key ~  cpx_timer
!end_xlist
!end_node


!begin_node cpx_call

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_callÆ - Aufruf des CPX Moduls
!item [Deklaration]
WORD cdecl (*cpx_call) ( GRECT *work );

WORD cdecl (*cpx_call) ( GRECT *work, DIALOG *dialog );
!item [Beschreibung]
Die Funktion wird aufgerufen, wenn der Anwender das entsprechende Modul
ausgewÑhlt hat. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [work]
Rechteck mit den Koordinaten des XControl-Fensters
!item [dialog]
Zeiger auf einen Fensterdialog
!end_xlist

(!B)Hinweis:(!b) Die zweite Aufrufform steht nur unter COPS zur VerfÅgung.
Der Parameter (!I)dialog(!i) enthÑlt in diesem Fall einen Zeiger auf die
Fensterdialogstruktur. Der Dialog wird von COPS nach dem cpx_init mit Hilfe
von wdlg_create und wdlg_open geîffnet. Der Parameter (!I)work(!i) und der
Objektbaum liegen bis zum ersten Aufruf von Xform_do bzw. bis zur RÅckkehr
aus der Funktion cpx_call auûerhalb des sichtbaren Bildschirms.
!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_table [r l l]
0 !! = !! Ende der Bearbeitung
<> 0 !! = !! CPX soll weiterbearbeitet werden
!end_table

!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
XCONTROL
!end_xlist
!end_node


!begin_node cpx_close

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_closeÆ - Ereignis zum Schlieûen des Fensters
!item [Deklaration]
VOID cdecl (*cpx_close) (WORD flag);
!item [Beschreibung]
Die Funktion sorgt fÅr das Schlieûen des CPX-Moduls. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [flag]
Grund des Schlieûens
!begin_table [r l l]
0 !! = !! AC_CLOSE Message
<> 0 !! = !! WM_CLOSE Message
!end_table
!end_xlist

(!B)Hinweis:(!b) Die Funktion wird bei jeder (!nolink [AC_CLOSE]) bzw. WM_CLOSE
Nachricht aufgerufen. Die CPX sollte dann sofort allen reservierten
Speicher freigeben. Die Funktion muss bei jeder Event-CPX implementiert
sein. (!nolink [AC_CLOSE]) ist als 'Abbruch', WM_CLOSE als 'Ok' zu werten.
!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_init ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node cpx_draw

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_drawÆ - Ereignis zum Neuzeichnen des CPX-Fensters
!item [Deklaration]
VOID cdecl (*cpx_draw) (GRECT *clip);
!item [Beschreibung]
Die Funktion sorgt fÅr das Neuzeichnen von Teilen des CPX-Fensters. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [clip]
neu zu zeichnender Bereich, der auch als Åbergabe-Parameter fÅr (!nolink [GetFirstRect])
benîtigt wird.
!end_xlist

(!B)Hinweis:(!b) Die nîtige Rechteckliste muss per (!nolink [GetFirstRect]) und
(!nolink [GetNextRect]) ermittelt werden.
!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_wmove ~  GetFirstRect ~  GetNextRect
!end_xlist
!end_node


!begin_node cpx_hook

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_hookÆ - Preemption Hook
!item [Definiton]
WORD cdecl (*cpx_hook) (WORD event, WORD *msg, MRETS *mrets, WORD *key,
WORD *nclicks);
!item [Beschreibung]
Die Funktion wird sofort nach evnt_multi aufgerufen, also noch bevor
XControl das Event bearbeitet. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [event]
aufgetretene Events
!item [msg]
Ereignispuffer
!item [mrets]
Mausparameter
!item [key]
Tastendruck
!item [nclicks]
Anzahl der Mausklicks
!end_xlist

!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_table [r l l]
0 !! = !! Event-Bearbeitung fortsetzen
<> 0 !! = !! Event-Bearbeitung abbrechen
!end_table

!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_button ~  cpx_draw ~  cpx_key ~  cpx_m1 ~  cpx_m2 ~  cpx_timer ~ cpx_wmove
!end_xlist
!end_node


!begin_node cpx_init

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_initÆ - Initialisierung der CPX
!item [Deklaration]
CPXINFO * cdecl cpx_init (XCPB *xcpb);

(!nolink [CPXINFO]) * (!nolink [cdecl]) cpx_init ((!nolink [XCPB]) *xcpb, LONG magic,
LONG version );

!item [Beschreibung]
Die Funktion sorgt fÅr die Initialisierung der CPX. Es gilt:

!begin_xlist [Parameter]
!item [Parameter]
Bedeutung
!item [xcpb]
Zeiger auf die XCPB-Struktur von XControl
!end_xlist

(!B)Hinweis:(!b) Die Funktion muss am Beginn des Textsegments der CPX-Datei
stehen, und wird wÑhrend der XControl-Initialisierung sowie beim Aktivieren
der CPX aufgerufen.

Mit Hilfe der zweiten Aufrufform kann anhand der Parameter (!I)magic(!i) und
(!I)version(!i) festgestellt werden, ob die CPX unter (!nolink [XCONTROL]) oder COPS
lÑuft. Es bietet sich die folgende Routine an:

!label COPS, Test auf
!begin_verbatim
WORD is_COPS ( LONG magic, LONG version )
{
   if ((magic == 'COPS') && (version >= 0x10000L))
      return (TRUE);      /* COPS */
   else return (FALSE);   /* XCONTROL */ 
}
!end_verbatim

Falls COPS erkannt wurde, kann die CPX einen bis zu 512*384 Pixel groûen
Objektbaum zeichnen und bei der Funktion Xform_do Åbergeben.
!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_table [l l l]
NULL !! : !! 'Set Only'-CPX
sonst !! : !! Zeiger auf die (!nolink [CPXINFO])-Struktur der CPX
!end_table

!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_close ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node cpx_m1

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_m1Æ - Ereignis fÅr ein Mausrechteck
!item [Deklaration]
VOID cdecl (*cpx_m1) (MRETS *mrets, WORD *event);
!item [Beschreibung]
Die Funktion wird aufgerufen, wenn der Mauszeiger einen bestimmten Bereich
betritt oder verlÑût. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [mrets]
Parameter der Maus
!item [event]
auf den Wert 1 setzen, wenn die CPX verlassen werden soll
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_m2 ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node cpx_m2

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_m2Æ - Ereignis fÅr ein Mausrechteck
!item [Deklaration]
VOID cdecl (*cpx_m2) (MRETS *mrets, WORD *event);
!item [Beschreibung]
Die Funktion wird aufgerufen, wenn der Mauszeiger einen bestimmten Bereich
betritt oder verlÑût. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [mrets]
Parameter der Maus
!item [event]
auf den Wert 1 setzen, wenn die CPX verlassen werden soll
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_m1 ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node cpx_key

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_keyÆ - Ereignis fÅr einen Tastendruck
!item [Deklaration]
VOID cdecl (*cpx_key) (WORD kstate, WORD key, WORD *event);
!item [Beschreibung]
Die Funktion wird aufgerufen, wenn ein Keyboard-Event aufgetreten ist. Es
gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [kstate]
Status der Umschalttasten (Alternate, Control, Shift, etc.)
!item [key]
(!B)auslîsende Taste(!b)
!begin_table [l l l]
Highbyte !! : !! Scan-Code der Taste
Lowbyte !! : !! ASCII-Code der Taste
!end_table

!item [event]
auf den Wert 1 setzen, wenn die CPX verlassen werden soll
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_button ~  cpx_timer
!end_xlist
!end_node


!begin_node cpx_timer

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_timerÆ - Timer Ereignis
!item [Deklaration]
VOID cdecl (*cpx_timer) (WORD *event);
!item [Beschreibung]
Die Funktion wird aufgerufen, wenn ein Timer-Event aufgetreten ist. Es gilt:

!begin_xlist
!item [Parameter]
Bedeutung
!item [event]
auf den Wert 1 setzen, wenn die CPX verlassen werden soll
!end_xlist

(!B)Hinweis:(!b) Timer-Events werden von Form-CPX (!I)nicht(!i) unterstÅtzt.
!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_button  ~ cpx_key  ~ (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node cpx_wmove

!begin_xlist [Beschreibung]
!item [Name]
Øcpx_wmoveÆ - Verschiebung des XControl-Fensters
!item [Deklaration]
VOID cdecl (*cpx_wmove) (GRECT *work);
!item [Beschreibung]
Die Funktion wird aufgerufen, wenn der Anwender das Xcontrol-Fenster bewegt.
Es gilt:

!begin_xlist [Parameter]
!item [Parameter]
Bedeutung
!item [work]
neue Koordinaten des XControl-Fensters
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
CPX-Funktionen
!item [Querverweis]
cpx_draw ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node
!end_node


!begin_node XCONTROL-Funktionen

!begin_xlist [˘ Set_Evnt_Mask] !short 
!item [˘ CPX_Save     ]   Defaults sichern
!item [˘ Get_Buffer   ]   Zwischenspeicher ermitteln
!item [˘ getcookie    ]   Cookie-Variablen abfragen
!item [˘ GetFirstRect ]   Behandlung der Rechteckliste
!item [˘ GetNextRect  ]   Behandlung der Rechteckliste
!item [˘ MFsave       ]   Mausform sichern/wiederherstellen
!item [˘ Popup        ]   Popup-MenÅ
!item [˘ rsh_fix      ]   Objektbaum-Umwandlung
!item [˘ rsh_obfix    ]   Objektbaum-Umwandlung
!item [˘ Set_Evnt_Mask]   Eventmaske setzen
!item [˘ Sl_arrow     ]   Slider-Arrow
!item [˘ Sl_dragx     ]   Sliderdrag-Bewegung
!item [˘ Sl_dragy     ]   Sliderdrag-Bewegung
!item [˘ Sl_size      ]   Slidergrîûe
!item [˘ Sl_x         ]   Positionierung eines Sliders
!item [˘ Sl_y         ]   Positionierung eines Sliders
!item [˘ Xform_do     ]   Formular-Verwaltung
!item [˘ XGen_Alert   ]   Alarmbox
!end_xlist


!begin_node CPX_Save
!begin_xlist [Beschreibung]
!item [Name]
ØCPX_SaveÆ - Defaults sichern
!item [Deklaration]
WORD cdecl (*CPX_Save) (VOID *ptr, LONG num);
!item [Beschreibung]
Die Funktion erlaubt das Speichern von Defaulteinstellungen einer CPX. Es
gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [ptr]
Adresse der zu speichernden Daten
!item [num]
Anzahl der zu speichernden Bytes
!end_xlist

(!B)Hinweis:(!b) XControl speichert die Einstellungen im DATA Segment der
CPX. Daher mÅssen Entwickler selbst fÅr ausreichend freien Speicherplatz im
DATA-Segment sorgen. Dies geschieht Åber das Datenfeld 'SAVE_VARS' in
CPXSTART.S.
!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_table [r l l]
0 !! : !! Fehler aufgetreten
<> 0 !! : !! kein Fehler aufgetreten
!end_table

!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
(!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Get_Buffer

!begin_xlist [Beschreibung]
!item [Name]
ØGet_BufferÆ - Zwischenspeicher ermitteln
!item [Deklaration]
VOID cdecl (*Get_Buffer) (VOID);
!item [Beschreibung]
Die Funktion ermittelt die Adresse eines 64 Byte groûen, residenten
Speicherbereiches.

(!B)Hinweis:(!b) In diesem Speicher kann die CPX Inhalte von
Write-Only-Registern sichern, falls TOS keine Funktion zur Abfrage bietet
(Beispiel: Fensterfarben). Es sei noch einmal darauf hingewiesen, daû jeder
andere Speicher einer CPX flÅchtig ist !
!item [Ergebnis]
Die Funktion liefert einen Zeiger auf den Speicherbereich zurÅck.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
(!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node getcookie

!begin_xlist [Beschreibung]
!item [Name]
ØgetcookieÆ - Cookievariablen abfragen
!item [Deklaration]
WORD cdecl (*getcookie) (LONG cookie, LONG *p_value);
!item [Beschreibung]
Die Funktion sucht einen Cookie, und ermittelt seinen Wert. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [cookie]
Cookie-Variable
!item [p_value]
Adresse einer Variablen die den Wert aufnehmen soll, oder NULL, falls der
Wert nicht von Interesse ist.
!end_xlist

!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_table [r l l]
0 !! : !! Cookie nicht gefunden
<>0 !! : !! Cookie gefunden
!end_table

!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
Cookie-Jar ~  Cookies
!end_xlist
!end_node


!begin_node GetFirstRect

!begin_xlist [Beschreibung]
!item [Name]
ØGetFirstRectÆ - Rechteckliste abfragen
!item [Deklaration]
GRECT * cdecl (*GetFirstRect) (GRECT *prect);
!item [Beschreibung]
Die Funktion ermittelt das erste Rechteck der Rechteckliste. Es gilt:

!begin_xlist [Parameter]
!item [Parameter]
Bedeutung
!item [prect]
zu aktualisierender Bereich
!end_xlist

(!B)Hinweis:(!b) Die Funktion wird zum Neuzeichnen von Fensterbereichen nach
einer WM_REDRAW Message benîtigt; der Objektbaum wird jedoch von XControl
selbst verwaltet.
!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_table [l l l]
NULL !! : !! keine weiteren Ausschnitte vorhanden
sonst !! : !! wiederherzustellender Ausschnitt
!end_table

!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
GetNextRect ~   (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node GetNextRect

!begin_xlist [Beschreibung]
!item [Name]
ØGetNextRectÆ - Rechteckliste abfragen
!item [Deklaration]
GRECT * cdecl (*GetNextRect) (VOID);
!item [Beschreibung]
Die Funktion ermittelt das nÑchste Rechteck der Rechteckliste.

(!B)Hinweis:(!b) Die Funktion wird zum Neuzeichnen von Fensterbereichen nach
einer WM_REDRAW Message benîtigt; der Objektbaum wird jedoch von XControl
selbst verwaltet.
!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_table [l l l]
NULL !! : !! keine weiteren Ausschnitte vorhanden
sonst !! : !! wiederherzustellender Ausschnitt
!end_table

!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
GetFirstRect ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node MFsave

!begin_xlist [Beschreibung]
!item [Name]
ØMFsaveÆ - Mausform sichern oder wiederherstellen
!item [Deklaration]
VOID cdecl (*MFsave) (WORD saveit, MFORM *mf);
!item [Beschreibung]
Die Funktion sichert oder restauriert die Form des Mauszeigers. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [savit]
!begin_table [l l l]
0 !! = !! Mausform wiederherstellen
1 !! = !! Mausform sichern
!end_table
!item [mf]
Speicherbereich zur Sicherung der Mausform
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
graf_mouse ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Popup

!begin_xlist [Beschreibung]
!item [Name]
ØPopupÆ - Verwaltung eines Popup-MenÅs
!item [Deklaration]
WORD cdecl  (*Popup) (BYTE *items[], WORD num_items, WORD default_item,
WORD font_size, GRECT *button, GRECT *world);
!item [Beschreibung]
Die Funktion ermîglicht die komplette Verwaltung eines Popup-MenÅs. Es gilt:

!begin_xlist [default_item] !short
!item [Parameter]
Bedeutung
!item [items]
Array mit Zeichenketten fÅr die einzelnen EintrÑge. Jeder Eintrag muss die
gleiche LÑnge besitzen, sowie vorne mindestens zwei und am Ende mindestens
ein Leerzeichen aufweisen.
!item [num_items]
Anzahl der EintrÑge
!item [default_item]
Default-Eintrag (ZÑhlung beginnt bei 0), oder der Wert -1
!item [font_size]
(!B)Zeichengrîûe:(!b) 8*16 oder 8*8-Font. Als Parameter sind die gleichen
Werte wie in der TEDINFO-Struktur zu verwenden. Laut Atari wird z.Zt. nur
der groûe Zeichensatz verwendet.
!item [button]
Rechteck des Buttons, zu dem das Popup gehîrt.
!item [world]
Rechteck des Hintergrund-Objekbaumes (i.d.R. der Objektbaum der CPX)
!end_xlist

(!B)Hinweis:(!b) Bei zu vielen EintrÑgen (ab fÅnf) wird das Popup
automatisch gescrollt; die Bearbeitung blockiert alle anderen Aktionen.
!item [Ergebnis]
Die Funktion liefert den gewÑhlten Eintrag des Popups zurÅck, oder den
Wert -1, wenn kein Element des Popups ausgewÑhlt worden ist.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
Xform_do ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node rsh_fix

!begin_xlist [Beschreibung]
!item [Name]
Ørsh_fixÆ - Umwandlung eines Objektbaumes
!item [Deklaration]
VOID cdecl (*rsh_fix) (WORD num_objs, WORD num_frstr, WORD num_frimg,
WORD num_tree, OBJECT *rs_object, TEDINFO *rs_tedinfo, BYTE *rs_string[],
ICONBLK *rs_iconblk, BITBLK *rs_bitblk, LONG *rs_frstr, LONG *rs_frimg,
LONG *rs_trindex, struct foobar *rs_imdope);
!item [Beschreibung]
Die Funktion wandelt einen Objektbaum auf Basis von 8*16 Pixel groûen
Zeichen. Es gilt:

!begin_xlist [rs_tedinfo] !short
!item [Parameter]
Bedeutung
!item [num_objs]
Gesamtzahl der Objekte
!item [num_frstr]
Gesamtzahl der Strings
!item [num_frimg]
Gesamtzahl der Images
!item [num_tree]
Gesamtzahl der ObjektbÑume
!item [rs_object]
!item [rs_tedinfo]
!item [rs_string]
!item [rs_iconblk]
!item [rs_bitblk]
!item [rs_frstr]
!item [rs_frimg]
!item [tr_trindex]
!item [rs_imdope]
!end_xlist

(!B)Hinweis:(!b) Die CPX hat somit unter allen Auflîsungen die gleiche
Pixelgrîûe. Bei der Arbeit mit einem RCS sollte man daher ebenfalls einen
Grafikmodus mit 8*16 Pixel groûen Zeichen wÑhlen.

Die Koordinaten-Umwandlung darf natÅrlich nur ein einziges Mal stattfinden -
XControl stellt dazu in der XCPB-Struktur das Flag 'SkipRshFix' zur
VerfÅgung.
!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
rsh_obfix ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node rsh_obfix

!begin_xlist [Beschreibung]
!item [Name]
Ørsh_obfixÆ - Umwandlung eines Objektes
!item [Deklaration]
VOID cdecl (*rsh_obfix) (OBJECT *tree, WORD curob);
!item [Beschreibung]
Die Funktion konvertiert die Grîûe und Position eines Objektes von einer
Zeichendarstellung in die Pixeldarstellung. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [tree]
Adresse des Objektbaumes
!item [curob]
zu konvertierendes Objekt
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
rsh_fix  ~ rsrc_obfix ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Set_Evnt_Mask

!begin_xlist [Beschreibung]
!item [Name]
ØSet_Evnt_MaskÆ - Festlegen der Ereignis Maske
!item [Deklaration]
VOID cdecl (*Set_Evnt_Mask) (WORD mask, MOBLK *m1, MOBLK *m2, LONG time);
!item [Beschreibung]
Die Funktion legt fest, auf welche Ereignisse die CPX reagieren soll. Es
gilt:

!begin_xlist [Parameter]
!item [Parameter]
Bedeutung
!item [mask]
erlaubte Events (analog evnt_multi)
!item [m1]
Mausrechteck und -richtung
!item [m2]
Mausrechteck und -richtung
!item [time]
Zeit in Millisekunden fÅr Timer-Event
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
(!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Sl_arrow

!begin_xlist [Beschreibung]
!item [Name]
ØSl_arrowÆ - Behandlung des Sliderarrows
!item [Deklaration]
VOID cdecl (*Sl_arrow) (OBJECT *tree, WORD base, WORD slider, WORD obj,
WORD inc, WORD min, WORD max, WORD *value, WORD direction,
VOID (*foo) (VOID));
!item [Beschreibung]
Die Funktion ist aufzurufen, sobald der Pfeil eines Sliders angeklickt wird.
Es gilt:

!begin_xlist [direction] !short
!item [Parameter]
Bedeutung
!item [tree]
Adresse des Objektbaumes
!item [base]
Basisobjekt
!item [slider]
Slider (Child des Basisobjektes)
!item [obj]
Pfeil der angeklickt wurde
!item [inc]
Anzahl der Einheiten die addiert bzw. subtrahiert werden sollen
!item [min]
Minimalwert der angenommen werden kann
!item [max]
Maximalwert der angenommen werden kann
!item [value]
Adresse fÅr aktuellen Wert
!item [direction]
(!B)Richtung(!b)
!begin_table [l l l]
0 !! = !! vertikal
1 !! = !! horizontal
!end_table
!item [foo]
Adresse einer Funktion (analog zu Sl_x, bzw. Sl_y).
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
Sl_dragx ~  Sl_dragy ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Sl_dragx

!begin_xlist [Beschreibung]
!item [Name]
ØSl_dragxÆ - Draggen eines Sliders
!item [Deklaration]
VOID cdecl (*Sl_dragx) (OBJECT *tree, WORD base, WORD slider, WORD min,
WORD max, WORD *value, VOID (*foo) (VOID));
!item [Beschreibung]
Die Funktion verwaltet die Bewegung des horizontalen Sliders. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [tree]
Adresse des Objektbaumes
!item [base]
Basisobjekt
!item [slider]
Slider (Child des Basisobjektes)
!item [min]
Minimalwert der angenommen werden kann
!item [max]
Maximalwert der angenommen werden kann
!item [value]
Adresse fÅr aktuellen Wert
!item [foo]
Adresse einer Funktion analog zu Sl_x
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
Sl_dragy ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Sl_dragy

!begin_xlist [Beschreibung]
!item [Name]
ØSl_dragyÆ - Draggen eines Sliders
!item [Deklaration]
VOID cdecl (*Sl_dragy) (OBJECT *tree, WORD base, WORD slider, WORD min,
WORD max, WORD *value, VOID (*foo) (VOID));
!item [Beschreibung]
Die Funktion verwaltet die Bewegung des horizontalen Sliders. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [tree]
Adresse des Objektbaumes
!item [base]
Basisobjekt
!item [slider]
Slider (Child des Basisobjektes)
!item [min]
Minimalwert der angenommen werden kann
!item [max]
Maximalwert der angenommen werden kann
!item [value]
Adresse fÅr aktuellen Wert
!item [foo]
Adresse einer Funktion analog zu Sl_y
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
Sl_dragx ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Sl_size

!begin_xlist [Beschreibung]
!item [Name]
ØSl_sizeÆ - Grîûe des Sliders festlegen
!item [Deklaration]
VOID cdecl (*Sl_size) (OBJECT *tree, WORD base, WORD slider, WORD num_items,
WORD visible, WORD direction, WORD min_size);
!item [Beschreibung]
Die Funktion stellt die Grîûe des Sliders ein. Es gilt:

!begin_xlist [direction] !short
!item [Parameter]
Bedeutung
!item [tree]
Adresse des Objektbaumes
!item [base]
Basisobjekt
!item [slider]
Slider (Child des Basisobjektes)
!item [num_items]
Anzahl der vorhandenen Elemente
!item [visible]
Anzahl der sichtbaren Elemente
!item [direction]
(!B)Richtung(!b)
!begin_table [l l l]
0 !! = !! vertical
1 !! = !! horizontal
!end_table
!item [min_size]
Minimalgrîûe des Sliders in Pixeln
!end_xlist

(!B)Hinweis:(!b) Die Funktion wird benîtigt, um die Relation der
dargestellten Datenmenge zur vorhandenen zu erhalten.
!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
Sl_dragx  ~ Sl_dragy ~  Sl_x ~  Sl_y ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Sl_x

!begin_xlist [Beschreibung]
!item [Name]
ØSl_xÆ - Positionierung eines Sliders
!item [Deklaration]
VOID cdecl (*Sl_x) (OBJECT *tree, WORD base, WORD slider, WORD value,
WORD min, WORD max, VOID (*foo) (VOID));
!item [Beschreibung]
Die Funktion positioniert den Slider innerhalb eines Basisobjektes in
horizontaler Richtung. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [tree]
Adresse des Objektbaumes
!item [base]
Basisobjekt
!item [slider]
Slider (Child des Basisobjektes)
!item [value]
neuer Wert, den der Slider reprÑsentieren soll
!item [min]
Minimalwert den value annehmen darf
!item [max]
Maximalwert den value annehmen darf
!item [foo]
Adresse einer Funktion (oder NULL), die gleichzeitig mit der
Slider-Neupositionierung aufgerufen wird; so lassen sich die
Sliderbewegungen ausnutzen, um auch die angezeigten Werte zu erneuern.
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
Sl_y  ~ (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Sl_y

!begin_xlist [Beschreibung]
!item [Name]
ØSl_yÆ - Positionierung eines Sliders
!item [Deklaration]
VOID cdecl (*Sl_y) (OBJECT *tree, WORD base, WORD slider, WORD value,
WORD min, WORD max, VOID (*foo) (VOID));
!item [Beschreibung]
Die Funktion positioniert den Slider innerhalb eines Basisobjektes in
vertikaler Richtung. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [tree]
Adresse des Objektbaumes
!item [base]
Basisobjekt
!item [slider]
Slider (Child des Basisobjektes)
!item [value]
neuer Wert, den der Slider reprÑsentieren soll
!item [min]
Minimalwert den value annehmen darf
!item [max]
Maximalwert den value annehmen darf
!item [foo]
Adresse einer Funktion (oder NULL), die gleichzeitig mit der
Slider-Neupositionierung aufgerufen wird; so lassen sich die
Sliderbewegungen ausnutzen, um auch die angezeigten Werte zu erneuern.
!end_xlist

!item [Ergebnis]
Die Funktion liefert kein Ergebnis.
!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
Sl_x  ~ (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node


!begin_node Xform_do

!begin_xlist [Beschreibung]
!item [Name]
ØXform_doÆ - Verwaltung eines Formulars
!item [Deklaration]
WORD cdecl (*Xform_do) (OBJECT *tree, WORD startob, WORD *puntmsg);
!item [Beschreibung]
Die Funktion Åbernimmt die Verwaltung eines Formulars, sowie (in geringem
Umfang) die Bearbeitung von AES Nachrichten. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [tree]
Adresse des Objektbaumes
!item [startob]
Startobjekt
!item [puntmsg]
Mitteilungs-Puffer
!end_xlist

(!B)Hinweis:(!b) Unter COPS kann die CPX einen bis zu 512*384 Pixel groûen
Objektbaum zeichnen und an diese Funktion Åbergeben.
!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_xlist
!item [-1:]
puntmsg enthÑlt eine Nachricht, die auszuwerten ist:

!begin_xlist [WM_REDRAW:]
!item [WM_REDRAW:]
die CPX muû solche Objekte selbst neuzeichnen, die nicht zum Objektbaum
gehîren. Die Rechteckliste kann Åber die Funktionen GetFirstRect und
GetNextRect ermittelt werden.
!item [AC_CLOSE:]
!item [WM_CLOSE:]
Die CPX wurde beendet; reservierter Speicher ist sofort freizugeben.
AC_CLOSE ist als 'Abbruch', WM_CLOSE als 'Ok' zu werten.
!item [CT_KEY:]
spezielle Nachricht, die das Auswerten von TastendrÅcken erlaubt, sofern
diese keine Auswirkungen auf EDIT-Felder haben kînnen.

!begin_table [l l l l]
puntmsg[3] !! Highbyte !! : !! Scan-Code der Taste
puntmsg[3] !! Lowbyte !! : !! ASCII-Code der Taste
!end_table
 
!item [sonst:]
Nummer des angeklickten Objektes (ein (!nolink [Doppelklick]) wird im oberen Bit
gekennzeichnet).
!end_xlist
!end_xlist

!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
form_do ~  form_xdo ~
(!link [Rechteckliste eines Fensters][Die Rechteckliste eines Fensters])
!end_xlist
!end_node


!begin_node XGen_Alert

!begin_xlist [Beschreibung]
!item [Name]
ØXGen_AlertÆ - Anzeigen einer Alarmbox
!item [Deklaration]
WORD cdecl (*XGen_Alert) (WORD id);
!item [Beschreibung]
Die Funktion ermîglicht das Anzeigen einer einfachen Alarmbox. Es gilt:

!begin_xlist [Parameter] !short
!item [Parameter]
Bedeutung
!item [id]
(!B)Art der Meldung(!b)
!begin_table [l l l]
0 !! = !! "Voreinstellungen sichern?"
1 !! = !! "Fehler bei Speicheranforderung!"
2 !! = !! "Fehler beim Schreiben/Lesen von Dateien"
3 !! = !! "Datei nicht gefunden"
!end_table
!end_xlist

(!B)Hinweis:(!b) Weitere Alarmboxen mÅssen selbst definiert werden. Hierzu
bietet sich form_alert jedoch (!I)nicht(!i) an, da es die Alarmbox bezÅglich
der vollen BildschirmflÑche und nicht bezÅglich des XControl-Fensters
zentriert.
!item [Ergebnis]
Die Funktion liefert einen der folgenden Werte zurÅck:

!begin_xlist [<> 0 :]
!item [~~~0 :]
Abbruch bzw. Cancel wurde angeklickt.
!item [<> 0 :]
Ok wurde angeklickt (falls eine Alarmbox nur einen Button hat, so ist es der
Ok-Button)
!end_xlist

!item [Gruppe]
XCONTROL-Funktionen
!item [Querverweis]
form_alert ~  (!link [XCONTROL][Das XCONTROL])
!end_xlist
!end_node
!end_node
!end_node
