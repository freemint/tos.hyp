<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2025/08/02 -->
<html lang="en">
<head>
<title>
The documentation for TOS: GEMDOS structures
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="gemdos_main.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
<a name="UDO_nav_lf_HEAD" href="gemdos_functions.html"><img src="udo_lf.gif" alt="GEMDOS function list" title="GEMDOS function list" border="0" width="24" height="24">GEMDOS function list</a>
<a name="UDO_nav_rg_HEAD" href="linea_main.html"><img src="udo_rg.gif" alt="Line-A" title="Line-A" border="0" width="24" height="24">Line-A</a>

<hr>

<h1><a name="GEMDOS_20structures">5.24 GEMDOS structures</a></h1>
<ul class="content">
	<li> 5.24.1 <a href="#CD-ROM_20definitions">CD-ROM definitions</a>
	<li> 5.24.2 <a href="#cdrom_audioctrl">cdrom_audioctrl</a>
	<li> 5.24.3 <a href="#cdrom_mcn">cdrom_mcn</a>
	<li> 5.24.4 <a href="#cdrom_msf">cdrom_msf</a>
	<li> 5.24.5 <a href="#cdrom_read">cdrom_read</a>
	<li> 5.24.6 <a href="#cdrom_subchnl">cdrom_subchnl</a>
	<li> 5.24.7 <a href="#cdrom_ti">cdrom_ti</a>
	<li> 5.24.8 <a href="#cdrom_tisrc">cdrom_tisrc</a>
	<li> 5.24.9 <a href="#cdrom_tocentry">cdrom_tocentry</a>
	<li> 5.24.10 <a href="#cdrom_tochdr">cdrom_tochdr</a>
	<li> 5.24.11 <a href="#cdrom_volctrl">cdrom_volctrl</a>
	<li> 5.24.12 <a href="#cd_ad">cd_ad</a>
	<li> 5.24.13 <a href="#DISKINFO">DISKINFO</a>
	<li> 5.24.14 <a href="#DOSTIME">DOSTIME</a>
	<li> 5.24.15 <a href="#DOSVARS">DOSVARS</a>
	<li> 5.24.16 <a href="#DTA">DTA</a>
	<li> 5.24.17 <a href="#fcookie">fcookie</a>
	<li> 5.24.18 <a href="#FILEPTR">FILEPTR</a>
	<li> 5.24.19 <a href="#flock_2C_20Fcntl">flock, Fcntl</a>
	<li> 5.24.20 <a href="#iovec">iovec</a>
	<li> 5.24.21 <a href="#LINE">LINE</a>
	<li> 5.24.22 <a href="#ltchars">ltchars</a>
	<li> 5.24.23 <a href="#msghdr">msghdr</a>
	<li> 5.24.24 <a href="#mutimbuf">mutimbuf</a>
	<li> 5.24.25 <a href="#Process_20Descriptor_20_28PD_29_20resp._20BASEPAGE">Process Descriptor (PD) resp. BASEPAGE</a>
	<li> 5.24.26 <a href="#Poll_20Descriptor">Poll Descriptor</a>
	<li> 5.24.27 <a href="#ploadinfo">ploadinfo</a>
	<li> 5.24.28 <a href="#sgttyb">sgttyb</a>
	<li> 5.24.29 <a href="#struct_20sigaction">struct sigaction</a>
	<li> 5.24.30 <a href="#sockaddr">sockaddr</a>
	<li> 5.24.31 <a href="#STAT">STAT</a>
	<li> 5.24.32 <a href="#tchars">tchars</a>
	<li> 5.24.33 <a href="#timeval">timeval</a>
	<li> 5.24.34 <a href="#timezone">timezone</a>
	<li> 5.24.35 <a href="#struct_20tty">struct tty</a>
	<li> 5.24.36 <a href="#winsize">winsize</a>
	<li> 5.24.37 <a href="#XATTR">XATTR</a>
	<li> 5.24.38 <a href="#xkey">xkey</a>
	</li>
</ul>
<br>
<h3><a name="CD-ROM_20definitions">5.24.1 CD-ROM definitions</a></h3>
<a name="CDROM_LBA"></a>
<a name="CDROM_MSF"></a>
<a name="CDROM_AUDIO_EMPHASIS"></a>
<a name="CDROM_COPY_PERMITTED"></a>
<a name="CDROM_DATA_TRACK"></a>
<a name="CDROM_FOUR_CHANNEL"></a>
<a name="CDROM_LEADOUT"></a>
<a name="CDROM_AUDIO_INVALID"></a>
<a name="CDROM_AUDIO_PLAY"></a>
<a name="CDROM_AUDIO_PAUSED"></a>
<a name="CDROM_AUDIO_COMPLETED"></a>
<a name="CDROM_AUDIO_ERROR"></a>
<a name="CDROM_AUDIO_NO_STATUS"></a>
<pre>/* CD-ROM address types */

#define CDROM_LBA               0x01
#define CDROM_MSF               0x02

/* SUB Q control bits */

#define CDROM_AUDIO_EMPHASIS    0x01
#define CDROM_COPY_PERMITTED    0x02
#define CDROM_DATA_TRACK        0x04
#define CDROM_FOUR_CHANNEL      0x08

/* The leadout track is always 0xAA, regardless of # of tracks on disc */

#define CDROM_LEADOUT   0xAA

/* return value from READ SUBCHANNEL DATA */

/* Audio status not supported         */
#define CDROM_AUDIO_INVALID     0x00
/* Audio play operation in progress   */
#define CDROM_AUDIO_PLAY        0x11
/* Audio play operation paused        */
#define CDROM_AUDIO_PAUSED      0x12
/* Audio play successfully completed  */
#define CDROM_AUDIO_COMPLETED   0x13
/* Audio play stopped due to error    */
#define CDROM_AUDIO_ERROR       0x14
/* No current audio status to return  */
#define CDROM_AUDIO_NO_STATUS   0x15
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cdrom_audioctrl">5.24.2 cdrom_audioctrl</a></h3>
<pre>struct cdrom_audioctrl
{
    /* input parameters */

    int16_t set;                   /* 0 = 0 == inquire only */

    /* input/output parameters */

    struct
    {
        int8_t selection;
        int8_t volume;
    } channel[4];
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cdrom_mcn">5.24.3 cdrom_mcn</a></h3>
<pre>struct cdrom_mcn
{
    int8_t  mcn_audiostatus;
    int8_t  mcn_mcn[23];       /* Media catalog number as ASCII string */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a> &nbsp; <a href="ascii.html">ASCII table</a>
</p>
<h3><a name="cdrom_msf">5.24.4 cdrom_msf</a></h3>
<pre>struct cdrom_msf
{
    int8_t cdmsf_min0;       /* Start minute  */
    int8_t cdmsf_sec0;       /* Start second  */
    int8_t cdmsf_frame0;     /* Start frame   */
    int8_t cdmsf_min1;       /* End minute    */
    int8_t cdmsf_sec1;       /* End second    */
    int8_t cdmsf_frame1;     /* End frame     */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cdrom_read">5.24.5 cdrom_read</a></h3>
<pre>struct cdrom_read
{
    int32_t  cdread_lba;       /* Logical block address */
    int8_t  *cdread_bufaddr;   /* Buffer pointer        */
    int32_t  cdread_buflen;    /* Byte count            */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cdrom_subchnl">5.24.6 cdrom_subchnl</a></h3>
<pre>struct cdrom_subchnl
{
    /* input parameters */

    int8_t cdsc_format;             /* <a href="gemdos_structures.html#CDROM_MSF">CDROM_MSF</a> or <a href="gemdos_structures.html#CDROM_LBA">CDROM_LBA</a> */

    /* output parameters */

    int8_t   cdsc_audiostatus;
    unsigned cdsc_resvd: 8;         /* Reserved               */
    unsigned cdsc_adr  : 4;
    unsigned cdsc_ctrl : 4;
    int8_t   cdsc_track;            /* Current track          */
    int8_t   cdsc_ind;              /* Current index          */
    <a href="#cd_ad">cd_ad</a>    cdsc_absaddr;          /* Absolute address       */
    <a href="#cd_ad">cd_ad</a>    cdsc_reladdr;          /* Track relative address */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cdrom_ti">5.24.7 cdrom_ti</a></h3>
<pre>struct cdrom_ti
{
    int8_t cdti_trk0;        /* Start track */
    int8_t cdti_ind0;        /* Start index */
    int8_t cdti_trk1;        /* End track   */
    int8_t cdti_ind1;        /* End index   */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cdrom_tisrc">5.24.8 cdrom_tisrc</a></h3>
<pre>struct cdrom_tisrc
{
    /* input parameters */

    int8_t tisrc_track;          /* Track number                 */

    /* output parameters */

    int8_t tisrc_audiostatus;
    int8_t tisrc_tisrc[23];      /* Track International Standard
                                    Recording Code (ASCII)       */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a> &nbsp; <a href="ascii.html">ASCII table</a>
</p>
<h3><a name="cdrom_tocentry">5.24.9 cdrom_tocentry</a></h3>
<pre>struct cdrom_tocentry
{
    /* input parameters */

    int8_t cdte_track;             /* Track number or <a href="gemdos_structures.html#CDROM_LEADOUT">CDROM_LEADOUT</a> */
    int8_t cdte_format;            /* <a href="gemdos_structures.html#CDROM_LBA">CDROM_LBA</a> or <a href="gemdos_structures.html#CDROM_MSF">CDROM_MSF</a>        */

    /* output parameters */

    unsigned cdte_adr:4;           /* the SUBQ channel encodes:
                                      0 = nothing
                                      1 = position data
                                      2 = MCN
                                      3 = ISRC
                                      Else: reserved                */
    unsigned cdte_ctrl:4;          /* Bit-0: Audio with pre-<a href="xbios_sound.html#emphasis">emphasis</a>
                                      Bit-1: Digital copy permitted
                                      Bit-2: Data track
                                      Bit-3: Four channel           */
    int8_t   cdte_datamode;        /* Currently not se              */
    <a href="#cd_ad">cd_ad</a>    dte_addr;             /* Track start                   */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cdrom_tochdr">5.24.10 cdrom_tochdr</a></h3>
<pre>struct cdrom_tochdr
{
    int8_t cdth_trk0;        /* Start track */
    int8_t cdth_trk1;        /* End track   */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cdrom_volctrl">5.24.11 cdrom_volctrl</a></h3>
<pre>struct cdrom_volctrl
{
    int8_t  channel0;   /* Channel 1: Volume 0...255 */
    int8_t  channel1;   /* Channel 2: Volume 0...255 */
    int8_t  channel2;   /* Channel 3: Volume 0...255 */
    int8_t  channel3;   /* Channel 4: Volume 0...255 */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="cd_ad">5.24.12 cd_ad</a></h3>
<p>This <a href="proto_xfsl.html#union">union</a> is defined as follows:
</p>
<pre>typedef <a href="proto_xfsl.html#union">union</a>
{
    struct
    {
       int8_t reserved;    /* Reserved   */
       int8_t minute;      /* Minute     */
       int8_t second;      /* Second     */
       int8_t frame;       /* Frame      */
    } msf;
    int32_t lba;
} cd_ad;
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM opcodes for Fcntl</a>
</p>
<h3><a name="DISKINFO">5.24.13 DISKINFO</a></h3>
<p>This structure is defined as follows:
</p>
<pre>typedef struct
{
    uint32_t   b_free;    /* Number of free clusters  */
    uint32_t   b_total;   /* Total number of clusters */
    uint32_t   b_secsiz;  /* Bytes per sektor         */
    uint32_t   b_clsiz;   /* sector per cluster       */
} DISKINFO;
</pre>
<p>See also: <a href="gemdos_directory.html#Dfree">Dfree</a> &nbsp; <a href="gemdos_main.html">GEMDOS</a>
</p>
<h3><a name="DOSTIME">5.24.14 DOSTIME</a></h3>
<pre>typedef struct
{
   uint16_t     time;  /* Time like <a href="gemdos_datetime.html#Tgettime">Tgettime</a> */
   uint16_t     date;  /* Date like <a href="gemdos_datetime.html#Tgetdate">Tgetdate</a> */
} DOSTIME;
</pre>
<p>The structure of both integer values is arranged as follows:
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bit</td>
<td valign="top"> Time
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0-4</td>
<td valign="top"> Seconds in units of two (0-29)
</td></tr>

<tr><td nowrap="nowrap" valign="top">5-10</td>
<td valign="top"> Minutes (0-59)
</td></tr>

<tr><td nowrap="nowrap" valign="top">11-15</td>
<td valign="top"> Hours (0-23)

</td></tr>
</table>

<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bit</td>
<td valign="top"> Date
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0-4</td>
<td valign="top"> Day of month (1-31)
</td></tr>

<tr><td nowrap="nowrap" valign="top">5-8</td>
<td valign="top"> Month (1-12)
</td></tr>

<tr><td nowrap="nowrap" valign="top">9-15</td>
<td valign="top"> Year (0-119, 0=1980)

</td></tr>
</table>

<p>See also: <a href="gemdos_file.html#Fdatime">Fdatime</a> &nbsp; <a href="gemdos_main.html">GEMDOS</a>
</p>
<h3><a name="DOSVARS">5.24.15 DOSVARS</a></h3>
<pre>typedef struct
{
   int8_t    *in_dos;                 /* Adress of the DOS semaphore  */
   int16_t   *dos_time;               /* Adress of the DOS time       */
   int16_t   *dos_date;               /* Adress of the DOS date       */
   int32_t   res1;                    /*                              */
   int32_t   res2;                    /*                              */
   int32_t   res3;                    /* is 0L                        */
   VOID      *act_pd;                 /* Running program              */
   int32_t   res4;                    /*                              */
   int16_t   res5;                    /*                              */
   VOID      *res6;                   /*                              */
   VOID      *res7;                   /* Internal DOS memory list     */
   VOID      (*resv_intmem)();        /* Extend DOS memory            */
   int32_t   (*<a href="bios_sysvars.html#etv_critic">etv_critic</a>)();         /* <a href="bios_sysvars.html#etv_critic">etv_critic</a> of the <a href="gemdos_main.html">GEMDOS</a>     */
   int8_t *  ((*err_to_str)(int8_t e)); /* Conversion code-&gt;plain text */
   VOID      *xaes_appls;             /*                              */
   VOID      *mem_root;               /*                              */
   VOID      *ur_pd;                  /*                              */
} DOSVARS;
</pre>
<p><b>Note:</b> These variables are READ-ONLY !
</p>
<p>With the aid of the function <i>resv_intmem</i> one can reserve
memory for internal memory management (similar to using FOLDRnnnn). In
contrast to TOS however this is stressed far less, so that
extension is not usually necessary. If memory has to be extended,
which also happens with <a href="magic_programs.html#ADDMEM">ADDMEM</a>, then one passes to the function
<i>resv_intmem</i> the address in register A0, and the length of the
memory block to be reserved in register D0.
</p>
<p><b>The prototype for the <i>Event Critic Handler</i> runs:</b>
</p>
<pre>int32_t <a href="bios_sysvars.html#etv_critic">etv_critic</a> (int16_t errcode, int16_t drvnr)
</pre>
<p>Note that the function expects the arguments on the stack, and
hence in <i>Pure-C</i> must be declared as <i>cdecl</i>.
</p>
<p>The function <i>err_to_str</i> expects in register D0 a TOS
error-code, and returns in registers D0 and A0 a pointer to the
descriptive character string. With an invalid error-code one receives
in D0 a NULL, and in A0 a pointer to the character string 'TOS
error'.
</p>
<p>As seen by KAOS 1.4.2 the structure looks like this:
</p>
<pre>typedef struct
{
   int8_t    *in_dos;                 /* Address of the DOS semaphores */
   int16_t   *dos_time;               /* Address of the DOS time       */
   int16_t   *dos_date;               /* Address of the DOS date       */
   int32_t   dos_stack;               /* Stack for DOS itself          */
   int32_t   pgm_superset;            /* User-program super stack      */
   <a href="bios_structures.html#MD">MD</a>        *menlist[3];             /* Address of the 3 <a href="bios_structures.html#MD">MD</a> lists     */
   VOID      *act_pd;                 /* Running program               */
   FCB       *fcbx;                   /* Files                         */
   int16_t   fcbn;                    /* Length of fcbx[]              */
   DMD       *dmdx;                   /* Pointer to 16 DMDs            */
   IMB       *imbx;                   /* Internal DOS memory list      */
   VOID      (*resv_intmem)();        /* Extend DOS memory             */
   int32_t   (*<a href="bios_sysvars.html#etv_critic">etv_critic</a>)();         /* <a href="bios_sysvars.html#etv_critic">etv_critic</a> of the <a href="gemdos_main.html">GEMDOS</a>      */
   int8_t *  ((*err_to_str)(int8_t e)); /* Conversion code-&gt;clear text */
} DOSVARS;
</pre>
<p>See also: <a href="AESVARS.html">AESVARS</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20MagX">Cookie of MagiC</a> &nbsp; <a href="gemdos_system.html#Sconfig">Sconfig</a>
</p>
<h3><a name="DTA">5.24.16 DTA</a></h3>
<p>This structure is defined as follows:
</p>
<pre>typedef struct
{
    int8_t    d_reserved[21];  /* Reserved for <a href="gemdos_main.html">GEMDOS</a> */
    uint8_t   d_attrib;        /* File attributes     */
    uint16_t  d_time;          /* Time                */
    uint16_t  d_date;          /* Date                */
    uint32_t  d_length;        /* File length         */
    int8_t    d_fname[14];     /* Filename            */
} DTA;
</pre>
<p><b>Recursive search in folders</b>
</p>
<p>In each DTA, all required information is stored that is required
after a <a href="gemdos_file.html#Fsfirst">Fsfirst</a> for further <a href="gemdos_file.html#Fsnext">Fsnext</a> calls. That means that one should
never call Fsfirst anew for other directories/wildcards as long as
further Fsnext calls are made in the same directory.
<br>For a recursive search one must use a new DTA for each new Fsfirst,
which must be maintained until all Fsnext for the Fsfirst have been
made. Here an example in pseudo-C:
</p>
<pre>void search_directory (int8_t *pfadname)
{
  DTA_Record local_dta, saved_dta;

  saved_dta = GetDTA ();
  SetDTA (local_dta);

  err = <a href="gemdos_file.html#Fsfirst">Fsfirst</a> (pfadname, ...);
  while (err == 0) {
    if (local_dta.attrib == subdir) {
      // recursive search in sub-dir
      search_directory (subdir-pfadname);
    } else {
      ... evaluate normal file
    }
    err = <a href="gemdos_file.html#Fsnext">Fsnext</a> ();
  }

  SetDTA (saved_dta);
}
</pre>
<p>See also: <a href="gemdos_file.html#Fgetdta">Fgetdta</a> &nbsp; <a href="gemdos_file.html#Fsetdta">Fsetdta</a> &nbsp; <a href="gemdos_file.html#Fsfirst">Fsfirst</a> &nbsp; <a href="gemdos_file.html#Fsnext">Fsnext</a> &nbsp; <a href="gemdos_main.html">GEMDOS</a>
</p>
<h3><a name="fcookie">5.24.17 fcookie</a></h3>
<pre>typedef struct f_cookie
{
    struct filesys *fs; /* File-system that knows this cookie       */
    uint16_t dev;       /* Device info (e.g. <a href="About_the_BIOS.html#Rwabs">Rwabs</a> device number)   */
    uint16_t aux;       /* Further data for the file-system         */
    int32_t  index;     /* Serves together with dev for identifying */
                        /* a file                                   */
} fcookie;
</pre>
<p>See also: <a href="#FILEPTR">FILEPTR</a> &nbsp; <a href="magic_xfs.html#FILESYS">FILESYS</a> &nbsp; <a href="magic_xfs.html">XFS-concept in MagiC</a>
</p>
<h3><a name="FILEPTR">5.24.18 FILEPTR</a></h3>
<pre>typedef struct fileptr
{
    int16_t         links;
    uint16_t        flags;
    int32_t         pos;
    int32_t         devinfo;
    <a href="#fcookie">fcookie</a>         fc;
    struct devdrv  *dev;
    struct fileptr *next;
} FILEPTR;
</pre>
<p>See also: <a href="gemdos_directory.html#Dcntl">Dcntl</a> &nbsp; <a href="magic_xfs.html#DEVDRV">DEVDRV</a>
</p>
<h3><a name="flock_2C_20Fcntl">5.24.19 flock, Fcntl</a></h3>
<pre>struct <a href="bios_sysvars.html#flock">flock</a>
{
    int16_t  l_type;     /* Type of lock                 */
    int16_t  l_whence;   /* SEEK_SET, SEEK_CUR, SEEK_END */
    int32_t  l_start;    /* Start of the locking region  */
    int32_t  l_len;      /* Length of the locking region */
    int16_t  l_pid;      /* PID of the locking process   */
};
</pre>
<p><b>Note:</b> Possible values for l_type are: 0 = Read locking,
1 = Write locking as well as 3 = No locking.
</p>
<h3><a name="iovec">5.24.20 iovec</a></h3>
<pre>struct iovec
{
    char    *iov_base;
    int32_t iov_len;
};
</pre>
<h3><a name="LINE">5.24.21 LINE</a></h3>
<pre>typedef struct
{
    uint8_t   maxlen;        /* Maximum line length */
    uint8_t   actuallen;     /* Current line length */
    int8_t    buffer[255];   /* Line buffer         */
} LINE;
</pre>
<p>See also: <a href="gemdos_chrinout.html#Cconrs">Cconrs</a> &nbsp; <a href="gemdos_main.html">GEMDOS</a>
</p>
<h3><a name="ltchars">5.24.22 ltchars</a></h3>
<pre>struct ltchars
{
    int8_t t_suspc;
    int8_t t_dsuspc;
    int8_t t_rprntc;
    int8_t t_flushc;
    int8_t t_werasc;
    int8_t t_lnextc;
};
</pre>
<p>See also: <a href="#struct_20tty">struct tty</a> &nbsp; <a href="magic_xfs.html">XFS-concept in MagiC</a>
</p>
<h3><a name="msghdr">5.24.23 msghdr</a></h3>
<pre>/* structure used with sendmsg() and recvmsg() */
struct msghdr
{
    struct <a href="#sockaddr">sockaddr</a> *msg_name;
    int32_t         msg_namelen;
    struct <a href="#iovec">iovec</a>    *msg_iov;
    int32_t         msg_iovlen;
    void            *msg_accrights;
    int32_t         msg_accrightslen;
};
</pre>
<h3><a name="mutimbuf">5.24.24 mutimbuf</a></h3>
<pre>struct mutimbuf
{
   uint16_t actime;     /* Access time               */
   uint16_t acdate;     /* Access date               */
   uint16_t modtime;    /* Time of last modification */
   uint16_t moddate;    /* Date of last modification */
};
</pre>
<p>See also: <a href="gemdos_directory.html#Dcntl">Dcntl</a> &nbsp; <a href="gemdos_file.html#Fcntl">Fcntl</a> &nbsp; <a href="gemdos_main.html">GEMDOS</a>
</p>
<h3><a name="Process_20Descriptor_20_28PD_29_20resp._20BASEPAGE">5.24.25 Process Descriptor (PD) resp. BASEPAGE</a></h3>
<a name="PD"></a>
<a name="BASEPAGE"></a>
<pre>typedef struct pd
{
   VOID     *p_lowtpa;      /* Start address of the TPA            */
   VOID     *p_hitpa;       /* First byte after the end of the TPA */
   VOID     *p_tbase;       /* Start address of the program code   */
   int32_t   p_tlen;        /* Length of the program code          */
   VOID     *p_dbase;       /* Start address of the DATA segment   */
   int32_t   p_dlen;        /* Length of the DATA section          */
   VOID     *p_bbase;       /* Start address of the BSS segment    */
   int32_t   p_blen;        /* Length of the BSS section           */
   <a href="#DTA">DTA</a>      *p_dta;         /* Pointer to the default <a href="#DTA">DTA</a>          */
                            /* Warning: Points first to the        */
                            /* command line !                      */
   struct pd *p_parent;     /* Pointer to the basepage of the      */
                            /* calling processes                   */
   int32_t   p_resrvd0;     /* Reserved                            */
   int8_t   *p_env;         /* Address of the environment string   */
   int8_t    p_resrvd1[80]; /* Reserved                            */
   int8_t    p_cmdlin[128]; /* Command line                        */
} PD; /* also: BASEPAGE */
</pre>
<p><b>Note about the command line:</b> The number of characters is
inserted in the first line. The maximum length of the command line
does <i>not</i> amount to 127, but only to 124 characters! (This does
not apply in <a href="magic.html">MagiC</a> as of Version 3 - see <a href="gemdos_argv.html">ARGV procedure</a>).
</p>
<p>See also: <a href="gemdos_main.html">GEMDOS</a> &nbsp; <a href="OSHEADER.html">OSHEADER</a> &nbsp; <a href="gemdos_process.html#Pexec">Pexec</a> &nbsp; <a href="gemdos_tpa.html">Program launch and TPA</a>
</p>
<h3><a name="Poll_20Descriptor">5.24.26 Poll Descriptor</a></h3>
<a name="POLLFD"></a>
<pre>typedef struct pollfd
{
        int32_t  fd;            /* <a href="magic_xfs.html#File_20descriptor">File descriptor</a> to poll */
        uint16_t events;        /* Types of events poller cares about */
        uint16_t revents;       /* Types of events that actually occurred */
} POLLFD;
</pre>
<p>See also: <a href="gemdos_main.html">GEMDOS</a> &nbsp; <a href="gemdos_file.html#Fpoll">Fpoll</a>
</p>
<h3><a name="ploadinfo">5.24.27 ploadinfo</a></h3>
<pre>struct ploadinfo
{
   int16_t fnamelen;  /* Lenght from 'fname'                         */
   int8_t *cmdlin;    /* Command line of the processes (128 bytes)   */
   int8_t *fname;     /* Complete path and filename of the processes */
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl">Fcntl</a> &nbsp; <a href="gemdos_file.html#PLOADINFO">PLOADINFO</a>
</p>
<h3><a name="sgttyb">5.24.28 sgttyb</a></h3>
<pre>struct sgttyb
{
    int8_t   sg_ispeed;
    int8_t   sg_ospeed;
    int8_t   sg_erase;
    int8_t   sg_kill;
    uint16_t sg_flags;
};
</pre>
<p>See also: <a href="#struct_20tty">struct tty</a> &nbsp; <a href="magic_xfs.html">XFS-concept in MagiC</a>
</p>
<h3><a name="struct_20sigaction">5.24.29 struct sigaction</a></h3>
<a name="sigaction"></a>
<p>This structure is defined as follows:
</p>
<pre>struct sigaction
{
   void cdecl (*sa_handler)(int32_t sig);
   int32_t    sa_mask;
   int16_t    sa_flags;
};
</pre>
<p><b>Note:</b> The component <i>sa_handler</i> can assume
various values here. A value of 0 means default signal-handling by the
system, with a value of 1 the signal will be ignored; any other value
will be interpreted as the address of a signal handling routine, which
is then called.
</p>
<p>The component <i>sa_mask</i> contains additionally (to the
signal currently being processed) the signals to be masked during the
signal handling. In that case mask = oldmask+(1&lt;&lt;sig)+sa_mask).
With <i>sa_flags</i> one can influence the behaviour of a signal
further. A value of 1 for <i>sa_flags</i> means in MiNT that the
signal <a href="gemdos_signals.html#SIGCHLD">SIGCHLD</a> is triggered only on termination and not on stopping
the child; other values for <i>sa_flags</i> are not yet defined at
the present time.
</p>
<p>See also: <a href="gemdos_signals.html">Signals</a> &nbsp; <a href="gemdos_signals.html#Signal-handler_20in_20MagiC">Signal-handler in MagiC</a> &nbsp; <a href="gemdos_main.html">GEMDOS</a> &nbsp;
<a href="gemdos_process.html#Psigaction">Psigaction</a> &nbsp; <a href="gemdos_process.html">Process functions</a>
</p>
<h3><a name="sockaddr">5.24.30 sockaddr</a></h3>
<pre>/* generic socket address */
struct sockaddr
{
    int16_t sa_family;
    char    sa_data[14];
};
</pre>
<h3><a name="STAT">5.24.31 STAT</a></h3>
<pre>struct time
{
   int32_t high_time;
   int32_t time;
   uint32_t nanoseconds;
};

typedef struct stat
{
   uint64_t   dev;               /* Device number             */
   uint32_t   ino;               /* File number               */
   uint32_t   mode;              /* File mode, statements for */
                                 /* - possible filetypes      */
                                 /* - special bits            */
                                 /* - access rights           */
   uint32_t   nlink;             /* Number of links           */
   uint32_t   uid;               /* User number               */
   uint32_t   gid;               /* Group number              */
   uint64_t   rdev;              /* Actual device             */
                                 /* (e.g. for <a href="bios_main.html">BIOS</a> files)     */
   struct time atime;            /* time of last access, UTC */
   struct time mtime;            /* time of last data modification, UTC */
   struct time ctime;            /* time of last file status change, UTC */
   int64_t    size;              /* File length               */
   int64_t    blocks;            /* occupied blocks           */
   int32_t    blksize;           /* Blocksize                 */
   uint32_t   flags;             /* user defined flags for file */
   uint32_t   gen;               /* file generation number    */
   int32_t    reserved[7];       /* reserved                  */
} STAT;
</pre>
<p><b>Note:</b> <a href="magic.html">MagiC</a> returns for FAT file-systems the following
index data:
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; Directories:</td>
<td valign="top"> Start cluster in Motorola format
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; Other files:</td>
<td valign="top">
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">High word =</td>
<td valign="top"> Start cluster of the directory
</td></tr>

<tr><td nowrap="nowrap" valign="top">Low word =</td>
<td valign="top"> Position within the directory &gt;&gt; 5

</td></tr>
</table>


</td></tr>
</table>

<p>This procedure is similar to that used by Linux and Solaris. The
drawback is that files alter their index during a move.
</p>
<p>The component <i>index</i> is therefore a LONGword for the
unambiguous identification of a file or a folder. The index must be
unique within a file-system; together with the following field
(<i>dev</i>) it completely pinpoints a file or a folder
system-globally.
</p>
<p>Under UNIX-like file-systems, <i>index</i> is the number of the
Inode.
</p>
<p>On Macintosh partitions, the hard file ID or the hard dir ID
that the MacOS makes available is used. However, the MacOS uses FSSpec
as the standard descriptors. For directories, i.e. for directory IDs,
there are functions of the MacOS to calculate a FSSpec. Unfortunately
the hard file IDs for normal files (i.e. not subdirectories)
<i>cannot</i> continue to be used, as they are not processed by any
function of the MacOS.
</p>
<p>See also: <a href="magic_xfs.html">XFS-concept in MagiC</a> &nbsp; <a href="gemdos_file.html#Fxattr">Fxattr</a> &nbsp; <a href="gemdos_directory.html#Dxreaddir">Dxreaddir</a>
</p>
<h4><a name="STAT_2C_20dev-components">5.24.31.1 STAT, dev-components</a></h4>
<p>Determines the file-system. On the Atari, 0..25 are the <a href="bios_main.html">BIOS</a>
drives A: to Z:, Drive U: or other file-systems use higher numbers. On
the Macintosh the 'volume ID' is used, which is assigned by the MacOS.
</p>
<h4><a name="STAT_2C_20possible_20filetypes">5.24.31.2 STAT, possible filetypes</a></h4>
<a name="Possible_20filetypes"></a>
<p><b>Possible filetypes that can be set or obtained via the <a href="#STAT">STAT</a>
structure:</b>
</p>
<pre>#define S_IFMT   0170000  /* For isolating the filetype */
#define S_IFSOCK 0010000  /* Socket file                */
#define S_IFCHR  0020000  /* Special <a href="bios_main.html">BIOS</a> file          */
#define S_IFDIR  0040000  /* Directory                  */
#define S_IFBLK  0060000  /* Block special file         */
#define S_IFREG  0100000  /* Normal file                */
#define S_IFIFO  0120000  /* FIFO (Pipe with name)      */
#define S_IMEM   0140000  /* Memory block/process file  */
#define S_IFLNK  0160000  /* Symbolic link              */
</pre>
<h4><a name="STAT_2C_20Sticky-bit">5.24.31.3 STAT, Sticky-bit</a></h4>
<p><b>Special bits that can be set or obtained via the <a href="#STAT">STAT</a>
structure:</b>
</p>
<pre>#define S_ISUID 04000  /* Set user ID of the owner */
#define S_ISGID 02000  /* Set group ID at call     */
#define S_ISVTX 01000  /* Sticky-bit               */
</pre>
<p><b>Note:</b> The meaning of the <i>sticky-bit</i> depends on
the filetype.
</p>
<h4><a name="STAT_2C_20size-components">5.24.31.4 STAT, size-components</a></h4>
<p>On <b>DOS partitions</b>, folders return the value 0 as their
length. The actual length unfortunately cannot be ascertained due to
limitations of MSDOS. Only the length of the root directory can be
obtained.
</p>
<p>On <b>Macintosh partitions</b> folders always have the length
0, the actual length cannot be obtained (at least under System 7).
</p>
<h4><a name="STAT_2C_20access_20rights">5.24.31.5 STAT, access rights</a></h4>
<p><b>Possible access rights that can be set or obtained via the
<a href="#STAT">STAT</a> structure:</b>
</p>
<pre>#define S_IRUSR 0400   /* Owner may read file       */
#define S_IWUSR 0200   /* Owner may write           */
#define S_IXUSR 0100   /* Owner members may execute */
#define S_IRGRP 0040   /* Group members may read    */
#define S_IWGRP 0020   /* Group members may write   */
#define S_IXGRP 0010   /* Group members may execute */
#define S_IROTH 0004   /* Others may read file      */
#define S_IWOTH 0002   /* Others may write          */
#define S_IXOTH 0001   /* Others may execute        */
</pre>
<h3><a name="tchars">5.24.32 tchars</a></h3>
<pre>struct tchars
{
    int8_t t_intrc;
    int8_t t_quitc;
    int8_t t_startc;
    int8_t t_stopc;
    int8_t t_eofc;
    int8_t t_brkc;
};
</pre>
<p>See also: <a href="#struct_20tty">struct tty</a> &nbsp; <a href="magic_xfs.html">XFS-concept in MagiC</a>
</p>
<h3><a name="timeval">5.24.33 timeval</a></h3>
<pre>struct timeval
{
  int32_t int tv_sec;
  int32_t int tv_usec;
};
</pre>
<p><i>tv_sec</i> holds the number of seconds elapsed since the
epoch. The epoch is Thu, Jan 1 1970 00:00:00 UTC.
</p>
<p><i>tv_usec</i> holds the fractional part of <i>tv_sec</i>
measured in microseconds.
</p>
<p>Note: seconds-since-the-epoch will overflow the range of a 32bit
int for dates after Tue Jan 19 03:14:07 2038 UTC. It will also
underflow for dates before Fri Dec 13 20:45:52 1901 UTC.
</p>
<h3><a name="timezone">5.24.34 timezone</a></h3>
<pre>struct timezone
{
  int32_t int tz_minuteswest;
  int32_t int tz_dsttime;
};
</pre>
<p><i>tz_minuteswest</i> holds the offset to UTC in seconds.
Timezones east of the zero-meridian (e.g. Eastern Europe) have a
negative offset, timezones west of the zero-meridian (e.g. America)
have a positive one.
</p>
<p><i>tz_dsttime</i> is non-zero if daylight savings time applies
during some part of the year.
</p>
<h3><a name="struct_20tty">5.24.35 struct tty</a></h3>
<pre>struct tty
{
    int16_t         pgrp;
    int16_t         state;
    int16_t         use_cnt;
    int16_t         res1;
    struct <a href="#sgttyb">sgttyb</a>   sg;
    struct <a href="#tchars">tchars</a>   tc;
    struct <a href="#ltchars">ltchars</a>  ltc;
    struct <a href="#winsize">winsize</a>  wsiz;
    int32_t         rsel;
    int32_t         wsel;
    int8_t          *<a href="#xkey">xkey</a>;
    int32_t         hup_ospeed;
    uint16_t        vmin, vtime;
    int32_t         resrvd[1];
};
</pre>
<p>See also: <a href="gemdos_directory.html#Dcntl">Dcntl</a> &nbsp; <a href="magic_xfs.html#dev_descr">dev_descr</a> &nbsp; <a href="magic_xfs.html">XFS-concept in MagiC</a>
</p>
<h3><a name="winsize">5.24.36 winsize</a></h3>
<pre>struct winsize
{
    int16_t  ws_row;
    int16_t  ws_col;
    int16_t  ws_xpixel;
    int16_t  ws_ypixel;
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl">Fcntl</a> &nbsp; <a href="gemdos_file.html#TIOCGWINSZ">TIOCGWINSZ</a>
</p>
<h3><a name="XATTR">5.24.37 XATTR</a></h3>
<pre>typedef struct xattr
{
   uint16_t   mode;              /* File mode, statements for */
                                 /* - possible filetypes      */
                                 /* - special bits            */
                                 /* - access rights           */
   int32_t    index;             /* File number               */
   uint16_t   dev;               /* Device number             */
   uint16_t   rdev;              /* Actual device             */
                                 /* (e.g. for <a href="bios_main.html">BIOS</a> files)     */
                                 /* in <a href="magic.html">MagiC</a> however reserved */
   uint16_t   nlink;             /* Number of links           */
   uint16_t   uid;               /* User number               */
   uint16_t   gid;               /* Group number              */
   int32_t    size;              /* File length               */
   int32_t    blksize, nblocks;  /* Blocksize/occupied blocks */
   uint16_t   mtime, mdate;      /* Date of last modification */
   uint16_t   atime, adate;      /* Date of the last access   */
   uint16_t   ctime, cdate;      /* Creation date             */
   uint16_t   attr;              /* <a href="tos_main.html">TOS</a> file attributes       */
   uint16_t   reserved2;         /* Reserviert                */
   int32_t    reserved3[2];      /* Reserviert                */
} XATTR;
</pre>
<p><b>Note:</b> <a href="magic.html">MagiC</a> returns for FAT file-systems the following
index data:
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; Directories:</td>
<td valign="top"> Start cluster in Motorola format
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; Other files:</td>
<td valign="top">
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">High word =</td>
<td valign="top"> Start cluster of the directory
</td></tr>

<tr><td nowrap="nowrap" valign="top">Low word =</td>
<td valign="top"> Position within the directory &gt;&gt; 5

</td></tr>
</table>


</td></tr>
</table>

<p>This procedure is similar to that used by Linux and Solaris. The
drawback is that files alter their index during a move.
</p>
<p>The component <i>index</i> is therefore a LONGword for the
unambiguous identification of a file or a folder. The index must be
unique within a file-system; together with the following field
(<i>dev</i>) it completely pinpoints a file or a folder
system-globally.
</p>
<p>Under UNIX-like file-systems, <i>index</i> is the number of the
Inode.
</p>
<p>On Macintosh partitions, the hard file ID or the hard dir ID
that the MacOS makes available is used. However, the MacOS uses FSSpec
as the standard descriptors. For directories, i.e. for directory IDs,
there are functions of the MacOS to calculate a FSSpec. Unfortunately
the hard file IDs for normal files (i.e. not subdirectories)
<i>cannot</i> continue to be used, as they are not processed by any
function of the MacOS.
</p>
<p>See also: <a href="magic_xfs.html">XFS-concept in MagiC</a> &nbsp; <a href="gemdos_file.html#Fxattr">Fxattr</a> &nbsp; <a href="gemdos_directory.html#Dxreaddir">Dxreaddir</a>
</p>
<h4><a name="XATTR_2C_20dev-components">5.24.37.1 XATTR, dev-components</a></h4>
<p>Determines the file-system. On the Atari, 0..25 are the BIOS
drives A: to Z:, Drive U: or other file-systems use higher numbers. On
the Macintosh the 'volume ID' is used, which is assigned by the MacOS.
</p>
<h4><a name="XATTR_2C_20possible_20filetypes">5.24.37.2 XATTR, possible filetypes</a></h4>
<p><b><a href="gemdos_structures.html#Possible_20filetypes">Possible filetypes</a> that can be set or obtained via the <a href="#XATTR">XATTR</a>
structure:</b>
</p>
<pre>#define S_IFMT  0170000  /* For isolating the filetype */
#define S_IFCHR 0020000  /* Special <a href="bios_main.html">BIOS</a> file          */
#define S_IFDIR 0040000  /* Directory                  */
#define S_IFREG 0100000  /* Normal file                */
#define S_IFIFO 0120000  /* FIFO (Pipe with name)      */
#define S_IMEM  0140000  /* Memory block/process file  */
#define S_IFLNK 0160000  /* Symbolic link              */
</pre>
<h4><a name="XATTR_2C_20Sticky-bit">5.24.37.3 XATTR, Sticky-bit</a></h4>
<p><b>Special bits that can be set or obtained via the <a href="#XATTR">XATTR</a>
structure:</b>
</p>
<pre>#define S_ISUID 04000  /* Set user ID of the owner */
#define S_ISGID 02000  /* Set group ID at call     */
#define S_ISVTX 01000  /* Sticky-bit               */
</pre>
<p><b>Note:</b> The meaning of the <i>sticky-bit</i> depends on
the filetype.
</p>
<h4><a name="XATTR_2C_20size-components">5.24.37.4 XATTR, size-components</a></h4>
<p>On <b>DOS partitions</b>, folders return the value 0 as their
length. The actual length unfortunately cannot be ascertained due to
limitations of MSDOS. Only the length of the root directory can be
obtained.
</p>
<p>On <b>Macintosh partitions</b> folders always have the length
0, the actual length cannot be obtained (at least under System 7).
</p>
<h4><a name="XATTR_2C_20access_20rights">5.24.37.5 XATTR, access rights</a></h4>
<p><b>Possible access rights that can be set or obtained via the
<a href="#XATTR">XATTR</a> structure:</b>
</p>
<pre>#define S_IRUSR 0400   /* Owner may read file       */
#define S_IWUSR 0200   /* Owner may write           */
#define S_IXUSR 0100   /* Owner members may execute */
#define S_IRGRP 0040   /* Group members may read    */
#define S_IWGRP 0020   /* Group members may write   */
#define S_IXGRP 0010   /* Group members may execute */
#define S_IROTH 0004   /* Others may read file      */
#define S_IWOTH 0002   /* Others may write          */
#define S_IXOTH 0001   /* Others may execute        */
</pre>
<h4><a name="XATTR_2C_20special_20bits">5.24.37.6 XATTR, special bits</a></h4>
<p><b>Special bits that may be set or obtained via the <a href="#XATTR">XATTR</a>
structure:</b>
</p>
<pre>#define S_ISUID 04000  /* Set user ID of the owner */
#define S_ISGID 02000  /* Set group ID at call     */
#define S_ISVTX 01000  /* Sticky-bit               */
</pre>
<p><b>Note:</b> The meaning of <i>sticky-bit</i> depends on the
filetype.
</p>
<h3><a name="xkey">5.24.38 xkey</a></h3>
<pre>struct xkey
{
    int16_t   xk_num;
    int8_t    xk_def[8];
};
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl">Fcntl</a> &nbsp; <a href="gemdos_file.html#TIOCGXKEY">TIOCGXKEY</a>
</p>
<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="gemdos_main.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
<a name="UDO_nav_lf_FOOT" href="gemdos_functions.html"><img src="udo_lf.gif" alt="GEMDOS function list" title="GEMDOS function list" border="0" width="24" height="24">GEMDOS function list</a>
<a name="UDO_nav_rg_FOOT" href="linea_main.html"><img src="udo_rg.gif" alt="Line-A" title="Line-A" border="0" width="24" height="24">Line-A</a>
</body>
</html>
