<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2025/08/02 -->
<html lang="en">
<head>
<title>
The documentation for TOS: Special commands
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_sound.html"><img src="udo_lf.gif" alt="Sound routines" title="Sound routines" border="0" width="24" height="24">Sound routines</a>
<a name="UDO_nav_rg_HEAD" href="xbios_keyboard.html"><img src="udo_rg.gif" alt="Keyboard functions" title="Keyboard functions" border="0" width="24" height="24">Keyboard functions</a>

<hr>

<h1><a name="Special_20commands">4.20 Special commands</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Blitmode">Blitmode</a></td>
<td valign="top"> Gets or changes blitter configuration.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#CacheCtrl">CacheCtrl</a></td>
<td valign="top"> CPU cache management.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#CJar">CJar</a></td>
<td valign="top"> Creates, interrogates and removes cookies.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dbmsg">Dbmsg</a></td>
<td valign="top"> Outputs debug message.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Janus">Janus</a></td>
<td valign="top"> Makes the &quot;<a href="#Janus">Janus</a>&quot; emulator available.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Puntaes">Puntaes</a></td>
<td valign="top"> Switches off <a href="aes_main.html">AES</a> in ROM.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Random">Random</a></td>
<td valign="top"> Generates a random number.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Ssbrk">Ssbrk</a></td>
<td valign="top"> Reserves memory (only used internally).
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Supexec">Supexec</a></td>
<td valign="top"> Starts routine in supervisor-mode.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Trapper">Trapper</a></td>
<td valign="top"> Hooks into system functions.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#WdgCtrl">WdgCtrl</a></td>
<td valign="top"> Sets the hardware watchdog.

</td></tr>
</table>

<p>See Also: <a href="xbios_interface.html">Interface programming</a>
</p>
<h3><a name="Blitmode">4.20.1 Blitmode</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »blitter mode« - Blitter-chip configuration
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 64
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Blitmode( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> Blitmode is an XBIOS routine to switch on the blitter or to
verify its existence. If the parameter <i>mode</i> has the value -1
then one obtains the state of the blitter chip. All other values
configure the blitter:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">Bit</td>
  <td align="left" valign="top">Description</td>
</tr>
<tr>
  <td align="right" valign="top">0</td>
  <td align="left" valign="top">0 = Blitter off</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">1 = Blitter on</td>
</tr>
<tr>
  <td align="right" valign="top">1-14</td>
  <td align="left" valign="top">Reserved</td>
</tr>
<tr>
  <td align="right" valign="top">15</td>
  <td align="left" valign="top">Must always be 0</td>
</tr>
</table>
</div>

<br><b>Note:</b> According to Atari the function may be used
without checking the TOS version (although it is not present in
TOS 1.0, for instance). This is possible due to a side-effect in
the <a href="the_system_vectors.html#Dispatcher_2C_20XBIOS">dispatcher of the XBIOS</a>. However, it is better not to rely on this, as the
corresponding trap may be diverted by other programs, so that the
correct value may not be returned.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the properties of the blitter chip by the
set bits:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">Bit</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">0: Blitter off</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">1: Blitter on</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">0: Blitter not present</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">1: Blitter present</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">15</td>
  <td align="left" valign="top">Always 0</td>
</tr>
</table>
</div>

<br>All further bits are reserved.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Officially this function is present only as of TOS Version
1.02.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20Blitmode">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Blitmode">4.20.1.1 Bindings for Blitmode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Blitmode">Blitmode</a>( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)   ; Offset 2
move.w    #64,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="CacheCtrl">4.20.2 CacheCtrl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »CacheCtrl« - CPU cache management
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 160
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t CacheCtrl( int16_t OpCode, int16_t Param );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine CacheCtrl serves for the management of the
CPU cache.
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">OpCode</td>
  <td align="left" valign="top">Description</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Return 0 to check that function is implemented</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Flush data cache</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Flush instruction cache</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">Flush data and instruction cache</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">Inquire data cache mode</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">Activation/deactivation of the data cache</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 0, switch off</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 1, switch on</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top">Write-back of the caches if necessary</td>
</tr>
<tr>
  <td align="center" valign="top">6</td>
  <td align="left" valign="top">Inquire instruction cache mode</td>
</tr>
<tr>
  <td align="center" valign="top">7</td>
  <td align="left" valign="top">Activation/deactivation of the command cache</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 0, switch off</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top"><i>Param</i>= 1, switch on</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;&nbsp;</td>
  <td align="left" valign="top">Write-back of the caches if necessary</td>
</tr>
</table>
</div>

<br><b>Note:</b>
<br>Under the CT60 XBIOS, OpCode 5/7 has the same effect :
<br><i>Param</i>: 0 = disable all caches.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 = enable all caches.
<br>All caches are: Data cache, store buffer, branch cache,
instruction cache.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> If successful the function returns the value 0, or <a href="bios_errors.html#EBADRQ">EBADRQ</a> when
a value larger than seven is passed for <i>OpCode.</i>
<br>&nbsp;
<br>As an alternative the driver &quot;CPU Cache Control Driver
v1.10&quot; by Robert Federle and Thomas Tempelmann is available for
other computers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function ist available on the Milan from TOS 4.06, in
CT60 XBIOS as of Version v0.98a.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20CacheCtrl">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20CacheCtrl">4.20.2.1 Bindings for CacheCtrl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#CacheCtrl">CacheCtrl</a>( int16_t OpCode, int16_t Param );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    Param,-(sp)  ; Offset 4
move.w    OpCode,-(sp) ; Offset 2
move.w    #160,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="CJar">4.20.3 CJar</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »CJar« - Creation, interrogation and removal of cookies
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 17226 (0x434A)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t CJar( int16_t mode, int32_t cookie, int32_t *value );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine CJar offers a simple way of creating,
interrogating and removing cookies.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> Mode 0:
<br>Obtains the value of a cookie and stores it at the specified
address. If one passed a NULL-pointer for <i>value</i>, then only the
existence of the cookie will be checked. If presence of the cookie is
established, the call returns 0x6172 (=&quot;CJar_OK&quot;), or a
different value otherwise.
<br>Mode 1:
<br>Creates a new cookie. In this case, <i>value</i> points to a
longword whose contents are copied into the cookie jar. If
<i>value</i> is NULL (zero), then a value of zero is entered into the
cookie jar. If the cookie already exists, the old value is
overwritten.
<br>This mode returns $6172 (=&quot;CJar_OK&quot;) if the addition was
successful or -1 if the addition failed due to lack of room in the
cookie jar.
<br>Mode 2:
<br>Removes the cookie <i>cookie</i> from the jar. The value of
<i>value</i> is immaterial. If the removal was successful the return
will be &quot;CJar_OK&quot;, or another value otherwise.
<br>Is only available if the system extension Liberty (cookie
'Lity') is <a href="xbios_sound.html#installed">installed</a>.
</td></tr>

<tr><td nowrap="nowrap" valign="top">cookie</td>
<td valign="top"> Cookie identifier
</td></tr>

<tr><td nowrap="nowrap" valign="top">value</td>
<td valign="top"> Address of the buffer in which the data is to be stored.

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> If successful the function returns the value CJar_OK (0x6172).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available when the cookie 'CJar' ($434A6172) is
present. This is created by JARxxx (Cookie Jar Manager) or by Liberty.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20CJar">Binding</a> &nbsp; <a href="gemdos_system.html#S_GETCOOKIE">Cookie function</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20CJar">4.20.3.1 Bindings for CJar</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#CJar">CJar</a>( int16_t mode, int32_t cookie, int32_t *value );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       value          ; Offset 8
move.l    cookie,-(sp)   ; Offset 4
move.w    mode,-(sp)     ; Offset 2
move.w    #17226,-(sp)   ; Offset 0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dbmsg">4.20.4 Dbmsg</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dbmsg« - Output debug message
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 11
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dbmsg( int16_t rsrvd, int16_t msg_num, int32_t msg_arg )
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> Dbmsg allows special debugging messages to be sent to a
resident debugger application.
<br>&nbsp;
<br><i>srsrvd</i> is currently reserved and should always be 5.
<br>&nbsp;
<br><i>msg_num</i> is the message number which you want to send to
the debugging host. Values of 0x0000 to 0xEFFF are reserved for
applications to define. Values of 0xF000 to 0xFFFF are reserved for
special debugging messages. If <i>msg_num</i> is in the application
defined range, it and the int32_t contained in <i>msg_arg</i> will be
displayed by the debugger and the application will be halted. If
<i>msg_num</i> is between 0xF001 and 0xF0FF inclusive then
<i>msg_arg</i> is interpreted as a character pointer pointing to a
string to be output by the debugger and debugging to halt. The string
length is determined by the low byte of <i>msg_num</i>.
<br>&nbsp;
<br>If <i>msg_num</i> is DB_NULLSTRING (0xF000), the string will be
output until a NULL is reached.
<br>&nbsp;
<br>If <i>msg_num</i> is DB_COMMAND (0xF100), <i>msg_arg</i> is
interpreted as a character pointer to a string containing a debugger
command. The command format is specific to the debugger which you are
running. A useful example of this format when running under the Atari
debugger allows a string to be output to the debugger without
terminating debugging as shown in the following example:
<br>&nbsp;
<br>Dbmsg( 5, DB_COMMAND, &quot;echo 'Debugging <a href="proto_ssp.html#Message">Message</a>';g&quot; );
<br>&nbsp;
<br>The Atari Debugger only understands the value DB_COMMAND
(0xF100) for <i>msg_num</i> as of version 3. Though it is normally
harmless to run an application with embedded debugging messages when
no debugger is present in the system, distribution versions of
applications should have these instructions removed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Only if a resident debugger was loaded, which supports this
call. The only debugger that currently supports this call is the Atari
debugger.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dbmsg">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dbmsg">4.20.4.1 Bindings for Dbmsg</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dbmsg">Dbmsg</a>( int16_t rsrvd, int16_t msg_num, int32_t msg_arg )
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    msg_arg,-(sp)  ; Offset 6
move.w    msg_num,-(sp)  ; Offset 4
move.w    srsrvd,-(sp)   ; Offset 2
move.w    #11,-(sp)      ; Offset 0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Janus">4.20.5 Janus</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Janus« - Make the &quot;Janus&quot; emulator available.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 43
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Janus( int16_t mode )
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function makes the hardware emulator &quot;Janus&quot;
available. According to an article in <i>ST-Computer</i> 1996-04 p.
44, the following may be achieved with this:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">mode</td>
  <td align="left" valign="top">Description</td>
</tr>
<tr>
  <td align="right" valign="top">-1</td>
  <td align="left" valign="top">Obtain the active parallel port</td>
</tr>
<tr>
  <td align="right" valign="top">1</td>
  <td align="left" valign="top">Switch to first parallel port</td>
</tr>
<tr>
  <td align="right" valign="top">2</td>
  <td align="left" valign="top">Switch to second parallel port</td>
</tr>
<tr>
  <td align="right" valign="top">256</td>
  <td align="left" valign="top">Quit Janus</td>
</tr>
</table>
</div>

<br><b>Note:</b> All statements without any guarantees, as the
article is not very detailed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Unknown, or see above.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Only with hardware emulator Janus.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20Janus">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Janus">4.20.5.1 Bindings for Janus</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Janus">Janus</a>( int16_t mode )
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)    ; Offset 2
move.w    #43,-(sp)     ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Puntaes">4.20.6 Puntaes</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »punt AES« - Switch off <a href="aes_main.html">AES</a> in ROM
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 39
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Puntaes( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function Puntaes switches off the <a href="aes_main.html">AES</a> part of the
operating system. The <a href="aes_main.html">AES</a> will start only if the &quot;os_magic&quot;
in <a href="OSHEADER.html">OSHEADER</a> has the magic number 0x87654321. Puntaes sets the flag
back (if possible) and reboots the system. Note that the call is only
valid with disk-loaded <a href="aes_main.html">AES</a>'s.
<br>&nbsp;
<br><b>Hint:</b> Ab <a href="magic.html">MagiC</a> 4.00 wurde diese Funktion verändert und
besitzt verschiedene Unterfunktionen. Zum Aufruf muss zusätzlich der
Wert 'AnKr' übergeben werden. Bei einer falschen Funktionsnummer wird
<a href="gemdos_errors.html#EINVFN">EINVFN</a> zurückgeliefert.
<br>&nbsp;
<br>int32_t Puntaes ( 'AnKr', subfn, ... )
<br>
<br>&nbsp;
<ul>
<li><p> int32_t Puntaes ( 'AnKr', 0 )
<br>System beenden und zurück zum MacOS bzw. Windows
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 1, int16_t keycode )
<br>Wandle folgenden Alt-Tastencode in ASCII u.
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 2 )
<br>Neustart (warm_boot, nur für Atari)
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 3 )
<br>Kaltstart (cold_boot, nur für Atari)
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 4, int32_t key ) seit 12.04.1998
<br>Ermittle Cookie
<br>Liefert den Zeiger des Cookies <i>key</i> oder 0L wenn er nicht
vorhanden ist.
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 5 )
<br>Date2str: initialisiert die interne Variable datemode von <a href="magic.html">MagiC</a>
und liefert einen Zeiger auf die interne Funktion date2str.
<br>&nbsp;
<br>void date2str ( int8_t *s, int16_t date );
<br>DOS-Datum in eine Zeichenkette umwandeln.
<br>&nbsp;
</p></li>
<li><p> int32_t Puntaes ( 'AnKr', 6, vtsys *pointer )
<br>VT52 anmelden, alten Vektor zurückgeben. Ist <i>pointer</i> -1
dann wird nur der alte Vektor zurückgeliefert, bei 0 wird er
gelöscht.
<br>&nbsp;
</p></li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Die Funktion liefert kein Ergebnis.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20Puntaes">Binding</a> &nbsp; <a href="gemdos_system.html#S_GETCOOKIE">Cookie function</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Puntaes">4.20.6.1 Bindings for Puntaes</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Puntaes">Puntaes</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #39,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Random">4.20.7 Random</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »random generator« - Random number generator
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 17
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Random( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Random returns a 24-bit random number (based
on a clock in the computer).
<br>&nbsp;
<br><b>Note:</b> With this function we are <i>not</i> dealing with
a hardware random number generator, but with a software version, which
uses the following algorithm:
<br>&nbsp;
<pre>X = (X * 3.1415926...) + 1
</pre>
<br>The return value is X shifted by 8 bits to the right, i.e. using
the lower three bytes of the returned int32_t. Incidentally, the
behaviour for the complete number is pretty good, the inquiry of
individual bits in the sense of reduced randomness is however
<i>not</i> advisable.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a 24-bit random number.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20Random">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Random">4.20.7.1 Bindings for Random</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#Random">Random</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #17,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Ssbrk">4.20.8 Ssbrk</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set memory break point« - Reserve memory
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 1
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void *Ssbrk( int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Ssbrk reserves memory at the top of RAM. The
number of bytes must be passed in <i>count.</i> This function must be
called prior to the initialization of <a href="gemdos_about.html">GEMDOS</a>, and should therefore
<i>not</i> be used by application programs. In all the Atari ROM
versions this function is implemented only as a dummy routine.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the start address of the allocated memory
segment.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20Ssbrk">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Ssbrk">4.20.8.1 Bindings for Ssbrk</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void *<a href="#Ssbrk">Ssbrk</a>( int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)  ; Offset 2
move.w    #1,-(sp)     ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Supexec">4.20.9 Supexec</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »supervisor execute« - Start routine in supervisor-mode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 38
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Supexec( int32_t (*func)( ) );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Supexec executes a user-defined routine in
supervisor-mode. <i>func</i> is the address of the function to be
called in supervisor-mode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the int32_t value returned by the user
function.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20Supexec">Binding</a> &nbsp; <a href="gemdos_system.html#Super">Super</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Supexec">4.20.9.1 Bindings for Supexec</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#Supexec">Supexec</a>( int32_t (*func)( ) );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       func         ; Offset 2
move.w    #38,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Trapper">4.20.10 Trapper</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Trapper« - Hook into system functions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 555
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t <a href="xbios_trap.html#xbios">xbios</a>( 555, int16_t layer, int16_t install, int16_t
opcode, void *function );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> With the aid of Trapper, other programs can hook themselves
simply and effectively before and after system calls - even completely
replace them - or add new system calls to the system.
<br>&nbsp;
<br>With Trapper we are dealing with an external program!
<br>&nbsp;
<br>More information in the instructions to be found there.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only present on computers on which the program
Trapper has been <a href="xbios_sound.html#installed">installed</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20Trapper">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Trapper">4.20.10.1 Bindings for Trapper</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="xbios_trap.html#xbios">xbios</a>( 555, int16_t layer, int16_t install, int16_t
opcode, void *function );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea (a2)                  ; <a href="tos_main.html">TOS</a> does not save A2 in traps
move.l    function,-(sp)  ; Offset 8
move.w    opcode,-(sp)    ; Offset 6
move.w    install,-(sp)   ; Offset 4
move.w    layer,-(sp)     ; Offset 2
move.w    #555,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp       ; Correct stack
move.l    (sp)+,a2        ; restore A2
</pre>

</td></tr>
</table>

<h3><a name="WdgCtrl">4.20.11 WdgCtrl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »WdgCtrl« - Set the hardware watchdog.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 161
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t WdgCtrl ( int16_t OpCode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function disables or activates the hardware watchdog.
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Value</td>
</tr>
<tr>
  <td align="left" valign="top">OpCode</td>
  <td align="left" valign="top">0x0000 - Return 0 to check that WdgCtrl is</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;present</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0x1234 - Enable watchdog</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0xdead - Disable watchdog</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0x4242 - Re-trigger watchdog</td>
</tr>
</table>
</div>

<br><b>Note:</b> The function is only meant for the hardware of the
Milan 2.1. The version however exists only as a special version and is
not freely available.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a> (0)</td>
<td valign="top"> - OK
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="bios_errors.html#EUNDEV">EUNDEV</a> (-15)</td>
<td valign="top"> - No watchdog present
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="bios_errors.html#EBADRQ">EBADRQ</a> (-5)</td>
<td valign="top"> - Unimplemented OpCode

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is present from MilanTOS with the date 2002-06-09
onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Special_20commands">Special commands</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20WdgCtrl">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20WdgCtrl">4.20.11.1 Bindings for WdgCtrl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">
<br>&nbsp;
<br>int32_t <a href="#WdgCtrl">WdgCtrl</a> ( int16_t OpCode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea (a2)                  ; <a href="tos_main.html">TOS</a> does not save A2 in traps
move.w    OpCode,-(sp)    ; Offset 2
move.w    #161,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       4(sp),sp        ; Correct stack
move.l    (sp)+,a2        ; restore A2
</pre>

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_sound.html"><img src="udo_lf.gif" alt="Sound routines" title="Sound routines" border="0" width="24" height="24">Sound routines</a>
<a name="UDO_nav_rg_FOOT" href="xbios_keyboard.html"><img src="udo_rg.gif" alt="Keyboard functions" title="Keyboard functions" border="0" width="24" height="24">Keyboard functions</a>
</body>
</html>
