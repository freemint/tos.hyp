<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2025/08/02 -->
<html lang="en">
<head>
<title>
The documentation for TOS: PCI-BIOS
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_overscan.html"><img src="udo_lf.gif" alt="OverScan XBIOS extension" title="OverScan XBIOS extension" border="0" width="24" height="24">OverScan XBIOS extension</a>
<a name="UDO_nav_rg_HEAD" href="xbios_interface.html"><img src="udo_rg.gif" alt="Interface programming" title="Interface programming" border="0" width="24" height="24">Interface programming</a>

<hr>

<h1><a name="PCI-BIOS">4.17 PCI-BIOS</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#bus_to_virt">bus_to_virt</a></td>
<td valign="top"> Convert PCI bus to virtual address
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_byte">fast_read_config_byte</a></td>
<td valign="top"> Read configuration byte fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_longword">fast_read_config_longword</a></td>
<td valign="top"> Read configuration longword fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_config_word">fast_read_config_word</a></td>
<td valign="top"> Read configuration word fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_io_byte">fast_read_io_byte</a></td>
<td valign="top"> Read IO byte fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_io_longword">fast_read_io_longword</a></td>
<td valign="top"> Read IO longword fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_io_word">fast_read_io_word</a></td>
<td valign="top"> Read IO word fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_mem_byte">fast_read_mem_byte</a></td>
<td valign="top"> Read memory byte fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_mem_longword">fast_read_mem_longword</a></td>
<td valign="top"> Read memory longword fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#fast_read_mem_word">fast_read_mem_word</a></td>
<td valign="top"> Read memory word fast
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#find_pci_classcode">find_pci_classcode</a></td>
<td valign="top"> Find PCI class code
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#find_pci_device">find_pci_device</a></td>
<td valign="top"> Find PCI device
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_card_used">get_card_used</a></td>
<td valign="top"> Get card used flag
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_machine_id">get_machine_id</a></td>
<td valign="top"> Get machine ID
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_pagesize">get_pagesize</a></td>
<td valign="top"> Get pagesize
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_resource">get_resource</a></td>
<td valign="top"> Get resource Data
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#get_routing">get_routing</a></td>
<td valign="top"> Get interrupt routing options
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#hook_interrupt">hook_interrupt</a></td>
<td valign="top"> Hook interrupt vector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#phys_to_virt">phys_to_virt</a></td>
<td valign="top"> Convert physical CPU to virtual address
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_byte">read_config_byte</a></td>
<td valign="top"> Read configuration byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_longword">read_config_longword</a></td>
<td valign="top"> Read configuration longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_config_word">read_config_word</a></td>
<td valign="top"> Read configuration word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_io_byte">read_io_byte</a></td>
<td valign="top"> Read IO byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_io_longword">read_io_longword</a></td>
<td valign="top"> Read IO longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_io_word">read_io_word</a></td>
<td valign="top"> Read IO word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_mem_byte">read_mem_byte</a></td>
<td valign="top"> Read memory byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_mem_longword">read_mem_longword</a></td>
<td valign="top"> Read memory longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#read_mem_word">read_mem_word</a></td>
<td valign="top"> Read memory word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#set_card_used">set_card_used</a></td>
<td valign="top"> Set card used flag
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#set_interrupt">set_interrupt</a></td>
<td valign="top"> Set hardware interrupt
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#special_cycle">special_cycle</a></td>
<td valign="top"> Generates special cycle
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#unhook_interrupt">unhook_interrupt</a></td>
<td valign="top"> Unhook interrupt vector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#virt_to_bus">virt_to_bus</a></td>
<td valign="top"> Convert virtual to PCI bus address
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#virt_to_phys">virt_to_phys</a></td>
<td valign="top"> Convert virtual to physical CPU address
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_byte">write_config_byte</a></td>
<td valign="top"> Write configuration byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_longword">write_config_longword</a></td>
<td valign="top"> Write configuration longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_config_word">write_config_word</a></td>
<td valign="top"> Write configuration word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_io_byte">write_io_byte</a></td>
<td valign="top"> Write IO byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_io_longword">write_io_longword</a></td>
<td valign="top"> Write IO longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_io_word">write_io_word</a></td>
<td valign="top"> Write IO word
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_mem_byte">write_mem_byte</a></td>
<td valign="top"> Write memory byte
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_mem_longword">write_mem_longword</a></td>
<td valign="top"> Write memory longword
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#write_mem_word">write_mem_word</a></td>
<td valign="top"> Write memory word

</td></tr>
</table>

<p>See also: <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20_PCI">Cookie _PCI</a> &nbsp; <a href="bios_cookiejar.html#Cookie_2C_20XPCI">Cookie XPCI</a>
</p>
<h3><a name="bus_to_virt">4.17.1 bus_to_virt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Bus to virtual« - Convert PCI bus to virtual address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 340
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t bus_to_virt (int32_t handle, uint32_t address, uint32_t
*pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function converts from PCI bus addresses to virtual
addresses (as the CPU uses them). This is necessary since the memory
may be mapped non-linear by the PMMU even when not using virtual
memory (it is on the MILAN).
<br>&nbsp;
<br>It is required that a resource (ie. a region of memory or IO
space on a PCI card) is mapped contiguously, so that a simple offset
can be used when copying to/from memory on a PCI card.
<br>&nbsp;
<br>This function might be limited to TOS or TOS-like
operating systems. If an operating system uses a different memory
layout, it may need to provide its own functions which drivers can
use.
<br>&nbsp;
<br>When using this function, the driver does not need to care about
DMA offsets at all.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> PCI bus address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">pointer</td>
<td valign="top"> Pointer to mem-struct for results
<br>&nbsp;

</td></tr>
</table>

<br><b>Note:</b> This function is the reverse of <a href="#virt_to_bus">virt_to_bus</a>. It
might be slow, so the driver should avoid using it if it can determine
the address by other means.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>. If successful, mem-struct is filled as follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> CPU (virtual) address
</td></tr>

<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> length of contiguous mapped area

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20bus_to_virt">Binding</a> &nbsp; <a href="#get_pagesize">get_pagesize</a> &nbsp; <a href="#phys_to_virt">phys_to_virt</a> &nbsp; <a href="#virt_to_bus">virt_to_bus</a> &nbsp;
<a href="#virt_to_phys">virt_to_phys</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20bus_to_virt">4.17.1.1 Bindings for bus_to_virt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#bus_to_virt">bus_to_virt</a> (int32_t handle, uint32_t address, uint32_t
*pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 10
move.l    address,-(sp) ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #340,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_byte">4.17.2 fast_read_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration byte fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 305
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int8_t fast_read_config_byte (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Register number (0,1,2,... for byte access)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS 2.0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_config_byte">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_byte">4.17.2.1 Bindings for fast_read_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int8_t <a href="#fast_read_config_byte">fast_read_config_byte</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #305,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_longword">4.17.3 fast_read_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration longword fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 307
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t fast_read_config_longword (int32_t handle, uint8_t
reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Register number (0,4,8,... for longword access)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_longword">4.17.3.1 Bindings for fast_read_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#fast_read_config_longword">fast_read_config_longword</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #307,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_config_word">4.17.4 fast_read_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration word fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 306
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t fast_read_config_word (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads data from the PCI configuration space of a
given card. It does only minimal error checking and is meant to be
used only when access to configuration space is needed in interrupt
handlers.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">reg</td>
<td valign="top"> Register number (0,2,4,... for Word access)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_config_word">4.17.4.1 Bindings for fast_read_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#fast_read_config_word">fast_read_config_word</a> (int32_t handle, uint8_t reg);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #306,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_io_byte">4.17.5 fast_read_io_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO byte fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 331
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> uint8_t fast_read_io_byte (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function is alternative for the normal IO read function.
It returns the read value in D0 and returns no error code, which makes
it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Read data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_io_byte">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp; <a href="#fast_read_io_word">fast_read_io_word</a> &nbsp;
<a href="#read_io_longword">read_io_longword</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_io_byte">4.17.5.1 Bindings for fast_read_io_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint8_t <a href="#fast_read_io_byte">fast_read_io_byte</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #331,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_io_longword">4.17.6 fast_read_io_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO longword fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 333
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> uint32_t fast_read_io_longword (int32_t handle, uint32_t
offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function is alternative for the normal IO read function.
It returns the read value in D0 and returns no error code, which makes
it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Read data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_io_longword">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp;
<a href="#fast_read_io_word">fast_read_io_word</a> &nbsp; <a href="#read_io_longword">read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_io_longword">4.17.6.1 Bindings for fast_read_io_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint32_t <a href="#fast_read_io_longword">fast_read_io_longword</a> (int32_t handle, uint32_t
offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #333,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_io_word">4.17.7 fast_read_io_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO word fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 332
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> uint16_t fast_read_io_word (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function is alternative for the normal IO read function.
It returns the read value in D0 and returns no error code, which makes
it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Read data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_io_word">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp;
<a href="#read_io_longword">read_io_longword</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_io_word">4.17.7.1 Bindings for fast_read_io_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint16_t <a href="#fast_read_io_word">fast_read_io_word</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #332,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_mem_byte">4.17.8 fast_read_mem_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory byte fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 322
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> uint8_t fast_read_mem_byte (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function is alternative for the normal memory read
function. It returns the read value in D0 and returns no error code,
which makes it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Read data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_mem_byte">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp; <a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp;
<a href="#read_mem_longword">read_mem_longword</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_mem_byte">4.17.8.1 Bindings for fast_read_mem_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint8_t <a href="#fast_read_mem_byte">fast_read_mem_byte</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #322,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_mem_longword">4.17.9 fast_read_mem_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory longword fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 324
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> uint32_t fast_read_mem_longword (int32_t handle, uint32_t
offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function is alternative for the normal memory read
function. It returns the read value in D0 and returns no error code,
which makes it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Read data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_mem_longword">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp;
<a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_mem_longword">4.17.9.1 Bindings for fast_read_mem_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint32_t <a href="#fast_read_mem_longword">fast_read_mem_longword</a> (int32_t handle, uint32_t
offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #324,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="fast_read_mem_word">4.17.10 fast_read_mem_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory word fast«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 323
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> uint16_t fast_read_mem_word (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function is alternative for the normal memory read
function. It returns the read value in D0 and returns no error code,
which makes it easier to use in C.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Read data.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20fast_read_mem_word">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp;
<a href="#read_mem_longword">read_mem_longword</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20fast_read_mem_word">4.17.10.1 Bindings for fast_read_mem_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>uint16_t <a href="#fast_read_mem_word">fast_read_mem_word</a> (int32_t handle, uint32_t offset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #323,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="find_pci_classcode">4.17.11 find_pci_classcode</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »find_pci_classcode« - Returns a device handle for a device
that matches the given class code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 301
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t find_pci_classcode( int32_t classcode, int16_t index );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This functions returns a device handle for a device that
matches the given class code.
<br>&nbsp;
<br>A driver can query multiple devices with the same class code by
starting with index = 0,1,2,... and calling this function until
<a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> is returned.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">classcode</td>
<td valign="top"> class code in bits 23..0
<br>
<br>&nbsp;
<br>Bit 23 ..16 Base class (0 - $FF)
<br>Bit 15 .. 8 Sub class (0 - $FF)
<br>Bit 7 .. 0 Programming Interface (0 - $FF)
<br>&nbsp;
<br>Mask in bits 26..24
<br>Bit 26: (0: compare base class, 1: ignore it)
<br>Bit 25: (0: compare sub class, 1: ignore it)
<br>Bit 24: (0: compare Progr. Interface, 1: ignore it)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"> index of card (0 - number of cards with these IDs)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Device handle for a device or <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20find_pci_classcode">Binding</a> &nbsp; <a href="#find_pci_device">find_pci_device</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20find_pci_classcode">4.17.11.1 Bindings for find_pci_classcode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#find_pci_classcode">find_pci_classcode</a>( int32_t classcode, int16_t index );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    index,-(sp)       ; Offset 6
move.l    classcode,-(sp)   ; Offset 2
move.w    #301,-(sp)        ; Offset 0
trap      #14               ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp             ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="find_pci_device">4.17.12 find_pci_device</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »find_pci_device« - Returns a device handle for a device that
matches the given device and vendor ID.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 300
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t find_pci_device( int32_t id, int16_t index);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This functions returns a device handle for a device that
matches the given device and vendor ID. A driver can query multiple
devices with the same device and vendor ID by starting with index =
0,1,2,... and calling this function until <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a> is
returned.
<br>&nbsp;
<br>As a special case, Vendor ID $FFFF can be used to query all
cards found in the system, the specified Device ID is ignored in that
case.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">id</td>
<td valign="top"> Device ID in bits 31..16 (0 - $FFFF)
<br>Vendor ID in bits 15..0 (0 - $FFFE)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">index</td>
<td valign="top"> <a href="indexudo.html">Index</a> of card (0 - number of cards with these IDs)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Device handle for a device or <a href="PCI_BIOS.html#PCI_DEVICE_NOT_FOUND">PCI_DEVICE_NOT_FOUND</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS V2.00
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20find_pci_device">Binding</a> &nbsp; <a href="#find_pci_classcode">find_pci_classcode</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20find_pci_device">4.17.12.1 Bindings for find_pci_device</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#find_pci_device">find_pci_device</a>( int32_t id, int16_t index);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    index,-(sp)  ; Offset 6
move.l    id,-(sp)     ; Offset 2
move.w    #300,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="get_card_used">4.17.13 get_card_used</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get card used flag«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 317
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t get_card_used (int32_t handle, uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function is used to manage which card is in use by which
driver. A driver can provide a means by which a call-back function can
be called from another driver to deactivate this driver. This is
necessary for the first driver to unhook from interrupt chains etc.,
before the new driver can take over.
<br>&nbsp;
<br>The returned status is either 0 (the card is free), 1 (the card
is in use), 2 (the card is in use, but the driver can be uninstalled)
or 3 (the card is in use, but can be taken over without further
actions).
<br>&nbsp;
<br>Case 3 means that the driver which brought the card to this
state may not hook into interrupt chains or other system resources
which need to be unhooked when another driver takes over the card.
<br>&nbsp;
<br>If the return code is 2, the call-back function entry of the
driver is returned in the memory pointer to by <i>address</i>.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> Pointer to longword where call-back address is stored
<br>&nbsp;

</td></tr>
</table>

<br><b>Call-back handlers:</b> Call-back functions are invoked by
calling the call-back entry point, they return with RTS. Call-back
functions may only modify those registers which are used to pass
arguments or results. Call-back functions must be called in supervisor
mode with at least 1024 bytes stack available. The call-back function
number is passed in D0.L. If the driver supports call-back functions,
the following functions are mandatory:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Call-back</td>
<td valign="top"> Description
</td></tr>

<tr><td nowrap="nowrap" valign="top">Get Driver ID (0)</td>
<td valign="top"> call_back0:
<br>Input: D0.L = call-back function number, ie. 0
<br>Output: D0.L = driver ID (same as the driver's XBRA ID)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Try to remove driver (1)</td>
<td valign="top"> call_back1:
<br>Input: D0.L = call-back function number, ie. 1
<br>Output: D0.L = result code: 0=success (card is free), 1=can't
uninstall

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20get_card_used">Binding</a> &nbsp; <a href="#set_card_used">set_card_used</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_card_used">4.17.13.1 Bindings for get_card_used</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_card_used">get_card_used</a> (int32_t handle, uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #317,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="get_machine_id">4.17.14 get_machine_id</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Machine ID«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 337
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t get_machine_id ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function can be used to get a unique machine ID for the
computer the driver is running on.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Machine ID, or 0 (no ID available), <a href="#PCI-BIOS">PCI-BIOS</a> error-codes
<br>&nbsp;
<br>Positive, non-zero values are machine IDs. They contain a
manufacturer code in bit 24..31 and a unique serial number which is
set by the manufacturer during production in bit 0..23.
<br>&nbsp;
<br>The following manufacturer codes are defined:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">Medusa/Hades</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">Milan</td>
</tr>
<tr>
  <td align="left" valign="top">2</td>
  <td align="left" valign="top">PAK/Panther 2</td>
</tr>
<tr>
  <td align="left" valign="top">3</td>
  <td align="left" valign="top">ARAnyM</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20get_machine_id">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_machine_id">4.17.14.1 Bindings for get_machine_id</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_machine_id">get_machine_id</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #337,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="get_pagesize">4.17.15 get_pagesize</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Pagesize«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 338
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t get_pagesize ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function can be used to get the active pagesize.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Active pagesize, or 0 (paging is not active), <a href="#PCI-BIOS">PCI-BIOS</a>
error-codes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20get_pagesize">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_pagesize">4.17.15.1 Bindings for get_pagesize</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_pagesize">get_pagesize</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #338,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="get_resource">4.17.16 get_resource</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Resource Data«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 316
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t get_resource ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top">
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Pointer to array of resource descriptors or <a href="#PCI-BIOS">PCI-BIOS</a>
error-codes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20get_resource">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_resource">4.17.16.1 Bindings for get_resource</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_resource">get_resource</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #316,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="get_routing">4.17.17 get_routing</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get Interrupt Routing Options«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 314
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t get_routing ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> To be defined. Not for use by device drivers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a> error-codes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20get_routing">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20get_routing">4.17.17.1 Bindings for get_routing</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#get_routing">get_routing</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)    ; Offset 2
move.w    #314,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp           ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="hook_interrupt">4.17.18 hook_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Hook Interrupt Vector«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 311
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t hook_interrupt (int32_t handle, uint32_t *routine,
uint32_t *parameter);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function hooks the driver into the interrupt chain to
which a specific interrupt on the given card is routed. The interrupt
is enabled on the system level, however, it is the drivers
responsibility to enable the interrupt on the card as needed.
<br>&nbsp;
<br>The driver should first hook into the interrupt chain, and then
enable the interrupt on the card, in order not to cause spurious
interrupts.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">routine</td>
<td valign="top"> Pointer to interrupt handler
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">parameter</td>
<td valign="top"> Parameter for interrupt handler
<br>&nbsp;
<br>The parameter is passed to the interrupt handler unmodified -
its meaning is totally driver dependent.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20hook_interrupt">Binding</a> &nbsp; <a href="#unhook_interrupt">unhook_interrupt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20hook_interrupt">4.17.18.1 Bindings for hook_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#hook_interrupt">hook_interrupt</a> (int32_t handle, uint32_t *routine,
uint32_t *parameter);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    parameter,-(sp) ; Offset 10
move.l    routine,-(sp)   ; Offset 6
move.l    handle,-(sp)    ; Offset 2
move.w    #311,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp       ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="phys_to_virt">4.17.19 phys_to_virt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Physical to virtual« - Convert physical CPU to virtual
address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 342
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t phys_to_virt (uint32_t address, uint32_t *pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function converts from physical CPU addresses to virtual
addresses. This is necessary since the memory may be mapped non-linear
by the PMMU even when not using virtual memory (it is on the MILAN).
<br>&nbsp;
<br>It does not depend on a special device, thus it does not get a
device handle.
<br>&nbsp;
<br>This function might be limited to TOS or TOS-like
operating systems. If an operating system uses a different memory
layout, it may need to provide its own functions which drivers can
use.
<br>&nbsp;
<br>When using this function, the driver does not need to care about
DMA offsets at all.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> Physical CPU address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">pointer</td>
<td valign="top"> Pointer to mem-struct for results
<br>&nbsp;

</td></tr>
</table>

<br><b>Note:</b> This function is the reverse of <a href="#virt_to_phys">virt_to_phys</a>. It
might be slow, so the driver should avoid using it if it can determine
the address by other means.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>. If successful, mem-struct is filled as follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> CPU (virtual) address
</td></tr>

<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> length of contiguous mapped area

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20phys_to_virt">Binding</a> &nbsp; <a href="#bus_to_virt">bus_to_virt</a> &nbsp; <a href="#get_pagesize">get_pagesize</a> &nbsp; <a href="#virt_to_bus">virt_to_bus</a> &nbsp;
<a href="#virt_to_phys">virt_to_phys</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20phys_to_virt">4.17.19.1 Bindings for phys_to_virt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#phys_to_virt">phys_to_virt</a> (uint32_t address, uint32_t *pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 6
move.l    address,-(sp) ; Offset 2
move.w    #342,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_config_byte">4.17.20 read_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 302
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_config_byte (int32_t handle, uint8_t reg, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function read data from the PCI configuration space of a
given card.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,1,2,... for Byte access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to space for read data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_config_byte">Binding</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_byte">4.17.20.1 Bindings for read_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#fast_read_config_byte">fast_read_config_byte</a> (int32_t handle, uint8_t reg,
uint8_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #302,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_config_longword">4.17.21 read_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 304
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_config_longword (int32_t handle, uint8_t reg,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function read data from the PCI configuration space of a
given card.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,4,8,... for Longword access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to space for read data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_config_longword">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#read_config_word">read_config_word</a> &nbsp; <a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_longword">4.17.21.1 Bindings for read_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_longword">read_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #304,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_config_word">4.17.22 read_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read configuration word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 303
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_config_word (int32_t handle, uint8_t reg, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function read data from the PCI configuration space of a
given card.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle of the selected PCI device
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Address of the configuration register
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to space for read data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_config_word">Binding</a> &nbsp; <a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#fast_read_config_byte">fast_read_config_byte</a> &nbsp;
<a href="#fast_read_config_word">fast_read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a> &nbsp;
<a href="#fast_read_config_longword">fast_read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_config_word">4.17.22.1 Bindings for read_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_config_word">read_config_word</a> (int32_t handle, uint8_t reg, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #303,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_io_byte">4.17.23 read_io_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 328
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_io_byte (int32_t handle, uint32_t offset, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads 8-bit values from a IO region.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_io_byte">Binding</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp; <a href="#fast_read_io_word">fast_read_io_word</a> &nbsp;
<a href="#read_io_longword">read_io_longword</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_io_byte">4.17.23.1 Bindings for read_io_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_io_byte">read_io_byte</a> (int32_t handle, uint32_t offset, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #328,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_io_longword">4.17.24 read_io_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 330
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_io_longword (int32_t handle, uint32_t offset,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads 32-bit values from a IO region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_io_longword">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#read_io_word">read_io_word</a> &nbsp;
<a href="#fast_read_io_word">fast_read_io_word</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_io_longword">4.17.24.1 Bindings for read_io_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_io_longword">read_io_longword</a> (int32_t handle, uint32_t offset,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #330,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_io_word">4.17.25 read_io_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read IO word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 329
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_io_word (int32_t handle, uint32_t offset, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads 16-bit values from a IO region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_io_word">Binding</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp; <a href="#fast_read_io_byte">fast_read_io_byte</a> &nbsp; <a href="#fast_read_io_word">fast_read_io_word</a> &nbsp;
<a href="#read_io_longword">read_io_longword</a> &nbsp; <a href="#fast_read_io_longword">fast_read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_io_word">4.17.25.1 Bindings for read_io_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_io_word">read_io_word</a> (int32_t handle, uint32_t offset, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #329,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_mem_byte">4.17.26 read_mem_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 319
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_mem_byte (int32_t handle, uint32_t offset, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads 8-bit values from a memory region. A driver
can use this function for access to registers and small buffers. For
larger amounts of data, the driver can choose to use his own copy
routines.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>. If successful, read data at buffer pointed to by
<i>address</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_mem_byte">Binding</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp;
<a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_mem_byte">4.17.26.1 Bindings for read_mem_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_mem_byte">read_mem_byte</a> (int32_t handle, uint32_t offset, uint8_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #319,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_mem_longword">4.17.27 read_mem_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 321
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_mem_longword (int32_t handle, uint32_t offset,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads 32-bit values from a memory region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use. A driver can use this function
for access to registers and small buffers. For larger amounts of data,
the driver can choose to use his own copy routines, provided it knows
the byte order in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>. If successful, read data at buffer pointed to by
<i>address</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_mem_longword">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp; <a href="#read_mem_word">read_mem_word</a> &nbsp;
<a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_mem_longword">4.17.27.1 Bindings for read_mem_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_mem_longword">read_mem_longword</a> (int32_t handle, uint32_t offset,
uint32_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #321,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="read_mem_word">4.17.28 read_mem_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Read memory word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 320
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t read_mem_word (int32_t handle, uint32_t offset,
uint16_t *address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function reads 16-bit values from a memory region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use. A driver can use this function
for access to registers and small buffers. For larger amounts of data,
the driver can choose to use his own copy routines, provided it knows
the byte order in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>address</i></td>
<td valign="top"> Pointer to data in memory
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>. If successful, read data at buffer pointed to by
<i>address</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20read_mem_word">Binding</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp; <a href="#fast_read_mem_byte">fast_read_mem_byte</a> &nbsp;
<a href="#fast_read_mem_word">fast_read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a> &nbsp; <a href="#fast_read_mem_longword">fast_read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20read_mem_word">4.17.28.1 Bindings for read_mem_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#read_mem_word">read_mem_word</a> (int32_t handle, uint32_t offset, uint16_t
*address);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       address       ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #320,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="set_card_used">4.17.29 set_card_used</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set card used flag«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 318
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t set_card_used (int32_t handle, uint32_t *callback);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function is used to manage which card is in use by which
driver. A driver can provide a means by which a call-back function can
be called from another driver to deactivate this driver. This is
necessary for the first driver to unhook from interrupt chains etc.,
before the new driver can take over.
<br>&nbsp;
<br>If the call-back entry is 0L, 1L or 3L, the card status is set
to that value. Only a driver which 'owns' the card may use this. If
any other value is passed, it is assumed to be a pointer to the
drivers call back entry point, and the card status is set to 2 (in
use, can be uninstalled).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">callback</td>
<td valign="top"> Address of call-back entry (not pointer to address!) or 0L, 1L
or 3L
<br>&nbsp;

</td></tr>
</table>

<br><b>Call-back handlers:</b> Call-back functions are invoked by
calling the call-back entry point, they return with RTS. Call-back
functions may only modify those registers which are used to pass
arguments or results. Call-back functions must be called in supervisor
mode with at least 1024 bytes stack available. The call-back function
number is passed in D0.L. If the driver supports call-back functions,
the following functions are mandatory:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Call-back</td>
<td valign="top"> Description
</td></tr>

<tr><td nowrap="nowrap" valign="top">Get Driver ID (0)</td>
<td valign="top"> call_back0:
<br>Input: D0.L = call-back function number, ie. 0
<br>Output: D0.L = driver ID (same as the driver's XBRA ID)
</td></tr>

<tr><td nowrap="nowrap" valign="top">Try to remove driver (1)</td>
<td valign="top"> call_back1:
<br>Input: D0.L = call-back function number, ie. 1
<br>Output: D0.L = result code: 0=success (card is free), 1=can't
uninstall

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20set_card_used">Binding</a> &nbsp; <a href="#get_card_used">get_card_used</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20set_card_used">4.17.29.1 Bindings for set_card_used</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#set_card_used">set_card_used</a> (int32_t handle, uint32_t *callback);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       callback      ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #318,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="set_interrupt">4.17.30 set_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set Hardware Interrupt«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 315
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t set_interrupt ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> To be defined. Not for use by device drivers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20set_interrupt">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20set_interrupt">4.17.30.1 Bindings for set_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#set_interrupt">set_interrupt</a> ( int32_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)    ; Offset 2
move.w    #315,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp           ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="special_cycle">4.17.31 special_cycle</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Generates special cycle«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 313
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t special_cycle ( unit8_t bus, uint32_t data );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function generates a special cycle on the PCI bus.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Bus number
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">data</td>
<td valign="top"> Cspecial cycle data
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20special_cycle">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20special_cycle">4.17.31.1 Bindings for special_cycle</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#special_cycle">special_cycle</a> ( unit8_t bus, uint32_t data );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    data,-(sp)    ; Offset 4
move.w    bus,-(sp)     ; Offset 2
move.w    #313,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="unhook_interrupt">4.17.32 unhook_interrupt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> » «
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 312
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t unhook_interrupt (int32_t handle);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function removes the driver from the interrupt chain to
which a specific interrupt on the given card is routed. The driver
must turn off interrupt generation on the card before calling this
function.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20unhook_interrupt">Binding</a> &nbsp; <a href="#hook_interrupt">hook_interrupt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20unhook_interrupt">4.17.32.1 Bindings for unhook_interrupt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#unhook_interrupt">unhook_interrupt</a> (int32_t handle);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handle,-(sp)  ; Offset 2
move.w    #312,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="virt_to_bus">4.17.33 virt_to_bus</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Virtual to bus« - Convert virtual to PCI bus address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 339
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t virt_to_bus (int32_t handle, uint32_t address, uint32_t
*pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function converts from virtual addresses (as the CPU uses
them) to PCI bus addresses. This is necessary since the memory may be
mapped non-linear by the PMMU even when not using virtual memory (it
is on the MILAN).
<br>&nbsp;
<br>It is required that a resource (ie. a region of memory or IO
space on a PCI card) is mapped contiguously, so that a simple offset
can be used when copying to/from memory on a PCI card.
<br>&nbsp;
<br>This function might be limited to TOS or TOS-like
operating systems. If an operating system uses a different memory
layout, it may need to provide its own functions which drivers can
use.
<br>&nbsp;
<br>When using this function, the driver does not need to care about
DMA offsets at all.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handle</td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> Address in virtual CPU space
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">pointer</td>
<td valign="top"> Pointer to mem-struct for results
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>. If successful, mem-struct is filled as follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> PCI bus address
</td></tr>

<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> length of contiguous mapped area, 0 if no DMA is possible at
this address

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20virt_to_bus">Binding</a> &nbsp; <a href="#bus_to_virt">bus_to_virt</a> &nbsp; <a href="#get_pagesize">get_pagesize</a> &nbsp; <a href="#phys_to_virt">phys_to_virt</a> &nbsp;
<a href="#virt_to_phys">virt_to_phys</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20virt_to_bus">4.17.33.1 Bindings for virt_to_bus</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#virt_to_bus">virt_to_bus</a> (int32_t handle, uint32_t address, uint32_t
*pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 10
move.l    address,-(sp) ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #339,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="virt_to_phys">4.17.34 virt_to_phys</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Virtual to physical« - Convert virtual to physical CPU
address
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 341
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t virt_to_phys (uint32_t address, uint32_t *pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function converts from virtual addresses to physical CPU
addresses. This is necessary since the memory may be mapped non-linear
by the PMMU even when not using virtual memory (it is on the MILAN).
<br>&nbsp;
<br>It does not depend on a special device, thus it does not get a
device handle.
<br>&nbsp;
<br>This function might be limited to TOS or TOS-like
operating systems. If an operating system uses a different memory
layout, it may need to provide its own functions which drivers can
use.
<br>&nbsp;
<br>When using this function, the driver does not need to care about
DMA offsets at all.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">address</td>
<td valign="top"> Address in virtual CPU space
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">pointer</td>
<td valign="top"> Pointer to mem-struct for results
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>. If successful, mem-struct is filled as follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> physical CPU address
</td></tr>

<tr><td nowrap="nowrap" valign="top">uint32_t</td>
<td valign="top"> length of contiguous mapped area, 0 if not mapped

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20virt_to_phys">Binding</a> &nbsp; <a href="#bus_to_virt">bus_to_virt</a> &nbsp; <a href="#get_pagesize">get_pagesize</a> &nbsp; <a href="#phys_to_virt">phys_to_virt</a> &nbsp;
<a href="#virt_to_bus">virt_to_bus</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20virt_to_phys">4.17.34.1 Bindings for virt_to_phys</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#virt_to_phys">virt_to_phys</a> (uint32_t address, uint32_t *pointer);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pointer       ; Offset 6
move.l    address,-(sp) ; Offset 2
move.w    #341,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_config_byte">4.17.35 write_config_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 308
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_config_byte (int32_t handle, uint8_t reg, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes data to the PCI configuration space of a
given card.
<br>&nbsp;
<br>The data is in little endian format, as described in the PCI
specification.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,1,2,... for byte access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (8 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_config_byte">Binding</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_byte">4.17.35.1 Bindings for write_config_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_byte">write_config_byte</a> (int32_t handle, uint8_t reg, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #308,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_config_longword">4.17.36 write_config_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 310
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_config_longword (int32_t handle, uint8_t reg,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes data to the PCI configuration space of a
given card.
<br>&nbsp;
<br>The data is in little endian format, as described in the PCI
specification.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,4,8,... for Longword access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (32 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_config_longword">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_word">write_config_word</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_longword">4.17.36.1 Bindings for write_config_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_longword">write_config_longword</a> (int32_t handle, uint8_t reg,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #310,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Stack korrigieren
</pre>

</td></tr>
</table>

<h3><a name="write_config_word">4.17.37 write_config_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write configuration word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 309
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_config_word (int32_t handle, uint8_t reg,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes data to the PCI configuration space of a
given card.
<br>&nbsp;
<br>The data is in little endian format, as described in the PCI
specification.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>reg</i></td>
<td valign="top"> Register number (0,2,4,... for Word access)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (16 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_config_word">Binding</a> &nbsp; <a href="#write_config_byte">write_config_byte</a> &nbsp; <a href="#write_config_longword">write_config_longword</a> &nbsp;
<a href="#read_config_byte">read_config_byte</a> &nbsp; <a href="#read_config_word">read_config_word</a> &nbsp; <a href="#read_config_longword">read_config_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_config_word">4.17.37.1 Bindings for write_config_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_config_word">write_config_word</a> (int32_t handle, uint8_t reg, uint16_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 8
move.w    reg,-(sp)     ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #309,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       10(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_io_byte">4.17.38 write_io_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write IO byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 334
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_io_byte (int32_t handle, uint32_t offset, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes 8-bit values to a IO region.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (8 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_io_byte">Binding</a> &nbsp; <a href="#write_io_word">write_io_word</a> &nbsp; <a href="#write_io_longword">write_io_longword</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp;
<a href="#read_io_word">read_io_word</a> &nbsp; <a href="#read_io_longword">read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_io_byte">4.17.38.1 Bindings for write_io_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_io_byte">write_io_byte</a> (int32_t handle, uint32_t offset, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #334,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_io_longword">4.17.39 write_io_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write IO longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 336
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_io_longword (int32_t handle, uint32_t offset,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes 32-bit values to a IO region and take care
of the byte ordering - ie. the data and address are converted as if
Motorola byte ordering was in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (32 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_io_longword">Binding</a> &nbsp; <a href="#write_io_byte">write_io_byte</a> &nbsp; <a href="#write_io_word">write_io_word</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp;
<a href="#read_io_word">read_io_word</a> &nbsp; <a href="#read_io_longword">read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_io_longword">4.17.39.1 Bindings for write_io_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_io_longword">write_io_longword</a> (int32_t handle, uint32_t offset,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #336,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_io_word">4.17.40 write_io_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write IO word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 335
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_io_word (int32_t handle, uint32_t offset,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes 16-bit values to a IO region and take care
of the byte ordering - ie. the data and address are converted as if
Motorola byte ordering was in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI IO address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (16 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_io_word">Binding</a> &nbsp; <a href="#write_io_byte">write_io_byte</a> &nbsp; <a href="#write_io_longword">write_io_longword</a> &nbsp; <a href="#read_io_byte">read_io_byte</a> &nbsp;
<a href="#read_io_word">read_io_word</a> &nbsp; <a href="#read_io_longword">read_io_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_io_word">4.17.40.1 Bindings for write_io_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_io_word">write_io_word</a> (int32_t handle, uint32_t offset, uint16_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #335,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_mem_byte">4.17.41 write_mem_byte</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write memory byte«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 325
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_mem_byte (int32_t handle, uint32_t offset,
uint8_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes 8-bit values to a memory region. A driver
can use this function for access to registers and small buffers. For
larger amounts of data, the driver can choose to use his own copy
routines.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (8 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_mem_byte">Binding</a> &nbsp; <a href="#write_mem_word">write_mem_word</a> &nbsp; <a href="#write_mem_longword">write_mem_longword</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp;
<a href="#read_mem_word">read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_mem_byte">4.17.41.1 Bindings for write_mem_byte</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_mem_byte">write_mem_byte</a> (int32_t handle, uint32_t offset, uint8_t
val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #325,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_mem_longword">4.17.42 write_mem_longword</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write memory longword«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 327
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_mem_longword (int32_t handle, uint32_t offset,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes 32-bit values to a memory region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use. A driver can use this function
for access to registers and small buffers. For larger amounts of data,
the driver can choose to use his own copy routines, provided it knows
the byte order in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (32 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_mem_longword">Binding</a> &nbsp; <a href="#write_mem_byte">write_mem_byte</a> &nbsp; <a href="#write_mem_word">write_mem_word</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp;
<a href="#read_mem_word">read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_mem_longword">4.17.42.1 Bindings for write_mem_longword</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_mem_longword">write_mem_longword</a> (int32_t handle, uint32_t offset,
uint32_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #327,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="write_mem_word">4.17.43 write_mem_word</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Write memory word«
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 326
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t write_mem_word (int32_t handle, uint32_t offset,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function writes 16-bit values to a memory region and take
care of the byte ordering - ie. the data and address are converted as
if Motorola byte ordering was in use. A driver can use this function
for access to registers and small buffers. For larger amounts of data,
the driver can choose to use his own copy routines, provided it knows
the byte order in use.
<br>&nbsp;
<table class="UDO_env_ilist">
<tr><td nowrap="nowrap" valign="top"><i>handle</i></td>
<td valign="top"> Device handle
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>offset</i></td>
<td valign="top"> Address to access (in PCI memory address space)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><i>val</i></td>
<td valign="top"> Data to write (16 bits)
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <a href="#PCI-BIOS_20Error_20codes">PCI-BIOS Error codes</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> PCI-BIOS
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#PCI-BIOS">PCI-BIOS</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20write_mem_word">Binding</a> &nbsp; <a href="#write_mem_byte">write_mem_byte</a> &nbsp; <a href="#write_mem_longword">write_mem_longword</a> &nbsp; <a href="#read_mem_byte">read_mem_byte</a> &nbsp;
<a href="#read_mem_word">read_mem_word</a> &nbsp; <a href="#read_mem_longword">read_mem_longword</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20write_mem_word">4.17.43.1 Bindings for write_mem_word</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#write_mem_word">write_mem_word</a> (int32_t handle, uint32_t offset,
uint16_t val);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    val,-(sp)     ; Offset 10
move.l    offset,-(sp)  ; Offset 6
move.l    handle,-(sp)  ; Offset 2
move.w    #326,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="PCI-BIOS_20Error_20codes">4.17.44 PCI-BIOS Error codes</a></h3>
<p>The following error codes can be returned by the PCI <a href="bios_main.html">BIOS</a>
functions:
</p>
<a name="PCI_SUCCESSFUL"></a>
<a name="PCI_FUNC_NOT_SUPPORTED"></a>
<a name="PCI_BAD_VENDOR_ID"></a>
<a name="PCI_DEVICE_NOT_FOUND"></a>
<a name="PCI_BAD_REGISTER_NUMBER"></a>
<a name="PCI_SET_FAILED"></a>
<a name="PCI_BUFFER_TOO_SMALL"></a>
<a name="PCI_GENERAL_ERROR"></a>
<a name="PCI_BAD_HANDLE"></a>
<div align="left"><table border="1" frame="box" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0x00000000</td>
  <td align="left" valign="top">PCI_SUCCESSFUL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFE</td>
  <td align="left" valign="top">PCI_FUNC_NOT_SUPPORTED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFD</td>
  <td align="left" valign="top">PCI_BAD_VENDOR_ID</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFC</td>
  <td align="left" valign="top">PCI_DEVICE_NOT_FOUND</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFB</td>
  <td align="left" valign="top">PCI_BAD_REGISTER_NUMBER</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFFA</td>
  <td align="left" valign="top">PCI_SET_FAILED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF9</td>
  <td align="left" valign="top">PCI_BUFFER_TOO_SMALL</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF8</td>
  <td align="left" valign="top">PCI_GENERAL_ERROR</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFFFF7</td>
  <td align="left" valign="top">PCI_BAD_HANDLE</td>
</tr>
</table>
</div>

<p>The following error codes are not returned by PCI <a href="bios_main.html">BIOS</a> functions
directly, but are reserved for use by a library which uses these
routines.
</p>
<a name="PCI_BIOS_NOT_INSTALLED"></a>
<a name="PCI_BIOS_WRONG_VERSION"></a>
<div align="left"><table border="1" frame="box" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0xFFFFF001</td>
  <td align="left" valign="top">PCI_BIOS_NOT_INSTALLED</td>
</tr>
<tr>
  <td align="left" valign="top">0xFFFFF000</td>
  <td align="left" valign="top">PCI_BIOS_WRONG_VERSION</td>
</tr>
</table>
</div>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_overscan.html"><img src="udo_lf.gif" alt="OverScan XBIOS extension" title="OverScan XBIOS extension" border="0" width="24" height="24">OverScan XBIOS extension</a>
<a name="UDO_nav_rg_FOOT" href="xbios_interface.html"><img src="udo_rg.gif" alt="Interface programming" title="Interface programming" border="0" width="24" height="24">Interface programming</a>
</body>
</html>
