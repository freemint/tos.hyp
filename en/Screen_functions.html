<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2025/08/02 -->
<html lang="en">
<head>
<title>
The documentation for TOS: Screen functions
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_trap.html"><img src="udo_lf.gif" alt="xbios-trap" title="xbios-trap" border="0" width="24" height="24">xbios-trap</a>
<a name="UDO_nav_rg_HEAD" href="CENTScreen_XBIOS_extension.html"><img src="udo_rg.gif" alt="CENTScreen XBIOS extension" title="CENTScreen XBIOS extension" border="0" width="24" height="24">CENTScreen XBIOS extension</a>

<hr>

<h1><a name="Screen_20functions">4.5 Screen functions</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Cursconf">Cursconf</a></td>
<td valign="top"> Changes or gets cursor display.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EgetPalette">EgetPalette</a></td>
<td valign="top"> Reads colour palette.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EgetShift">EgetShift</a></td>
<td valign="top"> Reads shift mode register.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetBank">EsetBank</a></td>
<td valign="top"> Sets colour table.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetColor">EsetColor</a></td>
<td valign="top"> Sets colour table entry.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetGray">EsetGray</a></td>
<td valign="top"> Sets colour interpretation.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetPalette">EsetPalette</a></td>
<td valign="top"> Loads colour palette.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetShift">EsetShift</a></td>
<td valign="top"> Sets shift mode register.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#EsetSmear">EsetSmear</a></td>
<td valign="top"> Sets colour smear.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Getrez">Getrez</a></td>
<td valign="top"> Gets resolution.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Initmouse">Initmouse</a></td>
<td valign="top"> Initializes mouse pointer.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Logbase">Logbase</a></td>
<td valign="top"> Gets address of the logical screen memory.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#mon_type">mon_type</a></td>
<td valign="top"> Gets monitor type.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Physbase">Physbase</a></td>
<td valign="top"> Gets address of the physical screen memory.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Setcolor">Setcolor</a></td>
<td valign="top"> Sets colour.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Setpalette">Setpalette</a></td>
<td valign="top"> Selects colour palette.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Setscreen">Setscreen</a></td>
<td valign="top"> Sets the current screen resolution and base addresses.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#ValidMode">ValidMode</a></td>
<td valign="top"> Validates a mode code.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VgetRGB">VgetRGB</a></td>
<td valign="top"> Gets RGB-value of a colour.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetScreen">VsetScreen</a></td>
<td valign="top"> Sets the screen resolution and base addresses.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VgetSize">VgetSize</a></td>
<td valign="top"> Gets size of the screen buffer.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetMask">VsetMask</a></td>
<td valign="top"> Sets transparency for True-Color.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetMode">VsetMode</a></td>
<td valign="top"> Sets video hardware register.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetRGB">VsetRGB</a></td>
<td valign="top"> Sets RGB-value of a colour.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#VsetSync">VsetSync</a></td>
<td valign="top"> Sets type of synchronisation for external video.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Vsync">Vsync</a></td>
<td valign="top"> Gets vertical synchronisation signal.

</td></tr>
</table>

<h3><a name="Cursconf">4.5.1 Cursconf</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »cursor configuration« - Sets the working of the VT52 cursor
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 21
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Cursconf( int16_t func, int16_t rate );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Cursconf alters the appearance and, if
desired, the blink rate of the cursor. The parameter <i>func</i> can
take the following values:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">func</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top"> Switch cursor off (hide it)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top"> Switch cursor on
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;2</td>
<td valign="top"> Enable cursor blink
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;3</td>
<td valign="top"> Disable cursor blink
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;4</td>
<td valign="top"> The blink rate of the cursor will be set to the value
<i>rate</i>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;5</td>
<td valign="top"> Returns the current blink rate
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;6</td>
<td valign="top"> The blink delay of the cursor will be set to the value
<i>rate</i>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;7</td>
<td valign="top"> Returns the current blink delay

</td></tr>
</table>

<br><b>Note:</b> The parameter <i>rate</i> should be used in steps
of the screen repetition frequency.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function only returns a defined result, namely the blink
rate, if the number 5 or 7 was passed in the parameter <i>func</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>Parameters 6 and 7 are available with TOS version &gt;= 1.02.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Cursconf">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Cursconf">4.5.1.1 Bindings for Cursconf</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Cursconf">Cursconf</a>( int16_t func, int16_t rate );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    rate,-(sp)   ; Offset 4
move.w    func,-(sp)   ; Offset 2
move.w    #21,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="EgetPalette">4.5.2 EgetPalette</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get look up table registers« - Reads several entries from
the colour table into a specified buffer.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 85
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void EgetPalette( int16_t colorNum, int16_t count, int16_t
*palettePtr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine EgetPalette reads out a contiguous region
from the TT colour registers.
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">colorNum</td>
<td valign="top"> First colour register to be read out
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Number of colour registers to be read out
</td></tr>

<tr><td nowrap="nowrap" valign="top">palettePtr</td>
<td valign="top"> Pointer to the colour palette to be transferred (this must be
even)

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only in the TOS of the Atari TT.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20EgetPalette">Binding</a> &nbsp; <a href="#EsetPalette">EsetPalette</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20EgetPalette">4.5.2.1 Bindings for EgetPalette</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#EgetPalette">EgetPalette</a>( int16_t colorNum, int16_t count, int16_t
*palettePtr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       palettePtr      ; Offset 6
move.w    count,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #85,-(sp)       ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp       ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="EgetShift">4.5.3 EgetShift</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Get current shift mode value« - Reads the shift mode
register (the current mode of the video shifter).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 81
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t EgetShift( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine EgetShift reads out the shift mode register
and returns the contents of the register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value of the register, with the
following assignments:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Bit</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">0..3</td>
  <td align="left" valign="top">Number of the colour register bank</td>
</tr>
<tr>
  <td align="left" valign="top">8..10</td>
  <td align="left" valign="top">Mode, according to <a href="#Getrez">Getrez</a></td>
</tr>
<tr>
  <td align="left" valign="top">12</td>
  <td align="left" valign="top">Hyper-mono (c.f. <a href="#EsetGray">EsetGray</a>)</td>
</tr>
<tr>
  <td align="left" valign="top">15</td>
  <td align="left" valign="top">Smear mode (c.f. <a href="#EsetSmear">EsetSmear</a>)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only in the TOS of the Atari TT.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20EgetShift">Binding</a> &nbsp; <a href="#EsetShift">EsetShift</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20EgetShift">4.5.3.1 Bindings for EgetShift</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EgetShift">EgetShift</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #81,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="EsetBank">4.5.4 EsetBank</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set color look up bank« - Sets the bank for the colour table
from the 16 available.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 82
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t EsetBank( int16_t bankNum );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine EsetBank sets the bank number for the colour
table of the TT to the value <i>bankNum</i>. The permitted value of
<i>bankNum</i> lies between 0 and 15. If <i>bankNum</i> is negative,
the current setting will not be altered.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the previous setting.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only in the TOS of the Atari TT.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20EsetBank">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20EsetBank">4.5.4.1 Bindings for EsetBank</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetBank">EsetBank</a>( int16_t bankNum );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    bankNum,-(sp)  ; Offset 2
move.w    #82,-(sp)      ; Offset 0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp          ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="EsetColor">4.5.5 EsetColor</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set color entry« - Writes an entry into the colour table for
an individual colour.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 83
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t EsetColor( int16_t colorNum, int16_t color );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine EsetColor sets the colour entry
<i>colorNum</i> (0..255) in the colour table to the value
<i>color</i>; a negative value does not alter the entry.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the previous setting.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only in the TOS of the Atari TT.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20EsetColor">Binding</a> &nbsp; <a href="#Setcolor">Setcolor</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20EsetColor">4.5.5.1 Bindings for EsetColor</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetColor">EsetColor</a>( int16_t colorNum, int16_t color );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    color,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #83,-(sp)       ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp           ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="EsetGray">4.5.6 EsetGray</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set/clear gray mode« - Switches on or off the colour
interpretation in the video shifter.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 86
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t EsetGray( int16_t switch );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine EsetGray switches on (1) or off (0) the
colour interpretation in the colour table as a greytone. A negative
value returns the grey bit of the video shifter but does not alter the
setting.
<br>&nbsp;
<br>In greytone mode one can select from a palette of 256 greytones
(0-255) instead of 4096 colours (RGB 0-15).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the previous value of the video shifter's
grey bit.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only in the TOS of the Atari TT
(when the high word of the '_VDO' cookie has the value of 2).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20EsetGray">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20EsetGray">4.5.6.1 Bindings for EsetGray</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetGray">EsetGray</a>( int16_t switch );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    switch,-(sp) ; Offset 2
move.w    #86,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="EsetPalette">4.5.7 EsetPalette</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set palette registers« - Sets several entries in the colour
table from the specified buffer.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 84
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void EsetPalette( int16_t colorNum, int16_t count, int16_t
*palettePtr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine EsetPalette sets <i>count</i> colour
entries from <i>colorNum</i> on in the colour table to the values in
array <i>palettePtr</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function has no return.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only in the TOS of the Atari TT.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20EsetPalette">Binding</a> &nbsp; <a href="#EgetPalette">EgetPalette</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20EsetPalette">4.5.7.1 Bindings for EsetPalette</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#EsetPalette">EsetPalette</a>( int16_t colorNum, int16_t count, int16_t
*palettePtr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       palettePtr      ; Offset 6
move.w    count,-(sp)     ; Offset 4
move.w    colorNum,-(sp)  ; Offset 2
move.w    #84,-(sp)       ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp       ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="EsetShift">4.5.8 EsetShift</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set shift mode register« - Sets the shift mode registers of
the video shifter.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 80
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t EsetShift( int16_t shftMode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine EsetShift writes to the shift mode register
of the TT the value <i>shftMode</i>. shftMode is a bit array with the
following assignments:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Bit</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">0..3</td>
  <td align="left" valign="top">Number of the colour register bank</td>
</tr>
<tr>
  <td align="left" valign="top">8..10</td>
  <td align="left" valign="top">Mode according to <a href="#Getrez">Getrez</a></td>
</tr>
<tr>
  <td align="left" valign="top">12</td>
  <td align="left" valign="top">Hyper-mono (c.f. <a href="#EsetGray">EsetGray</a>)</td>
</tr>
<tr>
  <td align="left" valign="top">15</td>
  <td align="left" valign="top">Smear mode (c.f. <a href="#EsetSmear">EsetSmear</a>)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the previous value of the register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only in the TOS of the Atari TT.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20EsetShift">Binding</a> &nbsp; <a href="#EgetShift">EgetShift</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20EsetShift">4.5.8.1 Bindings for EsetShift</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetShift">EsetShift</a>( int16_t shftMode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    shftMode,-(sp)  ; Offset 2
move.w    #80,-(sp)       ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp           ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="EsetSmear">4.5.9 EsetSmear</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Set/clear video smear mode« - Switches on (1) or off (0) the
smear mode of the video shifter.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 87
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t EsetSmear( int16_t switch );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine EsetSmear permits switching of the smear
mode of the TT video shifter. In smear mode, the last displayed pixel
colour is drawn in each case instead of the background colour (colour
0).
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">switch</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="center" valign="top">&lt;0</td>
  <td align="left" valign="top">Obtain existing value</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Smear mode off</td>
</tr>
<tr>
  <td align="center" valign="top">&gt;0</td>
  <td align="left" valign="top">Smear mode on</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the existing setting.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only in the TOS of the Atari TT.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20EsetSmear">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20EsetSmear">4.5.9.1 Bindings for EsetSmear</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#EsetSmear">EsetSmear</a>( int16_t switch );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    switch,-(sp)  ; Offset 2
move.w    #87,-(sp)     ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Getrez">4.5.10 Getrez</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »get resolution« - Return current screen resolution code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 4
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Getrez( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Getrez obtains the current resolution of the
screen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the following values:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">Value</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">&nbsp;320*200 (4 planes)</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">&nbsp;640*200 (2 planes)</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">&nbsp;640*400 (one plane)</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">&nbsp;640*480 (4 planes, TT only)</td>
</tr>
<tr>
  <td align="center" valign="top">6</td>
  <td align="left" valign="top">1280*960 (one plane, TT only)</td>
</tr>
<tr>
  <td align="center" valign="top">7</td>
  <td align="left" valign="top">&nbsp;320*480 (8 planes, TT only)</td>
</tr>
</table>
</div>

<br>All other values are reserved for future extensions.
<br>&nbsp;
<br><b>Note:</b> For the sake of clean programming this function
<i>should not be used</i>, as it is very dependent on the hardware;
particularly when graphics cards are in use, it has practically no
meaning. Instead, the screen resolution should be obtained via the
<a href="About_the_VDI.html">VDI</a> function (<a href="vdi_control.html#v_opnvwk">v_opnvwk</a>).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Getrez">Binding</a> &nbsp; <a href="vdi_control.html#v_opnvwk">v_opnvwk</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Getrez">4.5.10.1 Bindings for Getrez</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;portab.h&gt;
<br>#include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Getrez">Getrez</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #4,-(sp)     ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Initmouse">4.5.11 Initmouse</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »initialize mouse« - Initializes the mouse handler.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Initmouse( int16_t type, <a href="xbios_structures.html#MOUSE">MOUSE</a> *par, void (*mousevec)() );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> Initmouse is a XBIOS routine for low-level initialization of
the mouse. The parameter <i>type</i> sets the working mode of the
mouse. The following apply:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">type</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Disable mouse</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Enable mouse in relative mode</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Enable mouse in absolute mode</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">Unused</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">Enable mouse in key-code mode</td>
</tr>
</table>
</div>

<br>The bytes from 4 to 11 of the parameter <i>par</i> are only
used when the mouse is to work in absolute mode. With <i>mousevec</i>
you can set a new mouse interrupt vector. The vector will reset if you
disable the mouse (type=0).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function return -1 if it OK or 0 if no error has occurred.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Initmouse">Binding</a> &nbsp; <a href="xbios_structures.html#MOUSE">MOUSE</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Initmouse">4.5.11.1 Bindings for Initmouse</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Initmouse">Initmouse</a>( int16_t type, <a href="xbios_structures.html#MOUSE">MOUSE</a> *par, void (*mousevec)() );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       mousevec     ; Offset 8
pea       par          ; Offset 4
move.w    type,-(sp)   ; Offset 2
move.w    #0,-(sp)     ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Logbase">4.5.12 Logbase</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »logical screen RAM base« - Returns a pointer to the logical
start address of the video memory.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 3
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void *Logbase( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Logbase obtains the logical start address of
the RAM region currently being used for the video memory.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the start address of the logical screen
memory.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Logbase">Binding</a> &nbsp; <a href="#Physbase">Physbase</a> &nbsp; <a href="#Setscreen">Setscreen</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Logbase">4.5.12.1 Bindings for Logbase</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void *<a href="#Logbase">Logbase</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #3,-(sp)     ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="mon_type">4.5.13 mon_type</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »mon_type« - Identify the monitor type.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 89
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t mon_type( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function mon_type identifies the type of monitor
connected, based on pin 18(M1) and 19(M0) of the video port. A 0-bit
means ground at the corresponding pin, a 1-bit means no connection.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the type of monitor connected. The
following applies:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">Value</td>
  <td align="left" valign="top">Meaning</td>
  <td align="left" valign="top">Pin</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">ST monochrome monitor</td>
  <td align="left" valign="top">M1:0 M0:0</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">ST colour monitor</td>
  <td align="left" valign="top">M1:0 M0:1</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">VGA monitor</td>
  <td align="left" valign="top">M1:1 M0:0</td>
</tr>
<tr>
  <td align="center" valign="top">3</td>
  <td align="left" valign="top">TV devicet</td>
  <td align="left" valign="top">M1:1 M0:1</td>
</tr>
<tr>
  <td align="center" valign="top">4</td>
  <td align="left" valign="top">LCD</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="center" valign="top">5</td>
  <td align="left" valign="top">DVI</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
</table>
</div>

<br>Value four and five only available with ct60 and Radeon driver.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20mon_type">Binding</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20mon_type">4.5.13.1 Bindings for mon_type</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top">
<br>&nbsp;
<br>int16_t <a href="#mon_type">mon_type</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #89,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Physbase">4.5.14 Physbase</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »physical screen ram base« - Returns the physical start
address of the video memory.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 2
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void *Physbase( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Physbase returns the physical start address
of the RAM region currently being used for the video memory.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function Physbase returns the start address of the physical
screen memory.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Physbase">Binding</a> &nbsp; <a href="#Logbase">Logbase</a> &nbsp; <a href="#Setscreen">Setscreen</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Physbase">4.5.14.1 Bindings for Physbase</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void *<a href="#Physbase">Physbase</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #2,-(sp)     ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Setcolor">4.5.15 Setcolor</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Setcolor« - Sets one of 16 colours.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 7
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Setcolor( int16_t colornum, int16_t color );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Setcolor obtains the value of a colour
register or sets this to a new value. The following apply:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">colornum</td>
  <td align="left" valign="top">Number of the colour register (0..15)</td>
</tr>
<tr>
  <td align="left" valign="top">color</td>
  <td align="left" valign="top">New colour value (-1 = don't alter)</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the old value of the colour register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Setcolor">Binding</a> &nbsp; <a href="#Setpalette">Setpalette</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Setcolor">4.5.15.1 Bindings for Setcolor</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Setcolor">Setcolor</a>( int16_t colornum, int16_t color );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    color,-(sp)    ; Offset 4
move.w    colornum,-(sp) ; Offset 2
move.w    #7,-(sp)       ; Offset 0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp          ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Setpalette">4.5.16 Setpalette</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set palette« - Selects 16 colours.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 6
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Setpalette( void *pallptr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Setpalette permits the passing of a new
colour palette to the video hardware.
<br>&nbsp;
<br>The parameter <i>pallptr</i> points to a table of sixteen
16-bit words that contain the new palette. The lowest 12-bits are used
here for the RGB values. <i>pallptr</i> must point to an even
address.
<br>&nbsp;
<br>As the function's data are not processed immediately, one has to
ensure that the pointer <i>pallptr</i> still points to something
sensible in the next vertical blank.
<br>&nbsp;
<br><b>Note:</b> It is better to make use of the corresponding
functions of the <a href="About_the_VDI.html">VDI</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a value.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Setpalette">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Setpalette">4.5.16.1 Bindings for Setpalette</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Setpalette">Setpalette</a>( void *pallptr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       pallptr      ; Offset 2
move.w    #6,-(sp)     ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Setscreen">4.5.17 Setscreen</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set screen« - Initializes the screen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 5
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Setscreen( void *laddr, void *paddr, int16_t rez );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Setscreen serves to alter the screen
resolution and screen memory addresses. The following apply:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">laddr</td>
  <td align="left" valign="top">Address of the logical screen memory</td>
</tr>
<tr>
  <td align="left" valign="top">paddr</td>
  <td align="left" valign="top">Address of the physical screen memory</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">0 = ST Low</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">1 = ST Medium</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">2 = ST High</td>
</tr>
</table>
</div>

<br>A value of -1 here means that the corresponding address or
resolution will not be altered.
<br>&nbsp;
<br><b>Note:</b> One should always check whether possible changes
were really performed successfully. During resolution changes the
<a href="VT_52_terminal.html">VT52 emulator</a> is automatically initialized.
<br>&nbsp;
<br>Under some circumstances there is an extended version of this
function (<a href="#VsetScreen">VsetScreen</a>).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Setscreen">Binding</a> &nbsp; <a href="#Physbase">Physbase</a> &nbsp; <a href="#Logbase">Logbase</a> &nbsp; <a href="#Getrez">Getrez</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Setscreen">4.5.17.1 Bindings for Setscreen</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Setscreen">Setscreen</a>( void *laddr, void *paddr, int16_t rez );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    rez,-(sp)    ; Offset 10
move.l    paddr,-(sp)  ; Offset  6
move.l    laddr,-(sp)  ; Offset  2
move.w    #5,-(sp)     ; Offset  0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $C(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Setscreen_2C_20Milan">4.5.18 Setscreen, Milan</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set screen« - Initializes the screen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 5
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Setscreen( void *par1, void *par2, int16_t rez, int16_t
command );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This XBIOS routine corresponds to the <a href="#Setscreen">Setscreen</a> function with
additional parameters, and serves for altering the screen resolution
and screen memory addresses.
<br>&nbsp;
<a name="MI_MAGIC"></a>
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">par1</td>
  <td align="left" valign="top">Depending on function - see below</td>
</tr>
<tr>
  <td align="left" valign="top">par2</td>
  <td align="left" valign="top">Depending on function - see below</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">always 0x4D49 (MI_MAGIC)</td>
</tr>
<tr>
  <td align="left" valign="top">command</td>
  <td align="left" valign="top">Command</td>
</tr>
</table>
</div>

<br>The following values are defined for <i>command</i>:
<br>&nbsp;
<dl class="UDO_env_description">
<dd><a name="CMD_GETMODE"></a></dd>
<dt><b>CMD_GETMODE (0)</b></dt>
<dd>
<p> Getting current mode
<br>&nbsp;
<br>int32_t mode;
<br>Setscreen(-1, &amp;mode, MI_MAGIC, CMD_GETMODE);
<br>&nbsp;
<dd><a name="CMD_SETMODE"></a></dd>
</p>

</dd>
<dt><b>CMD_SETMODE (1)</b></dt>
<dd>
<p> Set new graphic mode
<br>&nbsp;
<br>int32_t mode=0x1023 /* 800*608*16 */
<br>Setscreen(-1, mode, MI_MAGIC, CMD_SETMODE)
<br>&nbsp;
<br><a href="bios_main.html">BIOS</a> and <a href="vdi_main.html">VDI</a> will be initialised. Not the <a href="aes_main.html">AES</a>.
<br>&nbsp;
<dd><a name="CMD_GETINFO"></a></dd>
</p>

</dd>
<dt><b>CMD_GETINFO (2)</b></dt>
<dd>
<p> Get screen info structure for mode
<br>&nbsp;
<pre><a href="xbios_structures.html#SCREENINFO">SCREENINFO</a> si;
/* Structure size has to be set         */
si.size=sizeof(<a href="xbios_structures.html#SCREENINFO">SCREENINFO</a>);
/* ID of the mode or 0 for current mode */
si.devID=0x1023;
/* status of the operation              */
si.scrFlags=0;
<a href="#Setscreen">Setscreen</a>(-1, &amp;si, MI_MAGIC, CMD_GETINFO);
if(si.scrFlags &amp; <a href="xbios_structures.html#SCRINFO_OK">SCRINFO_OK</a>)
  puts(&quot;OK&quot;);
else
  puts(&quot;Error&quot;);
</pre>
<dd><a name="CMD_ALLOCPAGE"></a></dd>
</p>

</dd>
<dt><b>CMD_ALLOCPAGE (3)</b></dt>
<dd>
<p> Allocate 2nd screenpage
<br>&nbsp;
<pre>int32_t adr=0;      /* Frame address or -1 */
<a href="#Setscreen">Setscreen</a>(&amp;adr, mode, MI_MAGIC, CMD_ALLOCPAGE);
if(adr)
  puts(&quot;OK&quot;);
else
  puts(&quot;Error&quot;);
</pre>
<br>This only allocates one page. A further call will only return
the frame address.
<br>&nbsp;
<dd><a name="CMD_FREEPAGE"></a></dd>
</p>

</dd>
<dt><b>CMD_FREEPAGE (4)</b></dt>
<dd>
<p> Release 2nd screenpage
<br>&nbsp;
<br>Setscreen(-1, -1, MI_MAGIC, CMD_FREEPAGE)
<br>&nbsp;
<br>The graphics card memory will be released again. If the second
page had still been active the call will switch back to the first page
with <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> set.
<br>&nbsp;
<dd><a name="CMD_FLIPPAGE"></a></dd>
</p>

</dd>
<dt><b>CMD_FLIPPAGE (5)</b></dt>
<dd>
<p> Switch to 2nd screenpage
<br>&nbsp;
<br>Setscreen(-1, -1, MI_MAGIC, CMD_FLIPPAGE)
<br>&nbsp;
<br>Will switch to the second screenpage. <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> will
be set.
<br>&nbsp;
<dd><a name="CMD_ALLOCMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_ALLOCMEM (6)</b></dt>
<dd>
<p> Allocate memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a> blk;

blk.size=sizeof(<a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a>);
/* alloc a block of 200 lines*/
blk.blk_y=200;

<a href="#Setscreen">Setscreen</a>(-1, &amp;blk, MI_MAGIC, CMD_ALLOCMEM);
if(blk.blk_start)
  puts(&quot;OK&quot;);
else
  puts(&quot;Out of memory&quot;);
</pre>
<br>The width of the block is currently always the width of the
virtual screen. For the hardware functions this block will be like a
screen (0,0,blk_w,blk_h), the coordinates start in the top left corner
(0,0). It will be internally recalculated.
<br>&nbsp;
<dd><a name="CMD_FREEMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_FREEMEM (7)</b></dt>
<dd>
<p> Release graphics card memory
<br>&nbsp;
<br>Setscreen(-1, &amp;blk, MI_MAGIC, CMD_FREEMEM)
<br>blk of the block to be released.
<br>&nbsp;
<dd><a name="CMD_SETADR"></a></dd>
</p>

</dd>
<dt><b>CMD_SETADR (8)</b></dt>
<dd>
<p> Set screen to fixed address
<br>&nbsp;
<pre>/* logical address or -1  */
int32_t logbase=blk.blk_start;
/* physical address or -1 */
int32_t physbase=blk.blk_start;

<a href="#Setscreen">Setscreen</a>(logbase, physbase, MI_MAGIC, CMD_SETADR);
</pre>
<dd><a name="CMD_ENUMMODES"></a></dd>
<dd><a name="ENUMMODE_EXIT"></a></dd>
<dd><a name="ENUMMODE_CONT"></a></dd>
</p>

</dd>
<dt><b>CMD_ENUMMODES (9)</b></dt>
<dd>
<p> Requests all available modes, since 13.01.2000
<br>&nbsp;
<pre>int32_t cdecl enumfunc(<a href="xbios_structures.html#SCREENINFO">SCREENINFO</a> *inf,int32_t flag)
{
  printf(&quot;%s\n&quot;,inf-&gt;name);
  return ENUMMODE_CONT;
}

<a href="#Setscreen">Setscreen</a>(-1, &amp;enumfunc, MI_MAGIC, CMD_ENUMMODES);
</pre>
<br>The function &quot;enumfunc&quot; will be called once for every
available mode. ENUMMODE_EXIT (0) will cancel CMD_ENUMMODES.
ENUMMODE_CONT (1) will continue. The parameters are handed over to the
stack using the C standard.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_TESTMODE">CMD_TESTMODE</a> (10)</b></dt>
<dd>
<p> This function only exist inside the ct60 with internal <a href="tos_main.html">TOS</a>
Radeon driver.
<br>&nbsp;
</p>

</dd>
</dl>
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Return value undefined.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available from the MilanTOS 4.08 onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Setscreen">Setscreen</a> &nbsp; <a href="#VsetScreen">VsetScreen</a> &nbsp; <a href="#Setscreen_2C_20ct60">Setscreen, ct60</a>
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Setscreen_2C_20ct60">4.5.19 Setscreen, ct60</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set screen« - Initializes the screen
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 5
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Setscreen( void *par1, void *par2, int16_t rez, int16_t
command );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This XBIOS routine corresponds to the <a href="#Setscreen">Setscreen</a> function with
additional parameters, and serves for altering the screen resolution
and screen memory addresses.
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">par1</td>
  <td align="left" valign="top">Depending on function - see below</td>
</tr>
<tr>
  <td align="left" valign="top">par2</td>
  <td align="left" valign="top">Depending on function - see below</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">Always 0x564E ('VN' for <a href="#VsetScreen">VsetScreen</a> New)</td>
</tr>
<tr>
  <td align="left" valign="top">command</td>
  <td align="left" valign="top">Command</td>
</tr>
</table>
</div>

<br>The following values are defined for <i>command</i>:
<br>&nbsp;
<dl class="UDO_env_description">
<dt><b><a href="Screen_functions.html#CMD_GETMODE">CMD_GETMODE</a> (0)</b></dt>
<dd>
<p> Getting current mode
<br>&nbsp;
<br>int32_t mode;
<br><a href="#Setscreen">Setscreen</a>(-1,&amp;mode,0x564E,<a href="Screen_functions.html#CMD_GETMODE">CMD_GETMODE</a>);
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_SETMODE">CMD_SETMODE</a> (1)</b></dt>
<dd>
<p> Set new graphic mode
<br>&nbsp;
<br>int32_t mode=0x1023 /* 800*608*16 */
<br>Setscreen(-1,mode,0x564E,<a href="Screen_functions.html#CMD_SETMODE">CMD_SETMODE</a>)
<br>&nbsp;
<br>This function is identical to <a href="#VsetScreen">VsetScreen</a>(0, 0, 3, modecode);
<br><a href="bios_main.html">BIOS</a> and <a href="vdi_main.html">VDI</a> will be initialised. Not the <a href="aes_main.html">AES</a>.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_GETINFO">CMD_GETINFO</a> (2)</b></dt>
<dd>
<p> Get screen info structure for mode
<br>&nbsp;
<pre><a href="xbios_structures.html#SCREENINFO">SCREENINFO</a> si;
/* Structure size has to be set         */
si.size=sizeof(<a href="xbios_structures.html#SCREENINFO">SCREENINFO</a>);
/* ID of the mode or 0 for current mode */
si.devID=0x1023;
/* status of the operation              */
si.scrFlags=0;
<a href="#Setscreen">Setscreen</a>(-1,&amp;si,0x564E,<a href="Screen_functions.html#CMD_GETINFO">CMD_GETINFO</a>);
if(si.scrFlags &amp; <a href="xbios_structures.html#SCRINFO_OK">SCRINFO_OK</a>)
  puts(&quot;OK&quot;);
else
  puts(&quot;Error&quot;);
</pre>
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_ALLOCPAGE">CMD_ALLOCPAGE</a> (3)</b></dt>
<dd>
<p> Allocate screenpage
<br>&nbsp;
<pre>/* Frame address or -1 */
int32_t adr=0;
<a href="#Setscreen">Setscreen</a>(&amp;adr,mode,0x564E,<a href="Screen_functions.html#CMD_ALLOCPAGE">CMD_ALLOCPAGE</a>);
if(adr)
  puts(&quot;OK&quot;);
else
  puts(&quot;Error&quot;);
</pre>
<br>This only allocates one page. A further call will only return
the frame address.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_FREEPAGE">CMD_FREEPAGE</a> (4)</b></dt>
<dd>
<p> Release screenpage
<br>&nbsp;
<br>Setscreen(-1,-1,0x564E,<a href="Screen_functions.html#CMD_FREEPAGE">CMD_FREEPAGE</a>)
<br>&nbsp;
<br>The graphics card memory will be released again. If the second
page had still been active the call will switch back to the first page
with <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> set.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_FLIPPAGE">CMD_FLIPPAGE</a> (5)</b></dt>
<dd>
<p> Switch to screenpage
<br>&nbsp;
<br>Setscreen(-1,-1,0x564E,<a href="Screen_functions.html#CMD_FLIPPAGE">CMD_FLIPPAGE</a>)
<br>&nbsp;
<br>Will switch to the second screenpage. <a href="#Logbase">Logbase</a> and <a href="#Physbase">Physbase</a> will
be set.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_ALLOCMEM">CMD_ALLOCMEM</a> (6)</b></dt>
<dd>
<p> Allocate memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a> blk;

blk.size=sizeof(<a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a>);
/* alloc a block of 200 lines*/
blk.blk_y=200;

<a href="#Setscreen">Setscreen</a>(-1,&amp;blk,0x564E,<a href="Screen_functions.html#CMD_ALLOCMEM">CMD_ALLOCMEM</a>);
if(blk.blk_start)
  puts(&quot;OK&quot;);
else
  puts(&quot;Out of memory&quot;);
</pre>
<br>The width of the block is currently always the width of the
virtual screen. For the hardware functions this block will be like a
screen (0,0,blk_w,blk_h), the coordinates start in the top left corner
(0,0). It will be internally recalculated.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_FREEMEM">CMD_FREEMEM</a> (7)</b></dt>
<dd>
<p> Release graphics card memory
<br>&nbsp;
<br>Setscreen(-1,&amp;blk,0x564E,<a href="Screen_functions.html#CMD_FREEMEM">CMD_FREEMEM</a>)
<br>blk of the block to be released.
<br>&nbsp;
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_SETADR">CMD_SETADR</a> (8)</b></dt>
<dd>
<p> Set screen to fixed address
<br>&nbsp;
<pre>/* logical address or -1  */
int32_t logbase=blk.blk_start;
/* physical address or -1 */
int32_t physbase=blk.blk_start;

<a href="#Setscreen">Setscreen</a>(logbase,physbase,0x564E,<a href="Screen_functions.html#CMD_SETADR">CMD_SETADR</a>);
</pre>
</p>

</dd>
<dt><b><a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a> (9)</b></dt>
<dd>
<p> Requests all available modes
<br>&nbsp;
<pre>int32_t cdecl enumfunc(<a href="xbios_structures.html#SCREENINFO">SCREENINFO</a> *inf,int32_t flag)
{
  printf(&quot;%s\n&quot;,inf-&gt;name);
  return <a href="Screen_functions.html#ENUMMODE_CONT">ENUMMODE_CONT</a>;
}

<a href="#Setscreen">Setscreen</a>(-1,&amp;enumfunc,0x564E,<a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a>);
</pre>
<br>The function &quot;enumfunc&quot; will be called once for every
available mode. <a href="Screen_functions.html#ENUMMODE_EXIT">ENUMMODE_EXIT</a> (0) will cancel <a href="Screen_functions.html#CMD_ENUMMODES">CMD_ENUMMODES</a>.
<a href="Screen_functions.html#ENUMMODE_CONT">ENUMMODE_CONT</a> (1) will continue. The parameters are handed over to the
stack using the C standard.
<br>&nbsp;
<dd><a name="CMD_TESTMODE"></a></dd>
</p>

</dd>
<dt><b>CMD_TESTMODE (10)</b></dt>
<dd>
<p> Test a graphic mode
<br>&nbsp;
<pre>/* 800*600*16M */
int32_t modecode=VESA_600+HORFLAG2+VGA+COL80+BPS32;
<a href="#Setscreen">Setscreen</a>(-1,modecode,0x564E,CMD_TESTMODE);
</pre>
<br>Only the <a href="bios_main.html">BIOS</a> is initialised, and a screen test arrives with
colored wide lines.
<br>&nbsp;
<br>This function not exist inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_COPYPAGE"></a></dd>
</p>

</dd>
<dt><b>CMD_COPYPAGE (11)</b></dt>
<dd>
<p> Copy screenpage
<br>&nbsp;
<pre><a href="#VsetScreen">VsetScreen</a>(-1,0,0x564E,CMD_COPYPAGE);
Copy first screenpage to second screenpage
<a href="#VsetScreen">VsetScreen</a>(-1,1,0x564E,CMD_COPYPAGE);
Copy second screenpage to first screenpage
</pre>
<br>This function not exist inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_FILLMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_FILLMEM (12)</b></dt>
<dd>
<p> Fill memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRFILLMEMBLK">SCRFILLMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRFILLMEMBLK">SCRFILLMEMBLK</a>);
blk.blk_op = BLK_COPY;
blk.blk_color = 0x112233;  /* background fill color */

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_SETMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Fill a block with a color with the GPU at (blk_x, blk_y), size
is blk_w, blk_h.
<br>Note that this structure has the same size and same entry the the
structure <a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a> for the entry for size, blk_status, blk_x, blk_y,
blk_y, blk_w and blk_h for use the allocated structure with a cast.
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_COPYMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_COPYMEM (13)</b></dt>
<dd>
<p> Copy memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRCOPYMEMBLK">SCRCOPYMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRCOPYMEMBLK">SCRCOPYMEMBLK</a>);

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_COPYMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Copy a block with the GPU at (blk_src_x, blk_src_y) to
(blk_dst_x, blk_dst_y), size is blk_w, blk_h.
<br>Note that this structure has the same size and same entry the the
structure <a href="xbios_structures.html#SCRMEMBLK">SCRMEMBLK</a> for the entry for size, blk_status, blk_x, blk_y,
blk_y, blk_w and blk_h for use the allocated structure with a cast
when blk_x is blk_dst_x and blk_y is blk_dst_y.
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_TEXTUREMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_TEXTUREMEM (14)</b></dt>
<dd>
<p> Put texture in memory on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRTEXTUREMEMBLK">SCRTEXTUREMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRTEXTUREMEMBLK">SCRTEXTUREMEMBLK</a>);

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_TEXTUREMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Copy a 65K texture from CPU local area to a 65K screen or an
ARGB texture to a 32M screen pixel format multiple times (best results
are with little source texture and big screen for destination).
<br>&nbsp;
<br>This function need a texture support inside the <a href="tos_main.html">TOS</a>.
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_GETVERSION"></a></dd>
</p>

</dd>
<dt><b>CMD_GETVERSION (15)</b></dt>
<dd>
<p>
<br>&nbsp;
<pre>/* if the function is not implemented, 0x0100 is the first release */
long version = 0x0100;
<a href="#VsetScreen">VsetScreen</a>(-1,&amp;version,0x564E,CMD_GETVERSION);
</pre>
<br>Return  the version of the video <a href="xbios_main.html">XBIOS</a>.
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_LINEMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_LINEMEM (16)</b></dt>
<dd>
<p> Draw line on the graphics card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRLINEMEMBLK">SCRLINEMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRLINEMEMBLK">SCRLINEMEMBLK</a>);
blk.blk_fbcolor = 0x112233;  /* foreground fill color */
blk.blk_bgcolor = 0;  /* background fill color */
blk.blk_pattern = 0xffffffff;  /* solid line */

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_LINEMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Draw a line with colors with the GPU at (blk_x1, blk_y1) to
(blk_x2, blk_y2).
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_CLIPMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_CLIPMEM (17)</b></dt>
<dd>
<p> Set clipping rectangle on the graphic card
<br>&nbsp;
<pre><a href="xbios_structures.html#SCRCLIPMEMBLK">SCRCLIPMEMBLK</a> blk;
blk.size=sizeof(<a href="xbios_structures.html#SCRCLIPMEMBLK">SCRCLIPMEMBLK</a>);
blk.blk_clip_on = 1; /* clipping flag 1:on,
                                      0:off */

<a href="#VsetScreen">VsetScreen</a>(-1,&amp;blk,0x564E,CMD_CLIPMEM);
if(blk.blk_status == <a href="xbios_structures.html#BLK_OK">BLK_OK</a>)
  puts(&quot;OK&quot;);
</pre>
<br>Enable or diable clipping rectange at (blk_x, blk_y), size is
blk_w, blk_h.
<br>&nbsp;
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_SYNCMEM"></a></dd>
</p>

</dd>
<dt><b>CMD_SYNCMEM (18)</b></dt>
<dd>
<p> <a href="powerdos.html#Wait">Wait</a> an empty GPU fifo for sync the drawing engine with the
memory.
<br>&nbsp;
<pre><a href="#VsetScreen">VsetScreen</a>(-1,-1,0x564E,CMD_SYNCMEM);
</pre>
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
<dd><a name="CMD_BLANK"></a></dd>
</p>

</dd>
<dt><b>CMD_BLANK (19)</b></dt>
<dd>
<p> Blank / unblank screen.
<br>&nbsp;
<pre>int32_t blank = 1; /* (0): unblank
                      (1): blank normal
                      (2): VSYNC suspend
                      (3): HSYNC suspend
                      (4): powerdown */
<a href="#VsetScreen">VsetScreen</a>(-1,blank,0x564E,CMD_BLANK);
</pre>
<br>This function exists since the version 0x0101 of the video <a href="xbios_main.html">XBIOS</a>
and is not inside the MilanTOS.
<br>&nbsp;
</p>

</dd>
</dl>
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Nothing (or current modecode in TOS mode)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Only valid with internal TOS Radeon driver (PCI.HEX) for the
ct60 (2007-01-24).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Setscreen">Setscreen</a> &nbsp; <a href="#VsetScreen">VsetScreen</a> &nbsp; <a href="#Setscreen_2C_20Milan">Setscreen, Milan</a>
<br>&nbsp;

</td></tr>
</table>

<h3><a name="ValidMode">4.5.20 ValidMode</a></h3>
<a name="VcheckMode"></a>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> «ValidMode» - Validates a mode code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 95
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t ValidMode( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function ValidMode returns a valid version of the
specified mode code, depending on the monitor that is connected. The
bits of the parameter <i>mode</i> have the following meaning:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">Bit</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="right" valign="top">0-2</td>
  <td align="left" valign="top">Number of colour planes:</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">0 =  1 plane       2 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">1 =  2 planes      4 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">2 =  4 planes     16 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">3 =  8 planes    256 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">4 = 16 planes  65536 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top">Set:     Image width at least 640 pixels (80 columns)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Cleared: Image width 320 pixels (40 columns)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">4</td>
  <td align="left" valign="top">Set:     VGA mode</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Cleared: TV mode (also Atari SC monitors)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">5</td>
  <td align="left" valign="top">Set:     PAL mode</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Cleared: NTSC mode</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">6</td>
  <td align="left" valign="top">Set:     Overscan active (not valid for VGA)</td>
</tr>
<tr>
  <td align="right" valign="top">7</td>
  <td align="left" valign="top">Set:     ST-compatible graphics</td>
</tr>
<tr>
  <td align="right" valign="top">8</td>
  <td align="left" valign="top">Set:     Interlace mode (on colour monitor or</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">double-line mode (on VGA monitor) active</td>
</tr>
</table>
</div>

<br><b>Note:</b> This function is not officially documented and
some development tools may also call it Validmode or VcheckMode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a valid mode code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series, Milan and CT60.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20ValidMode">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a> &nbsp; <a href="#VsetMode">VsetMode</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20ValidMode">4.5.20.1 Bindings for ValidMode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#ValidMode">ValidMode</a>( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)    ; Offset 2
move.w    #95,-(sp)     ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="VgetRGB">4.5.21 VgetRGB</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VgetRGB« - Obtain the RGB values of a colour palette.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 94
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void VgetRGB( int16_t index, int16_t count, int32_t *array );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function VgetRGB obtains the RGB values for
<i>count</i> colours starting from the colour index <i>index</i>.
The resulting values are stored in <i>array</i>.
<br>&nbsp;
<br><b>Note:</b> One should not try to backup more color than
supported by the video mode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See Also:</td>
<td valign="top"> <a href="#Bindings_20for_20VgetRGB">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20VgetRGB">4.5.21.1 Bindings for VgetRGB</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VgetRGB">VgetRGB</a>( int16_t index, int16_t count, int32_t *array );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    array,-(sp)  ; Offset 6
move.w    count,-(sp)  ; Offset 4
move.w    index,-(sp)  ; Offset 2
move.w    #94,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="VsetScreen">4.5.22 VsetScreen</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »set screen« - initializes the screen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 5
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void VsetScreen( void *laddr, void *paddr, int16_t rez, int16_t
mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine VsetScreen corresponds to the <a href="#Setscreen">Setscreen</a>
function with an additional parameter, and serves for altering the
current screen resolution and screen memory addresses.
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">laddr</td>
  <td align="left" valign="top">Address of the logical screen memory</td>
</tr>
<tr>
  <td align="left" valign="top">paddr</td>
  <td align="left" valign="top">Address of the physical screen memory</td>
</tr>
<tr>
  <td align="left" valign="top">rez</td>
  <td align="left" valign="top">0 = ST Low</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">1 = ST Medium</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">2 = ST High</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;&nbsp;&nbsp;</td>
  <td align="left" valign="top">3 = Resolution used, from <i>mode</i></td>
</tr>
<tr>
  <td align="left" valign="top">mode</td>
  <td align="left" valign="top">modecode (see <a href="#VsetMode">VsetMode</a>)</td>
</tr>
</table>
</div>

<br>A value of -1 here means that the corresponding address or
resolution will not be altered.
<br>&nbsp;
<br><b>Note:</b> One should always check whether possible changes
were really performed successfully. During resolution changes the
<a href="VT_52_terminal.html">VT52 emulator</a> is automatically initialized.
<br>&nbsp;
<br>The additional parameter <i>mode</i> is only available if the
cookie '<a href="bios_cookiejar.html#Cookie_2C_20_VDO">_VDO</a>' has the value 0x00030000 or greater.
<br>&nbsp;
<br>For the TOS of the Milan there is an additional function for
<a href="#Setscreen_2C_20Milan">Setscreen</a>, entsprechendes gilt auch für den <a href="#Setscreen_2C_20ct60">ct60</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20VsetScreen">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20VsetScreen">4.5.22.1 Bindings for VsetScreen</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VsetScreen">VsetScreen</a>( void *laddr, void *paddr, int16_t rez, int16_t
mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)   ; Offset 12
move.w    rez,-(sp)    ; Offset 10
move.l    paddr,-(sp)  ; Offset  6
move.l    laddr,-(sp)  ; Offset  2
move.w    #5,-(sp)     ; Offset  0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       14(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="VgetSize">4.5.23 VgetSize</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VgetSize« - Return the size of the screen buffer.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 91
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t VgetSize( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function VgetSize returns the size of the screen
buffer in bytes for the graphic mode <i>mode</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the size of the screen buffer in bytes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20VgetSize">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20VgetSize">4.5.23.1 Bindings for VgetSize</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#VgetSize">VgetSize</a>( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)    ; Offset 2
move.w    #91,-(sp)     ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="VsetMask">4.5.24 VsetMask</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VsetMask« - Set transparency for TrueColor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 150
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void VsetMask( int32_t ormask, int32_t andmask, int16_t overlay
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function VsetMask sets masks that are used to modify
the colours set by the <a href="About_the_VDI.html">VDI</a> function <a href="vdi_attribute.html#vs_color">vs_color</a>. <a href="vdi_attribute.html#vs_color">vs_color</a> obtains for
its parameter an RGB value. This is ORd bitwise with <i>ormask</i>
and ANDed with <i>andmask</i>. Thus colours may appear as transparent
in TrueColor mode. If <i>overlay</i> is non-zero a switch is made
into the overlay mode, or if zero switched back out of it.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20VsetMask">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp;
<a href="#VsetRGB">VsetRGB</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20VsetMask">4.5.24.1 Bindings for VsetMask</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VsetMask">VsetMask</a>( int32_t ormask, int32_t andmask, int16_t overlay
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    overlay,-(sp) ; Offset 10
move.l    andmask,-(sp) ; Offset 6
move.l    ormask,-(sp)  ; Offset 2
move.w    #150,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       12(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="VsetMode">4.5.25 VsetMode</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VsetMode« - Set video hardware registers.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 88
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t VsetMode( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function VsetMode programs the video hardware
register of the Falcon computer. The bits of the parameter
<i>mode</i> have the following meaning:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">Bit</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="right" valign="top">0-2</td>
  <td align="left" valign="top">Number of colour planes:</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">0 =  1 plane       2 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">1 =  2 planes      4 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">2 =  4 planes     16 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">3 =  8 planes    256 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">4 = 16 planes  65536 colours</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top">Set:     Image width at least 640 pixels (80 columns)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Cleared: Image width 320 pixels (40 columns)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">4</td>
  <td align="left" valign="top">Set:     VGA mode</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Cleared: TV mode (also Atari SC monitors)</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">5</td>
  <td align="left" valign="top">Set:     PAL mode</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">Cleared: NTSC mode</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
</tr>
<tr>
  <td align="right" valign="top">6</td>
  <td align="left" valign="top">Set:     Overscan active (not valid for VGA)</td>
</tr>
<tr>
  <td align="right" valign="top">7</td>
  <td align="left" valign="top">Set:     ST-compatible graphics</td>
</tr>
<tr>
  <td align="right" valign="top">8</td>
  <td align="left" valign="top">Set:     Interlace mode (on colour monitor or</td>
</tr>
<tr>
  <td align="right" valign="top">&nbsp;</td>
  <td align="left" valign="top">double-line mode (on VGA monitor) active</td>
</tr>
</table>
</div>

<a name="VM_INQUIRE"></a>
<br>If VM_INQUIRE (-1) is passed as <i>mode</i> one will get the
current resolution without changing anything.
<br>&nbsp;
<br><b>Note:</b> There is no check of the correctness of the coding
for the connected monitor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the old contents of the video hardware
register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20VsetMode">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20VsetMode">4.5.25.1 Bindings for VsetMode</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#VsetMode">VsetMode</a>( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)    ; Offset 2
move.w    #88,-(sp)     ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="VsetRGB">4.5.26 VsetRGB</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VsetRGB« - Set the RGB value of a colour.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 93
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void VsetRGB( int16_t index, int16_t count, int32_t *array );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function VsetRGB sets the RGB values for
<i>count</i> palette entries starting from the palette index
<i>index</i>. The colour values are stored in <i>array</i>.
<br>&nbsp;
<br><b>Note:</b> One should not try to restore more colors than
supported by the video mode.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20VsetRGB">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VsetSync">VsetSync</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20VsetRGB">4.5.26.1 Bindings for VsetRGB</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VsetRGB">VsetRGB</a>( int16_t index, int16_t count, int32_t *array );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    array,-(sp)  ; Offset 6
move.w    count,-(sp)  ; Offset 4
move.w    index,-(sp)  ; Offset 2
move.w    #93,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="VsetSync">4.5.27 VsetSync</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »VsetSync« - Sets the type of external synchronisation.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 90
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void VsetSync( int16_t flag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS function VsetSync determines how the video is to be
synchronized. The parameter <i>flag</i> is coded as follows:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">Bit</td>
  <td align="left" valign="top">Meaning for set bits</td>
</tr>
<tr>
  <td align="center" valign="top">0</td>
  <td align="left" valign="top">Use external clock</td>
</tr>
<tr>
  <td align="center" valign="top">1</td>
  <td align="left" valign="top">Use external vertical sync</td>
</tr>
<tr>
  <td align="center" valign="top">2</td>
  <td align="left" valign="top">Use external horizontal sync</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available on computers of the Falcon
series.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20VsetSync">Binding</a> &nbsp; <a href="#mon_type">mon_type</a> &nbsp; <a href="#VsetMode">VsetMode</a> &nbsp; <a href="#VgetSize">VgetSize</a> &nbsp; <a href="#VgetRGB">VgetRGB</a> &nbsp; <a href="#VsetRGB">VsetRGB</a> &nbsp;
<a href="#VsetMask">VsetMask</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20VsetSync">4.5.27.1 Bindings for VsetSync</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#VsetSync">VsetSync</a>( int16_t flag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    flag,-(sp)   ; Offset 2
move.w    #90,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Vsync">4.5.28 Vsync</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »vertical sync« - Hold process until next vertical sync
signal.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 37
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Vsync( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Vsync holds up program execution until the
next screen refresh (vertical blank interrupt). This makes it possible
to synchronize screen operations with the operating system.
<br>&nbsp;
<br><b>Note:</b> For time-critical operations (scrolling) it is
better to have recourse directly to the line counter in the Shifter.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Screen_20functions">Screen functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Vsync">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Vsync">4.5.28.1 Bindings for Vsync</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Vsync">Vsync</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #37,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Constants_20for_20the_20Falcon_27s_20video_20hardware">4.5.29 Constants for the Falcon's video hardware</a></h3>
<p>To simplify programming of the video hardware register of the
Falcon with the function <a href="#VsetMode">VsetMode</a>, the following constants are defined
in the header file tos.h, which can be combined with | :
</p>
<pre>    #define VERTFLAG  0x0100  /* Activate interlace                */
    #define STMODES   0x0080  /* ST-compatible graphics            */
    #define OVERSCAN  0x0040  /* Activate overscan                 */
    #define PAL       0x0020  /* PAL mode                          */
    #define FALC_VGA  0x0010  /* VGA mode                          */
    #define TV        0x0000  /* TV mode                           */

    #define COL80     0x0008  /* Picture width at least 640 pixels */
                                                      (80 columns) */
    #define COL40     0x0000  /* Picture width 320 pixels (40 col.)*/

    #define BPS16     4       /* 16 colour planes: 65536 colours   */
    #define BPS8      3       /*  8 colour planes:   256 colours   */
    #define BPS4      2       /*  4 colour planes:    16 colours   */
    #define BPS2      1       /*  2 colour planes:     4 colours   */
    #define BPS1      0       /*  1 colour plane:      2 colours   */
</pre>
<p>With the following constant the number of colour planes can be
masked out:
</p>
<pre>    #define NUMCOLS   7       /* if (( mode &amp; NUMCOLS ) == 0 ) */
                              /*   puts( &quot;monochrome mode&quot; );  */
</pre>
<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_trap.html"><img src="udo_lf.gif" alt="xbios-trap" title="xbios-trap" border="0" width="24" height="24">xbios-trap</a>
<a name="UDO_nav_rg_FOOT" href="CENTScreen_XBIOS_extension.html"><img src="udo_rg.gif" alt="CENTScreen XBIOS extension" title="CENTScreen XBIOS extension" border="0" width="24" height="24">CENTScreen XBIOS extension</a>
</body>
</html>
