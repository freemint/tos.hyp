<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2025/08/02 -->
<html lang="en">
<head>
<title>
The documentation for TOS: Process functions
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="gemdos_main.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
<a name="UDO_nav_lf_HEAD" href="gemdos_datetime.html"><img src="udo_lf.gif" alt="Date and Time" title="Date and Time" border="0" width="24" height="24">Date and Time</a>
<a name="UDO_nav_rg_HEAD" href="gemdos_memory.html"><img src="udo_rg.gif" alt="Memory management" title="Memory management" border="0" width="24" height="24">Memory management</a>

<hr>

<h1><a name="Process_20functions">5.11 Process functions</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pause">Pause</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Suspends a process until the arrival of a signal.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pdomain">Pdomain</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets or inquires the processes' execution domain.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pexec">Pexec</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Loads and executes a further program.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pfork">Pfork</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Creates a copy of the current process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetauid">Pgetauid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets the user ID of a process at the beginning.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetegid">Pgetegid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets the effective group ID of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgeteuid">Pgeteuid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets the effective user ID of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetgid">Pgetgid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets the group ID of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetgroups">Pgetgroups</a>&nbsp;&nbsp;</td>
<td valign="top"> gets the supplementary group ids for the calling process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetpgrp">Pgetpgrp</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets current process group number.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetpid">Pgetpid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets current process ID.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetppid">Pgetppid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets process ID for parent process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetpriority">Pgetpriority</a></td>
<td valign="top"> Gets the current priority value for a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pgetuid">Pgetuid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets the user ID of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pkill">Pkill</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sends a signal to a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pmsg">Pmsg</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sends and receives messages.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pnice">Pnice</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Alters priority of the calling process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Prenice">Prenice</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Adjusts priority of a specified process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Prusage">Prusage</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets resource information about current process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psemaphore">Psemaphore</a>&nbsp;&nbsp;</td>
<td valign="top"> Creates, uses or destroys a semaphore.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetauid">Psetauid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets user ID of a process at the start.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetegid">Psetegid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets effective group ID of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pseteuid">Pseteuid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets effective user ID of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetgid">Psetgid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Alters group ID of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetgroups">Psetgroups</a>&nbsp;&nbsp;</td>
<td valign="top"> Sets the supplementary group ids for the calling process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetlimit">Psetlimit</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets/gets limits of the system resources.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetpgrp">Psetpgrp</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets/gets process group number of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetpriority">Psetpriority</a></td>
<td valign="top"> Sets the current priority value for a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetregid">Psetregid</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets the real and/or effective group ID for the calling
process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetreuid">Psetreuid</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets the real and/or effective user ID for the calling process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psetuid">Psetuid</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Alters user ID of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigaction">Psigaction</a>&nbsp;&nbsp;</td>
<td valign="top"> Alters manner of signal handling.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigblock">Psigblock</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Alters signal mask.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigintr">Psigintr</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Assigns a signal to a particular exception vector.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psignal">Psignal</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Alters manner of signal handling.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigpause">Psigpause</a>&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets a new signal mask and then suspends process until the
arrival of a signal.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigpending">Psigpending</a>&nbsp;</td>
<td valign="top"> Checks which signals have been sent but not processed.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigreturn">Psigreturn</a>&nbsp;&nbsp;</td>
<td valign="top"> Prepares exit from a signal-handler.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psigsetmask">Psigsetmask</a>&nbsp;</td>
<td valign="top"> Sets/replaces a signal mask.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Psysctl">Psysctl</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets or sets system information.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pterm">Pterm</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Terminates program and returns value to caller.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pterm0">Pterm0</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Terminates program and returns 0 to caller.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Ptermres">Ptermres</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Terminates program but leaves it in memory.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Ptrace">Ptrace</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Process tracing and debugging.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pumask">Pumask</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets initial creation mask for files/directories.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pusrval">Pusrval</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Sets/interrogates specific process information.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pvfork">Pvfork</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Creates copy of the current process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pwait">Pwait</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Tries to get the exit code of waiting or terminated child
process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pwait3">Pwait3</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets exit code of any waiting or terminated children of the
calling process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Pwaitpid">Pwaitpid</a>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign="top"> Gets exit code information about one or more child processes.

</td></tr>
</table>

<p>See also: <a href="gemdos_memory.html">Memory management</a> &nbsp; <a href="gemdos_signals.html">Signals</a> &nbsp; <a href="magic_taskmanager.html">Task-Manager</a>
</p>
<h3><a name="Pause">5.11.1 Pause</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pause« - <a href="powerdos.html#Suspend">Suspend</a> a process until the arrival of a signal.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 289
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Pause ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pause suspends the calling process until a signal
for this arrives. If a signal-handler has been installed for this signal
with <a href="#Psignal">Psignal</a>, the handler will be called before the function Pause
returns.
<br>&nbsp;
<br>The function will not return if the signal-handler executes a
non-local jump (via longjump), or if the program is terminated.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function has no direct return result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04 and
<a href="magic.html">MagiC</a> as of Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pause">Binding</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="#Psigpause">Psigpause</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp;
<a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pause">5.11.1.1 Bindings for Pause</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Pause">Pause</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #289,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pdomain">5.11.2 Pdomain</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pdomain« - Set or get the caller's execution domain.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 281
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pdomain ( int16_t dom );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pdomain serves for setting or obtaining the domain
in which the process is executed. This domain can influence the
behaviour of the process drastically in parts. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">dom</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> Get currently valid domain (don't change it)
<a name="TOS-domain"></a>
<a name="Domain_2C_20TOS-"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top"> <b>TOS-domain</b> (default value). In this domain all
system calls behave exactly as under normal TOS.
<a name="MiNT-domain"></a>
<a name="Domain_2C_20MiNT-"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top"> <b>MiNT-domain</b>. In this domain the behaviour of <a href="gemdos_file.html#Fread">Fread</a> and
<a href="gemdos_file.html#Fwrite">Fwrite</a> is influences by the parameters set for <a href="gemdos_file.html#Fcntl">Fcntl</a> when these are
applied to a terminal. Furthermore, filenames returned by <a href="gemdos_file.html#Fsfirst">Fsfirst</a> or
<a href="gemdos_file.html#Fsnext">Fsnext</a> are handled in a different way.

</td></tr>
</table>

<br><b>Note:</b> MiNT-compatible processes should also be able to
deal with files that do <i>not</i> correspond to the standard DOS
convention (8+3 characters).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the domain of the process that was valid
at the function call.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04 and
<a href="magic.html">MagiC</a> as of Version 4.0 (05.11.1995).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pdomain">Binding</a> &nbsp; <a href="gemdos_directory.html#Dpathconf">Dpathconf</a> &nbsp; <a href="gemdos_directory.html#Dopendir">Dopendir</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pdomain">5.11.2.1 Bindings for Pdomain</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pdomain">Pdomain</a> ( int16_t dom );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    dom,-(sp)    ; Offset 2
move.w    #281,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pexec">5.11.3 Pexec</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Program execution« - Load and execute a program.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 75
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pexec ( uint16_t mode, ... );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pexec loads and launches a program. With the
parameter <i>mode</i> one can select from several variants:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> Meaning
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> int32_t Pexec (0, int8_t *name, int8_t *cmdline, int8_t *env);
<br>&nbsp;
<br><b>Load and go:</b> Loads and launches the program specified in
<i>name</i> and passes the command line <i>cmdline</i>. Returns a
WORD exit code when the child terminates. The following apply for the
parameter <i>env</i>:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> = Do not create an environment
</td></tr>

<tr><td nowrap="nowrap" valign="top">NULL</td>
<td valign="top"> = Inherit the environment of the parent

</td></tr>
</table>

<br>Any other value is a pointer to the environment to be inherited.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top"> PD *Pexec (3, int8_t* name, int8_t *cmdline, int8_t *env);
<br>&nbsp;
<br><b>Load, don't go:</b> This is used most often for launching
overlays or for loading programs in a debugger. Corresponds to
<i>mode 0</i> with the difference that the program is not launched
immediately, but that a pointer to the child processes' basepage is
returned as a LONG. The parent owns the memory of the child's
environment and basepage and hence must free them when finished with
the child.
<br><b>Note:</b> flushing of the data cache and invalidation of the
instruction cache is caller's responsibility in case the intention is
not to use Pexec mode 4 but calling the program's function manually
instead (e.g. plugins with a jump table).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">4</td>
<td valign="top"> int32_t Pexec (4, 0L, <a href="gemdos_structures.html#PD">PD</a> *basepage, 0L);
<br>&nbsp;
<br><b>Just go:</b> Launches an already loaded program with
basepage at the specified address. The basepage should have been
created with <i>mode 3</i> or <i>5</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">5</td>
<td valign="top"> PD *Pexec (5, 0L, int8_t *cmdline, int8_t *env);
<br>&nbsp;
<br><b>Create basepage:</b> First of all GEMDOS creates a new
environment. Then the largest block of free memory is allocated and a
basepage is created in the first 256 bytes. The following applies for
the parameter <i>env</i>:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> = Do not create an environment
</td></tr>

<tr><td nowrap="nowrap" valign="top">NULL</td>
<td valign="top"> = Inherit the environment of the parent

</td></tr>
</table>

<br>Any other value is a pointer to the environment to be inherited.
<br>&nbsp;
<br>With MiNT, use of this mode in conjunction with <i>mode 3</i>
can be used to emulate the <a href="#Pvfork">Pvfork</a> call without blocking the parent.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">6</td>
<td valign="top"> int32_t Pexec (6, 0L, <a href="gemdos_structures.html#PD">PD</a> *basepage, 0L);
<br>&nbsp;
<br><b>Just go, then free:</b> Corresponds to <i>mode 4</i> but
with the difference that the allocated memory belongs to the launched
process (child) and not to the launcher (parent); thus the basepage
memory blocks are freed automatically when the child is terminated
with <a href="#Pterm">Pterm</a>. Together with <i>mode 3</i> one can achieve the same
effect with it as with <i>mode 0</i>. This mode is available only
from GEMDOS Version 0.15.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">7</td>
<td valign="top"> <a href="gemdos_structures.html#PD">PD</a> *Pexec (7, uint32_t prgflags, int8_t *cmdline, int8_t *env);
<br>&nbsp;
<br><b>Create basepage, respecting prgflags:</b> Similar to
<i>mode 5</i>, but in <i>prgflags</i> one can pass the same
information as in the <a href="gemdos_programs.html#ph_prgflags">ph_prgflags</a> field of the program header. This
mode is used by the BIOS of the TT030 to launch <a href="gem_about.html">GEM</a>, and is only
available as of GEMDOS Version 0.19.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">100</td>
<td valign="top"> int32_t Pexec (100, int8_t *name, int8_t *cmdline, int8_t
*env);
<br>&nbsp;
<br><b>Load, go, don't wait:</b> Similar to <i>mode 0</i>, only
the caller does not wait until the launched program is terminated,
i.e. the parent process is returned to immediately while the child
continues to excecute. The return value is a negative error-code or
the positive PID of the child.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">101</td>
<td valign="top"> As this mode is only used internally by <a href="magic.html">MagiC</a> for inheriting
path and file handles, the details of the exact syntax will be forgone
here.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">102</td>
<td valign="top"> Is used internally by <a href="magic.html">MagiC</a> to remove a given process.
Therefore the details of the exact syntax will be forgone here.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">104</td>
<td valign="top"> int32_t Pexec (104, int8_t *name, <a href="gemdos_structures.html#PD">PD</a> *basepage, 0L);
<br>&nbsp;
<br><b>Just go, don't wait:</b> Similar to <i>mode 4</i>, only the
caller does not wait until the launched program is terminated. A
process will be launched whose basepage was set earlier with <i>mode
3, 5</i> or <i>7</i>. One should note that the environment and the
basepage of the child is also owned by the parent (in fact the child
inherits all the memory that is possessed by the parent). The
parameter <i>name</i> is a pointer to a string that describes the
name of the new process; with a NULL value the name of the parent
process will be used. The function returns a negative error-code, or
the positive PID of the child.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">106</td>
<td valign="top"> int32_t Pexec (106, int8_t *name, <a href="gemdos_structures.html#PD">PD</a> *basepage, 0L);
<br>&nbsp;
<br><b>Just go, don't wait, no sharing:</b> Similar to <i>mode
104</i>, however the environment and basepage of the child are
<i>not</i> in the possession of the parent, and the child has no
access to memory that was allocated to the parent process. At the
termination of the child its memory is released again. In combination
with <i>mode 3</i>, therefore, Pexec (106, ...) corresponds to
<i>mode 100</i> (while <i>mode 3</i> followed by <i>mode 6</i>
corresponds to a call of Pexec (0, ...)).
<br>Is no longer supported from <a href="magic.html">MagiC</a> 2.0 onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">107</td>
<td valign="top"> Corresponds essentially with <i>mode 7</i>, and is used
internally by <a href="magic.html">MagiC</a> since version 2.10. Hence the details of the exact
syntax will be forgone here.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">108</td>
<td valign="top"> Is used by MagiC since version 2.10 internally for launching a
desk accessory. Since the exact syntax is not officially documented,
it is better for own programs to fall back on <a href="shel.html#shel_write">shel_write</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">200</td>
<td valign="top"> int32_t Pexec (200, int8_t *name, int8_t *cmdline, int8_t
*env);
<br>&nbsp;
<br><b>Replace program and go:</b> Similar to <i>mode 100</i>,
however the new process overwrites the old one completely. Though the
old process retains its PID and most of its attributes, all the memory
it occupied will be released. While Pexec (0, ...) can be taken as a
subprogram call (call...return), this mode acts more like a 'goto'.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">300</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">301</td>
<td valign="top">
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">401</td>
<td valign="top"> Is used internally by <a href="magic.html">MagiC</a>. Therefore the details of the exact
syntax will be forgone here.
<br>&nbsp;

</td></tr>
</table>

<br><b>Note:</b> Not all the modes are available under all
varieties of operating system; therefore careful note should be taken
of the return value of the function. Unknown modes results in a
function return of <a href="gemdos_errors.html#EINVFN">EINVFN</a>.
<br>&nbsp;
<br>Command lines are passed as a <i>Pascal format</i> string, i.e.
the first byte contains the length of the line (maximum 124
characters).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> <b>Return value:</b> The function returns the exit code of the
child process. If an overlay was loaded, the result contains the
basepage of the overlay. With a negative result, an error has arisen.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All GEMDOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pexec">Binding</a> &nbsp; <a href="shel.html#shel_write">shel_write</a> &nbsp; <a href="gemdos_programs.html#The_20program_20flags">Program flags</a> &nbsp; <a href="gemdos_argv.html">ARGV procedure</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pexec">5.11.3.1 Bindings for Pexec</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pexec">Pexec</a> ( uint16_t mode, ... );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       env          ; Offset 12
pea       cmdline      ; Offset  8
pea       name         ; Offset  4
move.w    mode,-(sp)   ; Offset  2
move.w    #75,-(sp)    ; Offset  0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
lea       $10(sp),sp   ; Correct stack
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top"> Adresse%=Gemdos(&amp;H4B,W:mode%,L:name%,L:cmdline%,L:env)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Pfork">5.11.4 Pfork</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pfork« - Create a copy of the current process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 283
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pfork ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pfork creates a copy of the current process. The
child process inherits a copy of the address space of the parent
process, i.e. changes made to variables by the child have no effect on
the parent.
<br>&nbsp;
<br>The newly created process starts its work when the function
Pfork returns.
<br>&nbsp;
<br>If the parent is in supervisor-mode when this call is made, the
child is launched in user-mode anyway.
<br>&nbsp;
<br>New processes launched with this call should not use <a href="gemdos_memory.html#Mshrink">Mshrink</a>,
but are required to do any GEM initialisation such as <a href="appl.html#appl_init">appl_init</a> and
v_openvwk again (if they need to use GEM). Both parent and child
use <a href="#Pterm">Pterm</a> or <a href="#Pterm0">Pterm0</a> to terminate themselves.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> In child process
</td></tr>

<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> New process ID in parent process
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENSMEM">ENSMEM</a>:</td>
<td valign="top"> Not enough memory available to create the new process

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pfork">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pvfork">Pvfork</a> &nbsp; <a href="magic_threads.html">Threads</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pfork">5.11.4.1 Bindings for Pfork</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pfork">Pfork</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #283,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetauid">5.11.5 Pgetauid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetauid« - Get user ID of a process at the start.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 325 (0x0145)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pgetauid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetauid obtains the start user ID of the current
process. Together with <a href="#Psetauid">Psetauid</a> one can use it in a multi-user
environment to ascertain who was the first logged-in user.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The return value is the start user ID of the process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> From MiNT 1.11 onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetauid">Binding</a> &nbsp; <a href="#Psetauid">Psetauid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetauid">5.11.5.1 Bindings for Pgetauid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetauid">Pgetauid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #325,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetegid">5.11.6 Pgetegid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetegid« - Get effective group ID of a process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 313
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pgetegid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetegid returns the effective group ID of the
current process and resembles the system call <a href="#Pgetgid">Pgetgid</a>. The difference
lies in that here the effective group ID is returned.
<br>&nbsp;
<br>This is normally identical to the actual group ID; however, if a
program is running that has set the setgid bit, its effective group ID
is equal to the (actual) ID of the owner of this program file.
<br>&nbsp;
<br>File accesses are based, among other things, on the effective
group ID, so that the setgid mechanism allows users (particularly the
super-user) to permit access by other users.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The return value is the effective group ID of the process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.95
exists.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetegid">Binding</a> &nbsp; <a href="#Pgetuid">Pgetuid</a> &nbsp; <a href="#Pgetgid">Pgetgid</a> &nbsp; <a href="#Pgeteuid">Pgeteuid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetegid">5.11.6.1 Bindings for Pgetegid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pgetegid">Pgetegid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #313,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgeteuid">5.11.7 Pgeteuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgeteuid« - Get effective user ID of a process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 312
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pgeteuid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgeteuid returns the effective user ID of the
current process and resembles the system call <a href="#Pgetuid">Pgetuid</a>. The difference
lies in that here the effective user ID is returned.
<br>&nbsp;
<br>This is normally identical to the actual user ID; however, if a
program is running that has set the setuid bit, its effective user ID
is equal to the (actual) ID of the owner of this program file.
<br>&nbsp;
<br>File accesses are based, among other things, on the effective
user ID, so that the setuid mechanism allows users (particularly the
super-user) to permit access by other users.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The return value is the effective user ID of the process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.95
exists.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgeteuid">Binding</a> &nbsp; <a href="#Pgetuid">Pgetuid</a> &nbsp; <a href="#Pgetgid">Pgetgid</a> &nbsp; <a href="#Pgetegid">Pgetegid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgeteuid">5.11.7.1 Bindings for Pgeteuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pgeteuid">Pgeteuid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #312,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetgid">5.11.8 Pgetgid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetgid« - Get group ID of a processes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 276
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pgetgid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetgid returns the actual group ID of the current
calling processes. This is as number between 0 and 255, which sets the
rights of the process group.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The return value is the actual group ID of the process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetgid">Binding</a> &nbsp; <a href="#Pgetuid">Pgetuid</a> &nbsp; <a href="#Pgeteuid">Pgeteuid</a> &nbsp; <a href="#Pgetegid">Pgetegid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetgid">5.11.8.1 Bindings for Pgetgid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetgid">Pgetgid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #276,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetgroups">5.11.9 Pgetgroups</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetgroups« - Gets the supplementary group IDs for the
calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 327 (0x0147)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pgetgroups( int16_t len, int16_t *gidset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetgroups obtains the supplementary group IDs for
the calling process.
<br>&nbsp;
<br><i>len</i> specifies the length (in words) of the array to be
filled with the supplementary group IDs available. This value must be
a positive number not greater than NGROUPS_MAX. If <i>len</i> is a
zero, the call will return the number of supplementary group ids
currently available for the calling process.
<br>&nbsp;
<br><i>gidset</i> is a pointer to a word array to be filled with
retrieved ids.
<br>&nbsp;
<br>The NGROUPS_MAX value is returned by <a href="gemdos_system.html#Sysconf">Sysconf</a>().
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns a number of supplementary group IDs for the process on
success or a negative GEMDOS error code otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is available from MiNT 1.11 onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetgroups">Binding</a> &nbsp; <a href="#Psetgroups">Psetgroups</a> &nbsp; <a href="gemdos_system.html#Sysconf">Sysconf</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetgroups">5.11.9.1 Bindings for Pgetgroups</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pgetgroups">Pgetgroups</a>( int16_t len, int16_t *gidset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       gidset       ; Offset 4
move.w    len,-(sp)    ; Offset 2
move.w    #327,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetpgrp">5.11.10 Pgetpgrp</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetpgrp« - Get current group number.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 269
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pgetpgrp ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetpgrp returns the group number code of the
currently active process. Process groups are normally used for
job-control and similar purposes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Process group number of the active process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetpgrp">Bindings for Pgetpgrp</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Pgetpid">Pgetpid</a> &nbsp; <a href="#Psetpgrp">Psetpgrp</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetpgrp">5.11.10.1 Bindings for Pgetpgrp</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetpgrp">Pgetpgrp</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #269,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetpid">5.11.11 Pgetpid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetpid« - Get current process ID.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 267 (0x010b)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pgetpid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetpid returns the PID of the currently active
(calling) process, i.e. the one that currently 'owns' the CPU; this is
the filetype under which the current process is administered in the
directory U:\PROC.
<br>&nbsp;
<br>A PID is dynamically assigned to a process when it is created.
You should make no assumption on the PID a process may have. For the
kernel, the PID is a WORD but when you program in C, you should use
the pid_t type, which complies with the POSIX standard. The FreeMiNT
kernel's PID is always 0.
<br>&nbsp;
<br>The PID is useful when it is important to identify a process
among others in the system. Knowing the PID of a program, it is
possible to do a lot of things: send it a signal with <a href="#Psignal">Psignal</a>(), look
for its name in /proc by searching with a &quot;*.xxx&quot; mask (xxx
is the PID of the program which name we wanna know), etc.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> PID of the active processes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available in MagiC from Version 3.0 on and
under MiNT.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetpid">Binding</a> &nbsp; <a href="#Pgetpgrp">Pgetpgrp</a> &nbsp; <a href="#Pgetppid">Pgetppid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetpid">5.11.11.1 Bindings for Pgetpid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetpid">Pgetpid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #267,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetppid">5.11.12 Pgetppid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetppid« - Get process ID for parent process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 268 (0x010c)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pgetppid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetppid returns the PID of the parent process of
the currently active (calling) process.
<br>&nbsp;
<br>In the FreeMiNT kernel, processes are represented as a tree. The
root of the tree is the kernel itself (PID 0). At boot time, the
kernel launches another process (which can be 'init' in case of a
Unix-like setup, or an AES, a shell or whatever) specified by the
INIT or <a href="gem_about.html">GEM</a> keyword in the mint.cnf file. This process will launch
other processes (daemons, accessories, programs etc) that are its
so-called children.
<br>&nbsp;
<br>Therefore, every process (but the kernel, obviously) is created
by its so-called parent. The Pgetppid() (get parent's PID) call allows
determination the PID of the parent of the calling process. To have a
good illustration of this, you can use the 'ps' command in your shell.
You will see that all accessories parent is the AES, and that the
daemons are started by the 'init' program.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Process ID of the parent (positive). If the current process was
started directly from the kernel, 0 will be returned. A return value
of -1 signals that the process has no parent.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04 and
MagiC as of Version 3.0.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetppid">Binding</a> &nbsp; <a href="#Pgetpgrp">Pgetpgrp</a> &nbsp; <a href="#Pgetpid">Pgetpid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetppid">5.11.12.1 Bindings for Pgetppid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetppid">Pgetppid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #268,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetpriority">5.11.13 Pgetpriority</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetpriority« - Get the current priority value for a
process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 344 (0x0158)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pgetpriority ( int16_t which, int16_t who);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetpriority obtains the priority of the processes
specified by <i>which</i> and <i>who</i>. The interpretation of
parameter <i>who</i> depends on <i>which</i>:
<br>&nbsp;
<a name="PRIO_PROCESS"></a>
<br>PRIO_PROCESS (0) reads the priority of process with process ID
<i>who</i>. A <i>who</i> of 0 implies the process id of the calling
process.
<br>&nbsp;
<a name="PRIO_PGRP"></a>
<br>PRIO_PGRP (1) reads the priority of the process group with
process group ID <i>who</i>. If the priorities of the process differ,
the lowest valued priority (i.e. the highest CPU usage priority) is
returned. A <i>who</i> of 0 implies the process group id of the
calling process.
<br>&nbsp;
<a name="PRIO_USER"></a>
<br>PRIO_USER (2) reads the priority of the process of the user with
user ID <i>who</i>. For multiple processes the lowest valued priority
is returned. A <i>who</i> of 0 implies the user id of the calling
process.
<br>&nbsp;
<br>Library functions should first check for an error condition and
then decrement the returned value by 20.
<br>&nbsp;
<br>This call makes calls <a href="#Pnice">Pnice</a> and <a href="#Prenice">Prenice</a> obsolete.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Return value is either a negative error number in case of
failure or the requested priority + 20 on success.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> MiNT 1.15.0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetpriority">Binding</a> &nbsp; <a href="#Psetpriority">Psetpriority</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetpriority">5.11.13.1 Bindings for Pgetpriority</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pgetpriority">Pgetpriority</a> ( int16_t which, int16_t who);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    who,-(sp)    ; Offset 4
move.w    which,-(sp)  ; Offset 2
move.w    #344,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pgetuid">5.11.14 Pgetuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pgetuid« - Get user ID of a process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 271
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pgetuid ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pgetuid returns the actual user ID of the current
(calling) process. This is a number between 0 and 255 that determines
the access rights permissions of the process, and can be used to
differentiate the individual users in multi-user systems.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The return value is the actual user ID of the process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pgetuid">Binding</a> &nbsp; <a href="#Pgetgid">Pgetgid</a> &nbsp; <a href="#Pgeteuid">Pgeteuid</a> &nbsp; <a href="#Pgetegid">Pgetegid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pgetuid">5.11.14.1 Bindings for Pgetuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pgetuid">Pgetuid</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #271,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pkill">5.11.15 Pkill</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pkill« - <a href="powerdos.html#Send">Send</a> a signal to one or more processes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 273
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pkill ( int16_t pid, int16_t sig );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pkill sends the signal <i>sig</i> to one or more
processes. The following apply for the parameter <i>pid</i>:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">pid</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">&gt; 0</td>
<td valign="top"> The signal will be sent to the process with the specified
<i>pid</i>
</td></tr>

<tr><td nowrap="nowrap" valign="top">= 0</td>
<td valign="top"> The signal will be sent to all processes of the corresponding
process group (this includes the caller itself too!)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&lt; 0</td>
<td valign="top"> The signal will be sent to all processes with the group number
<i>-pid</i>

</td></tr>
</table>

<br>The signal <a href="gemdos_signals.html#SIGNULL">SIGNULL</a> is not handled by Pkill in the usual way. It
can be used to test the existence of a process. For this one sends it
a SIGNULL, and checks whether Pkill returns with the value 0.
<br>&nbsp;
<br>Since <a href="magic.html">MagiC</a> 6.01 (1998.10.10) are also PIDs &lt; 0 supported.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> No error has arisen
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> If <i>pid</i> &gt; 0 and the specified process no longer
exists, or if <i>pid</i> &lt; 0 and the specified process group has
no members any more
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> If <i>pid</i> &gt; 0, and the sending process has no EUID of 0
and in addition if the UID of the receiving process differs from the
sending one
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> <i>sig</i> is an invalid signal

</td></tr>
</table>

<br><b>Note:</b> If the current process receives the signal iself
and is terminated, the function does not return!
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04 and
<a href="magic.html">MagiC</a> as of Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pkill">Binding</a> &nbsp; <a href="#Psetpgrp">Psetpgrp</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pkill">5.11.15.1 Bindings for Pkill</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pkill">Pkill</a> ( int16_t pid, int16_t sig );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    sig,-(sp)    ; Offset 4
move.w    pid,-(sp)    ; Offset 2
move.w    #273,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pmsg">5.11.16 Pmsg</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pmsg« - <a href="powerdos.html#Send">Send</a> and receive messages.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 293
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pmsg ( int16_t mode, int32_t mbox, void *msg );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pmsg sends or receives a message to or from a
'mail box'. The operation to be executed in each case can be set with
the bits of the parameter <i>mode</i>. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> Operation
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x0000</td>
<td valign="top"> Block the process and don't return until a message is read from
the specified mailbox <i>mbox</i> and placed in the structure pointed
to by <i>msg</i>.
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x0001</td>
<td valign="top"> Block the process and don't return until a process waiting for
a message with mailbox ID <i>mbox</i> has received the message from
the structure pointed to by <i>msg</i>.
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x0002</td>
<td valign="top"> Block the process until a process waiting for a message with
the mailbox ID <i>mbox</i> has received the message held in the
structure pointed to by <i>msg</i> and a return message is received
with mailbox ID 0xffffxxxx (where xxxx is the PID of the current
process).
</td></tr>

<tr><td nowrap="nowrap" valign="top">0x8000</td>
<td valign="top"> An OR combination with this value allows the operation to be
performed in a non-blocking mode.

</td></tr>
</table>

<br>The messages are 5 words long, namely two LONGwords and one
SHORT (in that order). For this the two LONGs can be filled with any
desired information by the process, while the SHORT should have the
PID of the sender entered in it.
<br>&nbsp;
<br>After the message has been sent, this SHORT contains the PID of
the process that has read the message. Conversely, after reading a
message it contains the PID of the processes that wrote the message.
<br>&nbsp;
<br>If <i>mode</i> has the highest bit set and no readers or
writers for the mailbox <i>mbox</i> exist, then the value -1 will be
returned. Otherwise a read operation waits until a message has been
written, or a write operation waits until a read process is ready.
<br>&nbsp;
<br>Im <i>mode 2</i> the writer says that it would like to wait for
a reply. The idea behind this is that the process can put itself to
sleep, and can be reawakened later by the process that receives the
message. This will guarantee that the process that contains the
original message is not blocked when writing the reply.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a> :</td>
<td valign="top"> No error has arisen
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EINVFN">EINVFN</a> :</td>
<td valign="top"> Invalid value for the parameter <i>mode</i>
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1 :</td>
<td valign="top"> Bit 15 is set, and Pmsg would block

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.90
exists.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pmsg">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pmsg">5.11.16.1 Bindings for Pmsg</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pmsg">Pmsg</a> ( int16_t mode, int32_t mbox, void *msg );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       msg          ; Offset 8
move.l    mbox,-(sp)   ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #293,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
lea       $C(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pnice">5.11.17 Pnice</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pnice« - Alter priority of the calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 266
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pnice ( int16_t delta );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pnice alters the priority of the process calling
it by the value <i>delta</i>. A higher priority means that the
process receives a larger time-slice, i.e. it is not switched over so
often. In the same way, a lower priority means that the time-slice of
the process is reduced, and so it must yield time to the CPU more
often.
<br>&nbsp;
<br>For the parameter <i>delta</i> the following must apply:
<br>- 20 &lt;= delta &lt;= 20.
<br>&nbsp;
<br>The function Pnice corresponds to <a href="#Prenice">Prenice</a> (<a href="#Pgetpid">Pgetpid</a>, delta) and
is implemented for backwards compatibility.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the current process switching priority.
This is set to 0 by default. Higher or lower values mean that the
process is allocated respectively a larger or smaller time-slice.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04 and
<a href="magic.html">MagiC</a> since Version 6.20 (2000-01-02).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pnice">Binding</a> &nbsp; <a href="#Prenice">Prenice</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pnice">5.11.17.1 Bindings for Pnice</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pnice">Pnice</a> ( int16_t delta );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    delta,-(sp)  ; Offset 2
move.w    #266,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Prenice">5.11.18 Prenice</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Prenice« - Adjust priority of a specified process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 295
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Prenice ( int16_t pid, int16_t delta );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Prenice alters the priority of the process with
the ID <i>pid</i> by the value <i>delta</i>. A higher priority means
that the process receives a larger time-slice, i.e. it is not switched
over so often. In the same way, a lower priority means that the
time-slice of the process is reduced, and so it must yield time to the
CPU more often.
<br>&nbsp;
<br>For the parameter <i>delta</i> the following must apply:
<br>- 20 &lt;= delta &lt;= 20.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the current process switching priority.
This is set to 0 by default. Higher or lower values mean that the
process is allocated respectively a larger or smaller time-slice.
<br>&nbsp;
<br>In case of error the function returns:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> The specified process does not exist
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> The specified process has a different user ID than the calling
process

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.90
exists and <a href="magic.html">MagiC</a> since version 6.20 (2000-01-02).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Prenice">Bindings for Prenice</a> &nbsp; <a href="#Pnice">Pnice</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Prenice">5.11.18.1 Bindings for Prenice</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Prenice">Prenice</a> ( int16_t pid, int16_t delta );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    delta,-(sp)  ; Offset 4
move.w    pid,-(sp)    ; Offset 2
move.w    #295,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Prusage">5.11.19 Prusage</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Prusage« - Obtain resource information about current
process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 286
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Prusage ( int32_t *r );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Prusage returns information about the system
resources required by the current process.
<br>&nbsp;
<br>The information is passed to the outside by a pointer <i>r</i>
to an array of 8 LONGs; the allocation is as follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">r[0]:</td>
<td valign="top"> Process time spent in MiNT kernel
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[1]:</td>
<td valign="top"> Process time spent in its own program code
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[2]:</td>
<td valign="top"> Total process time spent by children of this process in MiNT
kernel
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[3]:</td>
<td valign="top"> Total process time spent by children of this process in their
own program code
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[4]:</td>
<td valign="top"> Memory allocated by process (in bytes)
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[5]:</td>
<td valign="top"> Reserved for future use
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[6]:</td>
<td valign="top"> Reserved
</td></tr>

<tr><td nowrap="nowrap" valign="top">r[7]:</td>
<td valign="top"> Reserved

</td></tr>
</table>

<br>All times are given in milliseconds.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function has no direct result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Prusage">Binding</a> &nbsp; <a href="#Psetlimit">Psetlimit</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Prusage">5.11.19.1 Bindings for Prusage</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Prusage">Prusage</a> ( int32_t *r );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       r            ; Offset 2
move.w    #286,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psemaphore">5.11.20 Psemaphore</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psemaphore« - Create, use or destroy a semaphore.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 308
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psemaphore ( int16_t mode, int32_t id, int32_t timeout
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psemaphore implements non-counting semaphores.
Only one process can access a semaphore at the same time.
<br>&nbsp;
<br>Semaphores can be used, for instance, to synchronise accesses to
data structures in <a href="magic_driveu.html#Shared_20memory">shared memory</a> by different subprocesses: Hence a
subprocess must try, before it accesses memory, to obtain possession
of the semaphore. This can be created during initialisation, for
instance, and removed again at program termination.
<br>&nbsp;
<br>Semaphores are identified by a name. This name is a LONGword
that may contain four ASCII characters. Semaphores whose name starts
with an underscore '_' are reserved for the operating system.
<br>&nbsp;
<br><b>The parameter <i>timeout</i> is only used in <i>mode
2</i>. The following assignments apply:</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">timeout</td>
<td valign="top"> = &nbsp;0: Return immediately.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> = -1: No timeout (wait indefinitely).

</td></tr>
</table>

<br>Other values for <i>timeout</i> specify the delay time in
milliseconds before a timeout occurs.
<br>&nbsp;
<br><b>The following values are possible for the parameter
<i>mode</i>:</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">mode</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> Create a semaphore with the ID <i>id</i> (and grant ownership
to the calling process)
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> Destroy semaphore with the ID <i>id</i>; this works only if
the semaphore is owned by the caller
</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top"> Request ownership of the semaphore with the ID <i>id</i>; this
blocks the caller until the semaphore becomes available, or a timeout
occurs
</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top"> Release ownership of semaphore with the ID <i>id</i>; this
works only if the semaphore is owned by the caller

</td></tr>
</table>

<br><b>Note:</b> When a process creates a semaphore, it also owns
it immediately. So that other processes may use it, it must first be
released. As the creation of a semphore has to reserve internal
memory, the function should be used frugally.
<br>&nbsp;
<br>If a blocked process is waiting for a semaphore (before the
timeout occurs), and a different process destroys the semaphore, then
the function Psemaphore returns with the message <a href="gemdos_errors.html#ERANGE">ERANGE</a>, as the
requested semaphore no longer exists.
<br>&nbsp;
<br>When a process terminates, all semaphores owned by it are
released automatically (but not destroyed). The ownership of a
semaphore can not be inherited (say with <a href="#Pfork">Pfork</a>). If a process creates
a semaphore and then crashes, the semaphore remains and cannot be
removed any more.
<br>&nbsp;
<br>In <a href="magic.html">MagiC</a>, plausibility checks ensure that no system semaphores
can be released; in addition, only modes 2 and 3 are supported at
present.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> No error has arisen
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="bios_errors.html#ERROR">ERROR</a> :</td>
<td valign="top"> A semaphore was requested that the caller already owns
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> An attempt was made to create a semaphore that already exists,
the caller is not the owner of the semaphore or a timeout has occurred
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> The specified semaphore does not exist

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.92
exists and MagiC as of version 3.0.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psemaphore">Binding</a> &nbsp; <a href="magic_semaphore.html">Semaphores in MagiC</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psemaphore">5.11.20.1 Bindings for Psemaphore</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psemaphore">Psemaphore</a> ( int16_t mode, int32_t id, int32_t timeout
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    timeout,-(sp)  ; Offset 8
move.l    id,-(sp)       ; Offset 4
move.w    mode,-(sp)     ; Offset 2
move.w    #308,-(sp)     ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a>
lea       $C(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetauid">5.11.21 Psetauid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetauid« - Set user ID of a process at the start.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 326 (0x0146)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Psetauid ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetauid sets the starting user ID of the current
process. This can only happen once. Together with <a href="#Pgetauid">Pgetauid</a> one can
ascertian who was the first logged-in user in a multi-user
environment. The parameter <i>id</i> is the desired start ID.
<br>&nbsp;
<br><b>Warning:</b> This function is optional, hence a call may be
answered with <a href="gemdos_errors.html#EINVFN">EINVFN</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Unknown at present.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.92
exists.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetauid">Binding</a> &nbsp; <a href="#Pgetauid">Pgetauid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetauid">5.11.21.1 Bindings for Psetauid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Psetauid">Psetauid</a> ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    id,-(sp)     ; Offset 2
move.w    #326,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetegid">5.11.22 Psetegid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetegid« - Set the effective group ID for the calling
process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 324 (0x0144)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psetegid ( int16_t egid );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> <i>egid</i> specifies the new effective group ID for the
calling process.
<br>&nbsp;
<br>Prior to MiNT version 1.12, this call contained a bug affecting
its functionality. Setting effective group id needs root privileges.
<br>&nbsp;
<br>This call is often used by daemon processes to downgrade their
privileges to user level.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns new <i>egid</i> on success or a negative GEMDOS
error-code otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> MiNT 1.11
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetegid">Binding</a> &nbsp; <a href="#Pseteuid">Pseteuid</a> &nbsp; <a href="#Psetgid">Psetgid</a> &nbsp; <a href="#Psetregid">Psetregid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetegid">5.11.22.1 Bindings for Psetegid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetegid">Psetegid</a> ( int16_t egid );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    egid,-(sp)   ; Offset 2
move.w    #324,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pseteuid">5.11.23 Pseteuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pseteuid« - Sets the effective user ID for the calling
process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 323 (0x0143)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pseteuid ( int16_t euid );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> <i>euid</i> specifies the new effective user ID for the
calling process.
<br>&nbsp;
<br>Prior to MiNT version 1.12 this call contained a bug affecting
its functionality. Setting effective user ID needs root privileges.
<br>&nbsp;
<br>This call is often used by daemon processes to downgrade their
privileges to user level.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns new <i>euid</i> on success or a negative GEMDOS error
code otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of MiNT 1.11.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pseteuid">Binding</a> &nbsp; <a href="#Psetegid">Psetegid</a> &nbsp; <a href="#Psetuid">Psetuid</a> &nbsp; <a href="#Psetreuid">Psetreuid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pseteuid">5.11.23.1 Bindings for Pseteuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pseteuid">Pseteuid</a> ( int16_t euid );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    euid,-(sp)   ; Offset 2
move.w    #323,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetgid">5.11.24 Psetgid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetgid« - Alter the group ID of the calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 277
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Psetgid ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetgid sets the group ID of the current process
to <i>id</i>. This must be a number between 0 and 255.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0-255 :</td>
<td valign="top"> No error has occurred (the new ID)
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> The process does not have the authority to alter its ID

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetgid">Binding</a> &nbsp; <a href="#Psetuid">Psetuid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetgid">5.11.24.1 Bindings for Psetgid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Psetgid">Psetgid</a> ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    id,-(sp)     ; Offset 2
move.w    #277,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetgroups">5.11.25 Psetgroups</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetgroups« - Sets the supplementary group IDs for the
calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 328 (0x0148)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psetgroups( int16_t len, int16_t *gidset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetgroups sets the supplementary group IDs for
the calling process.
<br>&nbsp;
<br><i>len</i> specifies the length (in words) of the array
containing the supplementary group IDs to be set. This value must be a
positive number not greater than NGROUPS_MAX. If <i>len</i> is a
zero, the call will return the number of supplementary group ids those
have been set.
<br>&nbsp;
<br><i>gidset</i> is a pointer to a word array containing the new
supplementary group IDs for the process.
<br>&nbsp;
<br>Setting new supplementary group IDs needs root privileges.
<br>&nbsp;
<br>The NGROUPS_MAX value is returned by <a href="gemdos_system.html#Sysconf">Sysconf</a>().
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns a number of new supplementary group IDs for the process
on success or a negative GEMDOS error code otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available from MiNT 1.11 onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetgroups">Binding</a> &nbsp; <a href="#Pgetgroups">Pgetgroups</a> &nbsp; <a href="gemdos_system.html#Sysconf">Sysconf</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetgroups">5.11.25.1 Bindings for Psetgroups</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetgroups">Psetgroups</a>( int16_t len, int16_t *gidset);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>peam      gidset       ; Offset 4
move.w    len,-(sp)    ; Offset 2
move.w    #328,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetlimit">5.11.26 Psetlimit</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetlimit« - Set or obtain allocation limits of the system
resources.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 287
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psetlimit ( int16_t lim, int32_t value );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetlimit serves for setting or obtaining resource
allocation limits for the current process. The parameter <i>lim</i>
determines the desired resource type:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">lim</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> Max. CPU-time for the process (milliseconds)
</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top"> Max. total memory allowed for process in bytes
</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top"> Max. allocatable memory for the process (in bytes)

</td></tr>
</table>

<br>The difference between 2 and 3 is that the total memory also
includes the TEXT, DATA and BSS segments of the process.
<br>&nbsp;
<br>With the help of this function the resource allocation limits
are set both for the current process as well as individually for all
child processes created later. So if a process sets a CPU limit and
later creates several child processes, then this CPU limit applies
also for each individual child process, and not, say, for all child
processes together.
<br>&nbsp;
<br>The parameter <i>value</i> determines the maximum value that a
resource is allowed to take. A value of 0 here means that the resource
is unlimited. A negative value here returns the current value, leaving
it unaltered.
<br>&nbsp;
<br><b>Note:</b> There are no restrictions on increasing the
limits. Each process may alter any of its limits or even set it to
unlimited.
<br>&nbsp;
<br>Memory allocation limits do not apply for <a href="#Pexec">Pexec</a>. If, say, a
process is limited to 256 kbyte, it can nevertheless use <a href="#Pexec">Pexec</a> to
launch a child process that uses more memory. <b>Warning:</b> This
does <i>not</i> apply in <a href="magic.html">MagiC</a>; here memory limits are inherited at
<a href="#Pexec">Pexec</a>!
<br>&nbsp;
<br>Memory limitations are not valid retrospectively. If, for
instance, a process owns 256 kbyte and then calls Psetlimit to reduce
its requirements to 128 kbyte, then though it will not be terminated,
it can not allocate any memory any more until its size falls under the
specified 128 kbyte.
<br>&nbsp;
<br>Limitations of the CPU-time on the other hand do act
retrospectively. If a process reduces its CPU-time below the
previously valid value, then it will receive a <a href="gemdos_signals.html#SIGXCPU">SIGXCPU</a> signal
immediately.
<br>&nbsp;
<br><b>Warning:</b> Invalid function numbers and those that are not
supported by <a href="magic.html">MagiC</a> return <a href="gemdos_errors.html#EINVFN">EINVFN</a>.
<br>&nbsp;
<br><b>Note about MagiC:</b> If a program has been modified with
the utility program LIMITMEM, then this setting takes precedence over
the calling process' memory limit. Psetlimit is supported by the
extended <a href="shel.html#shel_write">shel_write</a> mode; due to this, memory-limited applications may
also be started in parallel.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the old limit value.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> <a href="magic.html">MagiC</a> from Version 4.0 (17.09.1996) onwards and as of the first
in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetlimit">Binding</a> &nbsp; <a href="#Prusage">Prusage</a> &nbsp; <a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetlimit">5.11.26.1 Bindings for Psetlimit</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetlimit">Psetlimit</a> ( int16_t lim, int32_t value );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    value,-(sp)  ; Offset 4
move.w    lim,-(sp)    ; Offset 2
move.w    #287,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetpgrp">5.11.27 Psetpgrp</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetpgrp« - Get/Set process group number of a process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 270
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Psetpgrp ( int16_t pid, int16_t newgrp );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetpgrp alters the group number of the process
with the ID <i>pid</i> to the value <i>newgrp</i>, or inquires the
group number if <i>newgrp</i> is negative. The process must have the
same UID as the current process, or be the parent of it.
<br>&nbsp;
<br>If <i>pid</i> = 0, the process group of the current process
will be set. If <i>newgrp</i> = 0, the process group will be set to
the value of the PID of the current process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;= 0&nbsp; :</td>
<td valign="top"> No error (new or current process group number)
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> The process <i>pid</i> does not exist
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> The process <i>pid</i> has a different UID, and is not a child
of the calling process

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetpgrp">Binding</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Pgetpgrp">Pgetpgrp</a> &nbsp; <a href="#Pgetpid">Pgetpid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetpgrp">5.11.27.1 Bindings for Psetpgrp</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Psetpgrp">Psetpgrp</a> ( int16_t pid, int16_t newgrp );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    newgrp,-(sp)  ; Offset 4
move.w    pid,-(sp)     ; Offset 2
move.w    #270,-(sp)    ; Offset 0
trap      #1            ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetpriority">5.11.28 Psetpriority</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetpriority« - Set the current priority value for a
process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 345 (0x0159)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psetpriority ( int16_t which, int16_t who, int16_t pri
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetpriority sets the priority <i>pri</i> (not an
increment but an absolute value) for the processes specified by
<i>which</i> and <i>who</i>. The interpretation of parameter
<i>who</i> depends on <i>which</i>:
<br>&nbsp;
<br><a href="gemdos_process.html#PRIO_PROCESS">PRIO_PROCESS</a> (0) sets the priority of process with process ID
<i>who</i>. A <i>who</i> of 0 implies the process ID of the calling
process.
<br>&nbsp;
<br><a href="gemdos_process.html#PRIO_PGRP">PRIO_PGRP</a> (1) sets the priority of the process group with
process group ID <i>who</i>. A <i>who</i> of 0 implies the process
group ID of the calling process.
<br>&nbsp;
<br><a href="gemdos_process.html#PRIO_USER">PRIO_USER</a> (2) sets the priority of the process of the user with
user ID <i>who</i>. A <i>who</i> of 0 implies the user ID of the
calling process.
<br>&nbsp;
<a name="PRIO_MIN"></a>
<a name="PRIO_MAX"></a>
<br>The <i>pri</i> argument is silently changed to the maximum
(resp. minimum) possible value if it is not in the range between
PRIO_MIN (-20) and PRIO_MAX (+20).
<br>&nbsp;
<br>This call makes calls <a href="#Pnice">Pnice</a> and <a href="#Prenice">Prenice</a> obsolete.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns <a href="gemdos_errors.html#E_OK">E_OK</a> on success or a negative error-code
otherwise. The following error conditions are defined:
<br>&nbsp;
<br><a href="gemdos_errors.html#EINVAL">EINVAL</a>, invalid argument for <i>who</i>, <i>which</i> or
<i>pri</i>.
<br>&nbsp;
<br><a href="gemdos_errors.html#EACCES">EACCES</a>, the calling process is not an owner of one or more of
the selected processes; the other selected processes are still
affected
<br>&nbsp;
<br><a href="gemdos_errors.html#EPERM">EPERM</a>, the calling process does not have privileges to change
the priority of one or more of the selected processes; this can only
happen if an attempt was made to change the priority of a process to a
positive value
<br>&nbsp;
<br><a href="gemdos_errors.html#ESRCH">ESRCH</a>, the combination of <i>which</i> and <i>who</i> does not
match any existing process.
<br>&nbsp;
<br>The error condition reported is the last error condition
encountered (in other words if both <a href="gemdos_errors.html#EACCES">EACCES</a> and <a href="gemdos_errors.html#EPERM">EPERM</a> occur the return
value is arbitrary).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of MiNT 1.15.0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetpriority">Binding</a> &nbsp; <a href="#Pgetpriority">Pgetpriority</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetpriority">5.11.28.1 Bindings for Psetpriority</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetpriority">Psetpriority</a> ( int16_t which, int16_t who, int16_t pri
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    pri,-(sp)    ; Offset 6
move.w    who,-(sp)    ; Offset 4
move.w    which,-(sp)  ; Offset 2
move.w    #345,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetregid">5.11.29 Psetregid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetregid« - Set the real and/or effective group ID for the
calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 335 (0x014f)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psetregid ( int16_t rgid, int16_t egid);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetregid sets the real and/or effective group ID
for the calling process.
<br>&nbsp;
<br><i>rgid</i> specifies the new real group ID and <i>egid</i>
specifies the new effective group ID for the calling process. If
either argument is -1, only the other gets changed
<br>&nbsp;
<br>Setting group IDs needs root privileges.
<br>&nbsp;
<br>This call is often used by daemon processes to downgrade their
privileges to user level.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns <a href="gemdos_errors.html#E_OK">E_OK</a> on success or a negative error-code otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of MiNT 1.12.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetregid">Binding</a> &nbsp; <a href="#Psetreuid">Psetreuid</a> &nbsp; <a href="#Psetegid">Psetegid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetregid">5.11.29.1 Bindings for Psetregid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetregid">Psetregid</a> ( int16_t rgid, int16_t egid);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    egid,-(sp)   ; Offset 4
move.w    rgid,-(sp)   ; Offset 2
move.w    #335,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetreuid">5.11.30 Psetreuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetreuid« - Sets the real and/or effective user ID for the
calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 334 (0x014e)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psetreuid ( int16_t ruid, int16_t euid);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetreuid sets the real and/or effective user ID
for the calling process.
<br>&nbsp;
<br><i>ruid</i> specifies the new real user ID and <i>euid</i>
specifies the new effective user ID for the calling process. If either
argument is -1, only the other gets changed.
<br>&nbsp;
<br>Setting user ids needs root privileges.
<br>&nbsp;
<br>This call is often used by daemon processes to downgrade their
privileges to user level.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns <a href="gemdos_errors.html#E_OK">E_OK</a> on success or a negative GEMDOS error code
otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of MiNT 1.12.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetreuid">Binding</a> &nbsp; <a href="#Psetregid">Psetregid</a> &nbsp; <a href="#Pseteuid">Pseteuid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetreuid">5.11.30.1 Bindings for Psetreuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psetreuid">Psetreuid</a> ( int16_t ruid, int16_t euid);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    euid,-(sp)   ; Offset 4
move.w    ruid,-(sp)   ; Offset 2
move.w    #334,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psetuid">5.11.31 Psetuid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psetuid« - Alter the user ID of a process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 272
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Psetuid ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psetuid sets the user ID of the current process to
<i>id</i>. This must be a number between 0 and 255. The function
fails if the user ID of the process does not have the value 0, i.e.
once set, the user ID can no longer be altered.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">0-255 :</td>
<td valign="top"> No error has occurred (the new ID)
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> The process does not have authority to alter its ID

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psetuid">Binding</a> &nbsp; <a href="#Psetgid">Psetgid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psetuid">5.11.31.1 Bindings for Psetuid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Psetuid">Psetuid</a> ( int16_t id );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    id,-(sp)     ; Offset 2
move.w    #272,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psigaction">5.11.32 Psigaction</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigaction« - Set default action for a specified signal.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 311
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psigaction ( int16_t sig, <a href="gemdos_structures.html#struct_20sigaction">struct sigaction</a> *act, struct
<a href="gemdos_structures.html#sigaction">sigaction</a> *oact );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psigaction alters the response to the signal
<i>sig</i>. The parameter <i>act</i> for this is either NULL, or
points to a <a href="gemdos_structures.html#sigaction">sigaction</a> structure that describes the behaviour of the
signal handling. The following applies for the component
<i>sa_handler</i>:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">sa_handler</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> On arrival of the signal the default action for the signal will
be executed
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> The signal <i>sig</i> will be ignored; If it currently
present, it will be deleted

</td></tr>
</table>

<br>Any other value of <i>sa_handler</i> is interpreted as an
address of a function that will be called when the signal occurs. This
function is passed a LONG value via the stack that corresponds to the
relevant signal number. In this way it is possible to use the
signal-handler for several signals.
<br>&nbsp;
<br>While a signal is being processed, it cannot be sent again.
Furthermore, one should note that (in contrast to some Unix versions)
the signal handling before the execution of the handler is not reset
to the default handler.
<br>&nbsp;
<br>The signal-handler must either be terminated with RTS
(<b>R</b>eturn <b>T</b>o <b>S</b>ender), or <a href="#Psigreturn">Psigreturn</a> called to
indicate that the signal handling has been concluded. Following this,
the blocking of the signal will be lifted. <a href="#Psigreturn">Psigreturn</a> additionally
performs some internal mopping up in the kernel, necessary in case the
signal-handler is not terminated (longjump).
<br>&nbsp;
<br>Signal-handlers can make any BIOS, XBIOS and GEMDOS calls.
AES or VDI calls on the other hand are not permitted. However
this does not apply in <a href="magic.html">MagiC</a>; here one needs to heed several
differences.
<br>&nbsp;
<br>A Psigaction call has the side effect that the signal will be
unmasked (i.e. released). In this way a process, while handling a
signal, can reset it and then send it to itself again - for instance
to suspend itself while a signal for job-control is processed. The
signal handling is secured against <a href="#Pfork">Pfork</a>/<a href="#Pvfork">Pvfork</a>.
<br>&nbsp;
<br>Signals that are ignored by a process will also be ignored by its
child after a <a href="#Pexec">Pexec</a> call. Additionally, signals that are intercepted
by a signal-handler will be reset in the child process to the default
value.
<br>&nbsp;
<br>The component <i>sa_flags</i> of the <a href="gemdos_structures.html#sigaction">sigaction</a> structure
defines an additional, signal-specific behaviour: If <i>sig</i> is
the signal <a href="gemdos_signals.html#SIGCHLD">SIGCHLD</a>, and the SA_NOCLDSTOP bit is set in
<i>sa_flags</i>, then <a href="gemdos_signals.html#SIGCHLD">SIGCHLD</a> is sent to the process only when one of
its children terminates (and not just when a child is suspended by a
job-control signal).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> No error has arisen
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> Signal cannot be intercepted by the user
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> <i>sig</i> is an invalid signal

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.95
exists, and MagiC as of Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psigaction">Binding</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="#Psigreturn">Psigreturn</a> &nbsp; <a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psigaction">5.11.32.1 Bindings for Psigaction</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigaction">Psigaction</a> ( int16_t sig, <a href="gemdos_structures.html#struct_20sigaction">struct sigaction</a> *act, struct
<a href="gemdos_structures.html#sigaction">sigaction</a> *oact );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       oact         ; Offset 8
pea       act          ; Offset 4
move.w    sig,-(sp)    ; Offset 2
move.w    #311,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
lea       $C(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psigblock">5.11.33 Psigblock</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigblock« - Alter signal mask.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 278
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psigblock ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psigblock blocks selected signals from delivery.
It adds the signals specified in <i>mask</i> to the set of currently
blocking signals. For this, each bit of the parameter <i>mask</i>
represents one signal. If bit <i>n</i> in <i>mask</i> is set, it
means that the signal with the number <i>n</i> will be blocked.
<br>&nbsp;
<br>One should note that some signals (e.g. <a href="gemdos_signals.html#SIGKILL">SIGKILL</a>) can not be
blocked. The kernel will delete these signals from <i>mask</i> before
any change of the signal set is performed.
<br>&nbsp;
<br>Furthermore it should be pointed out that blocked signals also
remain blocked via <a href="#Pfork">Pfork</a>/<a href="#Pvfork">Pvfork</a> calls. After a <a href="#Pexec">Pexec</a> call the child
always starts with an empty set of signals to be blocked, irrespective
of which signals were blocked by its parent.
<br>&nbsp;
<br><b>Warning:</b> This function is optional, hence a call may be
answered with <a href="gemdos_errors.html#EINVFN">EINVFN</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the set of blocked signals that were valid
before the call. So with a Psigsetmask call the old set can be recovered
again.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04 and in
<a href="magic.html">MagiC</a> from Version 4.50 onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psigblock">Binding</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp; <a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psigblock">5.11.33.1 Bindings for Psigblock</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigblock">Psigblock</a> ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    mask,-(sp)   ; Offset 2
move.w    #278,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psigintr">5.11.34 Psigintr</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigintr« - Assigns a signal to a particular exception
vector.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 318 (0x013e)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psigintr ( int16_t vec, int16_t sig );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psigintr assigns a signal to a particular
exception vector. When the exception occurs, the kernel will send the
signal to the process.
<br>&nbsp;
<br><i>vec</i> specifies the exception vector. This is the same
value as specified for <a href="About_the_BIOS.html#Setexc">Setexc</a>() call. <i>sig</i> specifies the signal
number that is supposed to be delivered when an exception assigned to
the vector <i>vec</i> occurs. When both <i>sig</i> and <i>vec</i>
are zero, all handlers <a href="xbios_sound.html#installed">installed</a> by your program are removed.
<br>&nbsp;
<br>You should install a signal-handler prior to making this call,
otherwise your process will most probably get killed by the first
occurrence of the interrupt assigned to vec vector.
<br>Also notice that the function is not available on machines
equipped with 68000 and 68010 processors.
<br>&nbsp;
<br>This function has been totally rewritten as of MiNT version
1.15.1. However, the only change visible to programs is that the old
value of <i>vec</i> is no longer returned (it had little use anyway).
Also, since long stack frames are needed, a 68020 or newer processor
is required.
<br>&nbsp;
<br>The handler set up by Psigintr gets removed when your process
terminates.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> Returns <a href="gemdos_errors.html#E_OK">E_OK</a> on success, or a negative GEMDOS error code
otherwise:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EBADARG">EBADARG</a>:</td>
<td valign="top"> A signal or vector number was specified outside the allowed
range. Only autovectors ($60-$7c), traps ($80-$bc) and user defined
interrupts ($0100-$03fc) are allowed (other interrupts already
generate fixed signals).
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENOMEM">ENOMEM</a>:</td>
<td valign="top"> The kernel ran out of memory while trying to allocate RAM for
internal structures needed by this call.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENXIO">ENXIO</a>:</td>
<td valign="top"> The interrupt you want to register has no service routine
installed.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENOSYS">ENOSYS</a>:</td>
<td valign="top"> The function is not available (wrong architecture).

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> When a 'MiNT' cookie with a version of at least 1.11 exists. As
of MiNT version 1.15.1 this call is available only on machines
equipped with 68020 processor or higher.
<br>&nbsp;
<br><span style="color: red;"> This function has been disabled as of FreeMiNT 1.16. </span>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psigintr">Binding</a> &nbsp; <a href="#Pause">Pause</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psigintr">5.11.34.1 Bindings for Psigintr</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigintr">Psigintr</a> ( int16_t vec, int16_t sig );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    sig,-(sp)    ; Offset 4
move.w    vec,-(sp)    ; Offset 2
move.w    #318,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psignal">5.11.35 Psignal</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psignal« - Alter manner of signal handling.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 274
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psignal ( int16_t sig, int32_t handler );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psignal alters the action to be taken when the
signal <i>sig</i> arrives. The parameter <i>handler</i> can assume 3
possible values:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">handler</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">0</td>
<td valign="top"> The signal will be answered with the default action
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> The signal will be ignored by the process; if currently
present, it will be deleted

</td></tr>
</table>

<br>Any other value will be interpreted as the address of a user
function that will be called when the signal <i>sig</i> appears. This
function is passed a LONG value (via the stack) that corresponds to
the signal number. In this way it is possible to use the
signal-handler for several signals.
<br>&nbsp;
<br>While a signal is being processed, it cannot be sent again.
Furthermore, one should note that (in contrast to some Unix versions)
the signal handling before the execution of the handler is not reset
to the default handler.
<br>&nbsp;
<br>The signal-handler must either be terminated with RTS
(<b>R</b>eturn <b>T</b>o <b>S</b>ender), or <a href="#Psigreturn">Psigreturn</a> called to
indicate that the signal handling has been concluded. Following this,
the blocking of the signal will be lifted. Psigreturn additionally
performs some internal mopping up in the kernel, necessary in case the
signal-handler is not terminated (longjump).
<br>&nbsp;
<br>Signal-handlers can make any BIOS, XBIOS and GEMDOS calls.
AES or VDI calls on the other hand are not permitted. However
this does not apply in <a href="magic.html">MagiC</a>; here one needs to heed several
differences.
<br>&nbsp;
<br>A <a href="#Psigaction">Psigaction</a> call has the side effect that the signal will be
unmasked (i.e. released). In this way a process, while handling a
signal, can reset it and then send it to itself again - for instance
to suspend itself while a signal for job-control is processed. The
signal handling is secured against <a href="#Pfork">Pfork</a>/<a href="#Pvfork">Pvfork</a>.
<br>&nbsp;
<br>Signals that are ignored by a process will also be ignored by its
child after a <a href="#Pexec">Pexec</a> call. Additionally, signals that are intercepted
by a signal-handler will be reset in the child process to the default
value.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the old value of the signal-handler. This
is either 0, 1 or the address of the handler.
<br>&nbsp;
<br>In case of error, the following results are returned:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> Signal cannot be intercepted by the user
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> <i>sig</i> is an invalid signal

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04 and
MagiC as of Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> Process Functions
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psignal">Binding</a> &nbsp; <a href="#Pkill">Pkill</a> &nbsp; <a href="#Psigaction">Psigaction</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psigreturn">Psigreturn</a> &nbsp; <a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psignal">5.11.35.1 Bindings for Psignal</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psignal">Psignal</a> ( int16_t sig, int32_t handler );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    handler,-(sp)  ; Offset 4
move.w    sig,-(sp)      ; Offset 2
move.w    #274,-(sp)     ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #8,sp          ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psigpause">5.11.36 Psigpause</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigpause« - Set a new signal mask and then suspend process
until the arrival of a signal.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 310
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Psigpause ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psigpause sets a new signal mask <i>mask</i>, and
suspends the called process until a signal arrives that is not masked
or ignored.
<br>&nbsp;
<br>If a handler has been installed for this signal with <a href="#Psignal">Psignal</a>, then
this will be called before the function returns. If the handler
executes a longjump to another part of the program, or the process
terminates, then the function will never return.
<br>&nbsp;
<br><b>Note:</b> When the function returns, the signal mask will be
reset to the value that applied before the call of Psigpause. Thus the
signal mask set by the function is only valid temporarily. In <a href="magic.html">MagiC</a>,
problems may arise if several threads call this function at the same
time, as the signal mask here is process-global.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns always 0.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.95
exists, and MagiC as of Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psigpause">Binding</a> &nbsp; <a href="#Pause">Pause</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp; <a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psigpause">5.11.36.1 Bindings for Psigpause</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Psigpause">Psigpause</a> ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mask,-(sp)   ; Offset 2
move.w    #310,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psigpending">5.11.37 Psigpending</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigpending« - Check which signals have been sent but not
yet processed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 291
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psigpending ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psigpending returns the signals that have been
sent to the calling process, but not yet handled (say because they are
blocked with <a href="#Psigblock">Psigblock</a> or because they are currently being processed).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the desired signals as a bit-mask in a
LONG; for each bit <i>n</i> set, signal <i>n</i> is waiting to be
processed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04, and
<a href="magic.html">MagiC</a> as of Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psigpending">Binding</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="#Psigsetmask">Psigsetmask</a> &nbsp; <a href="gemdos_signals.html">Signals</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psigpending">5.11.37.1 Bindings for Psigpending</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigpending">Psigpending</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #291,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psigreturn">5.11.38 Psigreturn</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigreturn« - Prepare exit from a signal-handler.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 282
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Psigreturn ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psigreturn prepares for the exit from a
signal-handler. As this happens automatically when the handler
returns, calling Psigreturn is only necessary if the handler executes
a non-local jump (perhaps with longjump) rather than using RTS.
<br>&nbsp;
<br>The call has no effect when no signal is being processed at the
time.
<br>&nbsp;
<br>In MagiC, the thread of the active signal-handler will become
the main thread of the process and then be removed. All other signal
processes will be removed as well (nesting). The locked semaphores of
the main thread will be released, and the supervisor stack will be
reset to the value at process start.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function has <i>no</i> direct result under MiNT/MultiTOS;
in MagiC the value <a href="gemdos_errors.html#EACCDN">EACCDN</a> will be returned if the caller is
<i>not</i> a signal-handling routine, or the value <a href="gemdos_errors.html#E_OK">E_OK</a> otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04, and
<a href="magic.html">MagiC</a> as of Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psigreturn">Binding</a> &nbsp; <a href="#Psignal">Psignal</a> &nbsp; <a href="gemdos_signals.html">Signals</a> &nbsp; <a href="gemdos_signals.html#Signal-handler_20in_20MagiC">Signal-handler in MagiC</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psigreturn">5.11.38.1 Bindings for Psigreturn</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Psigreturn">Psigreturn</a> ( void );
<br>int32_t <a href="#Psigreturn">Psigreturn</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #282,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psigsetmask">5.11.39 Psigsetmask</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psigsetmask« - Set/replace a signal mask.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 279
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psigsetmask ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psigsetmask replaces the set of signals that are
currently to be blocked completely by the signals specified in the
parameter <i>mask</i>.
<br>&nbsp;
<br>One should note that some signals (e.g. <a href="gemdos_signals.html#SIGKILL">SIGKILL</a>) can not be
blocked. The kernel will delete these signals from <i>mask</i> before
any change of the signal set is performed.
<br>&nbsp;
<br>Furthermore it should be pointed out that blocked signals also
remain blocked via <a href="#Pfork">Pfork</a>/<a href="#Pvfork">Pvfork</a> calls. After a <a href="#Pexec">Pexec</a> call the child
always starts with an empty set of signals to be blocked, irrespective
of which signals were blocked by its parent.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the set of the blocked signals that were
valid before the call.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04, and
<a href="magic.html">MagiC</a> as of Version 4.50.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psigsetmask">Binding</a> &nbsp; <a href="#Psigblock">Psigblock</a> &nbsp; <a href="gemdos_signals.html">Signals</a> &nbsp; <a href="gemdos_signals.html#Signal-handler_20in_20MagiC">Signal-handler in MagiC</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psigsetmask">5.11.39.1 Bindings for Psigsetmask</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psigsetmask">Psigsetmask</a> ( int32_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    mask,-(sp)   ; Offset 2
move.w    #279,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Psysctl">5.11.40 Psysctl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Psysctl« - Get or set system information.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 350 (0x015e)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Psysctl ( int32_t *name, uint32_t namelen, void *old,
uint32_t *oldlenp, void *new, uint32_t newlen );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Psysctl retrieves system information and allows
processes with appropriate privileges to set system information. The
system information may be an integer, a string or a structure.
<br>&nbsp;
<br><i>name</i> and <i>namelen</i> specify the system information
to retrieve. <i>name</i> is an array of longwords which defines a
path to the actual value. The first longword holds the top level name,
the second longword is the second level name... <i>namelen</i> is the
size of this array.
<br>&nbsp;
<br>The information is copied into the buffer specified by
<i>old</i> and <i>oldlenp</i>.
<br>&nbsp;
<br>Before the call, <i>oldlenp</i> points to a long specifiying
the size of the buffer. After the call, this long word is set to the
amount of copied data.
<br>&nbsp;
<br>If both <i>old</i> and <i>oldlenp</i> are set to NULL, the old
value is not returned.
<br>&nbsp;
<br>If only <i>old</i> is set to NULL, <i>oldlenp</i> will be set
to the amount of available data.
<br>&nbsp;
<br>To set a new value, <i>new</i> is set to a pointer to a buffer
of lenght <i>newlen</i>. Otherwise, <i>new</i> should be set to NULL
and <i>newlen</i> set to 0.
<br>&nbsp;
<br>The top level names are defined with the following CTL_ prefix.
<br>&nbsp;
<a name="UDO__25ctl_1"></a>
<br><b>CTL_KERN (1): Kernel</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">KERN_OSTYPE=1</td>
<td valign="top"> (string) System version
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_OSRELEASE=2</td>
<td valign="top"> (string) System release
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_OSREV=3</td>
<td valign="top"> (integer) System revision
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_VERSION=4</td>
<td valign="top"> (string) Compile time information
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_HOSTNAME=5</td>
<td valign="top"> (string) Hostname
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_DOMAINNAME=6</td>
<td valign="top"> (string) (YP) Domainname
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_SECURELVL=7</td>
<td valign="top"> (integer) System security level
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_MAXPROC=8</td>
<td valign="top"> (integer) Max processes
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_MAXFILES=9</td>
<td valign="top"> (integer) Max open files
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_NGROUPS=10</td>
<td valign="top"> (integer) Number of supplemental group IDs
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_IOV_MAX=11</td>
<td valign="top"> (integer) Max <a href="gemdos_structures.html#iovec">iovec</a>'s for readv(2) etc.
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_LOGIN_<a href="wind.html#NAME">NAME</a>_MAX=12</td>
<td valign="top"> (integer) Max length login name + NUL
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_BOOTTIME=13</td>
<td valign="top"> (struct <a href="gemdos_structures.html#timeval">timeval</a>) Time kernel was booted
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_INITIALTPA=14</td>
<td valign="top"> (integer) Max TPA size of a process
</td></tr>

<tr><td nowrap="nowrap" valign="top">KERN_SYSDIR=15</td>
<td valign="top"> (string) The system directory

</td></tr>
</table>

<a name="UDO__25ctl_2"></a>
<br><b>CTL_HW (2): Generic CPU/IO</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">HW_MACHINE=1</td>
<td valign="top"> (string) Machine class
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_MACHINE_ARCH=2</td>
<td valign="top"> (string) Machine architecture
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_MODEL=3</td>
<td valign="top"> (string) Specific machine model
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_NCPU=4</td>
<td valign="top"> (integer) Number of CPUs
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_BYTEORDER=5</td>
<td valign="top"> (integer) Machine byte order
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_PAGESIZE=6</td>
<td valign="top"> (integer) Software page size
</td></tr>

<tr><td nowrap="nowrap" valign="top">HW_FREEPHYSMEM=7</td>
<td valign="top"> (integer) <a href="c_task_royal.html#Free">Free</a> physical memory

</td></tr>
</table>

<a name="UDO__25ctl_3"></a>
<br><b>CTL_MACHDEP (3): Machine dependent (not yet implemented)</b>
<br>&nbsp;
<a name="UDO__25ctl_4"></a>
<br><b>CTL_DEBUG (4): Debugging parameters (not yet
implemented)</b>
<br>&nbsp;
<a name="UDO__25ctl_5"></a>
<br><b>CTL_PROC (5): Per-proc attributes</b>
<br>The second level name specifies the process ID (PROC_CURPROC or
any PID), the third level name specifies the system information
(PROC_PID_DEBUG).
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">PROC_CURPROC=0x7fffffff</td>
<td valign="top"> (2^31-1) (integer) Select the current process
</td></tr>

<tr><td nowrap="nowrap" valign="top">Other value</td>
<td valign="top"> (integer) ID of specified process
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">PROC_PID_DEBUG=1</td>
<td valign="top"> (integer) Process debug level

</td></tr>
</table>


</td></tr>
</table>

<a name="UDO__25ctl_6"></a>
<br><b>CTL_KBD (6): Keyboard configuration</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">KBD_PC_STYLE_CAPS=1</td>
<td valign="top"> (integer) CAPS key operate in PC style mode
</td></tr>

<tr><td nowrap="nowrap" valign="top">KBD_<a href="xbios_structures.html#MOUSE">MOUSE</a>_PIXELS=2</td>
<td valign="top"> (integer) Keyboard mouse movement pixels
</td></tr>

<tr><td nowrap="nowrap" valign="top">KBD_PIXELS_FINE=3</td>
<td valign="top"> (integer) Keyboard mouse movement pixels 'fine'

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> No error has arisen
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENOMEM">ENOMEM</a> :</td>
<td valign="top"> The amount of data available is greater than the size of the
buffer supplied
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EACCDN">EACCDN</a>:</td>
<td valign="top"> An attempt was made to change a read-only value or was made by
a process with insufficient privilege
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ERANGE">ERANGE</a>:</td>
<td valign="top"> The <i>name</i> array was less than two or greater than
CTL_MAXNAME
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENOTDIR">ENOTDIR</a>:</td>
<td valign="top"> <i>name</i> specifies an intermediate rather than terminal
name
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EOPNOTSUPP">EOPNOTSUPP</a>:</td>
<td valign="top"> <i>name</i> not found
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ESRCH">ESRCH</a></td>
<td valign="top"> Process not found

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is available as of FreeMiNT 1.15.12.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Psysctl">Binding</a> &nbsp; <a href="gemdos_system.html#Sysconf">Sysconf</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Psysctl">5.11.40.1 Bindings for Psysctl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Psysctl">Psysctl</a> ( int32_t *name, uint32_t namelen, void *old,
uint32_t *oldlenp, void *new, uint32_t newlen );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    newlen,-(sp)   ; Offset 22
pea       new,-(sp)      ; Offset 18
pea       oldlenp,-(sp)  ; Offset 14
pea       old,-(sp)      ; Offset 10
move.l    namelen,-(sp)  ; Offset 6
pea       name,-(sp)     ; Offset 2
move.w    #350,-(sp)     ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a>
lea       $1A(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pterm">5.11.41 Pterm</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Process termination« - Terminate a TOS program.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 76
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Pterm ( uint16_t retcode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The GEMDOS routine Pterm terminates a running process, and
removes it from memory. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">retcode</td>
<td valign="top"> Status that is returned to the calling program.
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">-32 =</td>
<td valign="top"> Should not be used, as one obtains this value for programs
terminated by Control-C
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;-1 =</td>
<td valign="top"> Should not be used, as one obtains this value from GEMDOS 0.15
onwards if a process crashes
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;0 =</td>
<td valign="top"> No error has arisen
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;1 =</td>
<td valign="top"> General error
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;2 =</td>
<td valign="top"> Error in the parameters

</td></tr>
</table>


</td></tr>
</table>

<br><b>Note about MagiC:</b> Before any steps are taken, the
vector <a href="bios_sysvars.html#etv_term">etv_term</a> is located via <a href="About_the_BIOS.html#Setexc">Setexc</a> and jumped over. Subsequently,
the process is cleaned up properly (including VDI workstations,
informing all XFSs via <a href="magic_xfs.html#xfs_pterm">xfs_pterm</a>, closing of all opened files and
current paths, and deleting the process file in directory U:\PROC).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All GEMDOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pterm">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pterm0">Pterm0</a> &nbsp; <a href="#Ptermres">Ptermres</a> &nbsp; <a href="magic_xfs.html">XFS-concept in MagiC</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pterm">5.11.41.1 Bindings for Pterm</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Pterm">Pterm</a> ( uint16_t retcode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    retcode,-(sp)  ; Offset 2
move.w    #76,-(sp)      ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp          ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pterm0">5.11.42 Pterm0</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Process termination« - Terminate a TOS program and return
0 to caller.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 0
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Pterm0 ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The GEMDOS routine Pterm0 terminates a TOS program and does
not return again. The routine returns an exit code of 0.
<br>&nbsp;
<br><b>Note:</b> In <a href="magic.html">MagiC</a> this function is executed directly as
<a href="#Pterm">Pterm</a>(0).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All GEMDOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pterm0">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pterm">Pterm</a> &nbsp; <a href="#Ptermres">Ptermres</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pterm0">5.11.42.1 Bindings for Pterm0</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Pterm0">Pterm0</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #0,-(sp)     ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Ptermres">5.11.43 Ptermres</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Terminate and stay resident« - Terminate a program but leave
it in memory.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 49
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Ptermres ( int32_t keepcnt, int16_t retcode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The GEMDOS routine Ptermres terminates a program, yet leaves a
part of the program's TPA <a href="xbios_sound.html#intact">intact</a> and removes the memory left from
GEMDOS's memory list. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">keepcnt</td>
<td valign="top"> Number of bytes that are to be retained (applies from the start
of the basepage and includes the length of the TEXT, DATA and BSS
segments of the application plus length of the stack; minimum is 128
bytes). <b>Important:</b> The memory retained by this call may not be
freed later since it has been removed completely from the GEMDOS
memory list.
</td></tr>

<tr><td nowrap="nowrap" valign="top">retcode</td>
<td valign="top"> Status that is returned to the calling program
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">-32 =</td>
<td valign="top"> Should not be used, as one obtains this value for programs
terminated by Control-C
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;-1 =</td>
<td valign="top"> Should not be used, as one obtains this value from GEMDOS 0.15
onwards if a process crashes
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;0 =</td>
<td valign="top"> No error has arisen
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;1 =</td>
<td valign="top"> General error
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;2 =</td>
<td valign="top"> Error in the parameters

</td></tr>
</table>


</td></tr>
</table>

<br><b>Note:</b> In a network all lockings of the processes will be
lifted.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All GEMDOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Ptermres">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pterm">Pterm</a> &nbsp; <a href="#Pterm0">Pterm0</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Ptermres">5.11.43.1 Bindings for Ptermres</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Ptermres">Ptermres</a> ( int32_t keepcnt, int16_t retcode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    retcode,-(sp)  ; Offset 6
move.l    keepcnt,-(sp)  ; Offset 2
move.w    #49,-(sp)      ; Offset 0
trap      #1             ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #8,sp          ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Ptrace">5.11.44 Ptrace</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Ptrace« - Process tracing and debugging
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 320
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Ptrace(int16_t request, int16_t pid, void * addr,
int32_t data)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> Ptrace provides tracing and debugging facilities. It allows one
process (the tracing process) to control another (the traced process).
Most of the time, the traced process runs normally, but when it
receives a signal (see <a href="gemdos_structures.html#sigaction">sigaction</a>(2)), it stops. The tracing process is
expected to notice this via wait(2) or the delivery of a <a href="gemdos_signals.html#SIGCHLD">SIGCHLD</a>
signal, examine the state of the stopped process, and cause it to
terminate or continue as appropriate. Ptrace is the mechanism by which
all this happens.
<br>&nbsp;
<br>The <i>request</i> argument specifies what operation is being
performed; the meaning of the rest of the arguments depends on the
operation, but except for one special case noted below, all ptrace
calls are made by the tracing process, and the <i>pid</i> argument
specifies the process ID of the traced process. <i>request</i> can
be:
<br>&nbsp;
<table class="UDO_env_xlist">
<a name="PT_TRACE_ME"></a>
<tr><td nowrap="nowrap" valign="top">PT_TRACE_ME (0)</td>
<td valign="top"> This request is the only one used by the traced process; it
declares that the process expects to be traced by its parent. All the
other arguments are ignored. (If the parent process does not expect to
trace the child, it will probably be rather confused by the results;
once the traced process stops, it cannot be made to continue except
via ptrace.) When a process has used this request and calls execve(2)
or any of the routines built on it (such as execv(3)), it will stop
before executing the first instruction of the new image. Also, any
setuid or setgid bits on the executable being executed will be
ignored.
<br>&nbsp;
<a name="PT_READ_I"></a>
<a name="PT_READ_D"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_READ_I (1), PT_READ_D (2)</td>
<td valign="top">
<br>These requests read a single int of data from the traced process'
address space. Traditionally, ptrace has allowed for machines with
distinct address spaces for instruction and data, which is why there
are two requests: conceptually, PT_READ_I reads from the instruction
space and PT_READ_D reads from the data space. In the current NetBSD
implementation, these two requests are completely identical. The addr
argument specifies the address (in the traced process' virtual address
space) at which the read is to be done. This address does not have to
meet any alignment constraints. The value read is returned as the
return value from ptrace.
<br>&nbsp;
<a name="PT_WRITE_I"></a>
<a name="PT_WRITE_D"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_WRITE_I (4), PT_WRITE_D (5)</td>
<td valign="top">
<br>These requests parallel PT_READ_I and PT_READ_D, except that they
write rather than read. The data argument supplies the value to be
written.
<br>&nbsp;
<a name="PT_CONTINUE"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_CONTINUE (7)</td>
<td valign="top"> The traced process continues execution. <i>addr</i> is an
address specifying the place where execution is to be resumed (a new
value for the program counter), or (caddr_t)1 to indicate that
execution is to pick up where it left off. <i>data</i> provides a
signal number to be delivered to the traced process as it resumes
execution, or 0 if no signal is to be sent.
<br>&nbsp;
<a name="PT_KILL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_KILL (8)</td>
<td valign="top"> The traced process terminates, as if PT_CONTINUE had been used
with <a href="gemdos_signals.html#SIGKILL">SIGKILL</a> given as the signal to be delivered.
<br>&nbsp;
<a name="PT_ATTACH"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_ATTACH (9)</td>
<td valign="top"> This request allows a process to gain control of an otherwise
unrelated process and begin tracing it. It does not need any
cooperation from the to-be-traced process. In this case, <i>pid</i>
specifies the process ID of the to-be-traced process, and the other
two arguments are ignored. This request requires that the target
process must have the same real UID as the tracing process, and that
it must not be executing a setuid or setgid executable. (If the
tracing process is running as root, these restrictions do not apply.)
The tracing process will see the newly-traced process stop and may
then control it as if it had been traced all along.
<br>&nbsp;
<br>Two other restrictions apply to all tracing processes, even
those running as root. First, no process may trace the process running
init(8). Second, if a process has its root directory set with
chroot(2), it may not trace another process unless that process' root
directory is at or below the tracing process' root.
<br>&nbsp;
<a name="PT_DETACH"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_DETACH (10)</td>
<td valign="top"> This request is like PT_CONTINUE, except that it does not allow
specifying an alternative place to continue execution, and after it
succeeds, the traced process is no longer traced and continues
execution normally.
<br>&nbsp;
<a name="PT_SYSCALL"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_SYSCALL (11)</td>
<td valign="top"> Continue and stop at next return from syscall.
<br>&nbsp;

</td></tr>
</table>

<br>Additionally, machine-specific requests can exist. On the SPARC,
these are:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">PT_GETREGS</td>
<td valign="top"> This request reads the traced process' machine registers into
the struct reg (defined in &lt;machine/reg.h&gt;) pointed to by
<i>addr</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_SETREGS</td>
<td valign="top"> This request is the converse of PT_GETREGS; it loads the traced
process' machine registers from the struct reg (defined in
&lt;machine/reg.h&gt;) pointed to by <i>addr</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_GETFPREGS</td>
<td valign="top"> This request reads the traced process' floating-point registers
into the struct fpreg (defined in &lt;machine/reg.h&gt;) pointed to by
<i>addr</i>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">PT_SETFPREGS</td>
<td valign="top"> This request is the converse of PT_GETFPREGS; it loads the
traced process' floating-point registers from the struct fpreg
(defined in &lt;machine/reg.h&gt;) pointed to by <i>addr</i>.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return alue:</td>
<td valign="top"> Some requests can cause ptrace to return -1 as a non-error
value; to disambiguate, errno can be set to 0 before the call and
checked afterwards. The possible errors are:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">ww</td>
<td valign="top"> No process having the specified process ID exists.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EINVAL">EINVAL</a></td>
<td valign="top">
<br>&nbsp;
<ul>
<li> A process attempted to use PT_ATTACH on itself.
</li>
<li> The request was not one of the legal requests.
</li>
<li> The signal number (in <i>data</i>) to PT_CONTINUE was neither
0 nor a legal signal number.
</li>
<li> PT_GETREGS, PT_SETREGS, PT_GETFPREGS, or PT_SETFPREGS was
attempted on a process with no valid register set. (This is normally
true only of system processes.)
</li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EBUSY">EBUSY</a></td>
<td valign="top">
<br>&nbsp;
<ul>
<li> PT_ATTACH was attempted on a process that was already being
traced.
</li>
<li> A request attempted to manipulate a process that was being
traced by some process other than the one making the request.
</li>
<li> A request (other than PT_ATTACH) specified a process that
wasn't stopped.
</li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EPERM">EPERM</a></td>
<td valign="top">
<br>&nbsp;
<ul>
<li> A request (other than PT_ATTACH) attempted to manipulate a
process that wasn't being traced at all.
</li>
<li> An attempt was made to use PT_ATTACH on a process in violation
of the requirements listed under PT_ATTACH above.
</li>
</ul>


</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is available as of FreeMiNT 1.15.11.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Ptrace">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Ptrace">5.11.44.1 Bindings for Ptrace</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Ptrace">Ptrace</a>(int16_t request, int16_t pid, void *addr,
int32_t data);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre><pre>move.l    data,-(sp)    ; Offset 10
pea       addr          ; Offset 6
move.w    pid,-(sp)     ; Offset 4
move.w    request,-(sp) ; Offset 2
move.w    #320,-(sp)    ; Offset 0
trap      #1            ; <a href="gemdos_main.html">GEMDOS</a>
lea       14(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pumask">5.11.45 Pumask</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pumask« - Set initial creation mask for files and
directories.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 307
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pumask ( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pumask alters the file/directory creation mask of
the current process to <i>mode</i>, which is a WORD bitmask of
various access permission flags as defined in <a href="gemdos_file.html#Fchmod">Fchmod</a>. The new value of
the mask is inherited by child processes.
<br>&nbsp;
<br>When a new file or a new directory is created (with <a href="gemdos_file.html#Fcreate">Fcreate</a> or
<a href="gemdos_directory.html#Dcreate">Dcreate</a> respectively), the access rights are normally set so that full
access is permitted. (Exception: New files are normally not
executable.)
<br>&nbsp;
<br>With the aid of Pumask one can specify which access rights
during creation of a file are not (!) to be permitted.
<br>&nbsp;
<br>Explicit <a href="gemdos_file.html#Fchmod">Fchmod</a> calls are not affected by Pumask.
<br>&nbsp;
<br><b>Warning:</b> In <a href="magic.html">MagiC</a> however the mask is not evaluated by
any internal XFS of MagiC, and finds use exclusively in UNIX-like
file-systems.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value of the old creation mask.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.92
exists, and <a href="magic.html">MagiC</a> as of Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pumask">Binding</a> &nbsp; <a href="gemdos_directory.html#Dcreate">Dcreate</a> &nbsp; <a href="gemdos_file.html#Fchmod">Fchmod</a> &nbsp; <a href="gemdos_file.html#Fcreate">Fcreate</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pumask">5.11.45.1 Bindings for Pumask</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pumask">Pumask</a> ( int16_t mode );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mode,-(sp)   ; Offset 2
move.w    #307,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pusrval">5.11.46 Pusrval</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pusrval« - Set/interrogate specific process information.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 280
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pusrval ( int32_t val );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pusrval permits the setting or interrogation of
process-specific information. These are stored in a LONGword, and
inherited by all child processes.
<br>&nbsp;
<br>The meaning of the value can be freely determined by the calling
program.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the old value.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04, and
<a href="magic.html">MagiC</a> as of Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pusrval">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pusrval">5.11.46.1 Bindings for Pusrval</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pusrval">Pusrval</a> ( int32_t val );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    val,-(sp)    ; Offset 2
move.w    #280,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pvfork">5.11.47 Pvfork</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pvfork« - Create copy of the current process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 275
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Pvfork ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pvfork creates a copy of the current process.
Parent and child process share the same address and data space, i.e.
every change that the child makes to variables will also affect the
parent. The new process starts its work when the function Pvfork
returns.
<br>&nbsp;
<br>Note that if the parent is in supervisor-mode when the call is
made, the child is placed in user-mode anyway.
<br>&nbsp;
<br>As both processes share the same address space (and stack),
problems would arise if both ran at the same time. For this reason the
parent is paused until the child process is either terminated or uses
<a href="#Pexec">Pexec</a> (mode 200) to write itself as a new process to a new address
space.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#E_OK">E_OK</a>&nbsp; :</td>
<td valign="top"> In child process
</td></tr>

<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> New process ID in parent process
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#ENSMEM">ENSMEM</a>:</td>
<td valign="top"> Not enough memory available to create a new process

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pvfork">Binding</a> &nbsp; <a href="#Pexec">Pexec</a> &nbsp; <a href="#Pfork">Pfork</a> &nbsp; <a href="magic_threads.html">Threads</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pvfork">5.11.47.1 Bindings for Pvfork</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int16_t <a href="#Pvfork">Pvfork</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #275,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pwait">5.11.48 Pwait</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pwait« - Try to obtain exit code of waiting or terminated
child process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 265
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pwait ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pwait is equivalent to <a href="#Pwait3">Pwait3</a> (2, NULL) and is
offered for reasons of backwards compatibility.
<br>&nbsp;
<br>According to POSIX, the library function 'wait' should be
implemented as <a href="#Pwaitpid">Pwaitpid</a> (-1, 0, NULL). Hence Pwait should not be used
for a POSIX-compatible library.
<br>&nbsp;
<br><b>Warning:</b> In <a href="magic.html">MagiC</a> the function is implemented as
<a href="#Pwaitpid">Pwaitpid</a> (-1, 2, NULL).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Exit status and PID of the child in the lower and upper 16 bits
respectively of a 32-bit return code
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> No child processes have terminated.
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> No child processes exist

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04, and
<a href="magic.html">MagiC</a> as of Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pwait">Binding</a> &nbsp; <a href="#Pwait3">Pwait3</a> &nbsp; <a href="#Pwaitpid">Pwaitpid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pwait">5.11.48.1 Bindings for Pwait</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pwait">Pwait</a> ( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #265,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pwait3">5.11.49 Pwait3</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pwait3« - Get exit code of any waiting or terminated
children of the calling process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 284
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pwait3 ( int16_t flag, int32_t *rusage );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pwait3 is equivalent to a call of <a href="#Pwaitpid">Pwaitpid</a> (-1,
flag, rusage) and determines with it the exit code as well as the CPU
load of a terminated or stopped child process.
<br>&nbsp;
<br><i>flag</i> is a bit-mask showing the specifics of this call as
follows:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Value</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> If set, the function will not block the calling process if no
child has been stopped or terminated, but will just return 0; if not
set (clear), the process will be blocked until a child of the process
has been terminated or stopped
</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top"> If set, returns exit codes for processes that have been
terminated as well as stopped; if clear, only returns exit codes for
processes that have actually terminated

</td></tr>
</table>

<br><i>rusage</i> points to an array of two LONGs that are filled
in with information about resource usage of the stopped or terminated
process. The first LONG holds the number of milliseconds used by the
child in user space; the second LONG shows the number of milliseconds
spent by the process in kernel space. If this information is not
required, <i>rusage</i> may be set to NULL.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following results:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Exit status and PID of the child in the lower and upper 16 bits
respectively of a 32-bit return code
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> No child processes have been stopped and/or terminated, or, if
bit 0 of the parameter <i>flag</i> is set, the function would be
blocked when waiting for the exit or the stopping of the child process
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> No child processes exist

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> As of the first in MultiTOS integrated MiNT version 1.04, and
<a href="magic.html">MagiC</a> as of Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pwait3">Binding</a> &nbsp; <a href="#Pwait">Pwait</a> &nbsp; <a href="#Pwaitpid">Pwaitpid</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pwait3">5.11.49.1 Bindings for Pwait3</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pwait3">Pwait3</a> ( int16_t flag, int32_t *rusage );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       rusage       ; Offset 4
move.w    flag,-(sp)   ; Offset 2
move.w    #284,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Pwaitpid">5.11.50 Pwaitpid</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Pwaitpid« - Get exit code information about one or more
child processes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 314
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Pwaitpid ( int16_t pid, int16_t flag, int32_t *rusage
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Pwaitpid tries to obtain the exit code of child
processes that have been stopped or terminated. If bit 1 of the
parameter <i>flag</i> is set, then the child processes currently
stopped will be reported; if clear, child processes newly terminated
or stopped by tracing will be reported.
<br>&nbsp;
<br>A stopped process will be reported once, as a rule, (as long as
it has not been restarted and stopped again). Equally, a terminated
process will be reported only once.
<br>&nbsp;
<br>If child processes are present that have neither been stopped
nor terminated (or are waiting for such an event), then the further
behaviour of the function is determined by bit 0 of the parameter
<i>flag</i>. The following applies here:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Bit-0 = 0:</td>
<td valign="top"> <a href="powerdos.html#Wait">Wait</a> until child is stopped or terminated
</td></tr>

<tr><td nowrap="nowrap" valign="top">Bit-0 = 1:</td>
<td valign="top"> Return immediately

</td></tr>
</table>

<br><b>With the parameter <i>pid</i> the children whose exit codes
are of interest can be specified more exactly:</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">pid</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> Inquire status for all children
</td></tr>

<tr><td nowrap="nowrap" valign="top">&gt;0</td>
<td valign="top"> <i>pid</i> is the process ID of the child whose status is to
be established
</td></tr>

<tr><td nowrap="nowrap" valign="top">=0</td>
<td valign="top"> Inquire status for all children whose group ID is the same as
that of the calling process
</td></tr>

<tr><td nowrap="nowrap" valign="top">&lt; -1</td>
<td valign="top"> Inquire status for all children whose group ID corresponds to
the absolute value of <i>pid</i>

</td></tr>
</table>

<br><b>With the parameter <i>rusage</i> information about the
usage of CPU time of the child is accounted for:</b>
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">rusage[0]:</td>
<td valign="top"> Time spent in user space (msec)
</td></tr>

<tr><td nowrap="nowrap" valign="top">rusage[1]:</td>
<td valign="top"> Time spent in kernel space (msec)

</td></tr>
</table>

<br>If a child process was found, its PID will be given in the upper
16 bits and its exit status in the lower 16 bits of the return value.
If the process was stopped or terminated by a signal with the number
n, its exit status will be 256*n+x, where:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">x = 127,</td>
<td valign="top"> if the process was stopped
</td></tr>

<tr><td nowrap="nowrap" valign="top">x = 0,</td>
<td valign="top"> If the process was terminated

</td></tr>
</table>

<br><b>Warning:</b> In <a href="magic.html">MagiC</a>, stopped child-processes are not yet
recognized, but only terminated child processes. In addition, only
NULL-values are returned at present in the parameter <i>rusage</i>.
<br>&nbsp;
<br>Process groups, too, are not properly supported at present
because the function <a href="#Psetpgrp">Psetpgrp</a> is missing.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function can return the following values:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&gt;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> Exit status and PID of the child in the lower and upper 16 bits
respectively of a 32-bit return code
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0&nbsp;&nbsp;&nbsp; :</td>
<td valign="top"> No child processes have been stopped and/or terminated, or, if
bit 0 of the parameter <i>flag</i> is set, the function would be
blocked when waiting for the exit or the stopping of the child process
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EFILNF">EFILNF</a>:</td>
<td valign="top"> No child processes exist

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> Available when a 'MiNT' cookie with a version of at least 0.96
exists, and <a href="magic.html">MagiC</a> as of Version 5.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Process_20functions">Process functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Pwaitpid">Binding</a> &nbsp; <a href="#Pwait">Pwait</a> &nbsp; <a href="#Pwait3">Pwait3</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Pwaitpid">5.11.50.1 Bindings for Pwaitpid</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Pwaitpid">Pwaitpid</a> ( int16_t pid, int16_t flag, int32_t *rusage
);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       rusage       ; Offset 6
move.w    flag,-(sp)   ; Offset 4
move.w    pid,-(sp)    ; Offset 2
move.w    #314,-(sp)   ; Offset 0
trap      #1           ; <a href="gemdos_main.html">GEMDOS</a>
lea       $A(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="gemdos_main.html"><img src="udo_up.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
<a name="UDO_nav_lf_FOOT" href="gemdos_datetime.html"><img src="udo_lf.gif" alt="Date and Time" title="Date and Time" border="0" width="24" height="24">Date and Time</a>
<a name="UDO_nav_rg_FOOT" href="gemdos_memory.html"><img src="udo_rg.gif" alt="Memory management" title="Memory management" border="0" width="24" height="24">Memory management</a>
</body>
</html>
