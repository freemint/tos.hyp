<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2025/08/02 -->
<html lang="en">
<head>
<title>
The documentation for TOS: DSP programming
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_printer.html"><img src="udo_lf.gif" alt="Printer functions" title="Printer functions" border="0" width="24" height="24">Printer functions</a>
<a name="UDO_nav_rg_HEAD" href="xbios_dhs.html"><img src="udo_rg.gif" alt="Hatari DHS XBIOS extension" title="Hatari DHS XBIOS extension" border="0" width="24" height="24">Hatari DHS XBIOS extension</a>

<hr>

<h1><a name="DSP_20programming">4.11 DSP programming</a></h1>
<p>On the Falcon, the following routines for programming the
DSP-56001 digital signal processor are available:
</p>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_Available">Dsp_Available</a></td>
<td valign="top"> Obtains amount of free memory.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a></td>
<td valign="top"> Bytewise data transfer.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a></td>
<td valign="top"> Data transfer with handshake.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a></td>
<td valign="top"> Transfer of DSP-words (max. 4 byte long).
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_BlkWords">Dsp_BlkWords</a></td>
<td valign="top"> Wordwise data transfer.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_DoBlock">Dsp_DoBlock</a></td>
<td valign="top"> Data transfer to the DSP.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a></td>
<td valign="top"> Loads bootstrap program for the DSP.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_ExecProg">Dsp_ExecProg</a></td>
<td valign="top"> Executes DSP program.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a></td>
<td valign="top"> Removes subroutines.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_GetProgAbility">Dsp_GetProgAbility</a></td>
<td valign="top"> Requests identification of a process.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_GetWordSize">Dsp_GetWordSize</a></td>
<td valign="top"> Obtains size of a DSP-word.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_Hf0">Dsp_Hf0</a></td>
<td valign="top"> Sets or clears bit 3 of the HSR.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_Hf1">Dsp_Hf1</a></td>
<td valign="top"> Sets or clears bit 4 of the HSR.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_Hf2">Dsp_Hf2</a></td>
<td valign="top"> Inquires bit 3 of the HCR.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_Hf3">Dsp_Hf3</a></td>
<td valign="top"> Inquires bit 4 of the HCR.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_HStat">Dsp_HStat</a></td>
<td valign="top"> Inquires value of the ISR-register.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a></td>
<td valign="top"> Inquires subroutine identifier.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_InStream">Dsp_InStream</a></td>
<td valign="top"> Data transfer to DSP via an interrupt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_IOStream">Dsp_IOStream</a></td>
<td valign="top"> Data transfer from and to DSP via two interrupts.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_LoadProg">Dsp_LoadProg</a></td>
<td valign="top"> Loads and executes DSP-program.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a></td>
<td valign="top"> Installs a subroutine.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_Lock">Dsp_Lock</a></td>
<td valign="top"> Inquires availability of the DSP.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a></td>
<td valign="top"> Converts LOD to Binary format.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a></td>
<td valign="top"> Data transfer from and to DSP.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_OutStream">Dsp_OutStream</a></td>
<td valign="top"> Data transfer from DSP via an interrupt.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a></td>
<td valign="top"> Turns off generation of DSP interrupts.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_RequestUniqueAbility">Dsp_RequestUniqueAbility</a></td>
<td valign="top"> Generates an identifier.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_Reserve">Dsp_Reserve</a></td>
<td valign="top"> Reserves DSP memory for use by a program.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a></td>
<td valign="top"> Starts execution of a subroutine.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_SetVectors">Dsp_SetVectors</a></td>
<td valign="top"> Installs custom transfer routines.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_TriggerHC">Dsp_TriggerHC</a></td>
<td valign="top"> Executes host command.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Dsp_Unlock">Dsp_Unlock</a></td>
<td valign="top"> Releases DSP.

</td></tr>
</table>

<p>See also: <a href="xbios_interface.html">Interface programming</a>
</p>
<h3><a name="Dsp_Available">4.11.1 Dsp_Available</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_Available« - Inquire amount of free X and Y memory
space.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 106
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_Available( int32_t *xavailable, int32_t *yavailable );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_Available inquires amount of free X and Y DSP
memory. <a href="c_task_royal.html#Free">Free</a> memory always starts at the physical address 0. The
lowest 64 words are reserved for interrupt vectors.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_Available">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp; <a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp;
<a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_Available">4.11.1.1 Bindings for Dsp_Available</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_Available">Dsp_Available</a>( int32_t *xavailable, int32_t *yavailable );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       yavailable   ; Offset 6
pea       xavailable   ; Offset 2
move.w    #106,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_BlkBytes">4.11.2 Dsp_BlkBytes</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_BlkBytes« - Bytewise data transfer to the DSP.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 124
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_BlkBytes( void *data_in, int32_t size_in, void
*data_out, int32_t size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function copies <i>size_in</i> unsigned bytes from the
buffer <i>data_in</i> to the DSP. After all data has been
transferred, the procedure waits until the data has been processed.
Then <i>size_out</i> 8-bit DSP-words are copied back into the buffer
<i>data_out</i>, irrespective of how much data is actually present.
If no data is to be sent, one has to set <i>size_in</i> to zero. The
same applies for the receipt; in that case <i>size_out</i> is
assigned zero. <i>size_in</i> and <i>size_out</i> are limited to 64
kbyte. Data is only exchanged when the DSP process is ready for this.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_BlkBytes">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_BlkBytes">4.11.2.1 Bindings for Dsp_BlkBytes</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a>( void *data_in, int32_t size_in, void
*data_out, int32_t size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #124,-(sp)      ; Offset  0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $12(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_BlkHandShake">4.11.3 Dsp_BlkHandShake</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »DspBlkHandShake« - Data transfer to DSP with handshake.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 97
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_BlkHandShake( int8_t *data_in, int32_t size_in, int8_t
*data_out, int32_t size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function copies <i>size_in</i> DSP-words from the buffer
<i>data_in</i> to the DSP. After all data has been transferred, the
procedure waits until the data has been processed. Then
<i>size_out</i> DSP-words are copied back into the buffer
<i>data_out</i>, irrespective of how much data is actually present.
If no data is to be sent, one has to set <i>size_in</i> to zero. The
same applies for the receipt; in that case <i>size_out</i> is
assigned zero. <i>size_in</i> and <i>size_out</i> are limited to 64
kbyte. Data is only exchanged when the DSP process is ready for this.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_BlkHandShake">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp;
<a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_BlkHandShake">4.11.3.1 Bindings for Dsp_BlkHandShake</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a>( int8_t *data_in, int32_t size_in, int8_t
*data_out, int32_t size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #97,-(sp)       ; Offset  0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $12(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_BlkUnpacked">4.11.4 Dsp_BlkUnpacked</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_BlkUnpacked« - Data transfer of DSP-words with a maximum
length of 4 bytes (longword array).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 98
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_BlkUnpacked( int32_t *data_in, int32_t size_in,
int32_t *data_out, int32_t size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> This function only works with DSP-words having a maximum length
of 4 bytes. The length of the DSP-words can be found with
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a>. Both <i>data_in</i> and <i>data_out</i> are LONG
fields. <i>size_in</i> and <i>size_out</i> refer to the size of the
fields in longwords. Depending on the length of the DSP-word, only the
lower bytes are transferred to the LONGs. The function copies
<i>size_in</i> DSP-words from the buffer <i>data_in</i> to the DSP.
After all data has been transferred, the procedure waits until the
data has been processed. Then <i>size_out</i> DSP-words are copied
back into the buffer <i>data_out</i>, irrespective of how much data
is actually present. If no data is to be sent, one has to set
<i>size_in</i> to zero. The same applies for the receipt; in that
case <i>size_out</i> is assigned zero. <i>size_in</i> and
<i>size_out</i> are limited to 64 kbyte.
<br>There is no guarantee that the higher-valued bytes of the received
LONGs are zero when the DSP-wordlength is less than 4.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_BlkUnpacked">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp; <a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp;
<a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_BlkUnpacked">4.11.4.1 Bindings for Dsp_BlkUnpacked</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a>( int32_t *data_in, int32_t size_in, int32_t
*data_out, int32_t size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #98,-(sp)       ; Offset  0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $12(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_BlkWords">4.11.5 Dsp_BlkWords</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_BlkWords« - Wordwise data transfer of an array of WORDS
to the DSP.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 123
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_BlkWords( void *data_in, int32_t size_in, void
*data_out, int32_T size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function copies <i>size_in</i> signed 16-bit words from
the buffer <i>data_in</i> to the DSP. The words are extended to
signed DSP-wordlength before transfer. After all data has been
transferred, the procedure waits until the data has been processed.
Then <i>size_out</i> 16-bit DSP-words are copied back into the buffer
<i>data_out</i>, irrespective of how much data is actually present.
If no data is to be sent, one has to set <i>size_in</i> to zero. The
same applies for the receipt; in that case <i>size_out</i> is
assigned zero. <i>size_in</i> and <i>size_out</i> are limited to 64
kbyte. Data is only exchanged when the DSP process is ready for this.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_BlkWords">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_BlkWords">4.11.5.1 Bindings for Dsp_BlkWords</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_BlkWords">Dsp_BlkWords</a>( void *data_in, int32_t size_in, void
*data_out, int32_T size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #123,-(sp)      ; Offset  0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $12(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_DoBlock">4.11.6 Dsp_DoBlock</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_DoBlock« - Data transfer to the DSP
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 96
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_DoBlock( int8_t *data_in, int32_t size_in, int8_t
*data_out, int32_t size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function copies <i>size_in</i> DSP-words from the buffer
<i>data_in</i> to the DSP. After all data has been transferred, the
procedure waits until the data has been processed. Then
<i>size_out</i> DSP-words are copied back into the buffer
<i>data_out</i>, irrespective of how much data is actually present.
If no data is to be sent, one has to set <i>size_in</i> to zero. The
same applies for the receipt; in that case <i>size_out</i> is
assigned zero. <i>size_in</i> and <i>size_out</i> are limited to 64
kbyte.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_DoBlock">Binding</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp;
<a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_DoBlock">4.11.6.1 Bindings for Dsp_DoBlock</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_DoBlock">Dsp_DoBlock</a>( int8_t *data_in, int32_t size_in, int8_t
*data_out, int32_t size_out );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    size_out,-(sp)  ; Offset 14
pea       data_out        ; Offset 10
move.l    size_in,-(sp)   ; Offset  6
pea       data_in         ; Offset  2
move.w    #96,-(sp)       ; Offset  0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $12(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_ExecBoot">4.11.7 Dsp_ExecBoot</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_ExecBoot« - Load bootstrap program into the DSP.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 110
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_ExecBoot( int8_t *codeptr, int32_t codesize, int16_t
ability );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_ExecBoot loads a bootstrap program into 512
words of the internal DSP memory. Before loading, the DSP is
completely reset. The DSP program must be present in a binary format.
The parameter <i>codeptr</i> points to the start of the program data.
The length of the program is specified by the parameter
<i>codesize</i> (in DSP-words). <i>ability</i> identifies the
program.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_ExecBoot">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_ExecBoot">4.11.7.1 Bindings for Dsp_ExecBoot</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>( int8_t *codeptr, int32_t codesize, int16_t
ability );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    ability,-(sp)  ; Offset 10
move.l    codesize,-(sp) ; Offset  6
pea       codeptr        ; Offset  2
move.w    #110,-(sp)     ; Offset  0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
lea       $C(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_ExecProg">4.11.8 Dsp_ExecProg</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_ExecProg« - Execute DSP program.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 109
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_ExecProg( int8_t *codeptr, int32_t codesize, int16_t
ability );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_ExecProg transfers a DSP program stored in
binary format in memory at the location <i>codeptr</i> and length
<i>codesize</i> to the DSP and executes it. Its size may not exceed
the memory reserved by <a href="#Dsp_Reserve">Dsp_Reserve</a>. The parameter <i>ability</i>
identifies the program.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_ExecProg">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a> &nbsp; <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_ExecProg">4.11.8.1 Bindings for Dsp_ExecProg</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_ExecProg">Dsp_ExecProg</a>( int8_t *codeptr, int32_t codesize, int16_t
ability );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    ability,-(sp)  ; Offset 10
move.l    codesize,-(sp) ; Offset  6
pea       codeptr        ; Offset  2
move.w    #109,-(sp)     ; Offset  0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
lea       $C(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_FlushSubroutines">4.11.9 Dsp_FlushSubroutines</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_FlushSubroutines« - Remove subroutines from the memory
of the DSP.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 115
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_FlushSubroutines( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_FlushSubroutines removes all subroutines from
the DSP's memory, and so increases the amount of available free
memory.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_FlushSubroutines">Binding</a> &nbsp; <a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a> &nbsp; <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a> &nbsp;
<a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_FlushSubroutines">4.11.9.1 Bindings for Dsp_FlushSubroutines</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #115,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_GetProgAbility">4.11.10 Dsp_GetProgAbility</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_GetProgAbility« - Request identification of a process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 114
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_GetProgAbility( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_GetProgAbility assigns an identifier to a DSP
process, with which one can check whether the code belonging to the
process is already present in the DSP.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the identifier valid for the process.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_GetProgAbility">Binding</a> &nbsp; <a href="#Dsp_RequestUniqueAbility">Dsp_RequestUniqueAbility</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_GetProgAbility">4.11.10.1 Bindings for Dsp_GetProgAbility</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_GetProgAbility">Dsp_GetProgAbility</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #114,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_GetWordSize">4.11.11 Dsp_GetWordSize</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_GetWordSize« - Obtain the size of a DSP-word.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 103
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_GetWordSize( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_GetWordSize obtains the length, in bytes, of a
DSP-word. This function is required to dimension the buffers for data
transfer adequately.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the size of a DSP-word.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_GetWordSize">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_GetWordSize">4.11.11.1 Bindings for Dsp_GetWordSize</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_GetWordSize">Dsp_GetWordSize</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #103,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_Hf0">4.11.12 Dsp_Hf0</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_Hf0« - Set or clear bit 3 of the HSR.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 119
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_Hf0( int16_t flag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_Hf0 obtains or resp. sets the value of bit 3
of the HSR register. The parameter <i>flag</i> has the following
meaning:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">flag</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;0</td>
  <td align="left" valign="top">Clear bit 3 of the HSR</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;1</td>
  <td align="left" valign="top">Set bit 3 of the HSR</td>
</tr>
<tr>
  <td align="center" valign="top">-1</td>
  <td align="left" valign="top">Leave bit 3 of the HSR unchanged</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value of bit 3 of the HSR.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_Hf0">Binding</a> &nbsp; <a href="#Dsp_Hf1">Dsp_Hf1</a> &nbsp; <a href="#Dsp_Hf2">Dsp_Hf2</a> &nbsp; <a href="#Dsp_Hf3">Dsp_Hf3</a> &nbsp; <a href="#Dsp_HStat">Dsp_HStat</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_Hf0">4.11.12.1 Bindings for Dsp_Hf0</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_Hf0">Dsp_Hf0</a>( int16_t flag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    flag,-(sp)   ; Offset 2
move.w    #119,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_Hf1">4.11.13 Dsp_Hf1</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_Hf1« - Set or clear bit 4 of the HSR.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 120
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_Hf1( int16_t flag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_Hf1 obtains or resp. sets the value of bit 4
of the HSR register. The parameter <i>flag</i> has the following
meaning:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">flag</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;0</td>
  <td align="left" valign="top">Clear bit 4 of the HSR</td>
</tr>
<tr>
  <td align="center" valign="top">&nbsp;1</td>
  <td align="left" valign="top">Set bit 4 of the HSR</td>
</tr>
<tr>
  <td align="center" valign="top">-1</td>
  <td align="left" valign="top">Leave bit 4 of the HSR unchanged</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value of bit 4 of the HSR.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_Hf1">Binding</a> &nbsp; <a href="#Dsp_Hf0">Dsp_Hf0</a> &nbsp; <a href="#Dsp_Hf2">Dsp_Hf2</a> &nbsp; <a href="#Dsp_Hf3">Dsp_Hf3</a> &nbsp; <a href="#Dsp_HStat">Dsp_HStat</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_Hf1">4.11.13.1 Bindings for Dsp_Hf1</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_Hf1">Dsp_Hf1</a>( int16_t flag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    flag,-(sp)   ; Offset 2
move.w    #120,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_Hf2">4.11.14 Dsp_Hf2</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_Hf2« - Inquire status of bit 3 of the HCR.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 121
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_Hf2( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_Hf2 inquires the current status of bit 3 of
the HCR register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value of bit 3 of the HCR.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_Hf2">Binding</a> &nbsp; <a href="#Dsp_Hf0">Dsp_Hf0</a> &nbsp; <a href="#Dsp_Hf1">Dsp_Hf1</a> &nbsp; <a href="#Dsp_Hf3">Dsp_Hf3</a> &nbsp; <a href="#Dsp_HStat">Dsp_HStat</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_Hf2">4.11.14.1 Bindings for Dsp_Hf2</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_Hf2">Dsp_Hf2</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #121,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_Hf3">4.11.15 Dsp_Hf3</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_Hf3« - Inquire status of bit 4 of the HCR.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 122
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_Hf3( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_Hf3 inquires the current status of bit 4 of
the HCR register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value of bit 4 of the HCR.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_Hf3">Binding</a> &nbsp; <a href="#Dsp_Hf0">Dsp_Hf0</a> &nbsp; <a href="#Dsp_Hf1">Dsp_Hf1</a> &nbsp; <a href="#Dsp_Hf2">Dsp_Hf2</a> &nbsp; <a href="#Dsp_HStat">Dsp_HStat</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_Hf3">4.11.15.1 Bindings for Dsp_Hf3</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_Hf3">Dsp_Hf3</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #122,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_HStat">4.11.16 Dsp_HStat</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_HStat« - Inquire value of the ISR register
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 125
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int8_t Dsp_HStat( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_HStat inquires the value of the ISR register.
This way one can check whether data can be received or sent to the ISR
register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value of the ISR register.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_HStat">Binding</a> &nbsp; <a href="#Dsp_Hf0">Dsp_Hf0</a> &nbsp; <a href="#Dsp_Hf1">Dsp_Hf1</a> &nbsp; <a href="#Dsp_Hf2">Dsp_Hf2</a> &nbsp; <a href="#Dsp_Hf3">Dsp_Hf3</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_HStat">4.11.16.1 Bindings for Dsp_HStat</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int8_t <a href="#Dsp_HStat">Dsp_HStat</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #125,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_InqSubrAbility">4.11.17 Dsp_InqSubrAbility</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_InqSubrAbility« - Inquire subroutine identifier
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 117
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_InqSubrAbility( int16_t ability );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_InqSubrAbility inquires the identifier of the
subroutine with the functionality <i>abilitiy.</i>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the identifier of the subroutine. A return
value of 0 means that the corresponding subroutine is not present in
DSP memory; in that case the subroutine has to be installed with
<a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_InqSubrAbility">Binding</a> &nbsp; <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a> &nbsp; <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a> &nbsp;
<a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_InqSubrAbility">4.11.17.1 Bindings for Dsp_InqSubrAbility</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a>( int16_t ability );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    ability,-(sp)  ; Offset 2
move.w    #117,-(sp)     ; Offset 0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp          ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_InStream">4.11.18 Dsp_InStream</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_InStream« - Data transfer to the DSP via an interrupt
handler
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 99
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_InStream( int8_t *data_in, int32_t block_size, int32_t
num_blocks, int32_t *blocks_done );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function copies via a DSP interrupt handler
<i>num_blocks</i> data blocks with a size of <i>block_size</i>
DSP-words from the buffer <i>data_in</i> to the DSP. For each
interrupt one block will be transferred, irrespective of whether the
DSP is ready to receive or not. At the same time the counter
<i>blocks_done</i>, which keeps track of the number of blocks
transferred, will be incremented. As the data is transferred via an
interrupt, the procedure does not have to wait. Via
<i>blocks_done</i> the program can then determine whether the
transfer has been completed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_InStream">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_SetVectors">Dsp_SetVectors</a> &nbsp; <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a> &nbsp;
<a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_InStream">4.11.18.1 Bindings for Dsp_InStream</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_InStream">Dsp_InStream</a>( int8_t *data_in, int32_t block_size, int32_t
num_blocks, int32_t *blocks_done );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       blocks_done       ; Offset 14
move.l    num_blocks,-(sp)  ; Offset 10
move.l    block_size,-(sp)  ; Offset  6
pea       data_in           ; Offset  2
move.w    #99,-(sp)         ; Offset  0
trap      #14               ; Call <a href="xbios_main.html">XBIOS</a>
lea       $12(sp),sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_IOStream">4.11.19 Dsp_IOStream</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_IOStream« - Data transfer from and to DSP via two
interrupts
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 101
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_IOStream( int8_t *data_in, int8_t *data_out, int32_t
block_insize, int32_t block_outsize, int32_t num_blocks, int32_t
*blocks_done );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function sends and receives simultaneously via DSP
interrupt handling <i>num_blocks</i> data blocks with a size of
<i>block_insize</i> or <i>block_outsize</i> DSP-words from/to the
DSP. The sent data is taken from the buffer <i>data_in</i>, the
received data is stored in the buffer <i>data_out.</i> For each
interrupt one block is sent and one received (except for the first and
last interrupt). At the same time the counter <i>blocks_done</i>,
which keeps track of the number of blocks transferred, will be
incremented. As the data is transferred via an interrupt, the function
does not have to wait. Via <i>blocks_done</i> the program can then
determine whether the transfer has been completed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_IOStream">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_SetVectors">Dsp_SetVectors</a> &nbsp; <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a> &nbsp;
<a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_IOStream">4.11.19.1 Bindings for Dsp_IOStream</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_IOStream">Dsp_IOStream</a>( int8_t *data_in, int8_t *data_out, int32_t
block_insize, int32_t block_outsize, int32_t num_blocks, int32_t
*blocks_done );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       blocks_done          ; Offset 22
move.l    num_blocks,-(sp)     ; Offset 18
move.l    block_outsize,-(sp)  ; Offset 14
move.l    block_insize,-(sp)   ; Offset 10
pea       data_out             ; Offset  6
pea       data_in              ; Offset  2
move.w    #101,-(sp)           ; Offset  0
trap      #14                  ; Call <a href="xbios_main.html">XBIOS</a>
lea       $1A(sp),sp           ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_LoadProg">4.11.20 Dsp_LoadProg</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_LoadProg« - Load and execute DSP program
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 108
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_LoadProg( int8_t *file, int16_t ability, int8_t
*buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_LoadProg loads the DSP program with the name
<i>file</i> from disk. The program must be in the .LOD format and
must not exceed the memory space reserved by <a href="#Dsp_Reserve">Dsp_Reserve</a>. The
parameter <i>ability</i> identifies the program. <i>buffer</i>
points to a memory block where the DSP can place the binary code it
generates for the time being. The size of the memory block can be
calculated with the formula:
<br>&nbsp;
<pre>DSP-wordsize *
( Number of program and data words in the LOD file +
( DSP-wordsize * Number of blocks in the .LOD file ))
</pre>
<br>After this the program will be executed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value 0 if successful, or -1 in case
of error.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_LoadProg">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a> &nbsp; <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_LoadProg">4.11.20.1 Bindings for Dsp_LoadProg</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_LoadProg">Dsp_LoadProg</a>( int8_t *file, int16_t ability, int8_t
*buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer         ; Offset 8
move.w    ability,-(sp)  ; Offset 6
pea       file           ; Offset 2
move.w    #108,-(sp)     ; Offset 0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
lea       $C(sp),sp      ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_LoadSubroutine">4.11.21 Dsp_LoadSubroutine</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_LoadSubroutine« - <a href="c_task_royal.html#Install">Install</a> a subroutine in memory of the
DSP
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 116
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_LoadSubroutine( int8_t *codeptr, int32_t codesize,
int16_t ability );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_LoadSubroutine installs the DSP binary
subroutine from the buffer <i>codeptr</i> in the DSP's memory. The
subroutine has a size of <i>codesize</i> DSP- words and has the
identifier <i>ability.</i> The subroutine remains resident in DSP
memory until there is no more room for new subroutines and it is
displaced, or the function <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a> is called.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns 0 in case of error. A positive value
denotes the handle assigned to the subroutine, which may be called
with <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_LoadSubroutine">Binding</a> &nbsp; <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a> &nbsp; <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a> &nbsp;
<a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_LoadSubroutine">4.11.21.1 Bindings for Dsp_LoadSubroutine</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a>( int8_t *codeptr, int32_t codesize,
int16_t ability );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    ability,-(sp)   ; Offset 10
move.l    codesize,-(sp)  ; Offset  6
pea       codeptr         ; Offset  2
move.w    #116,-(sp)      ; Offset  0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $C(sp),sp       ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_Lock">4.11.22 Dsp_Lock</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_Lock« - Inquire availability of the DSP
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 104
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_Lock( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_Lock inquires whether the DSP is available for
calling applications and has not been blocked by something else.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value -1 if the DSP is being used
already by another process. A return value of 0 on the other hand
signifies the availability of the DSP and blocks this simultaneously
for others, until a call of <a href="#Dsp_Unlock">Dsp_Unlock</a> is received.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_Lock">Binding</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_Lock">4.11.22.1 Bindings for Dsp_Lock</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_Lock">Dsp_Lock</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #104,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_LodToBinary">4.11.23 Dsp_LodToBinary</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_LodToBinary« - Conversion of a file from the LOD to the
binary format
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 111
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Dsp_LodToBinary( int8_t *file, int8_t *codeptr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_LodToBinary converts the (ASCII) contents of
the .LOD file with the name <i>file</i> to a binary format. The DSP
program created in this way is stored at the address <i>codeptr.</i>
This block of memory must be dimensioned large enough to take it.
After this the program can be executed with <a href="#Dsp_ExecProg">Dsp_ExecProg</a> or
<a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the size of the resulting program in
DSP-words if successful, or a negative value in case of error.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_LodToBinary">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp;
<a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a> &nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_LodToBinary">4.11.23.1 Bindings for Dsp_LodToBinary</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int32_t <a href="#Dsp_LodToBinary">Dsp_LodToBinary</a>( int8_t *file, int8_t *codeptr );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       codeptr      ; Offset 6
pea       file         ; Offset 2
move.w    #111,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_MultBlocks">4.11.24 Dsp_MultBlocks</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_MultBlocks« - Data transfer of multiple blocks from and
to the DSP
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 127
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_MultBlocks( int32_t numsend, int32_t numreceive,
<a href="xbios_structures.html#DSPBLOCK">DSPBLOCK</a> *sendblocks, <a href="xbios_structures.html#DSPBLOCK">DSPBLOCK</a> *receiveblocks );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_MultBlocks sends and receives multiple blocks
of DSP data of varying size from and to the DSP. <i>numsend</i> is
the number of blocks to be sent and <i>numreceive</i> the number to
be received. <i>sendblocks</i> and <i>receiveblocks</i> are pointers
to arrays that describe the buffers and blocks.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_MultBlocks">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_MultBlocks">4.11.24.1 Bindings for Dsp_MultBlocks</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>( int32_t numsend, int32_t numreceive,
<a href="xbios_structures.html#DSPBLOCK">DSPBLOCK</a> *sendblocks, <a href="xbios_structures.html#DSPBLOCK">DSPBLOCK</a> *receiveblocks );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       receiveblocks     ; Offset 14
pea       sendblocks        ; Offset 10
move.l    numreceive,-(sp)  ; Offset  6
move.l    numsend,-(sp)     ; Offset  2
move.w    #127,-(sp)        ; Offset  0
trap      #14               ; Call <a href="xbios_main.html">XBIOS</a>
lea       $12(sp),sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_OutStream">4.11.25 Dsp_OutStream</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_OutStream« - Data transfer from DSP via an interrupt
handler to a given buffer
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 100
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_OutStream( int8_t *data_out, int32_t block_size,
int32_t num_blocks, int32_t *blocks_done );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function copies via a DSP interrupt handler
<i>num_blocks</i> data blocks with a size of <i>block_size</i>
DSP-words from the DSP into the buffer <i>data_out.</i> For each
interrupt one block will be transferred. At the same time the counter
<i>blocks_done</i>, which keeps track of the number of blocks
transferred, will be incremen- ted. As the data is transferred via an
interrupt, the function does not have to wait. Via <i>blocks_done</i>
the program can then determine whether the transfer has been
completed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_OutStream">Binding</a> &nbsp; <a href="#Dsp_DoBlock">Dsp_DoBlock</a> &nbsp; <a href="#Dsp_BlkUnpacked">Dsp_BlkUnpacked</a> &nbsp; <a href="#Dsp_BlkHandShake">Dsp_BlkHandShake</a> &nbsp;
<a href="#Dsp_BlkWords">Dsp_BlkWords</a> &nbsp; <a href="#Dsp_BlkBytes">Dsp_BlkBytes</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_GetWordSize">Dsp_GetWordSize</a> &nbsp; <a href="#Dsp_SetVectors">Dsp_SetVectors</a> &nbsp; <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a> &nbsp;
<a href="#Dsp_MultBlocks">Dsp_MultBlocks</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_OutStream">4.11.25.1 Bindings for Dsp_OutStream</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_OutStream">Dsp_OutStream</a>( int8_t *data_out, int32_t block_size,
int32_t num_blocks, int32_t *blocks_done );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       blocks_done       ; Offset 14
move.l    num_blocks,-(sp)  ; Offset 10
move.l    block_size,-(sp)  ; Offset  6
pea       data_out          ; Offset  2
move.w    #100,-(sp)        ; Offset  0
trap      #14               ; Call <a href="xbios_main.html">XBIOS</a>
lea       $12(sp),sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_RemoveInterrupts">4.11.26 Dsp_RemoveInterrupts</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_RemoveInterrupts« - Turn off generation of DSP
interrupts
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 102
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_RemoveInterrupts( int16_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_RemoveInterrupts turns off the generation of
DSP interrupts. The parameter <i>mask</i> determines which interrupts
are affected:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">mask</td>
<td valign="top"> Meaning
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">1</td>
<td valign="top"> No interrupts for sending data through the DSP
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">2</td>
<td valign="top"> No interrupts for receiving data through the DSP
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">3</td>
<td valign="top"> No interrupts for sending or receiving data through the DSP.
<br>&nbsp;

</td></tr>
</table>

<br>The function also removes routines that were installed with
<a href="#Dsp_SetVectors">Dsp_SetVectors</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_RemoveInterrupts">Binding</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_SetVectors">Dsp_SetVectors</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_RemoveInterrupts">4.11.26.1 Bindings for Dsp_RemoveInterrupts</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a>( int16_t mask );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    mask,-(sp)   ; Offset 2
move.w    #102,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_RequestUniqueAbility">4.11.27 Dsp_RequestUniqueAbility</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_RequestUniqueAbility« - Generate an identifier for a
process
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 113
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_RequestUniqueAbility( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_RequestUniqueAbility assigns to a DSP process
a random unique identifier (also called ability code) which is valid
for the run-time of the system. With it one can determine whether the
program code belonging to the process is already resident in the DSP.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the created identifier/ability code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_RequestUniqueAbility">Binding</a> &nbsp; <a href="#Dsp_GetProgAbility">Dsp_GetProgAbility</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_RequestUniqueAbility">4.11.27.1 Bindings for Dsp_RequestUniqueAbility</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_RequestUniqueAbility">Dsp_RequestUniqueAbility</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #113,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_Reserve">4.11.28 Dsp_Reserve</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_Reserve« - Reserve DSP memory for use by a program
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 107
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_Reserve( int32_t xreserve, int32_t yreserve );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_Reserve reserves <i>xreserve</i> words of
X-memory and <i>yreserve</i> words of Y-memory space. The memory
request must include all program and data space, and may not exceed
the amount of available memory. This function is necessary to prevent
DSP processes being overwritten by DSP subroutines. The reservation
remains active up to the next call of Dsp_Reserve.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value 0 if memory reservation was
successful, or -1 if not enough DSP memory was available (or some
other error).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_Reserve">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Unlock">Dsp_Unlock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_LoadProg">Dsp_LoadProg</a> &nbsp;
<a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_Reserve">4.11.28.1 Bindings for Dsp_Reserve</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_Reserve">Dsp_Reserve</a>( int32_t xreserve, int32_t yreserve );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    yreserve,-(sp)  ; Offset 6
move.l    xreserve,-(sp)  ; Offset 2
move.w    #107,-(sp)      ; Offset 0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp       ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_RunSubroutine">4.11.29 Dsp_RunSubroutine</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »DspRunSubroutine« - Start execution of a subroutine
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 118
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Dsp_RunSubroutine( int16_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_RunSubroutine starts execution of a program
with the identifier <i>handle.</i> The identifier for a subroutine
can be found by using <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a> or <a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value 0 if successful, or a negative
number in case of failure.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_RunSubroutine">Binding</a> &nbsp; <a href="#Dsp_InqSubrAbility">Dsp_InqSubrAbility</a> &nbsp; <a href="#Dsp_FlushSubroutines">Dsp_FlushSubroutines</a> &nbsp;
<a href="#Dsp_LoadSubroutine">Dsp_LoadSubroutine</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_RunSubroutine">4.11.29.1 Bindings for Dsp_RunSubroutine</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Dsp_RunSubroutine">Dsp_RunSubroutine</a>( int16_t handle );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    handle,-(sp)  ; Offset 2
move.w    #118,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_SetVectors">4.11.30 Dsp_SetVectors</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_SetVectors« - Installation of a custom transfer routine
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 126
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_SetVectors( void (*receiver)(), int32_t
(*transmitter)() );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_SetVectors installs routines that are called
when the DSP wants to transfer data via interrupt handlers.
<i>receiver</i> is a pointer to a routine that is called after the
DSP has sent data, and <i>transmitter</i> a pointer to a routine that
is called before the DSP receives data. The reception routine
<i>receiver</i> is passed a LONG that was sent by the DSP as a
parameter on the stack. The sender routine <i>transmitter</i> passes
a LONG to the DSP in register D0. This must be non-zero so that it (or
rather the lowest three bytes) are transferred to the DSP. Both
routines are terminated by the assembler command RTS.
<br>&nbsp;
<br>If a 0 is passed for <i>receiver</i> or <i>transmitter</i>,
then the corresponding interrupt will be blocked. To remove a routine,
one has to call <a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a>.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_SetVectors">Binding</a> &nbsp; <a href="#Dsp_InStream">Dsp_InStream</a> &nbsp; <a href="#Dsp_OutStream">Dsp_OutStream</a> &nbsp; <a href="#Dsp_IOStream">Dsp_IOStream</a> &nbsp;
<a href="#Dsp_RemoveInterrupts">Dsp_RemoveInterrupts</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_SetVectors">4.11.30.1 Bindings for Dsp_SetVectors</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_SetVectors">Dsp_SetVectors</a>( void (*receiver)(), int32_t
(*transmitter)() );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       transmitter  ; Offset 6
pea       receiver     ; Offset 2
move.w    #126,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_TriggerHC">4.11.31 Dsp_TriggerHC</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_TriggerHC« - Execute host command set aside for DSP
programs
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 112
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_TriggerHC( int16_t vector );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_TriggerHC executes vector <i>vector.</i> Only
the two vectors $13 and $14 are available for free use by DSP
programs.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_TriggerHC">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_TriggerHC">4.11.31.1 Bindings for Dsp_TriggerHC</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_TriggerHC">Dsp_TriggerHC</a>( int16_t vector );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    vector,-(sp)  ; Offset 2
move.w    #112,-(sp)    ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Dsp_Unlock">4.11.32 Dsp_Unlock</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Dsp_Unlock« - Release DSP for other processes
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 105
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Dsp_Unlock( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function Dsp_Unlock releases the DSP for other processes.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is available only on computers with the DSP-56001
signal processor.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#DSP_20programming">DSP programming</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Dsp_Unlock">Binding</a> &nbsp; <a href="#Dsp_Lock">Dsp_Lock</a> &nbsp; <a href="#Dsp_Available">Dsp_Available</a> &nbsp; <a href="#Dsp_Reserve">Dsp_Reserve</a> &nbsp; <a href="#Dsp_LoadProg">Dsp_LoadProg</a>
&nbsp; <a href="#Dsp_ExecProg">Dsp_ExecProg</a> &nbsp; <a href="#Dsp_ExecBoot">Dsp_ExecBoot</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Dsp_Unlock">4.11.32.1 Bindings for Dsp_Unlock</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Dsp_Unlock">Dsp_Unlock</a>( void );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    #105,-(sp)   ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #2,sp        ; Correct stack
</pre>

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_printer.html"><img src="udo_lf.gif" alt="Printer functions" title="Printer functions" border="0" width="24" height="24">Printer functions</a>
<a name="UDO_nav_rg_FOOT" href="xbios_dhs.html"><img src="udo_rg.gif" alt="Hatari DHS XBIOS extension" title="Hatari DHS XBIOS extension" border="0" width="24" height="24">Hatari DHS XBIOS extension</a>
</body>
</html>
