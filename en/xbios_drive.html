<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2025/08/02 -->
<html lang="en">
<head>
<title>
The documentation for TOS: Drive functions
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_interrupt.html"><img src="udo_lf.gif" alt="Interrupt functions" title="Interrupt functions" border="0" width="24" height="24">Interrupt functions</a>
<a name="UDO_nav_rg_HEAD" href="matrix_XBIOS_extension.html"><img src="udo_rg.gif" alt="MATRIX XBIOS extension" title="MATRIX XBIOS extension" border="0" width="24" height="24">MATRIX XBIOS extension</a>

<hr>

<h1><a name="Drive_20functions">4.14 Drive functions</a></h1>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#DMAread">DMAread</a></td>
<td valign="top"> Reads sectors from hard drive.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#DMAwrite">DMAwrite</a></td>
<td valign="top"> Writes sectors to hard drive.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Flopfmt">Flopfmt</a></td>
<td valign="top"> Formats track on floppy disk.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Floprate">Floprate</a></td>
<td valign="top"> Sets <a href="bios_sysvars.html#seekrate">seekrate</a> and timeout of floppy drive.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Floprd">Floprd</a></td>
<td valign="top"> Reads individual sectors from floppy disk.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Flopver">Flopver</a></td>
<td valign="top"> Verifies sectors of a floppy disk.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Flopwr">Flopwr</a></td>
<td valign="top"> Writes sectors on floppy disk.
<a name="MetaDOS_20functions"></a>
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaclose">Metaclose</a></td>
<td valign="top"> Releases a <a href="xbios_metados.html">MetaDOS</a> device.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metadiscinfo">Metadiscinfo</a></td>
<td valign="top"> Obtains current status information.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metagettoc">Metagettoc</a></td>
<td valign="top"> Returns the table of contents of a device.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metainit">Metainit</a></td>
<td valign="top"> Obtains information about <a href="xbios_metados.html">MetaDOS</a> version.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaioctl">Metaioctl</a></td>
<td valign="top"> Sends GEMDOS opcodes to a <a href="xbios_metados.html">MetaDOS</a> device.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaopen">Metaopen</a></td>
<td valign="top"> Initializes a <a href="xbios_metados.html">MetaDOS</a> device.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaread">Metaread</a></td>
<td valign="top"> Reads data from a <a href="xbios_metados.html">MetaDOS</a> device.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metaseek">Metaseek</a></td>
<td valign="top"> Seeks to a physical address.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metasetsongtime">Metasetsongtime</a></td>
<td valign="top"> Starts audio playback of a timed portion of a track.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metastartaudio">Metastartaudio</a></td>
<td valign="top"> Starts audio playback of one or more songs.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metastatus">Metastatus</a></td>
<td valign="top"> Obtains the status of a <a href="xbios_metados.html">MetaDOS</a> device.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metastopaudio">Metastopaudio</a></td>
<td valign="top"> Stops audio playback.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Metawrite">Metawrite</a></td>
<td valign="top"> Writes data to a <a href="xbios_metados.html">MetaDOS</a> device.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&#x2022; <a href="#Protobt">Protobt</a></td>
<td valign="top"> Generates a boot-sector for a diskette.

</td></tr>
</table>

<p>See also: <a href="gemdos_file.html">GEMDOS file functions</a> &nbsp; <a href="gemdos_directory.html">GEMDOS directory functions</a>
</p>
<h3><a name="DMAread">4.14.1 DMAread</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »DMA read« - Read individual sectors from a DMA device.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 42
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t DMAread( int32_t sector, int16_t count, void *buffer,
int16_t devno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine DMAread reads single or multiple sectors
from an ACSI, SCSI or IDE device. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">sector</td>
<td valign="top"> First sector number to read
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Number of sectors to read
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Start address in memory where data stored
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Device number. This can be:
<br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0..7:</td>
  <td align="left" valign="top">ACSI device</td>
</tr>
<tr>
  <td align="left" valign="top">8..15:</td>
  <td align="left" valign="top">SCSI device (<a href="tos_main.html">TOS</a> 2.06 and 3.00 onwards)</td>
</tr>
<tr>
  <td align="left" valign="top">16:</td>
  <td align="left" valign="top">IDE device  (<a href="tos_main.html">TOS</a> 2.06 and 3.06 onwards)</td>
</tr>
</table>
</div>

<br>All other values are reserved for future extensions.

</td></tr>
</table>

<br><b>Note:</b> In many cases it is more sensible to use <a href="About_the_BIOS.html#Rwabs">Rwabs</a> in
place of this function. The specified memory block must be capable of
being written to for the hardware used (catchword: <a href="bios_cookiejar.html#Fast-RAM_20buffer">Fast-RAM buffer</a>).
On the TT030, SCSI devices are handled by this function not via DMA
but via handshaking to transfer individual bytes, so alternative RAM
may be used. But the Falcon uses DMA for SCSI transfers, so cannot use
alternative RAM for this.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns 0 if the operation was successful and no
error occurred, else a negative error-code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available from TOS 2.00 onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20DMAread">Binding</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20DMAread">4.14.1.1 Bindings for DMAread</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#DMAread">DMAread</a>( int32_t sector, int16_t count, void *buffer,
int16_t devno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    devno,-(sp)  ; Offset 12
pea       buffer       ; Offset  8
move.w    count,-(sp)  ; Offset  6
move.l    sector,-(sp) ; Offset  2
move.w    #42,-(sp)    ; Offset  0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $E(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="DMAwrite">4.14.2 DMAwrite</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »DMA write« - Write individual sectors to a DMA device.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 43
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t DMAwrite( int32_t sector, int16_t count, void *buffer,
int16_t devno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine DMAwrite writes single or multiple sectors
to an ACSI, SCSI or IDE device. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">sector</td>
<td valign="top"> First sector number to read
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Number of sectors to read
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Start address in memory where data stored
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Device number. This can be:
<br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0..7:</td>
  <td align="left" valign="top">ACSI device</td>
</tr>
<tr>
  <td align="left" valign="top">8..15:</td>
  <td align="left" valign="top">SCSI device (<a href="tos_main.html">TOS</a> 2.06 and 3.00 onwards)</td>
</tr>
<tr>
  <td align="left" valign="top">16</td>
  <td align="left" valign="top">IDE device  (<a href="tos_main.html">TOS</a> 2.06 and 3.06 onwards)</td>
</tr>
</table>
</div>

<br>All other values are reserved for future extensions.

</td></tr>
</table>

<br><b>Note:</b> In many cases it is more sensible to use <a href="About_the_BIOS.html#Rwabs">Rwabs</a> in
place of this function. The specified memory block must be capable of
being read from for the hardware used (catchword: <a href="bios_cookiejar.html#Fast-RAM_20buffer">Fast-RAM buffer</a>).
SCSI devices are operated by this function not via DMA but via
handshaking.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns 0 if the operation was successful and no
error occurred, else a negative error-code.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available from TOS 2.00 onwards.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20DMAwrite">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20DMAwrite">4.14.2.1 Bindings for DMAwrite</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#DMAwrite">DMAwrite</a>( int32_t sector, int16_t count, void *buffer,
int16_t devno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    devno,-(sp)  ; Offset 12
pea       buffer       ; Offset  8
move.w    count,-(sp)  ; Offset  6
move.l    sector,-(sp) ; Offset  2
move.w    #43,-(sp)    ; Offset  0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $E(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Flopfmt">4.14.3 Flopfmt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy format« - Format specific tracks on a floppy
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 10
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Flopfmt( void *buf, int32_t filler, int16_t devno,
int16_t spt, int16_t trackno, int16_t sideno, int16_t interlv, int32_t
magic, int16_t virgin );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Flopfmt formats one or more tracks on a
floppy disk. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top"> Pointer to a segment of memory where the data for one track may
be stored
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top"> For all TOS versions &lt; 1.02 unused, and to be set to 0.
From Blitter-TOS onwards: If <i>interlv</i> = -1, then
<i>filler</i> is to be treated as a pointer to a table of sector
numbers (16 bit words). This makes it possible to choose the order of
the sectors on the track freely.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> 0 = Drive A:, 1 = Drive B:
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">spt</td>
<td valign="top"> Sectors per track (normal: 9). If the cookie <a href="bios_cookiejar.html#Cookie_2C_20_FDC">_FDC</a> is set,
then in addition values of 18 (High Density) or 36 (Extra High
Density) sectors are permitted. Switching between the various write
modes takes place at 13 (HD) or 26 (ED).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top"> Number of the track (0..79)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top"> 0: Side 1
<br>1: Side 2 (for double-sided disks)
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">interlv</td>
<td valign="top"> Determines how many physical sectors lie between two logical
sectors in each case (normal: 1).
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">magic</td>
<td valign="top"> Must be 0x87654321, otherwise no formatting will be performed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">virgin</td>
<td valign="top"> Bit-pattern that is written during formatting into each sector
(normal: 0xe5e5). The upper four bits may not be set, as otherwise
this would be interpreted by the controller as a command.
<br>&nbsp;

</td></tr>
</table>

<br><b>Note:</b> As of the Blitter-TOS, the desktop allows a
list of sector numbers to be passed to arrange tracks in a spiral
format in such a way that the least possible time is lost at track
changes waiting for the next sector.
<br>&nbsp;
<br>For a normal format (9 sectors per track) the memory segment
specified with the parameter <i>buf</i> must have a size of at least
8 kbyte; in other cases the buffer may have to be increased above
this.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns 0 when no error has occurred in formatting
the track. Otherwise a NULL-terminated list of the faulty sectors will
be written as a int16_t array into the buffer <i>buf.</i>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All <a href="tos_main.html">TOS</a> versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Flopfmt">Binding</a> &nbsp; <a href="#Flopwr">Flopwr</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Flopfmt">4.14.3.1 Bindings for Flopfmt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Flopfmt">Flopfmt</a>( void *buf, int32_t filler, int16_t devno,
int16_t spt, int16_t trackno, int16_t sideno, int16_t interlv, int32_t
magic, int16_t virgin );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    virgin,-(sp)  ; Offset 24
move.l    magic,-(sp)   ; Offset 20
move.w    interlv,-(sp) ; Offset 18
move.w    sideno,-(sp)  ; Offset 16
move.w    trackno,-(sp) ; Offset 14
move.w    spt,-(sp)     ; Offset 12
move.w    devno,-(sp)   ; Offset 10
move.l    filler,-(sp)  ; Offset  6
pea       buf           ; Offset  2
move.w    #10,-(sp)     ; Offset  0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       $1A(sp),sp    ; Correct stack
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(10,L:buf%,L:filler%,W:devno%,W:spt%,W:trackno%,W:sideno%,W:interlv%,L:magic%,W:virgin%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Floprate">4.14.4 Floprate</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy rate« - Read or set the seek rate of a floppy drive.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 41
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Floprate( int16_t devno, int16_t newrate );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Floprate returns or sets the current seek
rate. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Drive number:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Drive A:</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Drive B: etc</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">newrate</td>
<td valign="top">
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="right" valign="top">-1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Do not alter seek rate</td>
</tr>
<tr>
  <td align="right" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Seek rate of  6ms</td>
</tr>
<tr>
  <td align="right" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Seek rate of 12ms</td>
</tr>
<tr>
  <td align="right" valign="top">2</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Seek rate of  2ms</td>
</tr>
<tr>
  <td align="right" valign="top">3</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Seek rate of  3ms</td>
</tr>
</table>
</div>


</td></tr>
</table>

<a name="Floppy_2C_20Timeout_20of_20the"></a>
<a name="Timeout_20of_20the_20floppy"></a>
<br><b>Note:</b> As of <a href="magic.html">MagiC</a> 3, one can additionally use Floprate
(-1, newrate) to set the <b>timeout</b> for the floppy; a value of
300 means 1.5 seconds) this is the value that is set by default at
booting).
<br>&nbsp;
<br>With older ROM-TOS versions one has to use the previously
undocumented system variables:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="center" valign="top">TOS-Version</td>
  <td align="center" valign="top">Drive A:</td>
  <td align="center" valign="top">Drive B:</td>
</tr>
<tr>
  <td align="center" valign="top">RAM <a href="tos_main.html">TOS</a></td>
  <td align="center" valign="top">0x6ca</td>
  <td align="center" valign="top">0x6ce</td>
</tr>
<tr>
  <td align="center" valign="top">1.00</td>
  <td align="center" valign="top">0xa08</td>
  <td align="center" valign="top">0xa0c</td>
</tr>
<tr>
  <td align="center" valign="top">1.02</td>
  <td align="center" valign="top">0xa4e</td>
  <td align="center" valign="top">0xa52</td>
</tr>
</table>
</div>

<br>For portable setting one can use the following <a href="#Seekrate_20for_20all_20TOS_20versions">sample routine</a>.
<br>&nbsp;
<br>The MilanTOS 4.08 (2003.09.03) do nothing and returns always
null.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the prior seek rate for the drive.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> The function is only available as of TOS 1.04.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Floprate">Binding</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="#Floprd">Floprd</a> &nbsp; <a href="#Flopver">Flopver</a> &nbsp; <a href="#Flopfmt">Flopfmt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Floprate">4.14.4.1 Bindings for Floprate</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Floprate">Floprate</a>( int16_t devno, int16_t newrate );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    newrate,-(sp) ; Offset 4
move.w    devno,-(sp)   ; Offset 2
move.w    #41,-(sp)     ; Offset 0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp         ; Correct stack
</pre>

</td></tr>
</table>

<h4><a name="Seekrate_20for_20all_20TOS_20versions">4.14.4.2 Seekrate for all TOS versions</a></h4>
<pre>/* Portable setting of the floppy seek rate for all <a href="tos_main.html">TOS</a> versions
   (except RAM-<a href="tos_main.html">TOS</a> 1.00).
   Parameters: As for the <a href="xbios_main.html">XBIOS</a> function &quot;<a href="#Floprate">Floprate</a>&quot; */

int16_t SeekRate ( int16_t devno, int16_t newrate )
{
  int32_t stack;
  int16_t version;
  <a href="OSHEADER.html">OSHEADER</a> *sys;

  /* Get pointer to OS-header */
  stack = <a href="gemdos_system.html#Super">Super</a> (0L);
  sys = *((<a href="OSHEADER.html">OSHEADER</a> **) 0x4f2);
  version = sys-&gt;os_version;
  <a href="gemdos_system.html#Super">Super</a> ((void *)stack);

  /* With newer <a href="tos_main.html">TOS</a> simply call &quot;<a href="#Floprate">Floprate</a>&quot;  */
  if ( version &gt;= 0x0104 )
    return <a href="#Floprate">Floprate</a> ( devno, newrate );
  else
  {
    /* otherwise calculate pointer to internal <a href="gemdos_main.html">GEMDOS</a> variables */
    int16_t *sk, merk;

    if ( version == 0x0102 )
      sk = (int16_t *) 0x0a4e;
    else
      sk = (int16_t *) 0x0a08;

    /* Drive B: 2 int16_t follows */
    if ( devno ) sk = &amp;(sk[2]);

    merk = *sk;
    /* enter value only if not -1 */
    if ( newrate != -1 ) *sk = newrate;

    /* always return old value */
    return merk;
  }
}
</pre>
<h3><a name="Floprd">4.14.5 Floprd</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy read« - Read individual sectors from floppy disk.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 8
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Floprd( void *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Floprd reads one or more physical sectors
from a floppy disk. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top"> Pointer to memory block to be used as a buffer for the read-in
sectors
</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top"> Unused
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Drive (0 = Drive A: etc.)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top"> Start sector (normally between 1 and 9)
</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top"> Track number (normally between 0 and 79)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top"> Side of the floppy disk (0 or 1)
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Number of sectors to be read

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns 0 if the operation was successful or a
non-zero error-code if not.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Floprd">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Flopwr">Flopwr</a> &nbsp; <a href="About_the_BIOS.html#Rwabs">Rwabs</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Floprd">4.14.5.1 Bindings for Floprd</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Floprd">Floprd</a>( void *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)   ; Offset 18
move.w    sideno,-(sp)  ; Offset 16
move.w    trackno,-(sp) ; Offset 14
move.w    sectno,-(sp)  ; Offset 12
move.w    devno,-(sp)   ; Offset 10
move.l    filler,-(sp)  ; Offset  6
pea       buf           ; Offset  2
move.w    #8,-(sp)      ; Offset  0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       $14(sp),sp    ; Correct stack
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(8,L:buf%,L:filler%,W:devno%,W:sectno%,W:trackno%,W:sideno%,W:count%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Flopver">4.14.6 Flopver</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy verify« - Verify sectors of a floppy disk.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 19
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Flopver( void *buf, int32_t filler, int16_t devno,
int16_ sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Flopver verifies that a series of sectors
can be read without error from a floppy disk drive. The following
apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top"> Pointer to a 1024 byte block of memory into which the sectors
to be verified can be read
</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top"> Unused (should be set to 0)
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Drive:
<br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Drive A:</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Drive B:</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top"> Start sector (normally between 1 and 9)
</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top"> Track nummer (normally between 0 and 79)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top"> Side of the floppy disk (0 or 1)
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Number of sectors to be verified

</td></tr>
</table>

<br><b>Note:</b> After the call one finds in the parameter
<i>buf</i> a NULL-terminated list of 16-bit words containing the
numbers of the defective sectors. So the function does <i>not</i>
compare sectors with a block of memory; instead it always reads the
sectors into the same buffer. This only verifies that the sectors can
be read correctly, or if read errors occur during reading.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value 0 if the list stored in the
parameter <i>buf</i> is valid, or a non-zero value otherwise.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Flopver">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Flopver">4.14.6.1 Bindings for Flopver</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Flopver">Flopver</a>( void *buf, int32_t filler, int16_t devno,
int16_ sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)    ; Offset 18
move.w    sideno,-(sp)   ; Offset 16
move.w    trackno,-(sp)  ; Offset 14
move.w    sectno,-(sp)   ; Offset 12
move.w    devno,-(sp)    ; Offset 10
move.l    filler,-(sp)   ; Offset  6
pea       buf            ; Offset  2
move.w    #19,-(sp)      ; Offset  0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
lea       $14(sp),sp     ; Correct stack
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(19,L:buf%,L:filler%,W:devno%,W:sectno,W:trackno%,W:sideno%,W:count%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Flopwr">4.14.7 Flopwr</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Floppy write« - Write individual sectors on a floppy disk.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 9
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int16_t Flopwr( VOID *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Flopwr writes one or more physical sectors
to a floppy disk. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">buf</td>
<td valign="top"> Pointer to memory block to be used as a buffer for the sectors
to be written
</td></tr>

<tr><td nowrap="nowrap" valign="top">filler</td>
<td valign="top"> Unused
</td></tr>

<tr><td nowrap="nowrap" valign="top">devno</td>
<td valign="top"> Drive (0 = Drive A: etc.)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sectno</td>
<td valign="top"> Start sector (normally between 1 and 9)
</td></tr>

<tr><td nowrap="nowrap" valign="top">trackno</td>
<td valign="top"> Track number (normally between 0 and 79)
</td></tr>

<tr><td nowrap="nowrap" valign="top">sideno</td>
<td valign="top"> Side of the floppy disk (0 or 1)
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Number of sectors to be written

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns 0 if the operation was successful or a
non-zero error-code if not.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Flopwr">Binding</a> &nbsp; <a href="#DMAread">DMAread</a> &nbsp; <a href="#DMAwrite">DMAwrite</a> &nbsp; <a href="#Floprd">Floprd</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Flopwr">4.14.7.1 Bindings for Flopwr</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>int16_t <a href="#Flopwr">Flopwr</a>( VOID *buf, int32_t filler, int16_t devno,
int16_t sectno, int16_t trackno, int16_t sideno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)    ; Offset 18
move.w    sideno,-(sp)   ; Offset 16
move.w    trackno,-(sp)  ; Offset 14
move.w    sectno,-(sp)   ; Offset 12
move.w    devno,-(sp)    ; Offset 10
move.l    filler,-(sp)   ; Offset  6
pea       buf            ; Offset  2
move.w    #9,-(sp)       ; Offset  0
trap      #14            ; Call <a href="xbios_main.html">XBIOS</a>
lea       $14(sp),sp     ; Correct stack
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top">
Fehler%=Xbios(9,L:buf%,L:filler%,W:devno%,W:sectno%,W:trackno%,W:sideno,W:count%)
<br>&nbsp;

</td></tr>
</table>

<h3><a name="Metaclose">4.14.8 Metaclose</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaclose« - Release a <a href="xbios_metados.html">MetaDOS</a> device again.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 50
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metaclose( int16_t drive );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function releases the drive <i>drive</i> again.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metaclose">Binding</a> &nbsp; <a href="#Metaopen">Metaopen</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metaclose">4.14.8.1 Bindings for Metaclose</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaclose">Metaclose</a>( int16_t drive );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    drive,-(sp)  ; Offset 2
move.w    #50,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metadiscinfo">4.14.9 Metadiscinfo</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metadiscinfo« - Obtain current status information.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 63
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metadiscinfo( int16_t drive, <a href="xbios_structures.html#CD_DISC_INFO">CD_DISC_INFO</a> *p );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function obtains information about the status of a <a href="xbios_metados.html">MetaDOS</a>
device. The following applies:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">Desired drive</td>
</tr>
<tr>
  <td align="left" valign="top">p</td>
  <td align="left" valign="top">Address of the receiving buffer</td>
</tr>
</table>
</div>

<br><b>Note:</b> The position data within the structure are coded
in BCD MSF format. The element <i>index</i> is not set by old BOS
drivers, and the element <i>disctype</i> is not set by SCSI
CD-ROMs.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metadiscinfo">Binding</a> &nbsp; <a href="#Metastatus">Metastatus</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metadiscinfo">4.14.9.1 Bindings for Metadiscinfo</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metadiscinfo">Metadiscinfo</a>( int16_t drive, <a href="xbios_structures.html#CD_DISC_INFO">CD_DISC_INFO</a> *p );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       p            ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #63,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metagettoc">4.14.10 Metagettoc</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metagettoc« - Return the table of contents of a device.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 62
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metagettoc( int16_t drive, int16_t flag, <a href="xbios_structures.html#CD_TOC_ENTRY">CD_TOC_ENTRY</a>
*buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function returns the table of contents of a drive. The
following applies:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">Desired drive</td>
</tr>
<tr>
  <td align="left" valign="top">flag</td>
  <td align="left" valign="top">Reserved for CDAR504</td>
</tr>
<tr>
  <td align="left" valign="top">buffer</td>
  <td align="left" valign="top">Buffer for receiving the table of contents</td>
</tr>
</table>
</div>

<br><b>Note:</b> The receiving buffer should have room for 128
entries. Each entry consists of a track number and an MSF address
(both in BCD format). For the track number the following applies:
<br>0 = Record has no meaning
<br>0x01...0x99 = Track number in BCD coding
<br>0xa0 = First track with programmed order 0xa2 = End of the CD.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metagettoc">Binding</a> &nbsp; <a href="#Metaread">Metaread</a> &nbsp; <a href="#Metawrite">Metawrite</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metagettoc">4.14.10.1 Bindings for Metagettoc</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metagettoc">Metagettoc</a>( int16_t drive, int16_t flag, <a href="xbios_structures.html#CD_TOC_ENTRY">CD_TOC_ENTRY</a>
*buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 6
move.w    flag,-(sp)   ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #62,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $A(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metainit">4.14.11 Metainit</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metainit« - Obtain information about the installed <a href="xbios_metados.html">MetaDOS</a>
version.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 48
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Metainit( <a href="xbios_structures.html#META_INFO_1">META_INFO_1</a> *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Metainit obtains information about the
currently installed version of <a href="xbios_metados.html">MetaDOS</a>, and the devices known to it.
<br>&nbsp;
<br>The following procedure is suggested:
<br>&nbsp;
<ul>
<li> Clear the contents of <a href="xbios_structures.html#META_INFO_1">META_INFO_1</a> structure
</li>
<li> Call the function Metainit
</li>
<li> Test whether the element <i>version</i> still holds a
NULL-pointer (then <a href="xbios_metados.html">MetaDOS</a> is <i>not</i> installed.
</li>
</ul>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns no direct result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metainit">Binding</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metainit">4.14.11.1 Bindings for Metainit</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> void <a href="#Metainit">Metainit</a>( <a href="xbios_structures.html#META_INFO_1">META_INFO_1</a> *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 2
move.w    #48,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #6,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metaioctl">4.14.12 Metaioctl</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaioctl« - <a href="powerdos.html#Send">Send</a> GEMDOS opcodes to a <a href="xbios_metados.html">MetaDOS</a> device.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 55
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metaioctl( int16_t drive, int32_t magic, int16_t
opcode, void *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function permits opcodes of the GEMDOS routines Dcntl or
Fcntl to be sent to a <a href="xbios_metados.html">MetaDOS</a> device. The following apply:
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Parameter</td>
  <td align="left" valign="top">Meaning</td>
</tr>
<tr>
  <td align="left" valign="top">drive</td>
  <td align="left" valign="top">Desired drive</td>
</tr>
<tr>
  <td align="left" valign="top">magic</td>
  <td align="left" valign="top">Must have the value 'FCTL'</td>
</tr>
<tr>
  <td align="left" valign="top">opcode</td>
  <td align="left" valign="top">Opcode to be sent</td>
</tr>
<tr>
  <td align="left" valign="top">buffer</td>
  <td align="left" valign="top">Depends on opcode</td>
</tr>
</table>
</div>

<br><b>Note:</b> The <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">list of CD-ROM commands</a> is an itemization of all known opcodes
that may occur when working with CD-ROMs.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the following values in case of error:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top"><a href="gemdos_errors.html#EINVFN">EINVFN</a>:</td>
<td valign="top"> The specified opcode is not supported.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top"><a href="bios_errors.html#EUNCMD">EUNCMD</a>:</td>
<td valign="top"> The function itself (!) is not supported.
<br>&nbsp;

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metaioctl">Binding</a> &nbsp; <a href="gemdos_directory.html#Dcntl">Dcntl</a> &nbsp; <a href="gemdos_file.html#Fcntl">Fcntl</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metaioctl">4.14.12.1 Bindings for Metaioctl</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaioctl">Metaioctl</a>( int16_t drive, int32_t magic, int16_t
opcode, void *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 10
move.w    opcode,-(sp) ; Offset  8
move.l    magic,-(sp)  ; Offset  4
move.w    drive,-(sp)  ; Offset  2
move.w    #55,-(sp)    ; Offset  0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
lea       $E(sp),sp    ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metaopen">4.14.13 Metaopen</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaopen« - Initialize a <a href="xbios_metados.html">MetaDOS</a> device.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 49
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metaopen( int16_t drive, <a href="xbios_structures.html#META_DRVINFO">META_DRVINFO</a> *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function initializes a <a href="xbios_metados.html">MetaDOS</a> device. The following
applies:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> Desired drive
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Pointer for receiving the name of the driver

</td></tr>
</table>

<br><b>Note:</b> If the driver name starts with 'CD', one may
assume that this is a CD-ROM driver.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns the value 0 if all was OK, or a negative
error number.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metaopen">Binding</a> &nbsp; <a href="#Metaclose">Metaclose</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metaopen">4.14.13.1 Bindings for Metaopen</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaopen">Metaopen</a>( int16_t drive, <a href="xbios_structures.html#META_DRVINFO">META_DRVINFO</a> *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #49,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metaread">4.14.14 Metaread</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaread« - Read data from a <a href="xbios_metados.html">MetaDOS</a> device.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 51
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metaread( int16_t drive, void *buffer, int32_t blockno,
int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function reads data from a <a href="xbios_metados.html">MetaDOS</a> device. The following
apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> Desired drive
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Buffer for receiving the data
</td></tr>

<tr><td nowrap="nowrap" valign="top">blockno</td>
<td valign="top"> Number of the start block
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Number of blocks to be read

</td></tr>
</table>

<br><b>Note:</b> The block size for CD-ROMs is 2048 bytes; but
unfortunately this can not be obtained in each case. Due to a
limitation in Atari's BOS drivers, a maximum of 63 blocks can be read
at a time.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metaread">Binding</a> &nbsp; <a href="#Metawrite">Metawrite</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metaread">4.14.14.1 Bindings for Metaread</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaread">Metaread</a>( int16_t drive, void *buffer, int32_t blockno,
int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)   ; Offset 10
move.l    blockno,-(sp) ; Offset  8
pea       buffer        ; Offset  4
move.w    drive,-(sp)   ; Offset  2
move.w    #51,-(sp)     ; Offset  0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       $E(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metaseek">4.14.15 Metaseek</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metaseek« - Seeks to a physical address.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 53
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metaseek( int16_t drive, int32_t blockno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function will seek the physical unit to a physical address.
The function call will return once the seek has been completed or on
an error condition. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> Desired drive
</td></tr>

<tr><td nowrap="nowrap" valign="top">blockno</td>
<td valign="top"> Block number to seek to

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metaseek">Binding</a> &nbsp; <a href="#Metaread">Metaread</a> &nbsp; <a href="#Metawrite">Metawrite</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metaseek">4.14.15.1 Bindings for Metaseek</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metaseek">Metaseek</a>( int16_t drive, int32_t blockno );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    blockno,-(sp)    ; Offset 4
move.w    drive            ; Offset 2
move.w    #53,-(sp)        ; Offset 0
trap      #14              ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp            ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metasetsongtime">4.14.16 Metasetsongtime</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metasetsongtime« - Start audio playback of a timed portion
of the track.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 61
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metasetsongtime( int16_t drive, int16_t repeat, int32_t
starttime, int32_t endtime );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function starts audio playback of a specified timed portion
of an audio track. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> Desired drive
</td></tr>

<tr><td nowrap="nowrap" valign="top">repeat</td>
<td valign="top"> Repeat
<br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Without repeating</td>
</tr>
<tr>
  <td align="left" valign="top">1</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">With repeating</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">starttime</td>
<td valign="top"> BCD start time in MSF coding
</td></tr>

<tr><td nowrap="nowrap" valign="top">endtime</td>
<td valign="top"> BCD end time in MSF coding

</td></tr>
</table>

<br><b>Note:</b> The repeat mode appears to be supported only by
CDARGEN.BOS and also only for the Atari CDAR504 drive.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metasetsongtime">Binding</a> &nbsp; <a href="#Metastartaudio">Metastartaudio</a> &nbsp; <a href="#Metastopaudio">Metastopaudio</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metasetsongtime">4.14.16.1 Bindings for Metasetsongtime</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metasetsongtime">Metasetsongtime</a>( int16_t drive, int16_t repeat, int32_t
starttime, int32_t endtime );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.l    endtime,-(sp)    ; Offset 10
move.l    starttime,-(sp)  ; Offset  6
move.w    repeat           ; Offset  4
move.w    drive            ; Offset  2
move.w    #61,-(sp)        ; Offset  0
trap      #14              ; Call <a href="xbios_main.html">XBIOS</a>
lea       $E(sp),sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metastartaudio">4.14.17 Metastartaudio</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metastartaudio« - Start audio playback of one or more songs.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 59
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metastartaudio( int16_t drive, int16_t flag, uint8_t
*bytearray);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function starts audio playback of a specified song or
songs. The following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> Desired drive
</td></tr>

<tr><td nowrap="nowrap" valign="top">flag</td>
<td valign="top"> Mode
</td></tr>

<tr><td nowrap="nowrap" valign="top">bytearray</td>
<td valign="top"> Dependent on parameter flag

</td></tr>
</table>

<br><b>Note:</b> On SCSI devices only one mode exists (flag = 0).
In that case one passes in <i>bytearray[0]</i> the number of songs to
be played, and in <i>bytearray[1]</i> the number of the first song.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metastartaudio">Binding</a> &nbsp; <a href="#Metasetsongtime">Metasetsongtime</a> &nbsp; <a href="#Metastopaudio">Metastopaudio</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metastartaudio">4.14.17.1 Bindings for Metastartaudio</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metastartaudio">Metastartaudio</a>( int16_t drive, int16_t flag, uint8_t
*bytearray);
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       bytearray    ; Offset 6
move.w    flag,-(sp)   ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #59,-(sp)    ; Offset 0
trap      #14          ; <a href="#Drive_20functions">Drive functions</a>
lea       $A(sp),sp    ; Call <a href="xbios_main.html">XBIOS</a>
</pre>

</td></tr>
</table>

<h3><a name="Metastatus">4.14.18 Metastatus</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metastatus« - Obtain the status of a <a href="xbios_metados.html">MetaDOS</a> device.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 54
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metastatus( int16_t drive, void *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function obtains the status of a <a href="xbios_metados.html">MetaDOS</a> device. The
following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> Desired drive
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Dependent on the implementation of the BOS driver

</td></tr>
</table>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a 32-bit value, which is coded as follows:
codiert ist:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">High-Word:</td>
<td valign="top">
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">0x0000</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">All OK</td>
</tr>
<tr>
  <td align="left" valign="top">0xffff</td>
  <td align="left" valign="top">=</td>
  <td align="left" valign="top">Error has arisen</td>
</tr>
</table>
</div>

</td></tr>

<tr><td nowrap="nowrap" valign="top">Low-Word :</td>
<td valign="top">
<br>&nbsp;
<br><br>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">Bit-15</td>
  <td align="left" valign="top">(Error)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-07</td>
  <td align="left" valign="top">(Timeout)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-02</td>
  <td align="left" valign="top">(Media change)</td>
</tr>
<tr>
  <td align="left" valign="top">Bit-01</td>
  <td align="left" valign="top">(Busy)</td>
</tr>
</table>
</div>


</td></tr>
</table>

<br>All other bits of the low word are reserved at present.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metastatus">Binding</a> &nbsp; <a href="#Metadiscinfo">Metadiscinfo</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metastatus">4.14.18.1 Bindings for Metastatus</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metastatus">Metastatus</a>( int16_t drive, void *buffer );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>pea       buffer       ; Offset 4
move.w    drive,-(sp)  ; Offset 2
move.w    #54,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #8,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metastopaudio">4.14.19 Metastopaudio</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metastopaudio« - Stop audio playback.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 60
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metastopaudio( int16_t drive );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function stops audio playback for the drive <i>drive.</i>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metastopaudio">Binding</a> &nbsp; <a href="#Metastartaudio">Metastartaudio</a> &nbsp; <a href="#Metasetsongtime">Metasetsongtime</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metastopaudio">4.14.19.1 Bindings for Metastopaudio</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metastopaudio">Metastopaudio</a>( int16_t drive );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    drive,-(sp)  ; Offset 2
move.w    #60,-(sp)    ; Offset 0
trap      #14          ; Call <a href="xbios_main.html">XBIOS</a>
addq.l    #4,sp        ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Metawrite">4.14.20 Metawrite</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »Metawrite« - Write data to a <a href="xbios_metados.html">MetaDOS</a> device.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 52
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> int32_t Metawrite( int16_t drive, void *buffer, int32_t
blockno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The function writes data to a <a href="xbios_metados.html">MetaDOS</a> device. The following
apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Parameter</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">drive</td>
<td valign="top"> Desired drive
</td></tr>

<tr><td nowrap="nowrap" valign="top">buffer</td>
<td valign="top"> Address of the data buffer
</td></tr>

<tr><td nowrap="nowrap" valign="top">blockno</td>
<td valign="top"> Number of the start block
</td></tr>

<tr><td nowrap="nowrap" valign="top">count</td>
<td valign="top"> Number of blocks to be written

</td></tr>
</table>

<br><b>Note:</b> With a CD-ROM this function naturally has no
effect.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function returns a value of the type int32_t.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> This function is only available when <a href="xbios_metados.html">MetaDOS</a> has been installed.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Metawrite">Binding</a> &nbsp; <a href="#Metaread">Metaread</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Metawrite">4.14.20.1 Bindings for Metawrite</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> int32_t <a href="#Metawrite">Metawrite</a>( int16_t drive, void *buffer, int32_t
blockno, int16_t count );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    count,-(sp)   ; Offset 10
move.l    blockno,-(sp) ; Offset  8
pea       buffer        ; Offset  4
move.w    drive,-(sp)   ; Offset  2
move.w    #52,-(sp)     ; Offset  0
trap      #14           ; Call <a href="xbios_main.html">XBIOS</a>
lea       $E(sp),sp     ; Correct stack
</pre>

</td></tr>
</table>

<h3><a name="Protobt">4.14.21 Protobt</a></h3>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">Name:</td>
<td valign="top"> »prototype boot sector« - Generate a standard boot-sector for
a floppy disk.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Opcode:</td>
<td valign="top"> 18
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Syntax:</td>
<td valign="top"> void Protobt( void *buf, int32_t serialno, int16_t disktype,
int16_t execflag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Description:</td>
<td valign="top"> The XBIOS routine Protobt creates a boot-sector for a floppy
disk. The argument <i>buf</i> points to a 512 byte sized buffer
holding the contents of the boot-sector. The parameter
<i>serialno</i> serves to store a serial number in the boot-sector;
if the variable <i>serialno</i> is greater than 0x01000000, then a
random number will be stored instead. With <i>disktype</i> one of the
following floppy disk types will be selected:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">disktype</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;-1</td>
<td valign="top"> Don't change disk type
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;0</td>
<td valign="top"> 40 tracks, single-sided (180 kbyte)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;1</td>
<td valign="top"> 40 tracks, double-sided (360 kbyte)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;2</td>
<td valign="top"> 80 tracks, single-sided (360 kbyte)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;3</td>
<td valign="top"> 80 tracks, double-sided (720 kbyte)
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;4</td>
<td valign="top"> <b>High Density</b> (1,44 Mbyte)
<br>is only supported if the cookie <a href="bios_cookiejar.html#Cookie_2C_20_FDC">_FDC</a> holds the value for HD
support.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;5</td>
<td valign="top"> <b>Extra High Density</b> (2,88 Mbyte)
<br>is only supported if the cookie _FDC holds the value for ED
support.
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;&nbsp;&nbsp;6</td>
<td valign="top"> 80 tracks, double-sided, 10 sectors (800 kbyte)
<br>is only supported by EmuTOS since 2024/12/28.

</td></tr>
</table>

<br>Finally, the parameter <i>execflag</i> determines whether the
information in the boot-sector can be executed as a program. The
following apply:
<br>&nbsp;
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">execflag</td>
<td valign="top"> Meaning
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;</td>
<td valign="top"> &nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">-1</td>
<td valign="top"> Do not alter boot-sector
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;0</td>
<td valign="top"> Boot-sector is not executable
</td></tr>

<tr><td nowrap="nowrap" valign="top">&nbsp;1</td>
<td valign="top"> Boot-sector is executable

</td></tr>
</table>

<br><b>Note:</b> So that floppy disks may be read on MS-DOS systems
as well, the first 3 bytes of the boot-sector have to have the values
0xE9, 0x00 and 0x4E or 0xEB, 0x34 and 0x90 entered; however, floppy
disks of this kind are then <i>no longer bootable</i> under TOS.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Return value:</td>
<td valign="top"> The function does not return a result.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Availability:</td>
<td valign="top"> All TOS versions.
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Group:</td>
<td valign="top"> <a href="#Drive_20functions">Drive functions</a>
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">See also:</td>
<td valign="top"> <a href="#Bindings_20for_20Protobt">Binding</a> &nbsp; <a href="#Flopfmt">Flopfmt</a>
<br>&nbsp;

</td></tr>
</table>

<h4><a name="Bindings_20for_20Protobt">4.14.21.1 Bindings for Protobt</a></h4>
<table class="UDO_env_xlist">
<tr><td nowrap="nowrap" valign="top">C:</td>
<td valign="top"> #include &lt;tos.h&gt;
<br>&nbsp;
<br>void <a href="#Protobt">Protobt</a>( void *buf, int32_t serialno, int16_t disktype,
int16_t execflag );
<br>&nbsp;
</td></tr>

<tr><td nowrap="nowrap" valign="top">Assembler:</td>
<td valign="top">
<br>&nbsp;
<pre>move.w    execflag,-(sp)  ; Offset 12
move.w    disktype,-(sp)  ; Offset 10
move.l    serialno,-(sp)  ; Offset  6
pea       buf             ; Offset  2
move.w    #18,-(sp)       ; Offset  0
trap      #14             ; Call <a href="xbios_main.html">XBIOS</a>
lea       $E(sp),sp       ; Correct stack
</pre>
</td></tr>

<tr><td nowrap="nowrap" valign="top">GFA-Basic</td>
<td valign="top"> Fehler%=Xbios(18,L:buf%,L:serialno%,W:disktype%,W:execflag%)
<br>&nbsp;

</td></tr>
</table>

<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_interrupt.html"><img src="udo_lf.gif" alt="Interrupt functions" title="Interrupt functions" border="0" width="24" height="24">Interrupt functions</a>
<a name="UDO_nav_rg_FOOT" href="matrix_XBIOS_extension.html"><img src="udo_rg.gif" alt="MATRIX XBIOS extension" title="MATRIX XBIOS extension" border="0" width="24" height="24">MATRIX XBIOS extension</a>
</body>
</html>
