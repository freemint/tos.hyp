<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- last modified on 2025/12/20 -->
<html lang="en">
<head>
<title>
The documentation for TOS: XBIOS Structures
</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="Generator" content="UDO Version 7.12 (1248) for Linux">
</head>
<body style="position: relative;">

<a name="UDO_nav_hm_HEAD" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_HEAD" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_HEAD" href="xbios_functions.html"><img src="udo_lf.gif" alt="XBIOS function list" title="XBIOS function list" border="0" width="24" height="24">XBIOS function list</a>
<a name="UDO_nav_rg_HEAD" href="gemdos_main.html"><img src="udo_rg.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>

<hr>

<h1><a name="XBIOS_20Structures">4.24 XBIOS Structures</a></h1>
<ul class="content">
	<li> 4.24.1 <a href="#BCONMAP">BCONMAP</a>
	<li> 4.24.2 <a href="#CD_DISC_INFO">CD_DISC_INFO</a>
	<li> 4.24.3 <a href="#CD_TOC_ENTRY">CD_TOC_ENTRY</a>
	<li> 4.24.4 <a href="#DSPBLOCK">DSPBLOCK</a>
	<li> 4.24.5 <a href="#IOREC">IOREC</a>
	<li> 4.24.6 <a href="#KEYBDPARMS">KEYBDPARMS</a>
	<li> 4.24.7 <a href="#KBDVBASE">KBDVBASE</a>
	<li> 4.24.8 <a href="#KEYTAB">KEYTAB</a>
	<li> 4.24.9 <a href="#MAPTAB">MAPTAB</a>
	<li> 4.24.10 <a href="#META_DRVINFO">META_DRVINFO</a>
	<li> 4.24.11 <a href="#META_INFO_1">META_INFO_1</a>
	<li> 4.24.12 <a href="#META_INFO_2">META_INFO_2</a>
	<li> 4.24.13 <a href="#MOD_DESC">MOD_DESC</a>
	<li> 4.24.14 <a href="#MOUSE">MOUSE</a>
	<li> 4.24.15 <a href="#OVERPATCH">OVERPATCH</a>
	<li> 4.24.16 <a href="#PBDEF">PBDEF</a>
	<li> 4.24.17 <a href="#PCI_RSC_DESC">PCI_RSC_DESC</a>
	<li> 4.24.18 <a href="#PMODE">PMODE</a>
	<li> 4.24.19 <a href="#SCRCLIPMEMBLK">SCRCLIPMEMBLK</a>
	<li> 4.24.20 <a href="#SCRCOPYMEMBLK">SCRCOPYMEMBLK</a>
	<li> 4.24.21 <a href="#SCREEN">SCREEN</a>
	<li> 4.24.22 <a href="#SCREENINFO">SCREENINFO</a>
	<li> 4.24.23 <a href="#SCREEN_2C_20OverScan">SCREEN, OverScan</a>
	<li> 4.24.24 <a href="#SCRFILLMEMBLK">SCRFILLMEMBLK</a>
	<li> 4.24.25 <a href="#SCRLINEMEMBLK">SCRLINEMEMBLK</a>
	<li> 4.24.26 <a href="#SCRMEMBLK">SCRMEMBLK</a>
	<li> 4.24.27 <a href="#SCRTEXTUREMEMBLK">SCRTEXTUREMEMBLK</a>
	<li> 4.24.28 <a href="#VDO_MODE">VDO_MODE</a>
	<li> 4.24.29 <a href="#VDO_PARAM">VDO_PARAM</a>
	<li> 4.24.30 <a href="#vidix_capability_t">vidix_capability_t</a>
	<li> 4.24.31 <a href="#vidix_deinterlace_t">vidix_deinterlace_t</a>
	<li> 4.24.32 <a href="#vidix_dma_t">vidix_dma_t</a>
	<li> 4.24.33 <a href="#vidix_fourcc_t">vidix_fourcc_t</a>
	<li> 4.24.34 <a href="#vidix_grkey_t">vidix_grkey_t</a>
	<li> 4.24.35 <a href="#vidix_playback_t">vidix_playback_t</a>
	<li> 4.24.36 <a href="#vidix_video_eq_t">vidix_video_eq_t</a>
	<li> 4.24.37 <a href="#VPOS">VPOS</a>
	</li>
</ul>
<br>
<h3><a name="BCONMAP">4.24.1 BCONMAP</a></h3>
<pre>typedef struct
{
   <a href="#MAPTAB">MAPTAB</a>  *maptab;     /* List of the serial ports                   */
   int16_t  maptabsize; /* Number of port drivers                     */

   /* Undocumented, with <a href="tos_main.html">TOS</a> and <a href="magic.html">MagiC</a>:                               */
   int16_t  auxnr;      /* Current channel number set for AUX         */
   int32_t  rscon;      /* Pointer to currently set <a href="xbios_interface.html#Rsconf">Rsconf</a> function   */
   int32_t  iorec;      /* Pointer to <a href="#IOREC">IOREC</a> of the current channel    */
} BCONMAP;

See also: <a href="xbios_interface.html#Bconmap">Bconmap</a>
</pre>
<h3><a name="CD_DISC_INFO">4.24.2 CD_DISC_INFO</a></h3>
<pre>typedef struct
{
   uint8_t  disctype;         /* 0: audio, 1: data */
   uint8_t  firsttrack, lasttrack, curtrack;
   uint8_t  relposz, relposm, relposs, relposf;
   uint8_t  absposz, absposm, absposs, absposf;
   uint8_t  endposz, endposm, endposs, endposf;
   uint8_t  index, res[3];
   uint32_t reserved[123];
} CD_DISC_INFO;
</pre>
<p>See also: <a href="xbios_drive.html#Metadiscinfo">Metadiscinfo</a>
</p>
<h3><a name="CD_TOC_ENTRY">4.24.3 CD_TOC_ENTRY</a></h3>
<pre>typedef struct
{
   uint8_t trackno;
   uint8_t minute;
   uint8_t second;
   uint8_t frame;
} CD_TOC_ENTRY;
</pre>
<p>See also: <a href="gemdos_file.html#Fcntl_2C_20CD-ROM_20commands_20for">CD-ROM Opcodes for Fcntl</a>
</p>
<h3><a name="DSPBLOCK">4.24.4 DSPBLOCK</a></h3>
<pre>typedef struct
{
   int16_t  blocktype;  /* Type of data in buffer:  */
                        /*   0 : LongInt            */
                        /*   1 : Integer            */
                        /*   2 : Byte               */
   int32_t  blocksize;  /* Buffer size              */
   void    *blockaddr;  /* Pointer to the buffer    */
} DSPBLOCK;

</pre>
<p>See also: <a href="xbios_dsp56001.html#Dsp_MultBlocks">Dsp_MultBlocks</a> &nbsp; <a href="xbios_dsp56001.html">DSP programming</a>
</p>
<h3><a name="IOREC">4.24.5 IOREC</a></h3>
<pre>typedef struct
{
   void    *ibuf;        /* Pointer to buffer      */
   int16_t ibufsiz;      /* <a href="proto_olga.html#Size">Size</a> of buffer         */
   int16_t ibufhd;       /* Head index             */
   int16_t ibuftl;       /* Tail index             */
   int16_t ibuflow;      /* Low-water mark         */
   int16_t ibufhi;       /* High-water mark        */
} IOREC;
</pre>
<p><b>Note:</b> The serial ports are connected directly to a
corresponding output buffer. The two last pointers are only used for
the serial port in XON/XOFF or RTS/CTS operation.
</p>
<p>If the buffer fill-level falls below the low-water mark, the
sender is invited to send further characters; on the other hand, if it
exceeds the high-water mark then it is signalled not to send any more
characters.
</p>
<p>See also: <a href="xbios_interface.html#Iorec">Iorec</a>
</p>
<h3><a name="KEYBDPARMS">4.24.6 KEYBDPARMS</a></h3>
<pre>typedef struct
{
   int8_t *unshift;       /* Table of 'normal' key presses  */
   int8_t *shift;         /* Table of Shift key presses     */
   int8_t *capslock;      /* Table of Capslock key presses  */
   int8_t *altunshift;    /* From <a href="tos_main.html">TOS</a> 4.00, undocumented!   */
   int8_t *altshift;      /* From <a href="tos_main.html">TOS</a> 4.00, undocumented!   */
   int8_t *altcapslock;   /* From <a href="tos_main.html">TOS</a> 4.00, undocumented!   */
   int8_t *altgr;         /* From <a href="tos_main.html">TOS</a> 4.00, undocumented!   */
} <a href="#KEYTAB">KEYTAB</a>;
</pre>
<p>See also: <a href="xbios_keyboard.html#Keytbl">Keytbl</a>
</p>
<h3><a name="KBDVBASE">4.24.7 KBDVBASE</a></h3>
<pre>typedef struct
{
   void   (*kb_midivec)();   /* MIDI interrupt vector    */
   void   (*kb_vkbderr)();   /* Keyboard error vector    */
   void   (*kb_vmiderr)();   /* MIDI error vector        */
   void   (*kb_statvec)();   /* Keyboard status          */
   void   (*kb_mousevec)();  /* Keyboard mouse status    */
   void   (*kb_clockvec)();  /* Keyboard clock           */
   void   (*kb_joyvec)();    /* Keyboard joystick status */
   void   (*kb_midisys)();   /* System Midi vector       */
   void   (*kb_kbdsys)();    /* Keyboard vector          */
   int8_t drvstat;           /* Keyboard driver status   */
} KBDVBASE;
</pre>
<p><b>Note:</b> For the elements <i>kb_clockvec</i> and
<i>kb_joyvec</i> one should note that the address of the packet is
passed in register A0 and on the stack; also, the routines should be
terminated with an RTS, and if possible run for no more than 1ms.
</p>
<p>The element <i>drvstat</i> contains a non-zero value when the
IKBD is in the process of sending a packet.
</p>
<p>See also: <a href="xbios_interface.html#Kbdvbase">Kbdvbase</a>
</p>
<h3><a name="KEYTAB">4.24.8 KEYTAB</a></h3>
<pre>typedef struct
{
   int8_t *unshift;       /* Table of 'normal' key presses  */
   int8_t *shift;         /* Table of Shift key presses     */
   int8_t *capslock;      /* Table of Capslock key presses  */
   int8_t *altunshift;    /* From <a href="tos_main.html">TOS</a> 4.00, undocumented!   */
   int8_t *altshift;      /* From <a href="tos_main.html">TOS</a> 4.00, undocumented!   */
   int8_t *altcapslock;   /* From <a href="tos_main.html">TOS</a> 4.00, undocumented!   */
   int8_t *altgr;         /* From <a href="tos_main.html">TOS</a> 4.00, undocumented!   */
} KEYTAB;
</pre>
<p>Since KAOS 1.4.2 and <a href="magic.html">MagiC</a> are <i>altunshift</i>,
<i>altshift</i> and <i>altcapslock</i> also present.
</p>
<p>See also: <a href="xbios_keyboard.html#Keytbl">Keytbl</a>
</p>
<h3><a name="MAPTAB">4.24.9 MAPTAB</a></h3>
<pre>typedef struct
{
   int16_t  (*<a href="About_the_BIOS.html#Bconstat">Bconstat</a>)(void);
   int32_t  (*<a href="About_the_BIOS.html#Bconin">Bconin</a>)(void);
   int32_t  (*<a href="About_the_BIOS.html#Bcostat">Bcostat</a>)(void);
   void     (*<a href="About_the_BIOS.html#Bconout">Bconout</a>)(int16_t dev, int16_t c);
   uint32_t (*<a href="xbios_interface.html#Rsconf">Rsconf</a>)(int16_t baud, int16_t ctr, int16_t ucr, int16_t rsr, int16_t tsr, int16_t scr);
   <a href="#IOREC">IOREC</a>    *iorec;
} MAPTAB;
</pre>
<p>See also: <a href="xbios_interface.html#Bconmap">Bconmap</a> &nbsp; <a href="#BCONMAP">BCONMAP</a>
</p>
<h3><a name="META_DRVINFO">4.24.10 META_DRVINFO</a></h3>
<pre>typedef struct
{
   int8_t  *mdr_name;
   int32_t  reserved[3];
} META_DRVINFO;
</pre>
<p>See also: <a href="xbios_drive.html">Drive functions</a> &nbsp; <a href="xbios_drive.html#Metaopen">Metaopen</a>
</p>
<h3><a name="META_INFO_1">4.24.11 META_INFO_1</a></h3>
<pre>typedef struct
{
   uint32_t    drivemap;  /* Bits for <a href="xbios_metados.html">MetaDOS</a> drives.        */
                          /*   ((Bit 0 = Drive A:, etc.)     */
   int8_t      *version;  /* Name and version from <a href="xbios_metados.html">MetaDOS</a>   */
   int32_t     reserved;  /* Reserved                        */
   <a href="#META_INFO_2">META_INFO_2</a> *info;     /* Pointer to a second structure   */
} META_INFO_1;
</pre>
<p><b>Note:</b> The element <i>info</i> is available from MetaDOS
V2.30!
</p>
<p>See also: <a href="xbios_drive.html#Metainit">Metainit</a>
</p>
<h3><a name="META_INFO_2">4.24.12 META_INFO_2</a></h3>
<pre>typedef struct
{
   /* Version number (0x230 = '02.30') */
   uint16_t     mi_version;
   /* Magic constant '_MET' */
   int32_t      mi_magic;
   /* Maps DOS IDs to <a href="xbios_metados.html">MetaDOS</a> <a href="xbios_main.html">XBIOS</a> device numbers */
   const int8_t *mi_log2phys;
} META_INFO_2;
</pre>
<p><b>Note:</b> This structure exists only as of <a href="xbios_metados.html">MetaDOS</a> Version
2.30. The parameter <i>mi_log2phys</i> is a pointer to a field that
holds for each GEMDOS device the associated <a href="xbios_metados.html">MetaDOS</a> drive letter or
Null. So with the aid of this information one can determine which
MetaDOS drive letter belongs to which GEMDOS drive.
</p>
<p>See also: <a href="xbios_drive.html#Metainit">Metainit</a> &nbsp; <a href="#META_INFO_1">META_INFO_1</a>
</p>
<h3><a name="MOD_DESC">4.24.13 MOD_DESC</a></h3>
<pre>typedef struct
{
   int8_t  Name[34];   /* Descriptive text         */
   int32_t colors;
   int16_t xres,yres;
   int32_t fileptr;    /* Pointer to the mode file */
} MOD_DESC;
</pre>
<p>See also: <a href="crazydots.html">Crazy-Dots XBIOS extension</a>
</p>
<h3><a name="MOUSE">4.24.14 MOUSE</a></h3>
<pre>typedef struct
{
   int8_t  topmode;  /* 0: Y=0 at bottom             */
                     /* 1: Y=1 at top                */
   int8_t  buttons;  /* Similar to  IKBD             */
   int8_t  x_scale;  /* Additional parameters        */
   int8_t  y_scale;  /* Dependent on selected mode   */
   int16_t x_max;    /* Maximum X position           */
   int16_t y_max;    /* Maximum Y position           */
   int16_t x_start;  /* Start position X             */
   int16_t y_start;  /* Start position Y             */
} MOUSE;
</pre>
<p><b>Note:</b> The elements <i>x_max</i> and following are only
available in absolute mode.
</p>
<p>See also: <a href="gem_about.html">GEM</a> &nbsp; <a href="Screen_functions.html#Initmouse">Initmouse</a> &nbsp; <a href="vdi_main.html">VDI</a>
</p>
<h3><a name="OVERPATCH">4.24.15 OVERPATCH</a></h3>
<pre>typedef struct
{
   int16_t low_w  ,mid_w  ,high_w;   /* Width in pixels                  */
   int16_t low_h  ,mid_h  ,high_h;   /* Height in pixels                 */
   int32_t low_off,mid_off,high_off; /* Offset screen memory&lt;&gt;logbase    */
   int32_t mono_add,color_add;       /* Additional memory requirement    */
   int8_t  clear_scan;               /* Scancode of the clear function   */
   int8_t  clear_shift;              /* Shiftcode of the clear function  */
   int8_t  setup_shift;              /* Shiftcode for setup (mask)       */
   int8_t  invert_shift;             /* Shiftcode for inverting the mode */
   int8_t  abort_shift;              /* Shiftcode for termination        */
} OVERPATCH;
</pre>
<p>See also: <a href="xbios_overscan.html#Oscanpatch">Oscanpatch</a> &nbsp; <a href="xbios_overscan.html">OverScan XBIOS extension</a>
</p>
<h3><a name="PBDEF">4.24.16 PBDEF</a></h3>
<pre>typedef struct
{
   void    *pb_scrptr;  /* Pointer to start of screen memory */
   int16_t  pb_offset;  /* Offset to be added to this        */
   int16_t  pb_width;   /* Screen width in dots              */
   int16_t  pb_height;  /* Screen height in dots             */
   int16_t  pb_left;    /* Left margin in dots               */
   int16_t  pb_right;   /* Right margin in dots              */
   int16_t  pb_screz;   /* Resolution                        */
   int16_t  pb_prrez;   /* Printer type (Atari/Epson)        */
   void    *pb_colptr;  /* Pointer to colour palette         */
   int16_t  pb_prtype;  /* 0: Atari matrix monochrome
                           1: Atari matrix colour
                           2: Atari daisywheel monochrome
                           3: Epson matrix monochrome        */
   int16_t  pb_prport;  /* Centronics/RS-232 port            */
   void    *pb_mask;    /* Pointer to halftone mask          */
} PBDEF;
</pre>
<p><b>Note:</b> One has to ensure that the sum of the elements
<i>pb_width</i>, <i>pb_left</i> and <i>pb_right</i> corresponds
exactly to the actual screen width.
</p>
<p>See also: <a href="xbios_printer.html#Prtblk">Prtblk</a> &nbsp; <a href="xbios_main.html">XBIOS</a>
</p>
<h3><a name="PCI_RSC_DESC">4.24.17 PCI_RSC_DESC</a></h3>
<pre>typedef struct
{
  uint16_t next;      /* Length of this structure in bytes          */
                      /* Use this to get next descriptor            */
  uint16_t flags;     /* Type of resource and misc flags            */
  uint32_t start;     /* Start address of resource in PCI address space */
  uint32_t length;    /* Length of resource                         */
  uint32_t offset;    /* Offset from PCI to physical CPU address    */
  uint32_t dmaoffset; /* Offset for DMA-Memory transfers            */
} PCI_RSC_DESC;
</pre>
<p>The flags field is bit-coded as follows:
</p>
<a name="RSC_ROM"></a>
<a name="RSC_IO"></a>
<a name="RSC_LAST"></a>
<a name="FLG_8BIT"></a>
<a name="FLG_16BIT"></a>
<a name="FLG_32BIT"></a>
<a name="FLG_ENDMASK"></a>
<div align="left"><table border="0" class="UDO_env_table">
<tr>
  <td align="left" valign="top">RSC_ROM</td>
  <td align="left" valign="top">0x2000</td>
  <td align="left" valign="top">This is an expansion ROM (must be Memory, not IO)</td>
</tr>
<tr>
  <td align="left" valign="top">RSC_IO</td>
  <td align="left" valign="top">0x4000</td>
  <td align="left" valign="top">This is an IO area (memory area if bit is clear)</td>
</tr>
<tr>
  <td align="left" valign="top">RSC_LAST</td>
  <td align="left" valign="top">0x8000</td>
  <td align="left" valign="top">Last resource for this device</td>
</tr>
<tr>
  <td align="left" valign="top">FLG_8BIT</td>
  <td align="left" valign="top">0x0100</td>
  <td align="left" valign="top">8-bit accesses are supported</td>
</tr>
<tr>
  <td align="left" valign="top">FLG_16BIT</td>
  <td align="left" valign="top">0x0200</td>
  <td align="left" valign="top">16-bit accesses are supported</td>
</tr>
<tr>
  <td align="left" valign="top">FLG_32BIT</td>
  <td align="left" valign="top">0x0400</td>
  <td align="left" valign="top">32-bit accesses are supported</td>
</tr>
<tr>
  <td align="left" valign="top">FLG_ENDMASK</td>
  <td align="left" valign="top">0x000F</td>
  <td align="left" valign="top">Bit 0..3 specify which byte ordering is used:</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">0: Motorola (big endian)</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">1: Intel (little endian), address swapped</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">2: Intel (little endian), lane swapped</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">3..14: Reserved</td>
</tr>
<tr>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">&nbsp;</td>
  <td align="left" valign="top">15: Unknown. Access card only via <a href="bios_main.html">BIOS</a> functions</td>
</tr>
</table>
</div>

<p>The <i>start</i> field contains the start address on the PCI
bus of the resource. If the resource is not directly accessible, the
start address is 0.
</p>
<p>The <i>length</i> field contains its length.
</p>
<p>The <i>offset</i> field contains the offset from physical CPU
to PCI address for the resource - ie. the value that must be added to
the PCI address to get the physical address in CPU address space.
</p>
<p>The <i>dmaoffset</i> gives the offset that a PCI bus master
must add to a CPU memory address to access that address in main memory
over the PCI BUS.
</p>
<p><u>What are all these byte orders?</u>
</p>
<p>The PCI-bus is defined as a little endian byte ordering bus. The
most significant byte of a multi-byte number is located at the lowest
address occupied by this number.
</p>
<p>The 68xxx-series CPUs are big endian. PCI-bus and CPU are
connected together by a host bridge which does some kind of format
conversion. The <a href="PCI_BIOS.html">PCI-BIOS</a> knows about the format conversion performed
by the host bridge. The <a href="PCI_BIOS.html">PCI-BIOS</a> does not know about any format
conversion done (internally) by PCI devices. The driver has to know
its device's properties and capabilities.
</p>
<p>The table shows what 68xxx data byte (top row) is connected to
what PCI-bus data byte (lower right) by what 68xxx-access and format
conversion (left column):
</p>
<pre>                  68xxx-CPU data bus bits
                  D31..24  D23..16  D15..8   D7..0
----------------------------------------------------
big endian
32-bit-access +0  D31..24  D23..16  D15..8   D7..0
16-bit-access +0  D15..8   D7..0
16-bit-access +2                    D31..24  D23..16
 8-bit-access +0  D7..0
 8-bit-access +1           D15..8
 8-bit-access +2                    D23..16
 8-bit-access +3                             D31..24
----------------------------------------------------
little endian, lane swapped
32-bit-access +0  D0..7    D15..8   D23..16  D31..24
16-bit-access +0  D0..7    D15..8
16-bit-access +2                    D23..16  D31..24
 8-bit-access +0  D0..7
 8-bit-access +1           D15..8
 8-bit-access +2                    D23..16
 8-bit-access +3                             D31..24
----------------------------------------------------
little endian, address swapped
32-bit-access +0  D31..24  D23..16  D15..8   D7..0
16-bit-access +0  D31..24  D23..16
16-bit-access +2                    D15..8   D7..0
 8-bit-access +0  D31..24
 8-bit-access +1           D23..16
 8-bit-access +2                    D15..8
 8-bit-access +3                             D7..0
</pre>
<ul>
<li><p> &quot;Big endian&quot; makes the PCI-bus appear as a big endian
resource from the viewpoint of the 68xxx processor. It requires
dynamic route changes in the host bridge and seems not to be
implemented by any host bridge.
<br>&nbsp;
</p></li>
<li><p> &quot;Little endian, lane swapped&quot; is the easy way to make
8 bit per pixel modes work in the frame buffer of a PCI-device (VGA
controller) which does not have its own format conversion. This mode
is used in PCI-Macintoshs and for memory and IO accesses in the Milan.
In this mode, the address needs no modifications. 8-bit accesses work
normal, on 16 and 32 bit accesses endian conversion must be performed
on the the read or written data (ror.w #8,d0 for 16 bit, ror.w
#8,d0:swap d0:ror.w #8,d0 for 32 bit).
<br>&nbsp;
</p></li>
<li><p> &quot;Little endian, address swapped&quot; is the way to go if
accesses to 32 bit registers or 32 bit per pixel frame buffers have
top priority. In this mode, 32 bit accesses work without
modifications. On 16 bit accesses, the address needs to be XOR'd with
a value of 2, on 8-bit accesses the address is XOR'd with a value of
3. The data read or written is in correct format.
<br>&nbsp;
</p></li>
</ul>

<p>See also: <a href="PCI_BIOS.html#get_resource">get_resource</a>
</p>
<h3><a name="PMODE">4.24.18 PMODE</a></h3>
<pre>typedef struct  {
   int8_t  name[34];
   int16_t mode_id;       /* Running number                        */
   int16_t xres,yres;     /* Width/height in pixels                */
   int16_t fx,fy;         /* Width/height in total                 */
   int32_t colors;        /* Number of simultaneous colours        */
   int16_t org;           /* Organisation of the memory            */
   int16_t fh10,fv10;     /* Line-freq.*10, frame-freq.*10         */
   int16_t aspect100;     /* 100*pixel-width/pixel-height          */
   int16_t disp_scan100;
   int32_t clk;           /* Dot clock in Hz                       */
   /*
   * Register of the graphics controller
   */
   int16_t Clock;         /* Frequency number, must be translated  */
                          /* via the IcsLut before writing into
                             the clock register (see below)        */
   int8_t  misc_out;
   int8_t  ts[10];        /* Timing sequencer regs.                */
   int8_t  crtc[35];      /* CRT controller regs.                  */
   int8_t  gdc[10];       /* Graphics display controller           */
   int8_t  atc[24];       /* Attributes of controller              */
   int8_t  reserved[18];
} PMODE;

static int8_t IcsLut[32] = { 0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,
               30,1,17,9,25,5,21,13,29,3,19,11,27,7,23,15,31 };
</pre>
<p>See also: <a href="crazydots.html">Crazy-Dots XBIOS extension</a> &nbsp; <a href="crazydots.html#ReadMode">ReadMode</a> &nbsp;
<a href="crazydots.html#GetActiveModeDesc">GetActiveModeDesc</a>
</p>
<h3><a name="SCRCLIPMEMBLK">4.24.19 SCRCLIPMEMBLK</a></h3>
<pre>typedef struct _scrclipblk
{
  int32_t size;        /* size of structure            */
  int32_t blk_status;  /* status bits of blk           */
  int32_t blk_clip_on; /* clipping flag 1:on, 0:off    */
  int32_t blk_x;       /* x pos in total screen        */
  int32_t blk_y;       /* y pos in in total screen     */
  int32_t blk_w;       /* width                        */
  int32_t blk_h;       /* height                       */
} SCRCLIPMEMBLK;
</pre>
<p>See also: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCRCOPYMEMBLK">4.24.20 SCRCOPYMEMBLK</a></h3>
<pre>typedef struct _scrcopyblk
{
  int32_t size;                 /* size of structure            */
  int32_t blk_status;           /* status bits of blk           */
  int32_t blk_src_x;            /* x pos source in total screen */
  int32_t blk_src_y;            /* y pos source in total screen */
  int32_t blk_dst_x;            /* x pos dest in total screen   */
  int32_t blk_dst_y;            /* y pos dest in total screen   */
  int32_t blk_w;                /* width                        */
  int32_t blk_h;                /* height                       */
  int32_t blk_op;               /* mode operation               */
} SCRCOPYMEMBLK;
</pre>
<p>See also: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCREEN">4.24.21 SCREEN</a></h3>
<pre>typedef struct
{
   int8_t   xbra_id[4];       /* XBRA ID: 'CDOT'                      */
   int8_t   version[4];       /* At present: '1.10'                   */
   int8_t  *sm194_addr;       /* Pointer to large screen memory       */
   int8_t  *sm124_addr;       /* Pointer to SM124 screen memory       */
   <a href="linea_vars.html">LINEA</a>   *line_A;           /* Pointer to <a href="gemdos_structures.html#LINE">LINE</a>_A block              */
   int16_t  scrn_width;       /* Screen width                         */
   int16_t  scrn_height;      /* Screen height                        */
   int16_t  scrn_byte_width;  /* Screen width in bytes                */
   int16_t  scrn_planes;      /* Screen colour planes                 */
   int16_t  PhysMode;         /* Mode mumber                          */
   int16_t  VirtMode;         /* x/16 &amp; y/16 each coded in 1 byte     */
   <a href="#PMODE">PMODE</a>   *ModStruct;        /* Pointer to current graphic mode      */
   int16_t  grau;   /* Flag for the <a href="vdi_main.html">VDI</a> driver (Display: Grey/colour) */
   int16_t  BiosText;         /* Flag for the <a href="vdi_main.html">VDI</a> driver              */
   int16_t  CurText;          /* Flag for the <a href="vdi_main.html">VDI</a> driver              */
   int16_t  BlitMode;         /* Flag for the <a href="vdi_main.html">VDI</a> driver              */
} SCREEN;
</pre>
<p>See also: <a href="crazydots.html">Crazy-Dots XBIOS extension</a>
</p>
<h3><a name="SCREENINFO">4.24.22 SCREENINFO</a></h3>
<a name="SCRINFO_OK"></a>
<a name="NO_CLUT"></a>
<a name="HARD_CLUT"></a>
<a name="SOFT_CLUT"></a>
<a name="INTERLEAVE_PLANES"></a>
<a name="STANDARD_PLANES"></a>
<a name="PACKEDPIX_PLANES"></a>
<a name="STANDARD_BITS"></a>
<a name="FALCON_BITS"></a>
<a name="INTEL_BITS"></a>
<pre>/* scrFlags */
 #define SCRINFO_OK 1

/* scrClut */
 #define NO_CLUT    0
 #define HARD_CLUT  1
 #define SOFT_CLUT  2

/* scrFormat */
 #define INTERLEAVE_PLANES  0
 #define STANDARD_PLANES    1
 #define PACKEDPIX_PLANES   2

/* bitFlags */
 #define STANDARD_BITS  1
 #define FALCON_BITS    2
 #define INTEL_BITS     8

typedef struct screeninfo
{
  int32_t size;        /* <a href="proto_olga.html#Size">Size</a> of structur           */
  int32_t devID;       /* Device ID number           */
  int8_t  name[64];    /* Friendly name of Screen    */
  int32_t scrFlags;    /* Some flags                 */
  int32_t frameadr;    /* Adress of framebuffer      */
  int32_t scrHeight;   /* Visible X res              */
  int32_t scrWidth;    /* Visible Y res              */
  int32_t virtHeight;  /* Virtual X res              */
  int32_t virtWidth;   /* Virtual Y res              */
  int32_t scrPlanes;   /* color Planes               */
  int32_t scrColors;   /* # of colors                */
  int32_t lineWrap;    /* # of bytes to next line    */
  int32_t planeWarp;   /* # of bytes to next plane   */
  int32_t scrFormat;   /* Screen format              */
  int32_t scrClut;     /* Type of clut               */
  int32_t redBits;     /* Mask of Red Bits           */
  int32_t greenBits;   /* Mask of Green Bits         */
  int32_t blueBits;    /* Mask of Blue Bits          */
  int32_t alphaBits;   /* Mask of Alpha Bits         */
  int32_t genlockBits; /* Mask of Genlock Bits       */
  int32_t unusedBits;  /* Mask of unused Bits        */
  int32_t bitFlags;    /* Bits organisation flags    */
  int32_t maxmem;      /* Max. memory in this mode   */
  int32_t pagemem;     /* Needed memory for one page */
  int32_t max_x;       /* Max. possible width        */
  int32_t max_y;       /* Max. possible heigth       */
}SCREENINFO;
</pre>
<p>See also: <a href="Screen_functions.html#Setscreen_2C_20Milan">Setscreen, Milan</a> &nbsp; <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCREEN_2C_20OverScan">4.24.23 SCREEN, OverScan</a></h3>
<pre>typedef struct
{
   int16_t width;             /* Width in pixels                     */
   int16_t height;            /* Height in pixels                    */
   int16_t bytes_per_line;    /* Bytes per screen line               */
   int32_t length_of_screen;  /* Length of screen memory in bytes    */
   int32_t physbase_offset;   /* Offset start screen mem.&lt;&gt;<a href="Screen_functions.html#Physbase">Physbase</a>  */
   int32_t logbase_offset;    /* Offset start screen mem.&lt;&gt;<a href="Screen_functions.html#Logbase">Logbase</a>   */
} <a href="#SCREEN">SCREEN</a>;
</pre>
<p>See also: <a href="xbios_overscan.html">OverScan XBIOS functions</a> &nbsp; <a href="xbios_overscan.html#Oscantab">Oscantab</a>
</p>
<h3><a name="SCRFILLMEMBLK">4.24.24 SCRFILLMEMBLK</a></h3>
<pre>/* operations */
 #define BLK_CLEAR        0
 #define BLK_AND          1
 #define BLK_ANDREVERSE   2
 #define BLK_COPY         3
 #define BLK_ANDINVERTED  4
 #define BLK_NOOP         5
 #define BLK_XOR          6
 #define BLK_OR           7
 #define BLK_XNOR         8
 #define BLK_EQUIV        9
 #define BLK_INVERT       10
 #define BLK_ORREVERSE    11
 #define BLK_COPYINVERTED 12
 #define BLK_ORINVERTED   13
 #define BLK_NAND         14
 #define BLK_SET          15

typedef struct _scrsetblk
{
  int32_t size;                  /* size of structure           */
  int32_t blk_status;            /* status bits of blk          */
  int32_t blk_op;                /* mode operation              */
  int32_t blk_color;             /* background fill color       */
  int32_t blk_x;                 /* x pos in total screen       */
  int32_t blk_y;                 /* y pos in total screen       */
  int32_t blk_w;                 /* width                       */
  int32_t blk_h;                 /* height                      */
  int32_t blk_unused;
} SCRFILLMEMBLK;
</pre>
<p>See also: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCRLINEMEMBLK">4.24.25 SCRLINEMEMBLK</a></h3>
<pre>typedef struct _scrlineblk
{
  int32_t size;        /* size of structure            */
  int32_t blk_status;  /* status bits of blk           */
  int32_t blk_fgcolor; /* foreground fill color        */
  int32_t blk_bgcolor; /* background fill color        */
  int32_t blk_x1;      /* x1 pos dest in total screen  */
  int32_t blk_y1;      /* y1 pos dest in total screen  */
  int32_t blk_x2;      /* x2 pos dest in total screen  */
  int32_t blk_y2;      /* y2 pos dest in total screen  */
  int32_t blk_op;      /* mode operation               */
  int32_t blk_pattern; /* pattern (-1: solid line)     */
} SCRLINEMEMBLK;
</pre>
<p>See also: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCRMEMBLK">4.24.26 SCRMEMBLK</a></h3>
<a name="BLK_ERR"></a>
<a name="BLK_OK"></a>
<a name="BLK_CLEARED"></a>
<pre>
 #define BLK_ERR      0
 #define BLK_OK       1
 #define BLK_CLEARED  2

typedef struct _scrblk
{
  int32_t size;              /* <a href="proto_olga.html#Size">Size</a> of strukture                  */
  int32_t blk_status;        /* Status bits of blk                 */
  int32_t blk_start;         /* Start adress                       */
  int32_t blk_len;           /* Length of memblk                   */
  int32_t blk_x;             /* X pos in total screen              */
  int32_t blk_y;             /* Y pos in total screen              */
  int32_t blk_w;             /* Width                              */
  int32_t blk_h;             /* Height                             */
  int32_t blk_wrap;          /* Width in bytes, from: 2000-01-13   */
} SCRMEMBLK;
</pre>
<p>See also: <a href="Screen_functions.html#Setscreen_2C_20Milan">Setscreen, Milan</a> &nbsp; <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="SCRTEXTUREMEMBLK">4.24.27 SCRTEXTUREMEMBLK</a></h3>
<pre>typedef struct _scrtextureblk
{
  long size;                /* size of structure             */
  long blk_status;          /* status bits of blk            */
  long blk_src_x;           /* x pos source                  */
  long blk_src_y;           /* y pos source                  */
  long blk_dst_x;           /* x pos dest in total screen    */
  long blk_dst_y;           /* y pos dest in total screen    */
  long blk_w;               /* width                         */
  long blk_h;               /* height                        */
  long blk_op;              /* mode operation                */
  long blk_src_tex;         /* source texture address        */
  long blk_w_tex;           /* width texture                 */
  long blk_h_tex;           /* height texture                */
}SCRTEXTUREMEMBLK;
</pre>
<p>See also: <a href="Screen_functions.html#Setscreen_2C_20ct60">Setscreen, ct60</a>
</p>
<h3><a name="VDO_MODE">4.24.28 VDO_MODE</a></h3>
<pre>/* mode code xxxx xxxF SOPV 8NNN */
typedef struct
{
   uint16_t Plan:3;            /* bit 0-2: NNN (number of planes)       */
   uint16_t _80Col:1;          /* bit 3: 80 column flag (8)             */
   uint16_t VGA:1;             /* bit 4: VGA flag (V)                   */
   uint16_t Pal:1;             /* bit 5: PAL flag (P)                   */
   uint16_t Overscan:1;        /* bit 6: Overscan flag (O)              */
   uint16_t STComp:1;          /* bit 7: ST-compatible flag (S)         */
   uint16_t Vertical:1;        /* bit 8: Vertical flag (F)              */
   uint16_t NRJStart:1;        /* bit 9: Energy Star mode active or not */
   uint16_t Eco:1;             /* bit 10: Economiser active or not      */
   uint16_t Virtual:1;         /* bit 11: <a href="bios_cookiejar.html#Virtual_20screen">Virtual screen</a> active or not  */
   uint16_t ExtClock:1;        /* bit 12: External clock 32/36MHz (CT2) */
   uint16_t ExtClockEnable:1;  /* bit 13: Enable external clock         */
   uint16_t StandardResol:1;   /* bit 14: Standard resolution           */
   uint16_t DefaultMode:1;     /* bit 15: Video default mode            */
} VDO_MODE;
</pre>
<p>See also: <a href="#VDO_PARAM">VDO_PARAM</a>
</p>
<h3><a name="VDO_PARAM">4.24.29 VDO_PARAM</a></h3>
<pre>typedef struct
{
   int16_t V_Hdl;        /* Handle                                 */
   <a href="#VDO_MODE">VDO_MODE</a> V_mode;      /* Video mode like on Falcon              */
   int16_t  V_physw;     /* Width of the physical screen           */
   int16_t  V_physh;     /* Height of the physical screen          */
   int16_t  V_plan;      /* Number of plane                        */
   int16_t  V_logw;      /* Width of the virtual screen            */
   int16_t  V_logh;      /* Height of the virtual screen           */
   int16_t  V_eco;       /* Delay in seconds before shut down      */
   int16_t  V_eco2;      /* Delay in seconds between the shut down */
                         /* and the Energy Star mode               */
   int8_t   V_name[33];  /* Name of the video mode (32 bytes maxi) */
                         /* terminated by a 0.                     */
   int8_t   Reserved;    /* Reserved for future use                */
   int32_t  V_length;    /* Length of buffer                       */
} VDO_PARAM;
</pre>
<p>See also: <a href="CENTScreen_XBIOS_extension.html#Vread">Vread</a>
</p>
<h3><a name="vidix_capability_t">4.24.30 vidix_capability_t</a></h3>
<pre>typedef struct vidix_capability_s
{
   char    name[64];    /* Driver name */
   char    author[64];  /* Author name */
#define TYPE_OUTPUT      0x00000000    /* Is a video playback device */
#define TYPE_CAPTURE     0x00000001    /* Is a capture device */
#define TYPE_CODEC       0x00000002    /* Device supports hw (de)coding */
#define TYPE_FX          0x00000004    /* Is a video effects device */
   int    type;         /* Device type, see below */
   unsigned reserved0[4];
   int    maxwidth;
   int    maxheight;
   int    minwidth;
   int    minheight;
   int    maxframerate; /* -1 if unlimited */
#define FLAG_NONE        0x00000000 /* No flags defined */
#define FLAG_DMA         0x00000001 /* Card can use DMA */
#define FLAG_EQ_DMA      0x00000002 /* Card can use DMA only if src pitch == dest pitch */
#define FLAG_UPSCALER    0x00000010 /* Card supports hw upscaling */
#define FLAG_DOWNSCALER  0x00000020 /* Card supports hw downscaling */
#define FLAG_SUBPIC      0x00001000 /* Card supports DVD subpictures */
#define FLAG_EQUALIZER   0x00002000 /* Card supports equalizer */
   unsigned flags;      /* Feature flags, see above */
   unsigned short vendor_id;
   unsigned short device_id;
   unsigned reserved1[4];
}vidix_capability_t;
</pre>
<p>See also: <a href="vidix_xbios_extension.html">VIDIX XBIOS extension</a>
</p>
<h3><a name="vidix_deinterlace_t">4.24.31 vidix_deinterlace_t</a></h3>
<pre>typedef struct vidix_deinterlace_s
{
#define CFG_NON_INTERLACED        0x00000000 /* stream is not interlaced */
#define CFG_INTERLACED            0x00000001 /* stream is interlaced */
#define CFG_EVEN_ODD_INTERLACING  0x00000002 /* first frame contains even fields but second - odd */
#define CFG_ODD_EVEN_INTERLACING  0x00000004 /* first frame contains odd fields but second - even */
#define CFG_UNIQUE_INTERLACING    0x00000008 /* field deinterlace_pattern is valid */
#define CFG_UNKNOWN_INTERLACING   0x0000000f /* unknown deinterlacing - use adaptive if it's possible */
   unsigned    flags;               /* driver -&gt; app */
   unsigned    deinterlace_pattern; /* driver -&gt; app: deinterlace pattern if flag CFG_UNIQUE_INTERLACING is set */
}vidix_deinterlace_t;
</pre>
<p>See also: <a href="vidix_xbios_extension.html">VIDIX XBIOS extension</a>
</p>
<h3><a name="vidix_dma_t">4.24.32 vidix_dma_t</a></h3>
<pre>typedef struct vidix_dma_s
{
   void *src;               /* app -&gt; driver: Virtual address of source */
   unsigned dest_offset;    /* app -&gt; driver: Destination offset within of video memory */
   unsigned size;           /* app -&gt; driver: <a href="proto_olga.html#Size">Size</a> of transaction */
#define BM_DMA_NOSYNC      0
#define BM_DMA_SYNC        1 /* wait previous dma transfer completion */
#define BM_DMA_FIXED_BUFFS 2 /* app uses buffers witch are fixed in memory */
#define BM_DMA_BLOCK       4 /* block until the transfer is complete */
   unsigned flags;          /* app -&gt; driver */
   unsigned idx;            /* app -&gt; driver: index of the src buffer */
   unsigned src_incr;       /* app -&gt; driver: if src_incr &amp; dest_incr are */
   unsigned dest_incr;      /*                different, else 0 */
   void *internal[VID_PLAY_MAXFRAMES];    /* for internal use by driver */
}vidix_dma_t;
</pre>
<p>See also: <a href="vidix_xbios_extension.html">VIDIX XBIOS extension</a>
</p>
<h3><a name="vidix_fourcc_t">4.24.33 vidix_fourcc_t</a></h3>
<pre>typedef struct vidix_fourcc_s
{
   unsigned fourcc; /* input: requested fourcc */
   unsigned srcw;   /* input: hint: width of source */
   unsigned srch;   /* input: hint: height of source */
#define VID_DEPTH_NONE             0x0000
#define VID_DEPTH_1BPP             0x0001
#define VID_DEPTH_2BPP             0x0002
#define VID_DEPTH_4BPP             0x0004
#define VID_DEPTH_8BPP             0x0008
#define VID_DEPTH_12BPP            0x0010
#define VID_DEPTH_15BPP            0x0020
#define VID_DEPTH_16BPP            0x0040
#define VID_DEPTH_24BPP            0x0080
#define VID_DEPTH_32BPP            0x0100
   unsigned depth; /* output: screen depth for given fourcc */
#define VID_CAP_NONE               0x0000
#define VID_CAP_EXPAND             0x0001 /* if overlay can be bigger than source */
#define VID_CAP_SHRINK             0x0002 /* if overlay can be smaller than source */
#define VID_CAP_BLEND              0x0004 /* if overlay can be blended with framebuffer */
#define VID_CAP_COLORKEY           0x0008 /* if overlay can be restricted to a colorkey */
#define VID_CAP_ALPHAKEY           0x0010 /* if overlay can be restricted to an alpha channel */
#define VID_CAP_COLORKEY_ISRANGE   0x0020 /* if the colorkey can be a range */
#define VID_CAP_ALPHAKEY_ISRANGE   0x0040 /* if the alphakey can be a range */
#define VID_CAP_COLORKEY_ISMAIN    0x0080 /* colorkey is checked against framebuffer */
#define VID_CAP_COLORKEY_ISOVERLAY 0x0100 /* colorkey is checked against overlay */
#define VID_CAP_ALPHAKEY_ISMAIN    0x0200 /* alphakey is checked against framebuffer */
#define VID_CAP_ALPHAKEY_ISOVERLAY 0x0400 /* alphakey is checked against overlay */
   unsigned flags; /* output: capability */
}vidix_fourcc_t;
</pre>
<p>See also: <a href="vidix_xbios_extension.html">VIDIX XBIOS extension</a>
</p>
<h3><a name="vidix_grkey_t">4.24.34 vidix_grkey_t</a></h3>
<pre>typedef struct vidix_grkey_s
{
   vidix_ckey_t    ckey;      /* driver -&gt; app: color key */
   vidix_vkey_t    vkey;      /* driver -&gt; app: video key */
#define KEYS_PUT    0
#define KEYS_AND    1
#define KEYS_OR     2
#define KEYS_XOR    3
   unsigned    key_op;        /* driver -&gt; app: keys operations */
}vidix_grkey_t;
</pre>
<p>See also: <a href="vidix_xbios_extension.html">VIDIX XBIOS extension</a>
</p>
<h3><a name="vidix_playback_t">4.24.35 vidix_playback_t</a></h3>
<pre>typedef struct vidix_playback_s
{
   unsigned fourcc;           /* app -&gt; driver: movies's fourcc */
   unsigned capability;       /* app -&gt; driver: what capability to use */
   unsigned blend_factor;     /* app -&gt; driver: blending factor */
   vidix_rect_t src;          /* app -&gt; driver: original movie size */
   vidix_rect_t dest;         /* app -&gt; driver: destinition movie size. driver-&gt;app dest_pitch */
#define VID_PLAY_INTERLEAVED_UV 0x00000001    /* driver -&gt; app: interleaved UV planes */
#define INTERLEAVING_UV         0x00001000    /* UVUVUVUVUV used by Matrox G200 */
#define INTERLEAVING_VU         0x00001001    /* VUVUVUVUVU */
   int        flags;
   /* memory model */
   unsigned frame_size;       /* driver -&gt; app: destinition frame size */
   unsigned num_frames;       /* app -&gt; driver: after call: driver -&gt; app */
#define VID_PLAY_MAXFRAMES 64 /* reasonable limitation for decoding ahead */
   unsigned offsets[VID_PLAY_MAXFRAMES];    /* driver -&gt; app */
   vidix_yuv_t    offset;     /* driver -&gt; app: relative offsets within frame for yuv planes */
   void    *dga_addr;         /* driver -&gt; app: linear address */
}vidix_playback_t;
</pre>
<p>See also: <a href="vidix_xbios_extension.html">VIDIX XBIOS extension</a>
</p>
<h3><a name="vidix_video_eq_t">4.24.36 vidix_video_eq_t</a></h3>
<pre>typedef struct vidix_video_eq_s
{
#define VEQ_CAP_NONE            0x00000000UL
#define VEQ_CAP_BRIGHTNESS      0x00000001UL
#define VEQ_CAP_CONTRAST        0x00000002UL
#define VEQ_CAP_SATURATION      0x00000004UL
#define VEQ_CAP_HUE             0x00000008UL
#define VEQ_CAP_RGB_INTENSITY   0x00000010UL
   int        cap;             /* should contain capability of equalizer */
   /* end-user app can have presets like: cold-normal-hot picture and so on */
   int        brightness;      /* -1000 : +1000 */
   int        contrast;        /* -1000 : +1000 */
   int        saturation;      /* -1000 : +1000 */
   int        hue;             /* -1000 : +1000 */
   int        red_intensity;   /* -1000 : +1000 */
   int        green_intensity; /* -1000 : +1000 */
   int        blue_intensity;  /* -1000 : +1000 */
#define VEQ_FLG_ITU_R_BT_601    0x00000000 /* ITU-R BT.601 colour space (default) */
#define VEQ_FLG_ITU_R_BT_709    0x00000001 /* ITU-R BT.709 colour space */
#define VEQ_FLG_ITU_MASK        0x0000000f
   int        flags;           /* currently specifies ITU YCrCb color space to use */
}vidix_video_eq_t;
</pre>
<p>See also: <a href="vidix_xbios_extension.html">VIDIX XBIOS extension</a>
</p>
<h3><a name="VPOS">4.24.37 VPOS</a></h3>
<pre>typedef struct
{
   int16_t x;
   int16_t y;
} VPOS;
</pre>
<p>See also: <a href="CENTScreen_XBIOS_extension.html#Vseek">Vseek</a>
</p>
<hr>

<a name="UDO_nav_hm_FOOT" href="index.html"><img src="udo_hm.gif" alt="Home" title="Home" border="0" width="24" height="24"></a>
<a name="UDO_nav_up_FOOT" href="xbios_main.html"><img src="udo_up.gif" alt="XBIOS" title="XBIOS" border="0" width="24" height="24">XBIOS</a>
<a name="UDO_nav_lf_FOOT" href="xbios_functions.html"><img src="udo_lf.gif" alt="XBIOS function list" title="XBIOS function list" border="0" width="24" height="24">XBIOS function list</a>
<a name="UDO_nav_rg_FOOT" href="gemdos_main.html"><img src="udo_rg.gif" alt="GEMDOS" title="GEMDOS" border="0" width="24" height="24">GEMDOS</a>
</body>
</html>
